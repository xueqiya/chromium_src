This is a testharness.js-based test.
Found 67 tests; 47 PASS, 20 FAIL, 0 TIMEOUT, 0 NOTRUN.
PASS Test helper: fetching and sanity checking test JSON: resources/parsing-addresses-absolute.json
PASS Test helper: fetching and sanity checking test JSON: resources/parsing-addresses-invalid.json
PASS Test helper: fetching and sanity checking test JSON: resources/parsing-addresses.json
PASS Test helper: fetching and sanity checking test JSON: resources/parsing-invalid-json.json
PASS Test helper: fetching and sanity checking test JSON: resources/parsing-schema-normalization.json
PASS Test helper: fetching and sanity checking test JSON: resources/parsing-schema-scope.json
PASS Test helper: fetching and sanity checking test JSON: resources/parsing-schema-specifier-map.json
PASS Test helper: fetching and sanity checking test JSON: resources/parsing-schema-toplevel.json
PASS Test helper: fetching and sanity checking test JSON: resources/parsing-scope-keys.json
PASS Test helper: fetching and sanity checking test JSON: resources/parsing-specifier-keys.json
PASS Test helper: fetching and sanity checking test JSON: resources/parsing-trailing-slashes.json
FAIL Absolute URL addresses: should only accept absolute URL addresses with fetch schemes assert_equals: expected "{\"imports\":{\"about\":\"about:good\",\"blob\":\"blob:good\",\"data\":\"data:good\",\"file\":\"file:///good\",\"filesystem\":\"filesystem:http://example.com/good/\",\"ftp\":\"ftp://good/\",\"http\":\"http://good/\",\"https\":\"https://good/\",\"import\":\"import:bad\",\"javascript\":\"javascript:bad\",\"mailto\":\"mailto:bad\",\"wss\":\"wss://bad/\"},\"scopes\":{}}" but got "{\"imports\":{\"about\":[\"about:good\"],\"blob\":[\"blob:good\"],\"data\":[\"data:good\"],\"file\":[\"file:///good\"],\"filesystem\":[\"filesystem:http://example.com/good/\"],\"ftp\":[\"ftp://good/\"],\"http\":[\"http://good/\"],\"https\":[\"https://good/\"],\"import\":[\"import:bad\"],\"javascript\":[\"javascript:bad\"],\"mailto\":[\"mailto:bad\"],\"wss\":[\"wss://bad/\"]},\"scopes\":{}}"
FAIL Absolute URL addresses: should parse absolute URLs, ignoring unparseable ones assert_equals: expected "{\"imports\":{\"invalidButParseable1\":\"https://example.org/\",\"invalidButParseable2\":\"https://example.com///\",\"percentDecoding\":\"https://example.com/\",\"prettyNormal\":\"https://example.net/\"},\"scopes\":{}}" but got "{\"imports\":{\"invalidButParseable1\":[\"https://example.org/\"],\"invalidButParseable2\":[\"https://example.com///\"],\"percentDecoding\":[\"https://example.com/\"],\"prettyNormal\":[\"https://example.net/\"],\"unparseable2\":[],\"unparseable3\":[]},\"scopes\":{}}"
FAIL Other invalid addresses: should ignore unprefixed strings that are not absolute URLs assert_equals: expected "{\"imports\":{},\"scopes\":{}}" but got "{\"imports\":{\"foo1\":[],\"foo2\":[],\"foo3\":[],\"foo4\":[],\"foo5\":[]},\"scopes\":{}}"
FAIL Relative URL-like addresses: should accept strings prefixed with ./, ../, or / assert_equals: expected "{\"imports\":{\"dotDotSlash\":\"https://base.example/path1/foo\",\"dotSlash\":\"https://base.example/path1/path2/foo\",\"slash\":\"https://base.example/foo\"},\"scopes\":{}}" but got "{\"imports\":{\"dotDotSlash\":[\"https://base.example/path1/foo\"],\"dotSlash\":[\"https://base.example/path1/path2/foo\"],\"slash\":[\"https://base.example/foo\"]},\"scopes\":{}}"
FAIL Relative URL-like addresses: should not accept strings prefixed with ./, ../, or / for data: base URLs assert_equals: expected "{\"imports\":{},\"scopes\":{}}" but got "{\"imports\":{\"dotDotSlash\":[],\"dotSlash\":[],\"slash\":[]},\"scopes\":{}}"
FAIL Relative URL-like addresses: should accept the literal strings ./, ../, or / with no suffix assert_equals: expected "{\"imports\":{\"dotDotSlash\":\"https://base.example/path1/\",\"dotSlash\":\"https://base.example/path1/path2/\",\"slash\":\"https://base.example/\"},\"scopes\":{}}" but got "{\"imports\":{\"dotDotSlash\":[\"https://base.example/path1/\"],\"dotSlash\":[\"https://base.example/path1/path2/\"],\"slash\":[\"https://base.example/\"]},\"scopes\":{}}"
FAIL Relative URL-like addresses: should ignore percent-encoded variants of ./, ../, or / assert_equals: expected "{\"imports\":{},\"scopes\":{}}" but got "{\"imports\":{\"dotDotSlash1\":[],\"dotDotSlash2\":[],\"dotDotSlash3\":[],\"dotSlash1\":[],\"dotSlash2\":[],\"dotSlash3\":[],\"slash2\":[]},\"scopes\":{}}"
PASS Invalid JSON
PASS Normalization: should normalize empty import maps to have imports and scopes keys
PASS Normalization: should normalize an import map without imports to have imports
PASS Normalization: should normalize an import map without scopes to have scopes
PASS Mismatching scopes schema: should throw if a scope's value is not an object: null
PASS Mismatching scopes schema: should throw if a scope's value is not an object: boolean
PASS Mismatching scopes schema: should throw if a scope's value is not an object: number
PASS Mismatching scopes schema: should throw if a scope's value is not an object: string
PASS Mismatching scopes schema: should throw if a scope's value is not an object: array
FAIL Mismatching the specifier map schema: should ignore entries where the address is not a string assert_equals: expected "{\"imports\":{\"string\":\"https://example.com/\"},\"scopes\":{}}" but got "{\"imports\":{\"array\":[],\"array2\":[\"https://example.com/\"],\"null\":[],\"string\":[\"https://example.com/\"]},\"scopes\":{}}"
PASS Mismatching the specifier map schema: should ignore entries where the specifier key is an empty string
PASS Mismatching the top-level schema: should throw for top-level non-objects: null
PASS Mismatching the top-level schema: should throw for top-level non-objects: boolean
PASS Mismatching the top-level schema: should throw for top-level non-objects: number
PASS Mismatching the top-level schema: should throw for top-level non-objects: string
PASS Mismatching the top-level schema: should throw for top-level non-objects: array
PASS Mismatching the top-level schema: should throw if imports is a non-object: null
PASS Mismatching the top-level schema: should throw if imports is a non-object: boolean
PASS Mismatching the top-level schema: should throw if imports is a non-object: number
PASS Mismatching the top-level schema: should throw if imports is a non-object: string
PASS Mismatching the top-level schema: should throw if imports is a non-object: array
PASS Mismatching the top-level schema: should throw if scopes is a non-object: null
PASS Mismatching the top-level schema: should throw if scopes is a non-object: boolean
PASS Mismatching the top-level schema: should throw if scopes is a non-object: number
PASS Mismatching the top-level schema: should throw if scopes is a non-object: string
PASS Mismatching the top-level schema: should throw if scopes is a non-object: array
PASS Mismatching the top-level schema: should ignore unspecified top-level entries
PASS Relative URL scope keys should work with no prefix
PASS Relative URL scope keys should work with ./, ../, and / prefixes
PASS Absolute URL scope keys should ignore relative URL scope keys when the base URL is a data: URL
PASS Relative URL scope keys should work with ./, ../, or / with no suffix
PASS Relative URL scope keys should work with /s, ?s, and #s
PASS Relative URL scope keys should work with an empty string scope key
PASS Relative URL scope keys should work with / suffixes
FAIL Relative URL scope keys should deduplicate based on URL parsing rules assert_equals: expected "{\"imports\":{},\"scopes\":{\"https://base.example/path1/path2/foo//\":{\"3\":\"https://base.example/path1/path2/c\"}}}" but got "{\"imports\":{},\"scopes\":{\"https://base.example/path1/path2/foo//\":{\"3\":[\"https://base.example/path1/path2/c\"]}}}"
PASS Absolute URL scope keys should accept all absolute URL scope keys, with or without fetch schemes
PASS Absolute URL scope keys should parse absolute URL scope keys, ignoring unparseable ones
FAIL Relative URL specifier keys should absolutize strings prefixed with ./, ../, or / into the corresponding URLs assert_equals: expected "{\"imports\":{\"https://base.example/foo\":\"https://base.example/slash\",\"https://base.example/path1/foo\":\"https://base.example/dotdotslash\",\"https://base.example/path1/path2/foo\":\"https://base.example/dotslash\"},\"scopes\":{}}" but got "{\"imports\":{\"https://base.example/foo\":[\"https://base.example/slash\"],\"https://base.example/path1/foo\":[\"https://base.example/dotdotslash\"],\"https://base.example/path1/path2/foo\":[\"https://base.example/dotslash\"]},\"scopes\":{}}"
FAIL Relative URL specifier keys should not absolutize strings prefixed with ./, ../, or / with a data: URL base assert_equals: expected "{\"imports\":{\"../foo\":\"https://example.com/dotdotslash\",\"./foo\":\"https://example.com/dotslash\",\"/foo\":\"https://example.com/slash\"},\"scopes\":{}}" but got "{\"imports\":{\"../foo\":[\"https://example.com/dotdotslash\"],\"./foo\":[\"https://example.com/dotslash\"],\"/foo\":[\"https://example.com/slash\"]},\"scopes\":{}}"
FAIL Relative URL specifier keys should absolutize the literal strings ./, ../, or / with no suffix assert_equals: expected "{\"imports\":{\"https://base.example/\":\"https://base.example/slash/\",\"https://base.example/path1/\":\"https://base.example/dotdotslash/\",\"https://base.example/path1/path2/\":\"https://base.example/dotslash/\"},\"scopes\":{}}" but got "{\"imports\":{\"https://base.example/\":[\"https://base.example/slash/\"],\"https://base.example/path1/\":[\"https://base.example/dotdotslash/\"],\"https://base.example/path1/path2/\":[\"https://base.example/dotslash/\"]},\"scopes\":{}}"
FAIL Relative URL specifier keys should work with /s, ?s, and #s assert_equals: expected "{\"imports\":{\"https://base.example/path1/path2/foo/bar?baz#qux\":\"https://base.example/foo\"},\"scopes\":{}}" but got "{\"imports\":{\"https://base.example/path1/path2/foo/bar?baz#qux\":[\"https://base.example/foo\"]},\"scopes\":{}}"
PASS Relative URL specifier keys should ignore an empty string key
FAIL Relative URL specifier keys should treat percent-encoded variants of ./, ../, or / as bare specifiers assert_equals: expected "{\"imports\":{\"%2E%2E%2F\":\"https://base.example/dotDotSlash3\",\"%2E%2E/\":\"https://base.example/dotDotSlash1/\",\"%2E%2F\":\"https://base.example/dotSlash3\",\"%2E/\":\"https://base.example/dotSlash1/\",\"%2F\":\"https://base.example/slash2\",\".%2F\":\"https://base.example/dotSlash2\",\"..%2F\":\"https://base.example/dotDotSlash2\"},\"scopes\":{}}" but got "{\"imports\":{\"%2E%2E%2F\":[\"https://base.example/dotDotSlash3\"],\"%2E%2E/\":[\"https://base.example/dotDotSlash1/\"],\"%2E%2F\":[\"https://base.example/dotSlash3\"],\"%2E/\":[\"https://base.example/dotSlash1/\"],\"%2F\":[\"https://base.example/slash2\"],\".%2F\":[\"https://base.example/dotSlash2\"],\"..%2F\":[\"https://base.example/dotDotSlash2\"]},\"scopes\":{}}"
FAIL Relative URL specifier keys should deduplicate based on URL parsing rules assert_equals: expected "{\"imports\":{\"https://base.example/path1/path2/foo//\":\"https://base.example/foo3\"},\"scopes\":{}}" but got "{\"imports\":{\"https://base.example/path1/path2/foo//\":[\"https://base.example/foo3\"]},\"scopes\":{}}"
FAIL Absolute URL specifier keys should accept all absolute URL specifier keys, with or without fetch schemes assert_equals: expected "{\"imports\":{\"about:good\":\"https://base.example/about\",\"blob:good\":\"https://base.example/blob\",\"data:good\":\"https://base.example/data\",\"file:///good\":\"https://base.example/file\",\"filesystem:http://example.com/good/\":\"https://base.example/filesystem/\",\"ftp://good/\":\"https://base.example/ftp/\",\"http://good/\":\"https://base.example/http/\",\"https://good/\":\"https://base.example/https/\",\"import:bad\":\"https://base.example/import\",\"javascript:bad\":\"https://base.example/javascript\",\"mailto:bad\":\"https://base.example/mailto\",\"wss://bad/\":\"https://base.example/wss\"},\"scopes\":{}}" but got "{\"imports\":{\"about:good\":[\"https://base.example/about\"],\"blob:good\":[\"https://base.example/blob\"],\"data:good\":[\"https://base.example/data\"],\"file:///good\":[\"https://base.example/file\"],\"filesystem:http://example.com/good/\":[\"https://base.example/filesystem/\"],\"ftp://good/\":[\"https://base.example/ftp/\"],\"http://good/\":[\"https://base.example/http/\"],\"https://good/\":[\"https://base.example/https/\"],\"import:bad\":[\"https://base.example/import\"],\"javascript:bad\":[\"https://base.example/javascript\"],\"mailto:bad\":[\"https://base.example/mailto\"],\"wss://bad/\":[\"https://base.example/wss\"]},\"scopes\":{}}"
FAIL Absolute URL specifier keys should parse absolute URLs, treating unparseable ones as bare specifiers assert_equals: expected "{\"imports\":{\"http://[www.example.com]/\":\"https://base.example/unparseable3/\",\"https://example.com/\":\"https://base.example/percentDecoding/\",\"https://example.com///\":\"https://base.example/invalidButParseable2/\",\"https://example.com:demo\":\"https://base.example/unparseable2\",\"https://example.net/\":\"https://base.example/prettyNormal/\",\"https://example.org/\":\"https://base.example/invalidButParseable1/\"},\"scopes\":{}}" but got "{\"imports\":{\"http://[www.example.com]/\":[\"https://base.example/unparseable3/\"],\"https://example.com/\":[\"https://base.example/percentDecoding/\"],\"https://example.com///\":[\"https://base.example/invalidButParseable2/\"],\"https://example.com:demo\":[\"https://base.example/unparseable2\"],\"https://example.net/\":[\"https://base.example/prettyNormal/\"],\"https://example.org/\":[\"https://base.example/invalidButParseable1/\"]},\"scopes\":{}}"
FAIL Specifier keys should be sort correctly (issue #181) - Test #1 assert_equals: expected "{\"imports\":{\"https://example.com/a\":\"https://example.com/a\",\"https://example.com/aaa\":\"https://example.com/aaa\"},\"scopes\":{}}" but got "{\"imports\":{\"https://example.com/a\":[\"https://example.com/a\"],\"https://example.com/aaa\":[\"https://example.com/aaa\"]},\"scopes\":{}}"
FAIL Specifier keys should be sort correctly (issue #181) - Test #2 assert_equals: expected "{\"imports\":{\"https://example.com/a\":\"https://example.com/a\",\"https://example.com/aaa\":\"https://example.com/aaa\"},\"scopes\":{}}" but got "{\"imports\":{\"https://example.com/a\":[\"https://example.com/a\"],\"https://example.com/aaa\":[\"https://example.com/aaa\"]},\"scopes\":{}}"
FAIL Failing addresses: mismatched trailing slashes assert_equals: expected "{\"imports\":{},\"scopes\":{}}" but got "{\"imports\":{\"trailer/\":[]},\"scopes\":{}}"
Harness: the test ran to completion.

