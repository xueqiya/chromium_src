// services/audio/public/mojom/stream_factory.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif


#include "services/audio/public/mojom/stream_factory.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"
#include "media/mojo/mojom/audio_data_pipe.mojom.h"
#include "media/mojo/mojom/audio_input_stream.mojom.h"
#include "media/mojo/mojom/audio_logging.mojom.h"
#include "media/mojo/mojom/audio_output_stream.mojom.h"
#include "media/mojo/mojom/audio_parameters.mojom.h"
#include "mojo/public/mojom/base/unguessable_token.mojom.h"
#include "services/audio/public/mojom/audio_processing.mojom.h"


#ifndef SERVICES_AUDIO_PUBLIC_MOJOM_STREAM_FACTORY_MOJOM_JUMBO_H_
#define SERVICES_AUDIO_PUBLIC_MOJOM_STREAM_FACTORY_MOJOM_JUMBO_H_
#include "media/base/ipc/media_param_traits.h"
#include "mojo/public/cpp/base/shared_memory_mojom_traits.h"
#include "mojo/public/cpp/base/unguessable_token_mojom_traits.h"
#include "services/audio/public/cpp/audio_processing_mojom_traits.h"
#endif


namespace audio {
namespace mojom {


LocalMuterAsyncWaiter::LocalMuterAsyncWaiter(
    LocalMuter* proxy) : proxy_(proxy) {}

LocalMuterAsyncWaiter::~LocalMuterAsyncWaiter() = default;




void StreamFactoryInterceptorForTesting::CreateInputStream(mojo::PendingReceiver<::media::mojom::AudioInputStream> stream, mojo::PendingRemote<::media::mojom::AudioInputStreamClient> client, mojo::PendingRemote<::media::mojom::AudioInputStreamObserver> observer, mojo::PendingRemote<::media::mojom::AudioLog> log, const std::string& device_id, const ::media::AudioParameters& params, uint32_t shared_memory_count, bool enable_agc, mojo::ScopedSharedBufferHandle key_press_count_buffer, ::audio::mojom::AudioProcessingConfigPtr processing_config, CreateInputStreamCallback callback) {
  GetForwardingInterface()->CreateInputStream(std::move(stream), std::move(client), std::move(observer), std::move(log), std::move(device_id), std::move(params), std::move(shared_memory_count), std::move(enable_agc), std::move(key_press_count_buffer), std::move(processing_config), std::move(callback));
}
void StreamFactoryInterceptorForTesting::AssociateInputAndOutputForAec(const ::base::UnguessableToken& input_stream_id, const std::string& output_device_id) {
  GetForwardingInterface()->AssociateInputAndOutputForAec(std::move(input_stream_id), std::move(output_device_id));
}
void StreamFactoryInterceptorForTesting::CreateOutputStream(mojo::PendingReceiver<::media::mojom::AudioOutputStream> stream, mojo::PendingAssociatedRemote<::media::mojom::AudioOutputStreamObserver> observer, mojo::PendingRemote<::media::mojom::AudioLog> log, const std::string& device_id, const ::media::AudioParameters& params, const ::base::UnguessableToken& group_id, const base::Optional<::base::UnguessableToken>& processing_id, CreateOutputStreamCallback callback) {
  GetForwardingInterface()->CreateOutputStream(std::move(stream), std::move(observer), std::move(log), std::move(device_id), std::move(params), std::move(group_id), std::move(processing_id), std::move(callback));
}
void StreamFactoryInterceptorForTesting::BindMuter(mojo::PendingAssociatedReceiver<LocalMuter> receiver, const ::base::UnguessableToken& group_id) {
  GetForwardingInterface()->BindMuter(std::move(receiver), std::move(group_id));
}
void StreamFactoryInterceptorForTesting::CreateLoopbackStream(mojo::PendingReceiver<::media::mojom::AudioInputStream> receiver, mojo::PendingRemote<::media::mojom::AudioInputStreamClient> client, mojo::PendingRemote<::media::mojom::AudioInputStreamObserver> observer, const ::media::AudioParameters& params, uint32_t shared_memory_count, const ::base::UnguessableToken& group_id, CreateLoopbackStreamCallback callback) {
  GetForwardingInterface()->CreateLoopbackStream(std::move(receiver), std::move(client), std::move(observer), std::move(params), std::move(shared_memory_count), std::move(group_id), std::move(callback));
}
StreamFactoryAsyncWaiter::StreamFactoryAsyncWaiter(
    StreamFactory* proxy) : proxy_(proxy) {}

StreamFactoryAsyncWaiter::~StreamFactoryAsyncWaiter() = default;

void StreamFactoryAsyncWaiter::CreateInputStream(
    mojo::PendingReceiver<::media::mojom::AudioInputStream> stream, mojo::PendingRemote<::media::mojom::AudioInputStreamClient> client, mojo::PendingRemote<::media::mojom::AudioInputStreamObserver> observer, mojo::PendingRemote<::media::mojom::AudioLog> log, const std::string& device_id, const ::media::AudioParameters& params, uint32_t shared_memory_count, bool enable_agc, mojo::ScopedSharedBufferHandle key_press_count_buffer, ::audio::mojom::AudioProcessingConfigPtr processing_config, ::media::mojom::ReadOnlyAudioDataPipePtr* out_data_pipe, bool* out_initially_muted, base::Optional<::base::UnguessableToken>* out_stream_id) {
  base::RunLoop loop;
  proxy_->CreateInputStream(std::move(stream),std::move(client),std::move(observer),std::move(log),std::move(device_id),std::move(params),std::move(shared_memory_count),std::move(enable_agc),std::move(key_press_count_buffer),std::move(processing_config),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::media::mojom::ReadOnlyAudioDataPipePtr* out_data_pipe
,
             bool* out_initially_muted
,
             base::Optional<::base::UnguessableToken>* out_stream_id
,
             ::media::mojom::ReadOnlyAudioDataPipePtr data_pipe,
             bool initially_muted,
             const base::Optional<::base::UnguessableToken>& stream_id) {*out_data_pipe = std::move(data_pipe);*out_initially_muted = std::move(initially_muted);*out_stream_id = std::move(stream_id);
            loop->Quit();
          },
          &loop,
          out_data_pipe,
          out_initially_muted,
          out_stream_id));
  loop.Run();
}
void StreamFactoryAsyncWaiter::CreateOutputStream(
    mojo::PendingReceiver<::media::mojom::AudioOutputStream> stream, mojo::PendingAssociatedRemote<::media::mojom::AudioOutputStreamObserver> observer, mojo::PendingRemote<::media::mojom::AudioLog> log, const std::string& device_id, const ::media::AudioParameters& params, const ::base::UnguessableToken& group_id, const base::Optional<::base::UnguessableToken>& processing_id, ::media::mojom::ReadWriteAudioDataPipePtr* out_data_pipe) {
  base::RunLoop loop;
  proxy_->CreateOutputStream(std::move(stream),std::move(observer),std::move(log),std::move(device_id),std::move(params),std::move(group_id),std::move(processing_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::media::mojom::ReadWriteAudioDataPipePtr* out_data_pipe
,
             ::media::mojom::ReadWriteAudioDataPipePtr data_pipe) {*out_data_pipe = std::move(data_pipe);
            loop->Quit();
          },
          &loop,
          out_data_pipe));
  loop.Run();
}
void StreamFactoryAsyncWaiter::CreateLoopbackStream(
    mojo::PendingReceiver<::media::mojom::AudioInputStream> receiver, mojo::PendingRemote<::media::mojom::AudioInputStreamClient> client, mojo::PendingRemote<::media::mojom::AudioInputStreamObserver> observer, const ::media::AudioParameters& params, uint32_t shared_memory_count, const ::base::UnguessableToken& group_id, ::media::mojom::ReadOnlyAudioDataPipePtr* out_data_pipe) {
  base::RunLoop loop;
  proxy_->CreateLoopbackStream(std::move(receiver),std::move(client),std::move(observer),std::move(params),std::move(shared_memory_count),std::move(group_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::media::mojom::ReadOnlyAudioDataPipePtr* out_data_pipe
,
             ::media::mojom::ReadOnlyAudioDataPipePtr data_pipe) {*out_data_pipe = std::move(data_pipe);
            loop->Quit();
          },
          &loop,
          out_data_pipe));
  loop.Run();
}





}  // namespace mojom
}  // namespace audio

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif