// services/audio/public/mojom/stream_factory.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_AUDIO_PUBLIC_MOJOM_STREAM_FACTORY_MOJOM_TEST_UTILS_H_
#define SERVICES_AUDIO_PUBLIC_MOJOM_STREAM_FACTORY_MOJOM_TEST_UTILS_H_

#include "services/audio/public/mojom/stream_factory.mojom.h"


namespace audio {
namespace mojom {


class  LocalMuterInterceptorForTesting : public LocalMuter {
  virtual LocalMuter* GetForwardingInterface() = 0;
};
class  LocalMuterAsyncWaiter {
 public:
  explicit LocalMuterAsyncWaiter(LocalMuter* proxy);
  ~LocalMuterAsyncWaiter();

 private:
  LocalMuter* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(LocalMuterAsyncWaiter);
};


class  StreamFactoryInterceptorForTesting : public StreamFactory {
  virtual StreamFactory* GetForwardingInterface() = 0;
  void CreateInputStream(mojo::PendingReceiver<::media::mojom::AudioInputStream> stream, mojo::PendingRemote<::media::mojom::AudioInputStreamClient> client, mojo::PendingRemote<::media::mojom::AudioInputStreamObserver> observer, mojo::PendingRemote<::media::mojom::AudioLog> log, const std::string& device_id, const ::media::AudioParameters& params, uint32_t shared_memory_count, bool enable_agc, mojo::ScopedSharedBufferHandle key_press_count_buffer, ::audio::mojom::AudioProcessingConfigPtr processing_config, CreateInputStreamCallback callback) override;
  void AssociateInputAndOutputForAec(const ::base::UnguessableToken& input_stream_id, const std::string& output_device_id) override;
  void CreateOutputStream(mojo::PendingReceiver<::media::mojom::AudioOutputStream> stream, mojo::PendingAssociatedRemote<::media::mojom::AudioOutputStreamObserver> observer, mojo::PendingRemote<::media::mojom::AudioLog> log, const std::string& device_id, const ::media::AudioParameters& params, const ::base::UnguessableToken& group_id, const base::Optional<::base::UnguessableToken>& processing_id, CreateOutputStreamCallback callback) override;
  void BindMuter(mojo::PendingAssociatedReceiver<LocalMuter> receiver, const ::base::UnguessableToken& group_id) override;
  void CreateLoopbackStream(mojo::PendingReceiver<::media::mojom::AudioInputStream> receiver, mojo::PendingRemote<::media::mojom::AudioInputStreamClient> client, mojo::PendingRemote<::media::mojom::AudioInputStreamObserver> observer, const ::media::AudioParameters& params, uint32_t shared_memory_count, const ::base::UnguessableToken& group_id, CreateLoopbackStreamCallback callback) override;
};
class  StreamFactoryAsyncWaiter {
 public:
  explicit StreamFactoryAsyncWaiter(StreamFactory* proxy);
  ~StreamFactoryAsyncWaiter();
  void CreateInputStream(
      mojo::PendingReceiver<::media::mojom::AudioInputStream> stream, mojo::PendingRemote<::media::mojom::AudioInputStreamClient> client, mojo::PendingRemote<::media::mojom::AudioInputStreamObserver> observer, mojo::PendingRemote<::media::mojom::AudioLog> log, const std::string& device_id, const ::media::AudioParameters& params, uint32_t shared_memory_count, bool enable_agc, mojo::ScopedSharedBufferHandle key_press_count_buffer, ::audio::mojom::AudioProcessingConfigPtr processing_config, ::media::mojom::ReadOnlyAudioDataPipePtr* out_data_pipe, bool* out_initially_muted, base::Optional<::base::UnguessableToken>* out_stream_id);
  void CreateOutputStream(
      mojo::PendingReceiver<::media::mojom::AudioOutputStream> stream, mojo::PendingAssociatedRemote<::media::mojom::AudioOutputStreamObserver> observer, mojo::PendingRemote<::media::mojom::AudioLog> log, const std::string& device_id, const ::media::AudioParameters& params, const ::base::UnguessableToken& group_id, const base::Optional<::base::UnguessableToken>& processing_id, ::media::mojom::ReadWriteAudioDataPipePtr* out_data_pipe);
  void CreateLoopbackStream(
      mojo::PendingReceiver<::media::mojom::AudioInputStream> receiver, mojo::PendingRemote<::media::mojom::AudioInputStreamClient> client, mojo::PendingRemote<::media::mojom::AudioInputStreamObserver> observer, const ::media::AudioParameters& params, uint32_t shared_memory_count, const ::base::UnguessableToken& group_id, ::media::mojom::ReadOnlyAudioDataPipePtr* out_data_pipe);

 private:
  StreamFactory* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(StreamFactoryAsyncWaiter);
};




}  // namespace mojom
}  // namespace audio

#endif  // SERVICES_AUDIO_PUBLIC_MOJOM_STREAM_FACTORY_MOJOM_TEST_UTILS_H_