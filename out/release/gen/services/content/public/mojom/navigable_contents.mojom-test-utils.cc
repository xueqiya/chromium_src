// services/content/public/mojom/navigable_contents.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif


#include "services/content/public/mojom/navigable_contents.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"
#include "services/network/public/mojom/network_param.mojom.h"
#include "ui/accessibility/mojom/ax_tree_id.mojom.h"
#include "ui/base/mojom/window_open_disposition.mojom.h"
#include "ui/gfx/geometry/mojom/geometry.mojom.h"
#include "mojo/public/mojom/base/unguessable_token.mojom.h"
#include "url/mojom/url.mojom.h"


#ifndef SERVICES_CONTENT_PUBLIC_MOJOM_NAVIGABLE_CONTENTS_MOJOM_JUMBO_H_
#define SERVICES_CONTENT_PUBLIC_MOJOM_NAVIGABLE_CONTENTS_MOJOM_JUMBO_H_
#include "mojo/public/cpp/base/unguessable_token_mojom_traits.h"
#include "services/network/public/cpp/net_ipc_param_traits.h"
#include "services/network/public/cpp/network_param_mojom_traits.h"
#include "ui/accessibility/mojom/ax_tree_id_mojom_traits.h"
#include "ui/base/mojom/window_open_disposition_mojom_traits.h"
#include "ui/gfx/geometry/mojom/geometry_mojom_traits.h"
#include "url/mojom/url_gurl_mojom_traits.h"
#endif


namespace content {
namespace mojom {


void NavigableContentsInterceptorForTesting::Navigate(const ::GURL& url, NavigateParamsPtr params) {
  GetForwardingInterface()->Navigate(std::move(url), std::move(params));
}
void NavigableContentsInterceptorForTesting::GoBack(GoBackCallback callback) {
  GetForwardingInterface()->GoBack(std::move(callback));
}
void NavigableContentsInterceptorForTesting::CreateView(CreateViewCallback callback) {
  GetForwardingInterface()->CreateView(std::move(callback));
}
void NavigableContentsInterceptorForTesting::Focus() {
  GetForwardingInterface()->Focus();
}
void NavigableContentsInterceptorForTesting::FocusThroughTabTraversal(bool reverse) {
  GetForwardingInterface()->FocusThroughTabTraversal(std::move(reverse));
}
NavigableContentsAsyncWaiter::NavigableContentsAsyncWaiter(
    NavigableContents* proxy) : proxy_(proxy) {}

NavigableContentsAsyncWaiter::~NavigableContentsAsyncWaiter() = default;

void NavigableContentsAsyncWaiter::GoBack(
    bool* out_success) {
  base::RunLoop loop;
  proxy_->GoBack(
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             bool success) {*out_success = std::move(success);
            loop->Quit();
          },
          &loop,
          out_success));
  loop.Run();
}
void NavigableContentsAsyncWaiter::CreateView(
    ::base::UnguessableToken* out_embed_token) {
  base::RunLoop loop;
  proxy_->CreateView(
      base::BindOnce(
          [](base::RunLoop* loop,
             ::base::UnguessableToken* out_embed_token
,
             const ::base::UnguessableToken& embed_token) {*out_embed_token = std::move(embed_token);
            loop->Quit();
          },
          &loop,
          out_embed_token));
  loop.Run();
}



void NavigableContentsClientInterceptorForTesting::ClearViewFocus() {
  GetForwardingInterface()->ClearViewFocus();
}
void NavigableContentsClientInterceptorForTesting::DidFinishNavigation(const ::GURL& url, bool is_main_frame, bool is_error_page, const ::scoped_refptr<::net::HttpResponseHeaders>& response_headers) {
  GetForwardingInterface()->DidFinishNavigation(std::move(url), std::move(is_main_frame), std::move(is_error_page), std::move(response_headers));
}
void NavigableContentsClientInterceptorForTesting::DidStopLoading() {
  GetForwardingInterface()->DidStopLoading();
}
void NavigableContentsClientInterceptorForTesting::DidAutoResizeView(const ::gfx::Size& new_size) {
  GetForwardingInterface()->DidAutoResizeView(std::move(new_size));
}
void NavigableContentsClientInterceptorForTesting::DidSuppressNavigation(const ::GURL& url, ::WindowOpenDisposition disposition, bool from_user_gesture) {
  GetForwardingInterface()->DidSuppressNavigation(std::move(url), std::move(disposition), std::move(from_user_gesture));
}
void NavigableContentsClientInterceptorForTesting::UpdateCanGoBack(bool can_go_back) {
  GetForwardingInterface()->UpdateCanGoBack(std::move(can_go_back));
}
void NavigableContentsClientInterceptorForTesting::UpdateContentAXTree(const ::ui::AXTreeID& id) {
  GetForwardingInterface()->UpdateContentAXTree(std::move(id));
}
void NavigableContentsClientInterceptorForTesting::FocusedNodeChanged(bool is_editable_node, const ::gfx::Rect& node_bounds_in_screen) {
  GetForwardingInterface()->FocusedNodeChanged(std::move(is_editable_node), std::move(node_bounds_in_screen));
}
NavigableContentsClientAsyncWaiter::NavigableContentsClientAsyncWaiter(
    NavigableContentsClient* proxy) : proxy_(proxy) {}

NavigableContentsClientAsyncWaiter::~NavigableContentsClientAsyncWaiter() = default;






}  // namespace mojom
}  // namespace content

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif