// services/network/public/mojom/network_service.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif

#include "services/network/public/mojom/network_service.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/hash/md5_constexpr.h"
#include "base/logging.h"
#include "base/run_loop.h"
#include "base/task/common/task_annotator.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_context.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"

#include "services/network/public/mojom/network_service.mojom-params-data.h"
#include "services/network/public/mojom/network_service.mojom-shared-message-ids.h"

#include "services/network/public/mojom/network_service.mojom-import-headers.h"


#ifndef SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_SERVICE_MOJOM_JUMBO_H_
#define SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_SERVICE_MOJOM_JUMBO_H_
#include "components/content_settings/core/common/content_settings_mojom_traits.h"
#include "components/content_settings/core/common/content_settings_param_traits.h"
#include "mojo/public/cpp/base/application_state_mojom_traits.h"
#include "mojo/public/cpp/base/big_buffer_mojom_traits.h"
#include "mojo/public/cpp/base/big_string_mojom_traits.h"
#include "mojo/public/cpp/base/file_mojom_traits.h"
#include "mojo/public/cpp/base/file_path_mojom_traits.h"
#include "mojo/public/cpp/base/memory_pressure_level_mojom_traits.h"
#include "mojo/public/cpp/base/read_only_buffer_mojom_traits.h"
#include "mojo/public/cpp/base/string16_mojom_traits.h"
#include "mojo/public/cpp/base/time_mojom_traits.h"
#include "mojo/public/cpp/base/unguessable_token_mojom_traits.h"
#include "mojo/public/cpp/base/values_mojom_traits.h"
#include "services/network/public/cpp/cookie_manager_mojom_traits.h"
#include "services/network/public/cpp/default_credentials_mojom_traits.h"
#include "services/network/public/cpp/host_resolver_mojom_traits.h"
#include "services/network/public/cpp/http_request_headers_mojom_traits.h"
#include "services/network/public/cpp/ip_address_mojom_traits.h"
#include "services/network/public/cpp/mutable_network_traffic_annotation_tag_mojom_traits.h"
#include "services/network/public/cpp/net_log_mojom_traits.h"
#include "services/network/public/cpp/network_interface_mojom_traits.h"
#include "services/network/public/cpp/proxy_config_mojom_traits.h"
#include "services/network/public/cpp/proxy_config_with_annotation_mojom_traits.h"
#include "url/mojom/origin_mojom_traits.h"
#endif
namespace network {
namespace mojom {
LoadInfo::LoadInfo()
    : process_id(),
      routing_id(),
      host(),
      load_state(),
      state_param(),
      upload_position(),
      upload_size() {}

LoadInfo::LoadInfo(
    int32_t process_id_in,
    int32_t routing_id_in,
    const std::string& host_in,
    uint32_t load_state_in,
    const ::base::string16& state_param_in,
    uint64_t upload_position_in,
    uint64_t upload_size_in)
    : process_id(std::move(process_id_in)),
      routing_id(std::move(routing_id_in)),
      host(std::move(host_in)),
      load_state(std::move(load_state_in)),
      state_param(std::move(state_param_in)),
      upload_position(std::move(upload_position_in)),
      upload_size(std::move(upload_size_in)) {}

LoadInfo::~LoadInfo() = default;

bool LoadInfo::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
HttpAuthStaticParams::HttpAuthStaticParams()
    : supported_schemes(),
      gssapi_library_name() {}

HttpAuthStaticParams::HttpAuthStaticParams(
    std::vector<std::string> supported_schemes_in,
    const std::string& gssapi_library_name_in)
    : supported_schemes(std::move(supported_schemes_in)),
      gssapi_library_name(std::move(gssapi_library_name_in)) {}

HttpAuthStaticParams::~HttpAuthStaticParams() = default;

bool HttpAuthStaticParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
HttpAuthDynamicParams::HttpAuthDynamicParams()
    : server_allowlist(),
      delegate_allowlist(),
      delegate_by_kdc_policy(false),
      negotiate_disable_cname_lookup(false),
      enable_negotiate_port(true),
      ntlm_v2_enabled(false),
      android_negotiate_account_type(),
      allow_gssapi_library_load(true) {}

HttpAuthDynamicParams::HttpAuthDynamicParams(
    const std::string& server_allowlist_in,
    const std::string& delegate_allowlist_in,
    bool delegate_by_kdc_policy_in,
    bool negotiate_disable_cname_lookup_in,
    bool enable_negotiate_port_in,
    bool ntlm_v2_enabled_in,
    const std::string& android_negotiate_account_type_in,
    bool allow_gssapi_library_load_in)
    : server_allowlist(std::move(server_allowlist_in)),
      delegate_allowlist(std::move(delegate_allowlist_in)),
      delegate_by_kdc_policy(std::move(delegate_by_kdc_policy_in)),
      negotiate_disable_cname_lookup(std::move(negotiate_disable_cname_lookup_in)),
      enable_negotiate_port(std::move(enable_negotiate_port_in)),
      ntlm_v2_enabled(std::move(ntlm_v2_enabled_in)),
      android_negotiate_account_type(std::move(android_negotiate_account_type_in)),
      allow_gssapi_library_load(std::move(allow_gssapi_library_load_in)) {}

HttpAuthDynamicParams::~HttpAuthDynamicParams() = default;
size_t HttpAuthDynamicParams::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->server_allowlist);
  seed = mojo::internal::Hash(seed, this->delegate_allowlist);
  seed = mojo::internal::Hash(seed, this->delegate_by_kdc_policy);
  seed = mojo::internal::Hash(seed, this->negotiate_disable_cname_lookup);
  seed = mojo::internal::Hash(seed, this->enable_negotiate_port);
  seed = mojo::internal::Hash(seed, this->ntlm_v2_enabled);
  seed = mojo::internal::Hash(seed, this->android_negotiate_account_type);
  seed = mojo::internal::Hash(seed, this->allow_gssapi_library_load);
  return seed;
}

bool HttpAuthDynamicParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
EnvironmentVariable::EnvironmentVariable()
    : name(),
      value() {}

EnvironmentVariable::EnvironmentVariable(
    const std::string& name_in,
    const std::string& value_in)
    : name(std::move(name_in)),
      value(std::move(value_in)) {}

EnvironmentVariable::~EnvironmentVariable() = default;
size_t EnvironmentVariable::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->name);
  seed = mojo::internal::Hash(seed, this->value);
  return seed;
}

bool EnvironmentVariable::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
NetworkServiceParams::NetworkServiceParams()
    : initial_connection_type(::network::mojom::ConnectionType::CONNECTION_UNKNOWN),
      initial_connection_subtype(::network::mojom::ConnectionSubtype::SUBTYPE_UNKNOWN),
      environment() {}

NetworkServiceParams::NetworkServiceParams(
    ::network::mojom::ConnectionType initial_connection_type_in,
    ::network::mojom::ConnectionSubtype initial_connection_subtype_in,
    std::vector<EnvironmentVariablePtr> environment_in)
    : initial_connection_type(std::move(initial_connection_type_in)),
      initial_connection_subtype(std::move(initial_connection_subtype_in)),
      environment(std::move(environment_in)) {}

NetworkServiceParams::~NetworkServiceParams() = default;

bool NetworkServiceParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char NetworkServiceClient::Name_[] = "network.mojom.NetworkServiceClient";

class NetworkServiceClient_OnLoadingStateUpdate_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkServiceClient_OnLoadingStateUpdate_ForwardToCallback(
      NetworkServiceClient::OnLoadingStateUpdateCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  NetworkServiceClient::OnLoadingStateUpdateCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(NetworkServiceClient_OnLoadingStateUpdate_ForwardToCallback);
};

NetworkServiceClientProxy::NetworkServiceClientProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void NetworkServiceClientProxy::OnLoadingStateUpdate(
    std::vector<LoadInfoPtr> in_infos, OnLoadingStateUpdateCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkServiceClient::OnLoadingStateUpdate");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkServiceClient_OnLoadingStateUpdate_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkServiceClient_OnLoadingStateUpdate_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->infos)::BaseType::BufferWriter
      infos_writer;
  const mojo::internal::ContainerValidateParams infos_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::LoadInfoDataView>>(
      in_infos, buffer, &infos_writer, &infos_validate_params,
      &serialization_context);
  params->infos.Set(
      infos_writer.is_null() ? nullptr : infos_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->infos.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null infos in NetworkServiceClient.OnLoadingStateUpdate request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceClient::Name_);
  message.set_method_name("OnLoadingStateUpdate");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceClient_OnLoadingStateUpdate_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void NetworkServiceClientProxy::OnDataUseUpdate(
    int32_t in_network_traffic_annotation_id_hash, int64_t in_recv_bytes, int64_t in_sent_bytes) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkServiceClient::OnDataUseUpdate");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkServiceClient_OnDataUseUpdate_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkServiceClient_OnDataUseUpdate_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->network_traffic_annotation_id_hash = in_network_traffic_annotation_id_hash;
  params->recv_bytes = in_recv_bytes;
  params->sent_bytes = in_sent_bytes;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceClient::Name_);
  message.set_method_name("OnDataUseUpdate");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceClientProxy::OnRawRequest(
    int32_t in_process_id, int32_t in_routing_id, const std::string& in_devtool_request_id, const std::vector<::net::CookieWithStatus>& in_cookies_with_status, std::vector<::network::mojom::HttpRawHeaderPairPtr> in_headers) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkServiceClient::OnRawRequest");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkServiceClient_OnRawRequest_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkServiceClient_OnRawRequest_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->process_id = in_process_id;
  params->routing_id = in_routing_id;
  typename decltype(params->devtool_request_id)::BaseType::BufferWriter
      devtool_request_id_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_devtool_request_id, buffer, &devtool_request_id_writer, &serialization_context);
  params->devtool_request_id.Set(
      devtool_request_id_writer.is_null() ? nullptr : devtool_request_id_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->devtool_request_id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null devtool_request_id in NetworkServiceClient.OnRawRequest request");
  typename decltype(params->cookies_with_status)::BaseType::BufferWriter
      cookies_with_status_writer;
  const mojo::internal::ContainerValidateParams cookies_with_status_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::CookieWithStatusDataView>>(
      in_cookies_with_status, buffer, &cookies_with_status_writer, &cookies_with_status_validate_params,
      &serialization_context);
  params->cookies_with_status.Set(
      cookies_with_status_writer.is_null() ? nullptr : cookies_with_status_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->cookies_with_status.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null cookies_with_status in NetworkServiceClient.OnRawRequest request");
  typename decltype(params->headers)::BaseType::BufferWriter
      headers_writer;
  const mojo::internal::ContainerValidateParams headers_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::HttpRawHeaderPairDataView>>(
      in_headers, buffer, &headers_writer, &headers_validate_params,
      &serialization_context);
  params->headers.Set(
      headers_writer.is_null() ? nullptr : headers_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->headers.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null headers in NetworkServiceClient.OnRawRequest request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceClient::Name_);
  message.set_method_name("OnRawRequest");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceClientProxy::OnRawResponse(
    int32_t in_process_id, int32_t in_routing_id, const std::string& in_devtool_request_id, const std::vector<::net::CookieAndLineWithStatus>& in_cookies_with_status, std::vector<::network::mojom::HttpRawHeaderPairPtr> in_headers, const base::Optional<std::string>& in_raw_response_headers) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkServiceClient::OnRawResponse");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkServiceClient_OnRawResponse_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkServiceClient_OnRawResponse_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->process_id = in_process_id;
  params->routing_id = in_routing_id;
  typename decltype(params->devtool_request_id)::BaseType::BufferWriter
      devtool_request_id_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_devtool_request_id, buffer, &devtool_request_id_writer, &serialization_context);
  params->devtool_request_id.Set(
      devtool_request_id_writer.is_null() ? nullptr : devtool_request_id_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->devtool_request_id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null devtool_request_id in NetworkServiceClient.OnRawResponse request");
  typename decltype(params->cookies_with_status)::BaseType::BufferWriter
      cookies_with_status_writer;
  const mojo::internal::ContainerValidateParams cookies_with_status_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::CookieAndLineWithStatusDataView>>(
      in_cookies_with_status, buffer, &cookies_with_status_writer, &cookies_with_status_validate_params,
      &serialization_context);
  params->cookies_with_status.Set(
      cookies_with_status_writer.is_null() ? nullptr : cookies_with_status_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->cookies_with_status.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null cookies_with_status in NetworkServiceClient.OnRawResponse request");
  typename decltype(params->headers)::BaseType::BufferWriter
      headers_writer;
  const mojo::internal::ContainerValidateParams headers_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::HttpRawHeaderPairDataView>>(
      in_headers, buffer, &headers_writer, &headers_validate_params,
      &serialization_context);
  params->headers.Set(
      headers_writer.is_null() ? nullptr : headers_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->headers.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null headers in NetworkServiceClient.OnRawResponse request");
  typename decltype(params->raw_response_headers)::BaseType::BufferWriter
      raw_response_headers_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_raw_response_headers, buffer, &raw_response_headers_writer, &serialization_context);
  params->raw_response_headers.Set(
      raw_response_headers_writer.is_null() ? nullptr : raw_response_headers_writer.data());
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceClient::Name_);
  message.set_method_name("OnRawResponse");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
class NetworkServiceClient_OnLoadingStateUpdate_ProxyToResponder {
 public:
  static NetworkServiceClient::OnLoadingStateUpdateCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkServiceClient_OnLoadingStateUpdate_ProxyToResponder> proxy(
        new NetworkServiceClient_OnLoadingStateUpdate_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&NetworkServiceClient_OnLoadingStateUpdate_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkServiceClient_OnLoadingStateUpdate_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  NetworkServiceClient_OnLoadingStateUpdate_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkServiceClient::OnLoadingStateUpdateCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(NetworkServiceClient_OnLoadingStateUpdate_ProxyToResponder);
};

bool NetworkServiceClient_OnLoadingStateUpdate_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "network::mojom::NetworkServiceClient::OnLoadingStateUpdateCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::NetworkServiceClient_OnLoadingStateUpdate_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkServiceClient_OnLoadingStateUpdate_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  NetworkServiceClient_OnLoadingStateUpdate_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceClient::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkServiceClient_OnLoadingStateUpdate_ProxyToResponder::Run(
    ) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkServiceClient_OnLoadingStateUpdate_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkServiceClient_OnLoadingStateUpdate_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)network::mojom::NetworkServiceClient::OnLoadingStateUpdateCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceClient::Name_);
  message.set_method_name("OnLoadingStateUpdate");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool NetworkServiceClientStubDispatch::Accept(
    NetworkServiceClient* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kNetworkServiceClient_OnLoadingStateUpdate_Name: {
      break;
    }
    case internal::kNetworkServiceClient_OnDataUseUpdate_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkServiceClient::OnDataUseUpdate",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkServiceClient::OnDataUseUpdate");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkServiceClient_OnDataUseUpdate_Params_Data* params =
          reinterpret_cast<internal::NetworkServiceClient_OnDataUseUpdate_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int32_t p_network_traffic_annotation_id_hash{};
      int64_t p_recv_bytes{};
      int64_t p_sent_bytes{};
      NetworkServiceClient_OnDataUseUpdate_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_network_traffic_annotation_id_hash = input_data_view.network_traffic_annotation_id_hash();
      if (success)
        p_recv_bytes = input_data_view.recv_bytes();
      if (success)
        p_sent_bytes = input_data_view.sent_bytes();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceClient::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnDataUseUpdate(
std::move(p_network_traffic_annotation_id_hash), 
std::move(p_recv_bytes), 
std::move(p_sent_bytes));
      return true;
    }
    case internal::kNetworkServiceClient_OnRawRequest_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkServiceClient::OnRawRequest",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkServiceClient::OnRawRequest");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkServiceClient_OnRawRequest_Params_Data* params =
          reinterpret_cast<internal::NetworkServiceClient_OnRawRequest_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int32_t p_process_id{};
      int32_t p_routing_id{};
      std::string p_devtool_request_id{};
      std::vector<::net::CookieWithStatus> p_cookies_with_status{};
      std::vector<::network::mojom::HttpRawHeaderPairPtr> p_headers{};
      NetworkServiceClient_OnRawRequest_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_process_id = input_data_view.process_id();
      if (success)
        p_routing_id = input_data_view.routing_id();
      if (success && !input_data_view.ReadDevtoolRequestId(&p_devtool_request_id))
        success = false;
      if (success && !input_data_view.ReadCookiesWithStatus(&p_cookies_with_status))
        success = false;
      if (success && !input_data_view.ReadHeaders(&p_headers))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceClient::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnRawRequest(
std::move(p_process_id), 
std::move(p_routing_id), 
std::move(p_devtool_request_id), 
std::move(p_cookies_with_status), 
std::move(p_headers));
      return true;
    }
    case internal::kNetworkServiceClient_OnRawResponse_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkServiceClient::OnRawResponse",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkServiceClient::OnRawResponse");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkServiceClient_OnRawResponse_Params_Data* params =
          reinterpret_cast<internal::NetworkServiceClient_OnRawResponse_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int32_t p_process_id{};
      int32_t p_routing_id{};
      std::string p_devtool_request_id{};
      std::vector<::net::CookieAndLineWithStatus> p_cookies_with_status{};
      std::vector<::network::mojom::HttpRawHeaderPairPtr> p_headers{};
      base::Optional<std::string> p_raw_response_headers{};
      NetworkServiceClient_OnRawResponse_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_process_id = input_data_view.process_id();
      if (success)
        p_routing_id = input_data_view.routing_id();
      if (success && !input_data_view.ReadDevtoolRequestId(&p_devtool_request_id))
        success = false;
      if (success && !input_data_view.ReadCookiesWithStatus(&p_cookies_with_status))
        success = false;
      if (success && !input_data_view.ReadHeaders(&p_headers))
        success = false;
      if (success && !input_data_view.ReadRawResponseHeaders(&p_raw_response_headers))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceClient::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnRawResponse(
std::move(p_process_id), 
std::move(p_routing_id), 
std::move(p_devtool_request_id), 
std::move(p_cookies_with_status), 
std::move(p_headers), 
std::move(p_raw_response_headers));
      return true;
    }
  }
  return false;
}

// static
bool NetworkServiceClientStubDispatch::AcceptWithResponder(
    NetworkServiceClient* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kNetworkServiceClient_OnLoadingStateUpdate_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkServiceClient::OnLoadingStateUpdate",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkServiceClient::OnLoadingStateUpdate");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::NetworkServiceClient_OnLoadingStateUpdate_Params_Data* params =
          reinterpret_cast<
              internal::NetworkServiceClient_OnLoadingStateUpdate_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      std::vector<LoadInfoPtr> p_infos{};
      NetworkServiceClient_OnLoadingStateUpdate_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadInfos(&p_infos))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceClient::Name_, 0, false);
        return false;
      }
      NetworkServiceClient::OnLoadingStateUpdateCallback callback =
          NetworkServiceClient_OnLoadingStateUpdate_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnLoadingStateUpdate(
std::move(p_infos), std::move(callback));
      return true;
    }
    case internal::kNetworkServiceClient_OnDataUseUpdate_Name: {
      break;
    }
    case internal::kNetworkServiceClient_OnRawRequest_Name: {
      break;
    }
    case internal::kNetworkServiceClient_OnRawResponse_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kNetworkServiceClientValidationInfo[] = {
    {&internal::NetworkServiceClient_OnLoadingStateUpdate_Params_Data::Validate,
     &internal::NetworkServiceClient_OnLoadingStateUpdate_ResponseParams_Data::Validate},
    {&internal::NetworkServiceClient_OnDataUseUpdate_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkServiceClient_OnRawRequest_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkServiceClient_OnRawResponse_Params_Data::Validate,
     nullptr /* no response */},
};

bool NetworkServiceClientRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::NetworkServiceClient::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kNetworkServiceClientValidationInfo);
}

bool NetworkServiceClientResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::NetworkServiceClient::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kNetworkServiceClientValidationInfo);
}
const char NetworkService::Name_[] = "network.mojom.NetworkService";

class NetworkService_GetTotalNetworkUsages_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkService_GetTotalNetworkUsages_ForwardToCallback(
      NetworkService::GetTotalNetworkUsagesCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  NetworkService::GetTotalNetworkUsagesCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(NetworkService_GetTotalNetworkUsages_ForwardToCallback);
};

class NetworkService_GetNetworkList_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkService_GetNetworkList_ForwardToCallback(
      NetworkService::GetNetworkListCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  NetworkService::GetNetworkListCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(NetworkService_GetNetworkList_ForwardToCallback);
};

class NetworkService_UpdateCRLSet_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkService_UpdateCRLSet_ForwardToCallback(
      NetworkService::UpdateCRLSetCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  NetworkService::UpdateCRLSetCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(NetworkService_UpdateCRLSet_ForwardToCallback);
};

class NetworkService_UpdateLegacyTLSConfig_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkService_UpdateLegacyTLSConfig_ForwardToCallback(
      NetworkService::UpdateLegacyTLSConfigCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  NetworkService::UpdateLegacyTLSConfigCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(NetworkService_UpdateLegacyTLSConfig_ForwardToCallback);
};

NetworkServiceProxy::NetworkServiceProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void NetworkServiceProxy::SetClient(
    mojo::PendingRemote<NetworkServiceClient> in_client, NetworkServiceParamsPtr in_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::SetClient");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_SetClient_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_SetClient_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::network::mojom::NetworkServiceClientInterfaceBase>>(
      in_client, &params->client, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->client),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid client in NetworkService.SetClient request");
  typename decltype(params->params)::BaseType::BufferWriter
      params_writer;
  mojo::internal::Serialize<::network::mojom::NetworkServiceParamsDataView>(
      in_params, buffer, &params_writer, &serialization_context);
  params->params.Set(
      params_writer.is_null() ? nullptr : params_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in NetworkService.SetClient request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("SetClient");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceProxy::StartNetLog(
    ::base::File in_file, ::net::NetLogCaptureMode in_capture_mode, ::base::Value in_constants) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::StartNetLog");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_StartNetLog_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_StartNetLog_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->file)::BaseType::BufferWriter
      file_writer;
  mojo::internal::Serialize<::mojo_base::mojom::FileDataView>(
      in_file, buffer, &file_writer, &serialization_context);
  params->file.Set(
      file_writer.is_null() ? nullptr : file_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->file.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null file in NetworkService.StartNetLog request");
  mojo::internal::Serialize<::network::mojom::NetLogCaptureMode>(
      in_capture_mode, &params->capture_mode);
  typename decltype(params->constants)::BaseType::BufferWriter
      constants_writer;
  mojo::internal::Serialize<::mojo_base::mojom::DictionaryValueDataView>(
      in_constants, buffer, &constants_writer, &serialization_context);
  params->constants.Set(
      constants_writer.is_null() ? nullptr : constants_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->constants.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null constants in NetworkService.StartNetLog request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("StartNetLog");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceProxy::SetSSLKeyLogFile(
    ::base::File in_file) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::SetSSLKeyLogFile");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_SetSSLKeyLogFile_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_SetSSLKeyLogFile_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->file)::BaseType::BufferWriter
      file_writer;
  mojo::internal::Serialize<::mojo_base::mojom::FileDataView>(
      in_file, buffer, &file_writer, &serialization_context);
  params->file.Set(
      file_writer.is_null() ? nullptr : file_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->file.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null file in NetworkService.SetSSLKeyLogFile request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("SetSSLKeyLogFile");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceProxy::CreateNetworkContext(
    mojo::PendingReceiver<::network::mojom::NetworkContext> in_context, ::network::mojom::NetworkContextParamsPtr in_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::CreateNetworkContext");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_CreateNetworkContext_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_CreateNetworkContext_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::NetworkContextInterfaceBase>>(
      in_context, &params->context, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->context),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid context in NetworkService.CreateNetworkContext request");
  typename decltype(params->params)::BaseType::BufferWriter
      params_writer;
  mojo::internal::Serialize<::network::mojom::NetworkContextParamsDataView>(
      in_params, buffer, &params_writer, &serialization_context);
  params->params.Set(
      params_writer.is_null() ? nullptr : params_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in NetworkService.CreateNetworkContext request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("CreateNetworkContext");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceProxy::ConfigureStubHostResolver(
    bool in_insecure_dns_client_enabled, ::net::DnsConfig::SecureDnsMode in_secure_dns_mode, base::Optional<std::vector<::network::mojom::DnsOverHttpsServerPtr>> in_dns_over_https_servers) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::ConfigureStubHostResolver");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_ConfigureStubHostResolver_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_ConfigureStubHostResolver_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->insecure_dns_client_enabled = in_insecure_dns_client_enabled;
  mojo::internal::Serialize<::network::mojom::SecureDnsMode>(
      in_secure_dns_mode, &params->secure_dns_mode);
  typename decltype(params->dns_over_https_servers)::BaseType::BufferWriter
      dns_over_https_servers_writer;
  const mojo::internal::ContainerValidateParams dns_over_https_servers_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::DnsOverHttpsServerDataView>>(
      in_dns_over_https_servers, buffer, &dns_over_https_servers_writer, &dns_over_https_servers_validate_params,
      &serialization_context);
  params->dns_over_https_servers.Set(
      dns_over_https_servers_writer.is_null() ? nullptr : dns_over_https_servers_writer.data());
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("ConfigureStubHostResolver");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceProxy::DisableQuic(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::DisableQuic");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_DisableQuic_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_DisableQuic_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("DisableQuic");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceProxy::SetUpHttpAuth(
    HttpAuthStaticParamsPtr in_http_auth_static_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::SetUpHttpAuth");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_SetUpHttpAuth_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_SetUpHttpAuth_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->http_auth_static_params)::BaseType::BufferWriter
      http_auth_static_params_writer;
  mojo::internal::Serialize<::network::mojom::HttpAuthStaticParamsDataView>(
      in_http_auth_static_params, buffer, &http_auth_static_params_writer, &serialization_context);
  params->http_auth_static_params.Set(
      http_auth_static_params_writer.is_null() ? nullptr : http_auth_static_params_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->http_auth_static_params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null http_auth_static_params in NetworkService.SetUpHttpAuth request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("SetUpHttpAuth");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceProxy::ConfigureHttpAuthPrefs(
    HttpAuthDynamicParamsPtr in_http_auth_dynamic_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::ConfigureHttpAuthPrefs");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_ConfigureHttpAuthPrefs_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_ConfigureHttpAuthPrefs_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->http_auth_dynamic_params)::BaseType::BufferWriter
      http_auth_dynamic_params_writer;
  mojo::internal::Serialize<::network::mojom::HttpAuthDynamicParamsDataView>(
      in_http_auth_dynamic_params, buffer, &http_auth_dynamic_params_writer, &serialization_context);
  params->http_auth_dynamic_params.Set(
      http_auth_dynamic_params_writer.is_null() ? nullptr : http_auth_dynamic_params_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->http_auth_dynamic_params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null http_auth_dynamic_params in NetworkService.ConfigureHttpAuthPrefs request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("ConfigureHttpAuthPrefs");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceProxy::SetRawHeadersAccess(
    int32_t in_process_id, const std::vector<::url::Origin>& in_origins) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::SetRawHeadersAccess");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_SetRawHeadersAccess_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_SetRawHeadersAccess_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->process_id = in_process_id;
  typename decltype(params->origins)::BaseType::BufferWriter
      origins_writer;
  const mojo::internal::ContainerValidateParams origins_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::url::mojom::OriginDataView>>(
      in_origins, buffer, &origins_writer, &origins_validate_params,
      &serialization_context);
  params->origins.Set(
      origins_writer.is_null() ? nullptr : origins_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->origins.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null origins in NetworkService.SetRawHeadersAccess request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("SetRawHeadersAccess");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceProxy::SetMaxConnectionsPerProxy(
    int32_t in_max_connections) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::SetMaxConnectionsPerProxy");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_SetMaxConnectionsPerProxy_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_SetMaxConnectionsPerProxy_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->max_connections = in_max_connections;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("SetMaxConnectionsPerProxy");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceProxy::GetNetworkChangeManager(
    mojo::PendingReceiver<::network::mojom::NetworkChangeManager> in_network_change_manager) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::GetNetworkChangeManager");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_GetNetworkChangeManager_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_GetNetworkChangeManager_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::NetworkChangeManagerInterfaceBase>>(
      in_network_change_manager, &params->network_change_manager, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->network_change_manager),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid network_change_manager in NetworkService.GetNetworkChangeManager request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("GetNetworkChangeManager");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceProxy::GetNetworkQualityEstimatorManager(
    mojo::PendingReceiver<::network::mojom::NetworkQualityEstimatorManager> in_receiver) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::GetNetworkQualityEstimatorManager");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_GetNetworkQualityEstimatorManager_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_GetNetworkQualityEstimatorManager_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::NetworkQualityEstimatorManagerInterfaceBase>>(
      in_receiver, &params->receiver, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->receiver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid receiver in NetworkService.GetNetworkQualityEstimatorManager request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("GetNetworkQualityEstimatorManager");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceProxy::GetDnsConfigChangeManager(
    mojo::PendingReceiver<::network::mojom::DnsConfigChangeManager> in_receiver) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::GetDnsConfigChangeManager");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_GetDnsConfigChangeManager_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_GetDnsConfigChangeManager_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::DnsConfigChangeManagerInterfaceBase>>(
      in_receiver, &params->receiver, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->receiver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid receiver in NetworkService.GetDnsConfigChangeManager request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("GetDnsConfigChangeManager");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceProxy::GetTotalNetworkUsages(
    GetTotalNetworkUsagesCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::GetTotalNetworkUsages");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_GetTotalNetworkUsages_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_GetTotalNetworkUsages_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("GetTotalNetworkUsages");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkService_GetTotalNetworkUsages_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void NetworkServiceProxy::GetNetworkList(
    uint32_t in_policy, GetNetworkListCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::GetNetworkList");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_GetNetworkList_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_GetNetworkList_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->policy = in_policy;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("GetNetworkList");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkService_GetNetworkList_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void NetworkServiceProxy::UpdateCRLSet(
    ::base::span<const ::uint8_t> in_crl_set, UpdateCRLSetCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::UpdateCRLSet");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_UpdateCRLSet_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_UpdateCRLSet_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->crl_set)::BaseType::BufferWriter
      crl_set_writer;
  mojo::internal::Serialize<::mojo_base::mojom::ReadOnlyBufferDataView>(
      in_crl_set, buffer, &crl_set_writer, &serialization_context);
  params->crl_set.Set(
      crl_set_writer.is_null() ? nullptr : crl_set_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->crl_set.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null crl_set in NetworkService.UpdateCRLSet request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("UpdateCRLSet");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkService_UpdateCRLSet_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void NetworkServiceProxy::UpdateLegacyTLSConfig(
    ::base::span<const ::uint8_t> in_config, UpdateLegacyTLSConfigCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::UpdateLegacyTLSConfig");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_UpdateLegacyTLSConfig_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_UpdateLegacyTLSConfig_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->config)::BaseType::BufferWriter
      config_writer;
  mojo::internal::Serialize<::mojo_base::mojom::ReadOnlyBufferDataView>(
      in_config, buffer, &config_writer, &serialization_context);
  params->config.Set(
      config_writer.is_null() ? nullptr : config_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->config.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null config in NetworkService.UpdateLegacyTLSConfig request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("UpdateLegacyTLSConfig");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkService_UpdateLegacyTLSConfig_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void NetworkServiceProxy::OnCertDBChanged(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::OnCertDBChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_OnCertDBChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_OnCertDBChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("OnCertDBChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceProxy::AddCorbExceptionForPlugin(
    int32_t in_process_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::AddCorbExceptionForPlugin");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_AddCorbExceptionForPlugin_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_AddCorbExceptionForPlugin_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->process_id = in_process_id;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("AddCorbExceptionForPlugin");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceProxy::RemoveCorbExceptionForPlugin(
    int32_t in_process_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::RemoveCorbExceptionForPlugin");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_RemoveCorbExceptionForPlugin_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_RemoveCorbExceptionForPlugin_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->process_id = in_process_id;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("RemoveCorbExceptionForPlugin");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceProxy::OnMemoryPressure(
    ::base::MemoryPressureListener::MemoryPressureLevel in_memory_pressure_level) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::OnMemoryPressure");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_OnMemoryPressure_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_OnMemoryPressure_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::mojo_base::mojom::MemoryPressureLevel>(
      in_memory_pressure_level, &params->memory_pressure_level);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("OnMemoryPressure");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceProxy::OnPeerToPeerConnectionsCountChange(
    uint32_t in_count) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::OnPeerToPeerConnectionsCountChange");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_OnPeerToPeerConnectionsCountChange_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_OnPeerToPeerConnectionsCountChange_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->count = in_count;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("OnPeerToPeerConnectionsCountChange");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceProxy::OnApplicationStateChange(
    ::base::android::ApplicationState in_state) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::OnApplicationStateChange");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_OnApplicationStateChange_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_OnApplicationStateChange_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::mojo_base::mojom::ApplicationState>(
      in_state, &params->state);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("OnApplicationStateChange");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceProxy::SetEnvironment(
    std::vector<EnvironmentVariablePtr> in_environment) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::SetEnvironment");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_SetEnvironment_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_SetEnvironment_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->environment)::BaseType::BufferWriter
      environment_writer;
  const mojo::internal::ContainerValidateParams environment_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::EnvironmentVariableDataView>>(
      in_environment, buffer, &environment_writer, &environment_validate_params,
      &serialization_context);
  params->environment.Set(
      environment_writer.is_null() ? nullptr : environment_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->environment.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null environment in NetworkService.SetEnvironment request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("SetEnvironment");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceProxy::DumpWithoutCrashing(
    ::base::Time in_dump_request_time) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::DumpWithoutCrashing");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_DumpWithoutCrashing_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_DumpWithoutCrashing_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->dump_request_time)::BaseType::BufferWriter
      dump_request_time_writer;
  mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(
      in_dump_request_time, buffer, &dump_request_time_writer, &serialization_context);
  params->dump_request_time.Set(
      dump_request_time_writer.is_null() ? nullptr : dump_request_time_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->dump_request_time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null dump_request_time in NetworkService.DumpWithoutCrashing request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("DumpWithoutCrashing");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void NetworkServiceProxy::BindTestInterface(
    mojo::PendingReceiver<::network::mojom::NetworkServiceTest> in_receiver) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "network::mojom::NetworkService::BindTestInterface");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_BindTestInterface_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_BindTestInterface_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::NetworkServiceTestInterfaceBase>>(
      in_receiver, &params->receiver, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->receiver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid receiver in NetworkService.BindTestInterface request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("BindTestInterface");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
class NetworkService_GetTotalNetworkUsages_ProxyToResponder {
 public:
  static NetworkService::GetTotalNetworkUsagesCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkService_GetTotalNetworkUsages_ProxyToResponder> proxy(
        new NetworkService_GetTotalNetworkUsages_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&NetworkService_GetTotalNetworkUsages_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkService_GetTotalNetworkUsages_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  NetworkService_GetTotalNetworkUsages_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkService::GetTotalNetworkUsagesCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      std::vector<::network::mojom::NetworkUsagePtr> in_total_network_usages);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(NetworkService_GetTotalNetworkUsages_ProxyToResponder);
};

bool NetworkService_GetTotalNetworkUsages_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "network::mojom::NetworkService::GetTotalNetworkUsagesCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::NetworkService_GetTotalNetworkUsages_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkService_GetTotalNetworkUsages_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  std::vector<::network::mojom::NetworkUsagePtr> p_total_network_usages{};
  NetworkService_GetTotalNetworkUsages_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadTotalNetworkUsages(&p_total_network_usages))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkService::Name_, 13, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_total_network_usages));
  return true;
}

void NetworkService_GetTotalNetworkUsages_ProxyToResponder::Run(
    std::vector<::network::mojom::NetworkUsagePtr> in_total_network_usages) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_GetTotalNetworkUsages_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_GetTotalNetworkUsages_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->total_network_usages)::BaseType::BufferWriter
      total_network_usages_writer;
  const mojo::internal::ContainerValidateParams total_network_usages_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::NetworkUsageDataView>>(
      in_total_network_usages, buffer, &total_network_usages_writer, &total_network_usages_validate_params,
      &serialization_context);
  params->total_network_usages.Set(
      total_network_usages_writer.is_null() ? nullptr : total_network_usages_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->total_network_usages.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null total_network_usages in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)network::mojom::NetworkService::GetTotalNetworkUsagesCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("GetTotalNetworkUsages");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkService_GetNetworkList_ProxyToResponder {
 public:
  static NetworkService::GetNetworkListCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkService_GetNetworkList_ProxyToResponder> proxy(
        new NetworkService_GetNetworkList_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&NetworkService_GetNetworkList_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkService_GetNetworkList_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  NetworkService_GetNetworkList_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkService::GetNetworkListCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const base::Optional<std::vector<::net::NetworkInterface>>& in_networks);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(NetworkService_GetNetworkList_ProxyToResponder);
};

bool NetworkService_GetNetworkList_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "network::mojom::NetworkService::GetNetworkListCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::NetworkService_GetNetworkList_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkService_GetNetworkList_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  base::Optional<std::vector<::net::NetworkInterface>> p_networks{};
  NetworkService_GetNetworkList_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadNetworks(&p_networks))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkService::Name_, 14, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_networks));
  return true;
}

void NetworkService_GetNetworkList_ProxyToResponder::Run(
    const base::Optional<std::vector<::net::NetworkInterface>>& in_networks) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_GetNetworkList_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_GetNetworkList_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->networks)::BaseType::BufferWriter
      networks_writer;
  const mojo::internal::ContainerValidateParams networks_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::NetworkInterfaceDataView>>(
      in_networks, buffer, &networks_writer, &networks_validate_params,
      &serialization_context);
  params->networks.Set(
      networks_writer.is_null() ? nullptr : networks_writer.data());
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)network::mojom::NetworkService::GetNetworkListCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("GetNetworkList");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkService_UpdateCRLSet_ProxyToResponder {
 public:
  static NetworkService::UpdateCRLSetCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkService_UpdateCRLSet_ProxyToResponder> proxy(
        new NetworkService_UpdateCRLSet_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&NetworkService_UpdateCRLSet_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkService_UpdateCRLSet_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  NetworkService_UpdateCRLSet_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkService::UpdateCRLSetCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(NetworkService_UpdateCRLSet_ProxyToResponder);
};

bool NetworkService_UpdateCRLSet_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "network::mojom::NetworkService::UpdateCRLSetCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::NetworkService_UpdateCRLSet_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkService_UpdateCRLSet_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  NetworkService_UpdateCRLSet_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkService::Name_, 15, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkService_UpdateCRLSet_ProxyToResponder::Run(
    ) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_UpdateCRLSet_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_UpdateCRLSet_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)network::mojom::NetworkService::UpdateCRLSetCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("UpdateCRLSet");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkService_UpdateLegacyTLSConfig_ProxyToResponder {
 public:
  static NetworkService::UpdateLegacyTLSConfigCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkService_UpdateLegacyTLSConfig_ProxyToResponder> proxy(
        new NetworkService_UpdateLegacyTLSConfig_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&NetworkService_UpdateLegacyTLSConfig_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkService_UpdateLegacyTLSConfig_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  NetworkService_UpdateLegacyTLSConfig_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkService::UpdateLegacyTLSConfigCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(NetworkService_UpdateLegacyTLSConfig_ProxyToResponder);
};

bool NetworkService_UpdateLegacyTLSConfig_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "network::mojom::NetworkService::UpdateLegacyTLSConfigCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::NetworkService_UpdateLegacyTLSConfig_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkService_UpdateLegacyTLSConfig_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  NetworkService_UpdateLegacyTLSConfig_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkService::Name_, 16, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkService_UpdateLegacyTLSConfig_ProxyToResponder::Run(
    ) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kNetworkService_UpdateLegacyTLSConfig_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::network::mojom::internal::NetworkService_UpdateLegacyTLSConfig_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)network::mojom::NetworkService::UpdateLegacyTLSConfigCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkService::Name_);
  message.set_method_name("UpdateLegacyTLSConfig");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool NetworkServiceStubDispatch::Accept(
    NetworkService* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kNetworkService_SetClient_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::SetClient",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::SetClient");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_SetClient_Params_Data* params =
          reinterpret_cast<internal::NetworkService_SetClient_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      mojo::PendingRemote<NetworkServiceClient> p_client{};
      NetworkServiceParamsPtr p_params{};
      NetworkService_SetClient_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success) {
        p_client =
            input_data_view.TakeClient<decltype(p_client)>();
      }
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetClient(
std::move(p_client), 
std::move(p_params));
      return true;
    }
    case internal::kNetworkService_StartNetLog_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::StartNetLog",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::StartNetLog");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_StartNetLog_Params_Data* params =
          reinterpret_cast<internal::NetworkService_StartNetLog_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::base::File p_file{};
      ::net::NetLogCaptureMode p_capture_mode{};
      ::base::Value p_constants{};
      NetworkService_StartNetLog_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadFile(&p_file))
        success = false;
      if (success && !input_data_view.ReadCaptureMode(&p_capture_mode))
        success = false;
      if (success && !input_data_view.ReadConstants(&p_constants))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->StartNetLog(
std::move(p_file), 
std::move(p_capture_mode), 
std::move(p_constants));
      return true;
    }
    case internal::kNetworkService_SetSSLKeyLogFile_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::SetSSLKeyLogFile",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::SetSSLKeyLogFile");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_SetSSLKeyLogFile_Params_Data* params =
          reinterpret_cast<internal::NetworkService_SetSSLKeyLogFile_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::base::File p_file{};
      NetworkService_SetSSLKeyLogFile_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadFile(&p_file))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetSSLKeyLogFile(
std::move(p_file));
      return true;
    }
    case internal::kNetworkService_CreateNetworkContext_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::CreateNetworkContext",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::CreateNetworkContext");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_CreateNetworkContext_Params_Data* params =
          reinterpret_cast<internal::NetworkService_CreateNetworkContext_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      mojo::PendingReceiver<::network::mojom::NetworkContext> p_context{};
      ::network::mojom::NetworkContextParamsPtr p_params{};
      NetworkService_CreateNetworkContext_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success) {
        p_context =
            input_data_view.TakeContext<decltype(p_context)>();
      }
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateNetworkContext(
std::move(p_context), 
std::move(p_params));
      return true;
    }
    case internal::kNetworkService_ConfigureStubHostResolver_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::ConfigureStubHostResolver",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::ConfigureStubHostResolver");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_ConfigureStubHostResolver_Params_Data* params =
          reinterpret_cast<internal::NetworkService_ConfigureStubHostResolver_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_insecure_dns_client_enabled{};
      ::net::DnsConfig::SecureDnsMode p_secure_dns_mode{};
      base::Optional<std::vector<::network::mojom::DnsOverHttpsServerPtr>> p_dns_over_https_servers{};
      NetworkService_ConfigureStubHostResolver_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_insecure_dns_client_enabled = input_data_view.insecure_dns_client_enabled();
      if (success && !input_data_view.ReadSecureDnsMode(&p_secure_dns_mode))
        success = false;
      if (success && !input_data_view.ReadDnsOverHttpsServers(&p_dns_over_https_servers))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ConfigureStubHostResolver(
std::move(p_insecure_dns_client_enabled), 
std::move(p_secure_dns_mode), 
std::move(p_dns_over_https_servers));
      return true;
    }
    case internal::kNetworkService_DisableQuic_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::DisableQuic",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::DisableQuic");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_DisableQuic_Params_Data* params =
          reinterpret_cast<internal::NetworkService_DisableQuic_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      NetworkService_DisableQuic_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DisableQuic();
      return true;
    }
    case internal::kNetworkService_SetUpHttpAuth_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::SetUpHttpAuth",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::SetUpHttpAuth");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_SetUpHttpAuth_Params_Data* params =
          reinterpret_cast<internal::NetworkService_SetUpHttpAuth_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      HttpAuthStaticParamsPtr p_http_auth_static_params{};
      NetworkService_SetUpHttpAuth_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadHttpAuthStaticParams(&p_http_auth_static_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetUpHttpAuth(
std::move(p_http_auth_static_params));
      return true;
    }
    case internal::kNetworkService_ConfigureHttpAuthPrefs_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::ConfigureHttpAuthPrefs",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::ConfigureHttpAuthPrefs");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_ConfigureHttpAuthPrefs_Params_Data* params =
          reinterpret_cast<internal::NetworkService_ConfigureHttpAuthPrefs_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      HttpAuthDynamicParamsPtr p_http_auth_dynamic_params{};
      NetworkService_ConfigureHttpAuthPrefs_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadHttpAuthDynamicParams(&p_http_auth_dynamic_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ConfigureHttpAuthPrefs(
std::move(p_http_auth_dynamic_params));
      return true;
    }
    case internal::kNetworkService_SetRawHeadersAccess_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::SetRawHeadersAccess",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::SetRawHeadersAccess");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_SetRawHeadersAccess_Params_Data* params =
          reinterpret_cast<internal::NetworkService_SetRawHeadersAccess_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int32_t p_process_id{};
      std::vector<::url::Origin> p_origins{};
      NetworkService_SetRawHeadersAccess_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_process_id = input_data_view.process_id();
      if (success && !input_data_view.ReadOrigins(&p_origins))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetRawHeadersAccess(
std::move(p_process_id), 
std::move(p_origins));
      return true;
    }
    case internal::kNetworkService_SetMaxConnectionsPerProxy_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::SetMaxConnectionsPerProxy",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::SetMaxConnectionsPerProxy");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_SetMaxConnectionsPerProxy_Params_Data* params =
          reinterpret_cast<internal::NetworkService_SetMaxConnectionsPerProxy_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int32_t p_max_connections{};
      NetworkService_SetMaxConnectionsPerProxy_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_max_connections = input_data_view.max_connections();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetMaxConnectionsPerProxy(
std::move(p_max_connections));
      return true;
    }
    case internal::kNetworkService_GetNetworkChangeManager_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::GetNetworkChangeManager",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::GetNetworkChangeManager");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_GetNetworkChangeManager_Params_Data* params =
          reinterpret_cast<internal::NetworkService_GetNetworkChangeManager_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      mojo::PendingReceiver<::network::mojom::NetworkChangeManager> p_network_change_manager{};
      NetworkService_GetNetworkChangeManager_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success) {
        p_network_change_manager =
            input_data_view.TakeNetworkChangeManager<decltype(p_network_change_manager)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetNetworkChangeManager(
std::move(p_network_change_manager));
      return true;
    }
    case internal::kNetworkService_GetNetworkQualityEstimatorManager_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::GetNetworkQualityEstimatorManager",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::GetNetworkQualityEstimatorManager");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_GetNetworkQualityEstimatorManager_Params_Data* params =
          reinterpret_cast<internal::NetworkService_GetNetworkQualityEstimatorManager_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      mojo::PendingReceiver<::network::mojom::NetworkQualityEstimatorManager> p_receiver{};
      NetworkService_GetNetworkQualityEstimatorManager_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success) {
        p_receiver =
            input_data_view.TakeReceiver<decltype(p_receiver)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetNetworkQualityEstimatorManager(
std::move(p_receiver));
      return true;
    }
    case internal::kNetworkService_GetDnsConfigChangeManager_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::GetDnsConfigChangeManager",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::GetDnsConfigChangeManager");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_GetDnsConfigChangeManager_Params_Data* params =
          reinterpret_cast<internal::NetworkService_GetDnsConfigChangeManager_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      mojo::PendingReceiver<::network::mojom::DnsConfigChangeManager> p_receiver{};
      NetworkService_GetDnsConfigChangeManager_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success) {
        p_receiver =
            input_data_view.TakeReceiver<decltype(p_receiver)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetDnsConfigChangeManager(
std::move(p_receiver));
      return true;
    }
    case internal::kNetworkService_GetTotalNetworkUsages_Name: {
      break;
    }
    case internal::kNetworkService_GetNetworkList_Name: {
      break;
    }
    case internal::kNetworkService_UpdateCRLSet_Name: {
      break;
    }
    case internal::kNetworkService_UpdateLegacyTLSConfig_Name: {
      break;
    }
    case internal::kNetworkService_OnCertDBChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::OnCertDBChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::OnCertDBChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_OnCertDBChanged_Params_Data* params =
          reinterpret_cast<internal::NetworkService_OnCertDBChanged_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      NetworkService_OnCertDBChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 17, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnCertDBChanged();
      return true;
    }
    case internal::kNetworkService_AddCorbExceptionForPlugin_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::AddCorbExceptionForPlugin",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::AddCorbExceptionForPlugin");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_AddCorbExceptionForPlugin_Params_Data* params =
          reinterpret_cast<internal::NetworkService_AddCorbExceptionForPlugin_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int32_t p_process_id{};
      NetworkService_AddCorbExceptionForPlugin_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_process_id = input_data_view.process_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 18, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddCorbExceptionForPlugin(
std::move(p_process_id));
      return true;
    }
    case internal::kNetworkService_RemoveCorbExceptionForPlugin_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::RemoveCorbExceptionForPlugin",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::RemoveCorbExceptionForPlugin");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_RemoveCorbExceptionForPlugin_Params_Data* params =
          reinterpret_cast<internal::NetworkService_RemoveCorbExceptionForPlugin_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int32_t p_process_id{};
      NetworkService_RemoveCorbExceptionForPlugin_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_process_id = input_data_view.process_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 19, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RemoveCorbExceptionForPlugin(
std::move(p_process_id));
      return true;
    }
    case internal::kNetworkService_OnMemoryPressure_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::OnMemoryPressure",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::OnMemoryPressure");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_OnMemoryPressure_Params_Data* params =
          reinterpret_cast<internal::NetworkService_OnMemoryPressure_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::base::MemoryPressureListener::MemoryPressureLevel p_memory_pressure_level{};
      NetworkService_OnMemoryPressure_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadMemoryPressureLevel(&p_memory_pressure_level))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 20, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnMemoryPressure(
std::move(p_memory_pressure_level));
      return true;
    }
    case internal::kNetworkService_OnPeerToPeerConnectionsCountChange_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::OnPeerToPeerConnectionsCountChange",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::OnPeerToPeerConnectionsCountChange");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_OnPeerToPeerConnectionsCountChange_Params_Data* params =
          reinterpret_cast<internal::NetworkService_OnPeerToPeerConnectionsCountChange_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      uint32_t p_count{};
      NetworkService_OnPeerToPeerConnectionsCountChange_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_count = input_data_view.count();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 21, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnPeerToPeerConnectionsCountChange(
std::move(p_count));
      return true;
    }
    case internal::kNetworkService_OnApplicationStateChange_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::OnApplicationStateChange",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::OnApplicationStateChange");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_OnApplicationStateChange_Params_Data* params =
          reinterpret_cast<internal::NetworkService_OnApplicationStateChange_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::base::android::ApplicationState p_state{};
      NetworkService_OnApplicationStateChange_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadState(&p_state))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 22, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnApplicationStateChange(
std::move(p_state));
      return true;
    }
    case internal::kNetworkService_SetEnvironment_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::SetEnvironment",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::SetEnvironment");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_SetEnvironment_Params_Data* params =
          reinterpret_cast<internal::NetworkService_SetEnvironment_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      std::vector<EnvironmentVariablePtr> p_environment{};
      NetworkService_SetEnvironment_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadEnvironment(&p_environment))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 23, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetEnvironment(
std::move(p_environment));
      return true;
    }
    case internal::kNetworkService_DumpWithoutCrashing_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::DumpWithoutCrashing",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::DumpWithoutCrashing");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_DumpWithoutCrashing_Params_Data* params =
          reinterpret_cast<internal::NetworkService_DumpWithoutCrashing_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::base::Time p_dump_request_time{};
      NetworkService_DumpWithoutCrashing_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadDumpRequestTime(&p_dump_request_time))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 24, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DumpWithoutCrashing(
std::move(p_dump_request_time));
      return true;
    }
    case internal::kNetworkService_BindTestInterface_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::BindTestInterface",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::BindTestInterface");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::NetworkService_BindTestInterface_Params_Data* params =
          reinterpret_cast<internal::NetworkService_BindTestInterface_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      mojo::PendingReceiver<::network::mojom::NetworkServiceTest> p_receiver{};
      NetworkService_BindTestInterface_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success) {
        p_receiver =
            input_data_view.TakeReceiver<decltype(p_receiver)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 25, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BindTestInterface(
std::move(p_receiver));
      return true;
    }
  }
  return false;
}

// static
bool NetworkServiceStubDispatch::AcceptWithResponder(
    NetworkService* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kNetworkService_SetClient_Name: {
      break;
    }
    case internal::kNetworkService_StartNetLog_Name: {
      break;
    }
    case internal::kNetworkService_SetSSLKeyLogFile_Name: {
      break;
    }
    case internal::kNetworkService_CreateNetworkContext_Name: {
      break;
    }
    case internal::kNetworkService_ConfigureStubHostResolver_Name: {
      break;
    }
    case internal::kNetworkService_DisableQuic_Name: {
      break;
    }
    case internal::kNetworkService_SetUpHttpAuth_Name: {
      break;
    }
    case internal::kNetworkService_ConfigureHttpAuthPrefs_Name: {
      break;
    }
    case internal::kNetworkService_SetRawHeadersAccess_Name: {
      break;
    }
    case internal::kNetworkService_SetMaxConnectionsPerProxy_Name: {
      break;
    }
    case internal::kNetworkService_GetNetworkChangeManager_Name: {
      break;
    }
    case internal::kNetworkService_GetNetworkQualityEstimatorManager_Name: {
      break;
    }
    case internal::kNetworkService_GetDnsConfigChangeManager_Name: {
      break;
    }
    case internal::kNetworkService_GetTotalNetworkUsages_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::GetTotalNetworkUsages",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::GetTotalNetworkUsages");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::NetworkService_GetTotalNetworkUsages_Params_Data* params =
          reinterpret_cast<
              internal::NetworkService_GetTotalNetworkUsages_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      NetworkService_GetTotalNetworkUsages_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 13, false);
        return false;
      }
      NetworkService::GetTotalNetworkUsagesCallback callback =
          NetworkService_GetTotalNetworkUsages_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetTotalNetworkUsages(std::move(callback));
      return true;
    }
    case internal::kNetworkService_GetNetworkList_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::GetNetworkList",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::GetNetworkList");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::NetworkService_GetNetworkList_Params_Data* params =
          reinterpret_cast<
              internal::NetworkService_GetNetworkList_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      uint32_t p_policy{};
      NetworkService_GetNetworkList_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_policy = input_data_view.policy();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 14, false);
        return false;
      }
      NetworkService::GetNetworkListCallback callback =
          NetworkService_GetNetworkList_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetNetworkList(
std::move(p_policy), std::move(callback));
      return true;
    }
    case internal::kNetworkService_UpdateCRLSet_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::UpdateCRLSet",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::UpdateCRLSet");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::NetworkService_UpdateCRLSet_Params_Data* params =
          reinterpret_cast<
              internal::NetworkService_UpdateCRLSet_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::base::span<const ::uint8_t> p_crl_set{};
      NetworkService_UpdateCRLSet_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadCrlSet(&p_crl_set))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 15, false);
        return false;
      }
      NetworkService::UpdateCRLSetCallback callback =
          NetworkService_UpdateCRLSet_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateCRLSet(
std::move(p_crl_set), std::move(callback));
      return true;
    }
    case internal::kNetworkService_UpdateLegacyTLSConfig_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)network::mojom::NetworkService::UpdateLegacyTLSConfig",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)network::mojom::NetworkService::UpdateLegacyTLSConfig");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::NetworkService_UpdateLegacyTLSConfig_Params_Data* params =
          reinterpret_cast<
              internal::NetworkService_UpdateLegacyTLSConfig_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::base::span<const ::uint8_t> p_config{};
      NetworkService_UpdateLegacyTLSConfig_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadConfig(&p_config))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkService::Name_, 16, false);
        return false;
      }
      NetworkService::UpdateLegacyTLSConfigCallback callback =
          NetworkService_UpdateLegacyTLSConfig_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateLegacyTLSConfig(
std::move(p_config), std::move(callback));
      return true;
    }
    case internal::kNetworkService_OnCertDBChanged_Name: {
      break;
    }
    case internal::kNetworkService_AddCorbExceptionForPlugin_Name: {
      break;
    }
    case internal::kNetworkService_RemoveCorbExceptionForPlugin_Name: {
      break;
    }
    case internal::kNetworkService_OnMemoryPressure_Name: {
      break;
    }
    case internal::kNetworkService_OnPeerToPeerConnectionsCountChange_Name: {
      break;
    }
    case internal::kNetworkService_OnApplicationStateChange_Name: {
      break;
    }
    case internal::kNetworkService_SetEnvironment_Name: {
      break;
    }
    case internal::kNetworkService_DumpWithoutCrashing_Name: {
      break;
    }
    case internal::kNetworkService_BindTestInterface_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kNetworkServiceValidationInfo[] = {
    {&internal::NetworkService_SetClient_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkService_StartNetLog_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkService_SetSSLKeyLogFile_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkService_CreateNetworkContext_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkService_ConfigureStubHostResolver_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkService_DisableQuic_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkService_SetUpHttpAuth_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkService_ConfigureHttpAuthPrefs_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkService_SetRawHeadersAccess_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkService_SetMaxConnectionsPerProxy_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkService_GetNetworkChangeManager_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkService_GetNetworkQualityEstimatorManager_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkService_GetDnsConfigChangeManager_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkService_GetTotalNetworkUsages_Params_Data::Validate,
     &internal::NetworkService_GetTotalNetworkUsages_ResponseParams_Data::Validate},
    {&internal::NetworkService_GetNetworkList_Params_Data::Validate,
     &internal::NetworkService_GetNetworkList_ResponseParams_Data::Validate},
    {&internal::NetworkService_UpdateCRLSet_Params_Data::Validate,
     &internal::NetworkService_UpdateCRLSet_ResponseParams_Data::Validate},
    {&internal::NetworkService_UpdateLegacyTLSConfig_Params_Data::Validate,
     &internal::NetworkService_UpdateLegacyTLSConfig_ResponseParams_Data::Validate},
    {&internal::NetworkService_OnCertDBChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkService_AddCorbExceptionForPlugin_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkService_RemoveCorbExceptionForPlugin_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkService_OnMemoryPressure_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkService_OnPeerToPeerConnectionsCountChange_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkService_OnApplicationStateChange_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkService_SetEnvironment_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkService_DumpWithoutCrashing_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkService_BindTestInterface_Params_Data::Validate,
     nullptr /* no response */},
};

bool NetworkServiceRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::NetworkService::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kNetworkServiceValidationInfo);
}

bool NetworkServiceResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::NetworkService::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kNetworkServiceValidationInfo);
}
}  // namespace mojom
}  // namespace network

namespace mojo {


// static
bool StructTraits<::network::mojom::LoadInfo::DataView, ::network::mojom::LoadInfoPtr>::Read(
    ::network::mojom::LoadInfo::DataView input,
    ::network::mojom::LoadInfoPtr* output) {
  bool success = true;
  ::network::mojom::LoadInfoPtr result(::network::mojom::LoadInfo::New());
  
      if (success)
        result->process_id = input.process_id();
      if (success)
        result->routing_id = input.routing_id();
      if (success && !input.ReadHost(&result->host))
        success = false;
      if (success)
        result->load_state = input.load_state();
      if (success && !input.ReadStateParam(&result->state_param))
        success = false;
      if (success)
        result->upload_position = input.upload_position();
      if (success)
        result->upload_size = input.upload_size();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::network::mojom::HttpAuthStaticParams::DataView, ::network::mojom::HttpAuthStaticParamsPtr>::Read(
    ::network::mojom::HttpAuthStaticParams::DataView input,
    ::network::mojom::HttpAuthStaticParamsPtr* output) {
  bool success = true;
  ::network::mojom::HttpAuthStaticParamsPtr result(::network::mojom::HttpAuthStaticParams::New());
  
      if (success && !input.ReadSupportedSchemes(&result->supported_schemes))
        success = false;
      if (success && !input.ReadGssapiLibraryName(&result->gssapi_library_name))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::network::mojom::HttpAuthDynamicParams::DataView, ::network::mojom::HttpAuthDynamicParamsPtr>::Read(
    ::network::mojom::HttpAuthDynamicParams::DataView input,
    ::network::mojom::HttpAuthDynamicParamsPtr* output) {
  bool success = true;
  ::network::mojom::HttpAuthDynamicParamsPtr result(::network::mojom::HttpAuthDynamicParams::New());
  
      if (success && !input.ReadServerAllowlist(&result->server_allowlist))
        success = false;
      if (success && !input.ReadDelegateAllowlist(&result->delegate_allowlist))
        success = false;
      if (success)
        result->delegate_by_kdc_policy = input.delegate_by_kdc_policy();
      if (success)
        result->negotiate_disable_cname_lookup = input.negotiate_disable_cname_lookup();
      if (success)
        result->enable_negotiate_port = input.enable_negotiate_port();
      if (success)
        result->ntlm_v2_enabled = input.ntlm_v2_enabled();
      if (success && !input.ReadAndroidNegotiateAccountType(&result->android_negotiate_account_type))
        success = false;
      if (success)
        result->allow_gssapi_library_load = input.allow_gssapi_library_load();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::network::mojom::EnvironmentVariable::DataView, ::network::mojom::EnvironmentVariablePtr>::Read(
    ::network::mojom::EnvironmentVariable::DataView input,
    ::network::mojom::EnvironmentVariablePtr* output) {
  bool success = true;
  ::network::mojom::EnvironmentVariablePtr result(::network::mojom::EnvironmentVariable::New());
  
      if (success && !input.ReadName(&result->name))
        success = false;
      if (success && !input.ReadValue(&result->value))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::network::mojom::NetworkServiceParams::DataView, ::network::mojom::NetworkServiceParamsPtr>::Read(
    ::network::mojom::NetworkServiceParams::DataView input,
    ::network::mojom::NetworkServiceParamsPtr* output) {
  bool success = true;
  ::network::mojom::NetworkServiceParamsPtr result(::network::mojom::NetworkServiceParams::New());
  
      if (success && !input.ReadInitialConnectionType(&result->initial_connection_type))
        success = false;
      if (success && !input.ReadInitialConnectionSubtype(&result->initial_connection_subtype))
        success = false;
      if (success && !input.ReadEnvironment(&result->environment))
        success = false;
  *output = std::move(result);
  return success;
}

}  // namespace mojo

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif