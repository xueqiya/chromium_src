// services/network/public/mojom/network_context.mojom-blink.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_CONTEXT_MOJOM_BLINK_H_
#define SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_CONTEXT_MOJOM_BLINK_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "base/callback.h"
#include "base/macros.h"
#include "base/optional.h"

#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#if BUILDFLAG(MOJO_TRACE_ENABLED)
#include "base/trace_event/trace_event.h"
#endif
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"
#include "services/network/public/mojom/network_context.mojom-shared.h"
#include "services/network/public/mojom/network_context.mojom-blink-forward.h"
#include "mojo/public/mojom/base/big_buffer.mojom-blink.h"
#include "mojo/public/mojom/base/file.mojom-blink.h"
#include "mojo/public/mojom/base/file_path.mojom-blink.h"
#include "mojo/public/mojom/base/time.mojom-blink.h"
#include "mojo/public/mojom/base/unguessable_token.mojom-blink.h"
#include "mojo/public/mojom/base/values.mojom-blink.h"
#include "services/network/public/mojom/address_list.mojom-blink.h"
#include "services/network/public/mojom/cookie_manager.mojom-blink.h"
#include "services/network/public/mojom/default_credentials.mojom-blink.h"
#include "services/network/public/mojom/cors_origin_pattern.mojom-blink.h"
#include "services/network/public/mojom/cross_origin_embedder_policy.mojom-blink.h"
#include "services/network/public/mojom/host_resolver.mojom-blink.h"
#include "services/network/public/mojom/http_request_headers.mojom-blink.h"
#include "services/network/public/mojom/ip_address.mojom-blink.h"
#include "services/network/public/mojom/ip_endpoint.mojom-blink.h"
#include "services/network/public/mojom/mdns_responder.mojom-blink.h"
#include "services/network/public/mojom/mutable_network_traffic_annotation_tag.mojom-blink.h"
#include "services/network/public/mojom/net_log.mojom-blink.h"
#include "services/network/public/mojom/network_isolation_key.mojom-blink.h"
#include "services/network/public/mojom/network_param.mojom-blink.h"
#include "services/network/public/mojom/origin_policy_manager.mojom-blink.h"
#include "services/network/public/mojom/p2p.mojom-blink.h"
#include "services/network/public/mojom/p2p_trusted.mojom-blink.h"
#include "services/network/public/mojom/proxy_config.mojom-blink.h"
#include "services/network/public/mojom/proxy_config_with_annotation.mojom-blink.h"
#include "services/network/public/mojom/proxy_lookup_client.mojom-blink.h"
#include "services/network/public/mojom/proxy_resolving_socket.mojom-blink.h"
#include "services/network/public/mojom/quic_transport.mojom-blink.h"
#include "services/network/public/mojom/restricted_cookie_manager.mojom-blink.h"
#include "services/network/public/mojom/site_for_cookies.mojom-blink.h"
#include "services/network/public/mojom/ssl_config.mojom-blink.h"
#include "services/network/public/mojom/tcp_socket.mojom-blink.h"
#include "services/network/public/mojom/udp_socket.mojom-blink.h"
#include "services/network/public/mojom/url_loader.mojom-blink.h"
#include "services/network/public/mojom/url_loader_factory.mojom-blink.h"
#include "services/network/public/mojom/url_response_head.mojom-blink.h"
#include "services/network/public/mojom/websocket.mojom-blink.h"
#include "services/proxy_resolver/public/mojom/proxy_resolver.mojom-blink.h"
#include "url/mojom/origin.mojom-blink.h"
#include "url/mojom/url.mojom-blink.h"
#include "services/network/public/mojom/ct_log_info.mojom-blink.h"

#include "mojo/public/cpp/bindings/lib/wtf_clone_equals_util.h"
#include "mojo/public/cpp/bindings/lib/wtf_hash_util.h"
#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"

#include "mojo/public/cpp/bindings/associated_interface_ptr.h"
#include "mojo/public/cpp/bindings/associated_interface_ptr_info.h"
#include "mojo/public/cpp/bindings/associated_interface_request.h"
#include "mojo/public/cpp/bindings/interface_ptr.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"
#include "mojo/public/cpp/bindings/thread_safe_interface_ptr.h"


#include "third_party/blink/public/platform/web_common.h"




namespace WTF {
struct network_mojom_internal_NetworkContextParams_CorsMode_DataHashFn {
  static unsigned GetHash(const ::network::mojom::NetworkContextParams_CorsMode& value) {
    using utype = std::underlying_type<::network::mojom::NetworkContextParams_CorsMode>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::network::mojom::NetworkContextParams_CorsMode& left, const ::network::mojom::NetworkContextParams_CorsMode& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::network::mojom::NetworkContextParams_CorsMode>
    : public GenericHashTraits<::network::mojom::NetworkContextParams_CorsMode> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool hasIsEmptyValueFunction = true;
  static bool IsEmptyValue(const ::network::mojom::NetworkContextParams_CorsMode& value) {
    return value == static_cast<::network::mojom::NetworkContextParams_CorsMode>(-1000000);
  }
  static void ConstructDeletedValue(::network::mojom::NetworkContextParams_CorsMode& slot, bool) {
    slot = static_cast<::network::mojom::NetworkContextParams_CorsMode>(-1000001);
  }
  static bool IsDeletedValue(const ::network::mojom::NetworkContextParams_CorsMode& value) {
    return value == static_cast<::network::mojom::NetworkContextParams_CorsMode>(-1000001);
  }
};
}  // namespace WTF


namespace WTF {
struct network_mojom_internal_ClearDataFilter_Type_DataHashFn {
  static unsigned GetHash(const ::network::mojom::ClearDataFilter_Type& value) {
    using utype = std::underlying_type<::network::mojom::ClearDataFilter_Type>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::network::mojom::ClearDataFilter_Type& left, const ::network::mojom::ClearDataFilter_Type& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::network::mojom::ClearDataFilter_Type>
    : public GenericHashTraits<::network::mojom::ClearDataFilter_Type> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool hasIsEmptyValueFunction = true;
  static bool IsEmptyValue(const ::network::mojom::ClearDataFilter_Type& value) {
    return value == static_cast<::network::mojom::ClearDataFilter_Type>(-1000000);
  }
  static void ConstructDeletedValue(::network::mojom::ClearDataFilter_Type& slot, bool) {
    slot = static_cast<::network::mojom::ClearDataFilter_Type>(-1000001);
  }
  static bool IsDeletedValue(const ::network::mojom::ClearDataFilter_Type& value) {
    return value == static_cast<::network::mojom::ClearDataFilter_Type>(-1000001);
  }
};
}  // namespace WTF


namespace WTF {
struct network_mojom_internal_NetworkContext_DomainReliabilityClearMode_DataHashFn {
  static unsigned GetHash(const ::network::mojom::NetworkContext_DomainReliabilityClearMode& value) {
    using utype = std::underlying_type<::network::mojom::NetworkContext_DomainReliabilityClearMode>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::network::mojom::NetworkContext_DomainReliabilityClearMode& left, const ::network::mojom::NetworkContext_DomainReliabilityClearMode& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::network::mojom::NetworkContext_DomainReliabilityClearMode>
    : public GenericHashTraits<::network::mojom::NetworkContext_DomainReliabilityClearMode> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool hasIsEmptyValueFunction = true;
  static bool IsEmptyValue(const ::network::mojom::NetworkContext_DomainReliabilityClearMode& value) {
    return value == static_cast<::network::mojom::NetworkContext_DomainReliabilityClearMode>(-1000000);
  }
  static void ConstructDeletedValue(::network::mojom::NetworkContext_DomainReliabilityClearMode& slot, bool) {
    slot = static_cast<::network::mojom::NetworkContext_DomainReliabilityClearMode>(-1000001);
  }
  static bool IsDeletedValue(const ::network::mojom::NetworkContext_DomainReliabilityClearMode& value) {
    return value == static_cast<::network::mojom::NetworkContext_DomainReliabilityClearMode>(-1000001);
  }
};
}  // namespace WTF


namespace network {
namespace mojom {
namespace blink {

class CustomProxyConfigClientProxy;

template <typename ImplRefTraits>
class CustomProxyConfigClientStub;

class CustomProxyConfigClientRequestValidator;
class CustomProxyConfigClientResponseValidator;


class BLINK_PLATFORM_EXPORT CustomProxyConfigClient
    : public CustomProxyConfigClientInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = CustomProxyConfigClientInterfaceBase;
  using Proxy_ = CustomProxyConfigClientProxy;

  template <typename ImplRefTraits>
  using Stub_ = CustomProxyConfigClientStub<ImplRefTraits>;

  using RequestValidator_ = CustomProxyConfigClientRequestValidator;
  using ResponseValidator_ = CustomProxyConfigClientResponseValidator;
  enum MethodMinVersions : uint32_t {
    kOnCustomProxyConfigUpdatedMinVersion = 0,
    kMarkProxiesAsBadMinVersion = 0,
    kClearBadProxiesCacheMinVersion = 0,
  };
  virtual ~CustomProxyConfigClient() {}

  
  virtual void OnCustomProxyConfigUpdated(CustomProxyConfigPtr proxy_config) = 0;


  using MarkProxiesAsBadCallback = base::OnceCallback<void()>;
  
  virtual void MarkProxiesAsBad(::base::TimeDelta bypass_duration, ::network::mojom::blink::ProxyListPtr bad_proxies, MarkProxiesAsBadCallback callback) = 0;

  
  virtual void ClearBadProxiesCache() = 0;
};

class TrustedHeaderClientProxy;

template <typename ImplRefTraits>
class TrustedHeaderClientStub;

class TrustedHeaderClientRequestValidator;
class TrustedHeaderClientResponseValidator;


class BLINK_PLATFORM_EXPORT TrustedHeaderClient
    : public TrustedHeaderClientInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = TrustedHeaderClientInterfaceBase;
  using Proxy_ = TrustedHeaderClientProxy;

  template <typename ImplRefTraits>
  using Stub_ = TrustedHeaderClientStub<ImplRefTraits>;

  using RequestValidator_ = TrustedHeaderClientRequestValidator;
  using ResponseValidator_ = TrustedHeaderClientResponseValidator;
  enum MethodMinVersions : uint32_t {
    kOnBeforeSendHeadersMinVersion = 0,
    kOnHeadersReceivedMinVersion = 0,
  };
  virtual ~TrustedHeaderClient() {}


  using OnBeforeSendHeadersCallback = base::OnceCallback<void(int32_t, const base::Optional<::net::HttpRequestHeaders>&)>;
  
  virtual void OnBeforeSendHeaders(const ::net::HttpRequestHeaders& headers, OnBeforeSendHeadersCallback callback) = 0;


  using OnHeadersReceivedCallback = base::OnceCallback<void(int32_t, const WTF::String&, const base::Optional<::blink::KURL>&)>;
  
  virtual void OnHeadersReceived(const WTF::String& headers, const ::net::IPEndPoint& remote_endpoint, OnHeadersReceivedCallback callback) = 0;
};

class TrustedURLLoaderHeaderClientProxy;

template <typename ImplRefTraits>
class TrustedURLLoaderHeaderClientStub;

class TrustedURLLoaderHeaderClientRequestValidator;


class BLINK_PLATFORM_EXPORT TrustedURLLoaderHeaderClient
    : public TrustedURLLoaderHeaderClientInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = TrustedURLLoaderHeaderClientInterfaceBase;
  using Proxy_ = TrustedURLLoaderHeaderClientProxy;

  template <typename ImplRefTraits>
  using Stub_ = TrustedURLLoaderHeaderClientStub<ImplRefTraits>;

  using RequestValidator_ = TrustedURLLoaderHeaderClientRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kOnLoaderCreatedMinVersion = 0,
    kOnLoaderForCorsPreflightCreatedMinVersion = 0,
  };
  virtual ~TrustedURLLoaderHeaderClient() {}

  
  virtual void OnLoaderCreated(int32_t request_id, mojo::PendingReceiver<TrustedHeaderClient> header_client) = 0;

  
  virtual void OnLoaderForCorsPreflightCreated(const ::network::ResourceRequest& request, mojo::PendingReceiver<TrustedHeaderClient> header_client) = 0;
};

class AuthChallengeResponderProxy;

template <typename ImplRefTraits>
class AuthChallengeResponderStub;

class AuthChallengeResponderRequestValidator;


class BLINK_PLATFORM_EXPORT AuthChallengeResponder
    : public AuthChallengeResponderInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = AuthChallengeResponderInterfaceBase;
  using Proxy_ = AuthChallengeResponderProxy;

  template <typename ImplRefTraits>
  using Stub_ = AuthChallengeResponderStub<ImplRefTraits>;

  using RequestValidator_ = AuthChallengeResponderRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kOnAuthCredentialsMinVersion = 0,
  };
  virtual ~AuthChallengeResponder() {}

  
  virtual void OnAuthCredentials(::network::mojom::blink::AuthCredentialsPtr credentials) = 0;
};

class ClientCertificateResponderProxy;

template <typename ImplRefTraits>
class ClientCertificateResponderStub;

class ClientCertificateResponderRequestValidator;


class BLINK_PLATFORM_EXPORT ClientCertificateResponder
    : public ClientCertificateResponderInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = ClientCertificateResponderInterfaceBase;
  using Proxy_ = ClientCertificateResponderProxy;

  template <typename ImplRefTraits>
  using Stub_ = ClientCertificateResponderStub<ImplRefTraits>;

  using RequestValidator_ = ClientCertificateResponderRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kContinueWithCertificateMinVersion = 0,
    kContinueWithoutCertificateMinVersion = 0,
    kCancelRequestMinVersion = 0,
  };
  virtual ~ClientCertificateResponder() {}

  
  virtual void ContinueWithCertificate(::network::mojom::blink::X509CertificatePtr x509_certificate, const WTF::String& provider_name, const WTF::Vector<uint16_t>& algorithm_preferences, mojo::PendingRemote<SSLPrivateKey> ssl_private_key) = 0;

  
  virtual void ContinueWithoutCertificate() = 0;

  
  virtual void CancelRequest() = 0;
};

class SSLPrivateKeyProxy;

template <typename ImplRefTraits>
class SSLPrivateKeyStub;

class SSLPrivateKeyRequestValidator;
class SSLPrivateKeyResponseValidator;


class BLINK_PLATFORM_EXPORT SSLPrivateKey
    : public SSLPrivateKeyInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = SSLPrivateKeyInterfaceBase;
  using Proxy_ = SSLPrivateKeyProxy;

  template <typename ImplRefTraits>
  using Stub_ = SSLPrivateKeyStub<ImplRefTraits>;

  using RequestValidator_ = SSLPrivateKeyRequestValidator;
  using ResponseValidator_ = SSLPrivateKeyResponseValidator;
  enum MethodMinVersions : uint32_t {
    kSignMinVersion = 0,
  };
  virtual ~SSLPrivateKey() {}


  using SignCallback = base::OnceCallback<void(int32_t, const WTF::Vector<uint8_t>&)>;
  
  virtual void Sign(uint16_t algorithm, const WTF::Vector<uint8_t>& input, SignCallback callback) = 0;
};

class NetworkContextClientProxy;

template <typename ImplRefTraits>
class NetworkContextClientStub;

class NetworkContextClientRequestValidator;
class NetworkContextClientResponseValidator;


class BLINK_PLATFORM_EXPORT NetworkContextClient
    : public NetworkContextClientInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = NetworkContextClientInterfaceBase;
  using Proxy_ = NetworkContextClientProxy;

  template <typename ImplRefTraits>
  using Stub_ = NetworkContextClientStub<ImplRefTraits>;

  using RequestValidator_ = NetworkContextClientRequestValidator;
  using ResponseValidator_ = NetworkContextClientResponseValidator;
  enum MethodMinVersions : uint32_t {
    kOnAuthRequiredMinVersion = 0,
    kOnCertificateRequestedMinVersion = 0,
    kOnSSLCertificateErrorMinVersion = 0,
    kOnFileUploadRequestedMinVersion = 0,
    kOnCanSendReportingReportsMinVersion = 0,
    kOnCanSendDomainReliabilityUploadMinVersion = 0,
    kOnClearSiteDataMinVersion = 0,
    kOnCookiesChangedMinVersion = 0,
    kOnCookiesReadMinVersion = 0,
    kOnGenerateHttpNegotiateAuthTokenMinVersion = 0,
  };
  virtual ~NetworkContextClient() {}

  
  virtual void OnAuthRequired(const base::Optional<::base::UnguessableToken>& window_id, int32_t process_id, int32_t routing_id, uint32_t request_id, const ::blink::KURL& url, bool first_auth_attempt, ::network::mojom::blink::AuthChallengeInfoPtr auth_info, ::network::mojom::blink::URLResponseHeadPtr head, mojo::PendingRemote<AuthChallengeResponder> auth_challenge_responder) = 0;

  
  virtual void OnCertificateRequested(const base::Optional<::base::UnguessableToken>& window_id, int32_t process_id, int32_t routing_id, uint32_t request_id, ::network::mojom::blink::SSLCertRequestInfoPtr cert_info, mojo::PendingRemote<ClientCertificateResponder> cert_responder) = 0;


  using OnSSLCertificateErrorCallback = base::OnceCallback<void(int32_t)>;
  
  virtual void OnSSLCertificateError(int32_t process_id, int32_t routing_id, const ::blink::KURL& url, int32_t net_error, ::network::mojom::blink::SSLInfoPtr ssl_info, bool fatal, OnSSLCertificateErrorCallback callback) = 0;


  using OnFileUploadRequestedCallback = base::OnceCallback<void(int32_t, WTF::Vector<::base::File>)>;
  
  virtual void OnFileUploadRequested(int32_t process_id, bool async, const WTF::Vector<::base::FilePath>& file_paths, OnFileUploadRequestedCallback callback) = 0;


  using OnCanSendReportingReportsCallback = base::OnceCallback<void(const WTF::Vector<::scoped_refptr<const ::blink::SecurityOrigin>>&)>;
  
  virtual void OnCanSendReportingReports(const WTF::Vector<::scoped_refptr<const ::blink::SecurityOrigin>>& origins, OnCanSendReportingReportsCallback callback) = 0;


  using OnCanSendDomainReliabilityUploadCallback = base::OnceCallback<void(bool)>;
  
  virtual void OnCanSendDomainReliabilityUpload(const ::blink::KURL& origin, OnCanSendDomainReliabilityUploadCallback callback) = 0;


  using OnClearSiteDataCallback = base::OnceCallback<void()>;
  
  virtual void OnClearSiteData(int32_t process_id, int32_t routing_id, const ::blink::KURL& url, const WTF::String& header_value, int32_t load_flags, OnClearSiteDataCallback callback) = 0;

  
  virtual void OnCookiesChanged(bool is_service_worker, int32_t process_id, int32_t routing_id, const ::blink::KURL& url, const ::net::SiteForCookies& site_for_cookies, WTF::Vector<::network::mojom::blink::CookieWithStatusPtr> cookie_list) = 0;

  
  virtual void OnCookiesRead(bool is_service_worker, int32_t process_id, int32_t routing_id, const ::blink::KURL& url, const ::net::SiteForCookies& site_for_cookies, WTF::Vector<::network::mojom::blink::CookieWithStatusPtr> cookie_list) = 0;


  using OnGenerateHttpNegotiateAuthTokenCallback = base::OnceCallback<void(int32_t, const WTF::String&)>;
  
  virtual void OnGenerateHttpNegotiateAuthToken(const WTF::String& server_auth_token, bool can_delegate, const WTF::String& auth_negotiate_android_account_type, const WTF::String& spn, OnGenerateHttpNegotiateAuthTokenCallback callback) = 0;
};

class NetworkContextProxy;

template <typename ImplRefTraits>
class NetworkContextStub;

class NetworkContextRequestValidator;
class NetworkContextResponseValidator;


class BLINK_PLATFORM_EXPORT NetworkContext
    : public NetworkContextInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = true;

  using Base_ = NetworkContextInterfaceBase;
  using Proxy_ = NetworkContextProxy;

  template <typename ImplRefTraits>
  using Stub_ = NetworkContextStub<ImplRefTraits>;

  using RequestValidator_ = NetworkContextRequestValidator;
  using ResponseValidator_ = NetworkContextResponseValidator;
  enum MethodMinVersions : uint32_t {
    kSetClientMinVersion = 0,
    kCreateURLLoaderFactoryMinVersion = 0,
    kResetURLLoaderFactoriesMinVersion = 0,
    kGetCookieManagerMinVersion = 0,
    kGetRestrictedCookieManagerMinVersion = 0,
    kClearNetworkingHistorySinceMinVersion = 0,
    kClearHttpCacheMinVersion = 0,
    kComputeHttpCacheSizeMinVersion = 0,
    kNotifyExternalCacheHitMinVersion = 0,
    kClearHostCacheMinVersion = 0,
    kClearHttpAuthCacheMinVersion = 0,
    kClearReportingCacheReportsMinVersion = 0,
    kClearReportingCacheClientsMinVersion = 0,
    kClearNetworkErrorLoggingMinVersion = 0,
    kClearDomainReliabilityMinVersion = 0,
    kGetDomainReliabilityJSONMinVersion = 0,
    kQueueReportMinVersion = 0,
    kQueueSignedExchangeReportMinVersion = 0,
    kCloseAllConnectionsMinVersion = 0,
    kCloseIdleConnectionsMinVersion = 0,
    kSetNetworkConditionsMinVersion = 0,
    kSetAcceptLanguageMinVersion = 0,
    kSetEnableReferrersMinVersion = 0,
    kSetCTPolicyMinVersion = 0,
    kAddExpectCTMinVersion = 0,
    kSetExpectCTTestReportMinVersion = 0,
    kGetExpectCTStateMinVersion = 0,
    kCreateUDPSocketMinVersion = 0,
    kCreateTCPServerSocketMinVersion = 0,
    kCreateTCPConnectedSocketMinVersion = 0,
    kCreateTCPBoundSocketMinVersion = 0,
    kCreateProxyResolvingSocketFactoryMinVersion = 0,
    kLookUpProxyForURLMinVersion = 0,
    kForceReloadProxyConfigMinVersion = 0,
    kClearBadProxiesCacheMinVersion = 0,
    kCreateWebSocketMinVersion = 0,
    kCreateQuicTransportMinVersion = 0,
    kCreateNetLogExporterMinVersion = 0,
    kPreconnectSocketsMinVersion = 0,
    kCreateP2PSocketManagerMinVersion = 0,
    kCreateMdnsResponderMinVersion = 0,
    kResolveHostMinVersion = 0,
    kCreateHostResolverMinVersion = 0,
    kVerifyCertForSignedExchangeMinVersion = 0,
    kAddHSTSMinVersion = 0,
    kIsHSTSActiveForHostMinVersion = 0,
    kGetHSTSStateMinVersion = 0,
    kSetCorsOriginAccessListsForOriginMinVersion = 0,
    kSetCorsExtraSafelistedRequestHeaderNamesMinVersion = 0,
    kDeleteDynamicDataForHostMinVersion = 0,
    kSetSplitAuthCacheByNetworkIsolationKeyMinVersion = 0,
    kSaveHttpAuthCacheProxyEntriesMinVersion = 0,
    kLoadHttpAuthCacheProxyEntriesMinVersion = 0,
    kAddAuthCacheEntryMinVersion = 0,
    kLookupServerBasicAuthCredentialsMinVersion = 0,
    kEnableStaticKeyPinningForTestingMinVersion = 0,
    kSetFailingHttpTransactionForTestingMinVersion = 0,
    kVerifyCertificateForTestingMinVersion = 0,
    kAddDomainReliabilityContextForTestingMinVersion = 0,
    kForceDomainReliabilityUploadsForTestingMinVersion = 0,
    kGetOriginPolicyManagerMinVersion = 0,
  };
  
  using DomainReliabilityClearMode = NetworkContext_DomainReliabilityClearMode;
  virtual ~NetworkContext() {}

  
  virtual void SetClient(mojo::PendingRemote<NetworkContextClient> client) = 0;

  
  virtual void CreateURLLoaderFactory(mojo::PendingReceiver<::network::mojom::blink::URLLoaderFactory> url_loader_factory, URLLoaderFactoryParamsPtr params) = 0;

  
  virtual void ResetURLLoaderFactories() = 0;

  
  virtual void GetCookieManager(mojo::PendingReceiver<::network::mojom::blink::CookieManager> cookie_manager) = 0;

  
  virtual void GetRestrictedCookieManager(mojo::PendingReceiver<::network::mojom::blink::RestrictedCookieManager> restricted_cookie_manager, ::network::mojom::blink::RestrictedCookieManagerRole role, const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, const ::net::SiteForCookies& site_for_cookies, const ::scoped_refptr<const ::blink::SecurityOrigin>& top_frame_origin, bool is_service_worker, int32_t process_id, int32_t routing_id) = 0;


  using ClearNetworkingHistorySinceCallback = base::OnceCallback<void()>;
  
  virtual void ClearNetworkingHistorySince(::base::Time start_time, ClearNetworkingHistorySinceCallback callback) = 0;


  using ClearHttpCacheCallback = base::OnceCallback<void()>;
  
  virtual void ClearHttpCache(::base::Time start_time, ::base::Time end_time, ClearDataFilterPtr filter, ClearHttpCacheCallback callback) = 0;


  using ComputeHttpCacheSizeCallback = base::OnceCallback<void(bool, int64_t)>;
  
  virtual void ComputeHttpCacheSize(::base::Time start_time, ::base::Time end_time, ComputeHttpCacheSizeCallback callback) = 0;

  
  virtual void NotifyExternalCacheHit(const ::blink::KURL& url, const WTF::String& http_method, ::network::mojom::blink::NetworkIsolationKeyPtr key) = 0;


  using ClearHostCacheCallback = base::OnceCallback<void()>;
  
  virtual void ClearHostCache(ClearDataFilterPtr filter, ClearHostCacheCallback callback) = 0;


  using ClearHttpAuthCacheCallback = base::OnceCallback<void()>;
  
  virtual void ClearHttpAuthCache(::base::Time start_time, ClearHttpAuthCacheCallback callback) = 0;


  using ClearReportingCacheReportsCallback = base::OnceCallback<void()>;
  
  virtual void ClearReportingCacheReports(ClearDataFilterPtr filter, ClearReportingCacheReportsCallback callback) = 0;


  using ClearReportingCacheClientsCallback = base::OnceCallback<void()>;
  
  virtual void ClearReportingCacheClients(ClearDataFilterPtr filter, ClearReportingCacheClientsCallback callback) = 0;


  using ClearNetworkErrorLoggingCallback = base::OnceCallback<void()>;
  
  virtual void ClearNetworkErrorLogging(ClearDataFilterPtr filter, ClearNetworkErrorLoggingCallback callback) = 0;


  using ClearDomainReliabilityCallback = base::OnceCallback<void()>;
  
  virtual void ClearDomainReliability(ClearDataFilterPtr filter, NetworkContext::DomainReliabilityClearMode mode, ClearDomainReliabilityCallback callback) = 0;


  using GetDomainReliabilityJSONCallback = base::OnceCallback<void(::base::Value)>;
  
  virtual void GetDomainReliabilityJSON(GetDomainReliabilityJSONCallback callback) = 0;

  
  virtual void QueueReport(const WTF::String& type, const WTF::String& group, const ::blink::KURL& url, const WTF::String& user_agent, ::base::Value body) = 0;

  
  virtual void QueueSignedExchangeReport(SignedExchangeReportPtr report) = 0;


  using CloseAllConnectionsCallback = base::OnceCallback<void()>;
  
  virtual void CloseAllConnections(CloseAllConnectionsCallback callback) = 0;


  using CloseIdleConnectionsCallback = base::OnceCallback<void()>;
  
  virtual void CloseIdleConnections(CloseIdleConnectionsCallback callback) = 0;

  
  virtual void SetNetworkConditions(const ::base::UnguessableToken& throttling_profile_id, NetworkConditionsPtr conditions) = 0;

  
  virtual void SetAcceptLanguage(const WTF::String& new_accept_language) = 0;

  
  virtual void SetEnableReferrers(bool enable_referrers) = 0;

  
  virtual void SetCTPolicy(const WTF::Vector<WTF::String>& required_hosts, const WTF::Vector<WTF::String>& excluded_hosts, const WTF::Vector<WTF::String>& excluded_spkis, const WTF::Vector<WTF::String>& excluded_legacy_spkis) = 0;


  using AddExpectCTCallback = base::OnceCallback<void(bool)>;
  
  virtual void AddExpectCT(const WTF::String& host, ::base::Time expiry, bool enforce, const ::blink::KURL& report_uri, AddExpectCTCallback callback) = 0;


  using SetExpectCTTestReportCallback = base::OnceCallback<void(bool)>;
  
  virtual void SetExpectCTTestReport(const ::blink::KURL& report_uri, SetExpectCTTestReportCallback callback) = 0;


  using GetExpectCTStateCallback = base::OnceCallback<void(::base::Value)>;
  
  virtual void GetExpectCTState(const WTF::String& domain, GetExpectCTStateCallback callback) = 0;

  
  virtual void CreateUDPSocket(mojo::PendingReceiver<::network::mojom::blink::UDPSocket> receiver, mojo::PendingRemote<::network::mojom::blink::UDPSocketListener> listener) = 0;


  using CreateTCPServerSocketCallback = base::OnceCallback<void(int32_t, const base::Optional<::net::IPEndPoint>&)>;
  
  virtual void CreateTCPServerSocket(const ::net::IPEndPoint& local_addr, uint32_t backlog, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, mojo::PendingReceiver<::network::mojom::blink::TCPServerSocket> socket, CreateTCPServerSocketCallback callback) = 0;


  using CreateTCPConnectedSocketCallback = base::OnceCallback<void(int32_t, const base::Optional<::net::IPEndPoint>&, const base::Optional<::net::IPEndPoint>&, mojo::ScopedDataPipeConsumerHandle, mojo::ScopedDataPipeProducerHandle)>;
  
  virtual void CreateTCPConnectedSocket(const base::Optional<::net::IPEndPoint>& local_addr, ::network::mojom::blink::AddressListPtr remote_addr_list, ::network::mojom::blink::TCPConnectedSocketOptionsPtr tcp_connected_socket_options, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, mojo::PendingReceiver<::network::mojom::blink::TCPConnectedSocket> socket, mojo::PendingRemote<::network::mojom::blink::SocketObserver> observer, CreateTCPConnectedSocketCallback callback) = 0;


  using CreateTCPBoundSocketCallback = base::OnceCallback<void(int32_t, const base::Optional<::net::IPEndPoint>&)>;
  
  virtual void CreateTCPBoundSocket(const ::net::IPEndPoint& local_addr, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, mojo::PendingReceiver<::network::mojom::blink::TCPBoundSocket> socket, CreateTCPBoundSocketCallback callback) = 0;

  
  virtual void CreateProxyResolvingSocketFactory(mojo::PendingReceiver<::network::mojom::blink::ProxyResolvingSocketFactory> factory) = 0;

  
  virtual void LookUpProxyForURL(const ::blink::KURL& url, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, mojo::PendingRemote<::network::mojom::blink::ProxyLookupClient> proxy_lookup_client) = 0;


  using ForceReloadProxyConfigCallback = base::OnceCallback<void()>;
  
  virtual void ForceReloadProxyConfig(ForceReloadProxyConfigCallback callback) = 0;


  using ClearBadProxiesCacheCallback = base::OnceCallback<void()>;
  
  virtual void ClearBadProxiesCache(ClearBadProxiesCacheCallback callback) = 0;

  
  virtual void CreateWebSocket(const ::blink::KURL& url, const WTF::Vector<WTF::String>& requested_protocols, const ::net::SiteForCookies& site_for_cookies, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, WTF::Vector<::network::mojom::blink::HttpHeaderPtr> additional_headers, int32_t process_id, int32_t render_frame_id, const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, uint32_t options, mojo::PendingRemote<::network::mojom::blink::WebSocketHandshakeClient> handshake_client, mojo::PendingRemote<::network::mojom::blink::AuthenticationHandler> auth_handler, mojo::PendingRemote<TrustedHeaderClient> header_client) = 0;

  
  virtual void CreateQuicTransport(const ::blink::KURL& url, const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, mojo::PendingRemote<::network::mojom::blink::QuicTransportHandshakeClient> handshake_client) = 0;

  
  virtual void CreateNetLogExporter(mojo::PendingReceiver<::network::mojom::blink::NetLogExporter> receiver) = 0;

  
  virtual void PreconnectSockets(uint32_t num_streams, const ::blink::KURL& url, bool allow_credentials, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key) = 0;

  
  virtual void CreateP2PSocketManager(mojo::PendingRemote<::network::mojom::blink::P2PTrustedSocketManagerClient> client, mojo::PendingReceiver<::network::mojom::blink::P2PTrustedSocketManager> trusted_socket_manager, mojo::PendingReceiver<::network::mojom::blink::P2PSocketManager> socket_manager) = 0;

  
  virtual void CreateMdnsResponder(mojo::PendingReceiver<::network::mojom::blink::MdnsResponder> responder_receiver) = 0;

  
  virtual void ResolveHost(::network::mojom::blink::HostPortPairPtr host, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, ::network::mojom::blink::ResolveHostParametersPtr optional_parameters, mojo::PendingRemote<::network::mojom::blink::ResolveHostClient> response_client) = 0;

  
  virtual void CreateHostResolver(::network::mojom::blink::DnsConfigOverridesPtr config_overrides, mojo::PendingReceiver<::network::mojom::blink::HostResolver> host_resolver) = 0;


  using VerifyCertForSignedExchangeCallback = base::OnceCallback<void(int32_t, ::network::mojom::blink::CertVerifyResultPtr, ::network::mojom::blink::CTVerifyResultPtr)>;
  
  virtual void VerifyCertForSignedExchange(::network::mojom::blink::X509CertificatePtr certificate, const ::blink::KURL& url, const WTF::String& ocsp_response, const WTF::String& sct_list, VerifyCertForSignedExchangeCallback callback) = 0;


  using AddHSTSCallback = base::OnceCallback<void()>;
  
  virtual void AddHSTS(const WTF::String& host, ::base::Time expiry, bool include_subdomains, AddHSTSCallback callback) = 0;


  using IsHSTSActiveForHostCallback = base::OnceCallback<void(bool)>;
  
  virtual void IsHSTSActiveForHost(const WTF::String& host, IsHSTSActiveForHostCallback callback) = 0;


  using GetHSTSStateCallback = base::OnceCallback<void(::base::Value)>;
  
  virtual void GetHSTSState(const WTF::String& domain, GetHSTSStateCallback callback) = 0;


  using SetCorsOriginAccessListsForOriginCallback = base::OnceCallback<void()>;
  
  virtual void SetCorsOriginAccessListsForOrigin(const ::scoped_refptr<const ::blink::SecurityOrigin>& source_origin, WTF::Vector<::network::mojom::blink::CorsOriginPatternPtr> allow_patterns, WTF::Vector<::network::mojom::blink::CorsOriginPatternPtr> block_patterns, SetCorsOriginAccessListsForOriginCallback callback) = 0;

  
  virtual void SetCorsExtraSafelistedRequestHeaderNames(const WTF::Vector<WTF::String>& cors_extra_safelisted_request_header_names) = 0;


  using DeleteDynamicDataForHostCallback = base::OnceCallback<void(bool)>;
  
  virtual void DeleteDynamicDataForHost(const WTF::String& host, DeleteDynamicDataForHostCallback callback) = 0;

  
  virtual void SetSplitAuthCacheByNetworkIsolationKey(bool split_auth_cache_by_network_isolation_key) = 0;


  using SaveHttpAuthCacheProxyEntriesCallback = base::OnceCallback<void(const ::base::UnguessableToken&)>;
  
  virtual void SaveHttpAuthCacheProxyEntries(SaveHttpAuthCacheProxyEntriesCallback callback) = 0;


  using LoadHttpAuthCacheProxyEntriesCallback = base::OnceCallback<void()>;
  
  virtual void LoadHttpAuthCacheProxyEntries(const ::base::UnguessableToken& cache_key, LoadHttpAuthCacheProxyEntriesCallback callback) = 0;


  using AddAuthCacheEntryCallback = base::OnceCallback<void()>;
  
  virtual void AddAuthCacheEntry(::network::mojom::blink::AuthChallengeInfoPtr challenge, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, ::network::mojom::blink::AuthCredentialsPtr credentials, AddAuthCacheEntryCallback callback) = 0;


  using LookupServerBasicAuthCredentialsCallback = base::OnceCallback<void(::network::mojom::blink::AuthCredentialsPtr)>;
  
  virtual void LookupServerBasicAuthCredentials(const ::blink::KURL& url, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, LookupServerBasicAuthCredentialsCallback callback) = 0;

  // Sync method. This signature is used by the client side; the service side
  // should implement the signature with callback below.
  
  virtual bool EnableStaticKeyPinningForTesting();

  using EnableStaticKeyPinningForTestingCallback = base::OnceCallback<void()>;
  
  virtual void EnableStaticKeyPinningForTesting(EnableStaticKeyPinningForTestingCallback callback) = 0;

  // Sync method. This signature is used by the client side; the service side
  // should implement the signature with callback below.
  
  virtual bool SetFailingHttpTransactionForTesting(int32_t rv);

  using SetFailingHttpTransactionForTestingCallback = base::OnceCallback<void()>;
  
  virtual void SetFailingHttpTransactionForTesting(int32_t rv, SetFailingHttpTransactionForTestingCallback callback) = 0;

  // Sync method. This signature is used by the client side; the service side
  // should implement the signature with callback below.
  
  virtual bool VerifyCertificateForTesting(::network::mojom::blink::X509CertificatePtr certificate, const WTF::String& hostname, const WTF::String& ocsp_response, const WTF::String& sct_list, int32_t* out_error_code);

  using VerifyCertificateForTestingCallback = base::OnceCallback<void(int32_t)>;
  
  virtual void VerifyCertificateForTesting(::network::mojom::blink::X509CertificatePtr certificate, const WTF::String& hostname, const WTF::String& ocsp_response, const WTF::String& sct_list, VerifyCertificateForTestingCallback callback) = 0;

  // Sync method. This signature is used by the client side; the service side
  // should implement the signature with callback below.
  
  virtual bool AddDomainReliabilityContextForTesting(const ::blink::KURL& origin, const ::blink::KURL& upload_url);

  using AddDomainReliabilityContextForTestingCallback = base::OnceCallback<void()>;
  
  virtual void AddDomainReliabilityContextForTesting(const ::blink::KURL& origin, const ::blink::KURL& upload_url, AddDomainReliabilityContextForTestingCallback callback) = 0;

  // Sync method. This signature is used by the client side; the service side
  // should implement the signature with callback below.
  
  virtual bool ForceDomainReliabilityUploadsForTesting();

  using ForceDomainReliabilityUploadsForTestingCallback = base::OnceCallback<void()>;
  
  virtual void ForceDomainReliabilityUploadsForTesting(ForceDomainReliabilityUploadsForTestingCallback callback) = 0;

  
  virtual void GetOriginPolicyManager(mojo::PendingReceiver<::network::mojom::blink::OriginPolicyManager> origin_policy_manager) = 0;
};



class BLINK_PLATFORM_EXPORT CustomProxyConfigClientProxy
    : public CustomProxyConfigClient {
 public:
  using InterfaceType = CustomProxyConfigClient;

  explicit CustomProxyConfigClientProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void OnCustomProxyConfigUpdated(CustomProxyConfigPtr proxy_config) final;
  
  void MarkProxiesAsBad(::base::TimeDelta bypass_duration, ::network::mojom::blink::ProxyListPtr bad_proxies, MarkProxiesAsBadCallback callback) final;
  
  void ClearBadProxiesCache() final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class BLINK_PLATFORM_EXPORT TrustedHeaderClientProxy
    : public TrustedHeaderClient {
 public:
  using InterfaceType = TrustedHeaderClient;

  explicit TrustedHeaderClientProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void OnBeforeSendHeaders(const ::net::HttpRequestHeaders& headers, OnBeforeSendHeadersCallback callback) final;
  
  void OnHeadersReceived(const WTF::String& headers, const ::net::IPEndPoint& remote_endpoint, OnHeadersReceivedCallback callback) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class BLINK_PLATFORM_EXPORT TrustedURLLoaderHeaderClientProxy
    : public TrustedURLLoaderHeaderClient {
 public:
  using InterfaceType = TrustedURLLoaderHeaderClient;

  explicit TrustedURLLoaderHeaderClientProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void OnLoaderCreated(int32_t request_id, mojo::PendingReceiver<TrustedHeaderClient> header_client) final;
  
  void OnLoaderForCorsPreflightCreated(const ::network::ResourceRequest& request, mojo::PendingReceiver<TrustedHeaderClient> header_client) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class BLINK_PLATFORM_EXPORT AuthChallengeResponderProxy
    : public AuthChallengeResponder {
 public:
  using InterfaceType = AuthChallengeResponder;

  explicit AuthChallengeResponderProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void OnAuthCredentials(::network::mojom::blink::AuthCredentialsPtr credentials) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class BLINK_PLATFORM_EXPORT ClientCertificateResponderProxy
    : public ClientCertificateResponder {
 public:
  using InterfaceType = ClientCertificateResponder;

  explicit ClientCertificateResponderProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void ContinueWithCertificate(::network::mojom::blink::X509CertificatePtr x509_certificate, const WTF::String& provider_name, const WTF::Vector<uint16_t>& algorithm_preferences, mojo::PendingRemote<SSLPrivateKey> ssl_private_key) final;
  
  void ContinueWithoutCertificate() final;
  
  void CancelRequest() final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class BLINK_PLATFORM_EXPORT SSLPrivateKeyProxy
    : public SSLPrivateKey {
 public:
  using InterfaceType = SSLPrivateKey;

  explicit SSLPrivateKeyProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void Sign(uint16_t algorithm, const WTF::Vector<uint8_t>& input, SignCallback callback) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class BLINK_PLATFORM_EXPORT NetworkContextClientProxy
    : public NetworkContextClient {
 public:
  using InterfaceType = NetworkContextClient;

  explicit NetworkContextClientProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void OnAuthRequired(const base::Optional<::base::UnguessableToken>& window_id, int32_t process_id, int32_t routing_id, uint32_t request_id, const ::blink::KURL& url, bool first_auth_attempt, ::network::mojom::blink::AuthChallengeInfoPtr auth_info, ::network::mojom::blink::URLResponseHeadPtr head, mojo::PendingRemote<AuthChallengeResponder> auth_challenge_responder) final;
  
  void OnCertificateRequested(const base::Optional<::base::UnguessableToken>& window_id, int32_t process_id, int32_t routing_id, uint32_t request_id, ::network::mojom::blink::SSLCertRequestInfoPtr cert_info, mojo::PendingRemote<ClientCertificateResponder> cert_responder) final;
  
  void OnSSLCertificateError(int32_t process_id, int32_t routing_id, const ::blink::KURL& url, int32_t net_error, ::network::mojom::blink::SSLInfoPtr ssl_info, bool fatal, OnSSLCertificateErrorCallback callback) final;
  
  void OnFileUploadRequested(int32_t process_id, bool async, const WTF::Vector<::base::FilePath>& file_paths, OnFileUploadRequestedCallback callback) final;
  
  void OnCanSendReportingReports(const WTF::Vector<::scoped_refptr<const ::blink::SecurityOrigin>>& origins, OnCanSendReportingReportsCallback callback) final;
  
  void OnCanSendDomainReliabilityUpload(const ::blink::KURL& origin, OnCanSendDomainReliabilityUploadCallback callback) final;
  
  void OnClearSiteData(int32_t process_id, int32_t routing_id, const ::blink::KURL& url, const WTF::String& header_value, int32_t load_flags, OnClearSiteDataCallback callback) final;
  
  void OnCookiesChanged(bool is_service_worker, int32_t process_id, int32_t routing_id, const ::blink::KURL& url, const ::net::SiteForCookies& site_for_cookies, WTF::Vector<::network::mojom::blink::CookieWithStatusPtr> cookie_list) final;
  
  void OnCookiesRead(bool is_service_worker, int32_t process_id, int32_t routing_id, const ::blink::KURL& url, const ::net::SiteForCookies& site_for_cookies, WTF::Vector<::network::mojom::blink::CookieWithStatusPtr> cookie_list) final;
  
  void OnGenerateHttpNegotiateAuthToken(const WTF::String& server_auth_token, bool can_delegate, const WTF::String& auth_negotiate_android_account_type, const WTF::String& spn, OnGenerateHttpNegotiateAuthTokenCallback callback) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class BLINK_PLATFORM_EXPORT NetworkContextProxy
    : public NetworkContext {
 public:
  using InterfaceType = NetworkContext;

  explicit NetworkContextProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void SetClient(mojo::PendingRemote<NetworkContextClient> client) final;
  
  void CreateURLLoaderFactory(mojo::PendingReceiver<::network::mojom::blink::URLLoaderFactory> url_loader_factory, URLLoaderFactoryParamsPtr params) final;
  
  void ResetURLLoaderFactories() final;
  
  void GetCookieManager(mojo::PendingReceiver<::network::mojom::blink::CookieManager> cookie_manager) final;
  
  void GetRestrictedCookieManager(mojo::PendingReceiver<::network::mojom::blink::RestrictedCookieManager> restricted_cookie_manager, ::network::mojom::blink::RestrictedCookieManagerRole role, const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, const ::net::SiteForCookies& site_for_cookies, const ::scoped_refptr<const ::blink::SecurityOrigin>& top_frame_origin, bool is_service_worker, int32_t process_id, int32_t routing_id) final;
  
  void ClearNetworkingHistorySince(::base::Time start_time, ClearNetworkingHistorySinceCallback callback) final;
  
  void ClearHttpCache(::base::Time start_time, ::base::Time end_time, ClearDataFilterPtr filter, ClearHttpCacheCallback callback) final;
  
  void ComputeHttpCacheSize(::base::Time start_time, ::base::Time end_time, ComputeHttpCacheSizeCallback callback) final;
  
  void NotifyExternalCacheHit(const ::blink::KURL& url, const WTF::String& http_method, ::network::mojom::blink::NetworkIsolationKeyPtr key) final;
  
  void ClearHostCache(ClearDataFilterPtr filter, ClearHostCacheCallback callback) final;
  
  void ClearHttpAuthCache(::base::Time start_time, ClearHttpAuthCacheCallback callback) final;
  
  void ClearReportingCacheReports(ClearDataFilterPtr filter, ClearReportingCacheReportsCallback callback) final;
  
  void ClearReportingCacheClients(ClearDataFilterPtr filter, ClearReportingCacheClientsCallback callback) final;
  
  void ClearNetworkErrorLogging(ClearDataFilterPtr filter, ClearNetworkErrorLoggingCallback callback) final;
  
  void ClearDomainReliability(ClearDataFilterPtr filter, NetworkContext::DomainReliabilityClearMode mode, ClearDomainReliabilityCallback callback) final;
  
  void GetDomainReliabilityJSON(GetDomainReliabilityJSONCallback callback) final;
  
  void QueueReport(const WTF::String& type, const WTF::String& group, const ::blink::KURL& url, const WTF::String& user_agent, ::base::Value body) final;
  
  void QueueSignedExchangeReport(SignedExchangeReportPtr report) final;
  
  void CloseAllConnections(CloseAllConnectionsCallback callback) final;
  
  void CloseIdleConnections(CloseIdleConnectionsCallback callback) final;
  
  void SetNetworkConditions(const ::base::UnguessableToken& throttling_profile_id, NetworkConditionsPtr conditions) final;
  
  void SetAcceptLanguage(const WTF::String& new_accept_language) final;
  
  void SetEnableReferrers(bool enable_referrers) final;
  
  void SetCTPolicy(const WTF::Vector<WTF::String>& required_hosts, const WTF::Vector<WTF::String>& excluded_hosts, const WTF::Vector<WTF::String>& excluded_spkis, const WTF::Vector<WTF::String>& excluded_legacy_spkis) final;
  
  void AddExpectCT(const WTF::String& host, ::base::Time expiry, bool enforce, const ::blink::KURL& report_uri, AddExpectCTCallback callback) final;
  
  void SetExpectCTTestReport(const ::blink::KURL& report_uri, SetExpectCTTestReportCallback callback) final;
  
  void GetExpectCTState(const WTF::String& domain, GetExpectCTStateCallback callback) final;
  
  void CreateUDPSocket(mojo::PendingReceiver<::network::mojom::blink::UDPSocket> receiver, mojo::PendingRemote<::network::mojom::blink::UDPSocketListener> listener) final;
  
  void CreateTCPServerSocket(const ::net::IPEndPoint& local_addr, uint32_t backlog, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, mojo::PendingReceiver<::network::mojom::blink::TCPServerSocket> socket, CreateTCPServerSocketCallback callback) final;
  
  void CreateTCPConnectedSocket(const base::Optional<::net::IPEndPoint>& local_addr, ::network::mojom::blink::AddressListPtr remote_addr_list, ::network::mojom::blink::TCPConnectedSocketOptionsPtr tcp_connected_socket_options, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, mojo::PendingReceiver<::network::mojom::blink::TCPConnectedSocket> socket, mojo::PendingRemote<::network::mojom::blink::SocketObserver> observer, CreateTCPConnectedSocketCallback callback) final;
  
  void CreateTCPBoundSocket(const ::net::IPEndPoint& local_addr, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, mojo::PendingReceiver<::network::mojom::blink::TCPBoundSocket> socket, CreateTCPBoundSocketCallback callback) final;
  
  void CreateProxyResolvingSocketFactory(mojo::PendingReceiver<::network::mojom::blink::ProxyResolvingSocketFactory> factory) final;
  
  void LookUpProxyForURL(const ::blink::KURL& url, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, mojo::PendingRemote<::network::mojom::blink::ProxyLookupClient> proxy_lookup_client) final;
  
  void ForceReloadProxyConfig(ForceReloadProxyConfigCallback callback) final;
  
  void ClearBadProxiesCache(ClearBadProxiesCacheCallback callback) final;
  
  void CreateWebSocket(const ::blink::KURL& url, const WTF::Vector<WTF::String>& requested_protocols, const ::net::SiteForCookies& site_for_cookies, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, WTF::Vector<::network::mojom::blink::HttpHeaderPtr> additional_headers, int32_t process_id, int32_t render_frame_id, const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, uint32_t options, mojo::PendingRemote<::network::mojom::blink::WebSocketHandshakeClient> handshake_client, mojo::PendingRemote<::network::mojom::blink::AuthenticationHandler> auth_handler, mojo::PendingRemote<TrustedHeaderClient> header_client) final;
  
  void CreateQuicTransport(const ::blink::KURL& url, const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, mojo::PendingRemote<::network::mojom::blink::QuicTransportHandshakeClient> handshake_client) final;
  
  void CreateNetLogExporter(mojo::PendingReceiver<::network::mojom::blink::NetLogExporter> receiver) final;
  
  void PreconnectSockets(uint32_t num_streams, const ::blink::KURL& url, bool allow_credentials, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key) final;
  
  void CreateP2PSocketManager(mojo::PendingRemote<::network::mojom::blink::P2PTrustedSocketManagerClient> client, mojo::PendingReceiver<::network::mojom::blink::P2PTrustedSocketManager> trusted_socket_manager, mojo::PendingReceiver<::network::mojom::blink::P2PSocketManager> socket_manager) final;
  
  void CreateMdnsResponder(mojo::PendingReceiver<::network::mojom::blink::MdnsResponder> responder_receiver) final;
  
  void ResolveHost(::network::mojom::blink::HostPortPairPtr host, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, ::network::mojom::blink::ResolveHostParametersPtr optional_parameters, mojo::PendingRemote<::network::mojom::blink::ResolveHostClient> response_client) final;
  
  void CreateHostResolver(::network::mojom::blink::DnsConfigOverridesPtr config_overrides, mojo::PendingReceiver<::network::mojom::blink::HostResolver> host_resolver) final;
  
  void VerifyCertForSignedExchange(::network::mojom::blink::X509CertificatePtr certificate, const ::blink::KURL& url, const WTF::String& ocsp_response, const WTF::String& sct_list, VerifyCertForSignedExchangeCallback callback) final;
  
  void AddHSTS(const WTF::String& host, ::base::Time expiry, bool include_subdomains, AddHSTSCallback callback) final;
  
  void IsHSTSActiveForHost(const WTF::String& host, IsHSTSActiveForHostCallback callback) final;
  
  void GetHSTSState(const WTF::String& domain, GetHSTSStateCallback callback) final;
  
  void SetCorsOriginAccessListsForOrigin(const ::scoped_refptr<const ::blink::SecurityOrigin>& source_origin, WTF::Vector<::network::mojom::blink::CorsOriginPatternPtr> allow_patterns, WTF::Vector<::network::mojom::blink::CorsOriginPatternPtr> block_patterns, SetCorsOriginAccessListsForOriginCallback callback) final;
  
  void SetCorsExtraSafelistedRequestHeaderNames(const WTF::Vector<WTF::String>& cors_extra_safelisted_request_header_names) final;
  
  void DeleteDynamicDataForHost(const WTF::String& host, DeleteDynamicDataForHostCallback callback) final;
  
  void SetSplitAuthCacheByNetworkIsolationKey(bool split_auth_cache_by_network_isolation_key) final;
  
  void SaveHttpAuthCacheProxyEntries(SaveHttpAuthCacheProxyEntriesCallback callback) final;
  
  void LoadHttpAuthCacheProxyEntries(const ::base::UnguessableToken& cache_key, LoadHttpAuthCacheProxyEntriesCallback callback) final;
  
  void AddAuthCacheEntry(::network::mojom::blink::AuthChallengeInfoPtr challenge, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, ::network::mojom::blink::AuthCredentialsPtr credentials, AddAuthCacheEntryCallback callback) final;
  
  void LookupServerBasicAuthCredentials(const ::blink::KURL& url, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, LookupServerBasicAuthCredentialsCallback callback) final;
  
  bool EnableStaticKeyPinningForTesting() final;
  
  void EnableStaticKeyPinningForTesting(EnableStaticKeyPinningForTestingCallback callback) final;
  
  bool SetFailingHttpTransactionForTesting(int32_t rv) final;
  
  void SetFailingHttpTransactionForTesting(int32_t rv, SetFailingHttpTransactionForTestingCallback callback) final;
  
  bool VerifyCertificateForTesting(::network::mojom::blink::X509CertificatePtr certificate, const WTF::String& hostname, const WTF::String& ocsp_response, const WTF::String& sct_list, int32_t* out_error_code) final;
  
  void VerifyCertificateForTesting(::network::mojom::blink::X509CertificatePtr certificate, const WTF::String& hostname, const WTF::String& ocsp_response, const WTF::String& sct_list, VerifyCertificateForTestingCallback callback) final;
  
  bool AddDomainReliabilityContextForTesting(const ::blink::KURL& origin, const ::blink::KURL& upload_url) final;
  
  void AddDomainReliabilityContextForTesting(const ::blink::KURL& origin, const ::blink::KURL& upload_url, AddDomainReliabilityContextForTestingCallback callback) final;
  
  bool ForceDomainReliabilityUploadsForTesting() final;
  
  void ForceDomainReliabilityUploadsForTesting(ForceDomainReliabilityUploadsForTestingCallback callback) final;
  
  void GetOriginPolicyManager(mojo::PendingReceiver<::network::mojom::blink::OriginPolicyManager> origin_policy_manager) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class BLINK_PLATFORM_EXPORT CustomProxyConfigClientStubDispatch {
 public:
  static bool Accept(CustomProxyConfigClient* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      CustomProxyConfigClient* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<CustomProxyConfigClient>>
class CustomProxyConfigClientStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  CustomProxyConfigClientStub() {}
  ~CustomProxyConfigClientStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return CustomProxyConfigClientStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return CustomProxyConfigClientStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class BLINK_PLATFORM_EXPORT TrustedHeaderClientStubDispatch {
 public:
  static bool Accept(TrustedHeaderClient* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      TrustedHeaderClient* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<TrustedHeaderClient>>
class TrustedHeaderClientStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  TrustedHeaderClientStub() {}
  ~TrustedHeaderClientStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return TrustedHeaderClientStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return TrustedHeaderClientStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class BLINK_PLATFORM_EXPORT TrustedURLLoaderHeaderClientStubDispatch {
 public:
  static bool Accept(TrustedURLLoaderHeaderClient* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      TrustedURLLoaderHeaderClient* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<TrustedURLLoaderHeaderClient>>
class TrustedURLLoaderHeaderClientStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  TrustedURLLoaderHeaderClientStub() {}
  ~TrustedURLLoaderHeaderClientStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return TrustedURLLoaderHeaderClientStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return TrustedURLLoaderHeaderClientStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class BLINK_PLATFORM_EXPORT AuthChallengeResponderStubDispatch {
 public:
  static bool Accept(AuthChallengeResponder* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      AuthChallengeResponder* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<AuthChallengeResponder>>
class AuthChallengeResponderStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  AuthChallengeResponderStub() {}
  ~AuthChallengeResponderStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return AuthChallengeResponderStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return AuthChallengeResponderStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class BLINK_PLATFORM_EXPORT ClientCertificateResponderStubDispatch {
 public:
  static bool Accept(ClientCertificateResponder* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      ClientCertificateResponder* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<ClientCertificateResponder>>
class ClientCertificateResponderStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  ClientCertificateResponderStub() {}
  ~ClientCertificateResponderStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return ClientCertificateResponderStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return ClientCertificateResponderStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class BLINK_PLATFORM_EXPORT SSLPrivateKeyStubDispatch {
 public:
  static bool Accept(SSLPrivateKey* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      SSLPrivateKey* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<SSLPrivateKey>>
class SSLPrivateKeyStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  SSLPrivateKeyStub() {}
  ~SSLPrivateKeyStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return SSLPrivateKeyStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return SSLPrivateKeyStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class BLINK_PLATFORM_EXPORT NetworkContextClientStubDispatch {
 public:
  static bool Accept(NetworkContextClient* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      NetworkContextClient* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<NetworkContextClient>>
class NetworkContextClientStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  NetworkContextClientStub() {}
  ~NetworkContextClientStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return NetworkContextClientStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return NetworkContextClientStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class BLINK_PLATFORM_EXPORT NetworkContextStubDispatch {
 public:
  static bool Accept(NetworkContext* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      NetworkContext* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<NetworkContext>>
class NetworkContextStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  NetworkContextStub() {}
  ~NetworkContextStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return NetworkContextStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return NetworkContextStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class BLINK_PLATFORM_EXPORT CustomProxyConfigClientRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT TrustedHeaderClientRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT TrustedURLLoaderHeaderClientRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT AuthChallengeResponderRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT ClientCertificateResponderRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT SSLPrivateKeyRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT NetworkContextClientRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT NetworkContextRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT CustomProxyConfigClientResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT TrustedHeaderClientResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT SSLPrivateKeyResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT NetworkContextClientResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT NetworkContextResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};






class BLINK_PLATFORM_EXPORT HttpAuthStaticNetworkContextParams {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<HttpAuthStaticNetworkContextParams, T>::value>;
  using DataView = HttpAuthStaticNetworkContextParamsDataView;
  using Data_ = internal::HttpAuthStaticNetworkContextParams_Data;

  template <typename... Args>
  static HttpAuthStaticNetworkContextParamsPtr New(Args&&... args) {
    return HttpAuthStaticNetworkContextParamsPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static HttpAuthStaticNetworkContextParamsPtr From(const U& u) {
    return mojo::TypeConverter<HttpAuthStaticNetworkContextParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, HttpAuthStaticNetworkContextParams>::Convert(*this);
  }


  HttpAuthStaticNetworkContextParams();

  explicit HttpAuthStaticNetworkContextParams(
      ::network::mojom::blink::DefaultCredentials allow_default_credentials);

  ~HttpAuthStaticNetworkContextParams();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = HttpAuthStaticNetworkContextParamsPtr>
  HttpAuthStaticNetworkContextParamsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, HttpAuthStaticNetworkContextParams::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;
  size_t Hash(size_t seed) const;

  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        HttpAuthStaticNetworkContextParams::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        HttpAuthStaticNetworkContextParams::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::HttpAuthStaticNetworkContextParams_UnserializedMessageContext<
            UserType, HttpAuthStaticNetworkContextParams::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<HttpAuthStaticNetworkContextParams::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return HttpAuthStaticNetworkContextParams::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::HttpAuthStaticNetworkContextParams_UnserializedMessageContext<
            UserType, HttpAuthStaticNetworkContextParams::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<HttpAuthStaticNetworkContextParams::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::network::mojom::blink::DefaultCredentials allow_default_credentials;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, HttpAuthStaticNetworkContextParams::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, HttpAuthStaticNetworkContextParams::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, HttpAuthStaticNetworkContextParams::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, HttpAuthStaticNetworkContextParams::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}








class BLINK_PLATFORM_EXPORT NetworkUsage {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<NetworkUsage, T>::value>;
  using DataView = NetworkUsageDataView;
  using Data_ = internal::NetworkUsage_Data;

  template <typename... Args>
  static NetworkUsagePtr New(Args&&... args) {
    return NetworkUsagePtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static NetworkUsagePtr From(const U& u) {
    return mojo::TypeConverter<NetworkUsagePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NetworkUsage>::Convert(*this);
  }


  NetworkUsage();

  NetworkUsage(
      int32_t process_id,
      int32_t routing_id,
      int64_t total_bytes_received,
      int64_t total_bytes_sent);

  ~NetworkUsage();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = NetworkUsagePtr>
  NetworkUsagePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, NetworkUsage::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;
  size_t Hash(size_t seed) const;

  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        NetworkUsage::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        NetworkUsage::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::NetworkUsage_UnserializedMessageContext<
            UserType, NetworkUsage::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<NetworkUsage::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return NetworkUsage::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::NetworkUsage_UnserializedMessageContext<
            UserType, NetworkUsage::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<NetworkUsage::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  int32_t process_id;
  
  int32_t routing_id;
  
  int64_t total_bytes_received;
  
  int64_t total_bytes_sent;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, NetworkUsage::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, NetworkUsage::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, NetworkUsage::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, NetworkUsage::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}










class BLINK_PLATFORM_EXPORT CustomProxyConfig {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<CustomProxyConfig, T>::value>;
  using DataView = CustomProxyConfigDataView;
  using Data_ = internal::CustomProxyConfig_Data;

  template <typename... Args>
  static CustomProxyConfigPtr New(Args&&... args) {
    return CustomProxyConfigPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static CustomProxyConfigPtr From(const U& u) {
    return mojo::TypeConverter<CustomProxyConfigPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CustomProxyConfig>::Convert(*this);
  }


  CustomProxyConfig();

  CustomProxyConfig(
      ::network::mojom::blink::ProxyRulesPtr rules,
      bool should_override_existing_config,
      bool allow_non_idempotent_methods,
      bool assume_https_proxies_support_quic,
      bool can_use_proxy_on_http_url_redirect_cycles,
      const ::net::HttpRequestHeaders& pre_cache_headers,
      const ::net::HttpRequestHeaders& post_cache_headers,
      const ::net::HttpRequestHeaders& connect_tunnel_headers);

  ~CustomProxyConfig();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = CustomProxyConfigPtr>
  CustomProxyConfigPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, CustomProxyConfig::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        CustomProxyConfig::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        CustomProxyConfig::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::CustomProxyConfig_UnserializedMessageContext<
            UserType, CustomProxyConfig::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<CustomProxyConfig::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return CustomProxyConfig::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::CustomProxyConfig_UnserializedMessageContext<
            UserType, CustomProxyConfig::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<CustomProxyConfig::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::network::mojom::blink::ProxyRulesPtr rules;
  
  bool should_override_existing_config;
  
  bool allow_non_idempotent_methods;
  
  bool assume_https_proxies_support_quic;
  
  bool can_use_proxy_on_http_url_redirect_cycles;
  
  ::net::HttpRequestHeaders pre_cache_headers;
  
  ::net::HttpRequestHeaders post_cache_headers;
  
  ::net::HttpRequestHeaders connect_tunnel_headers;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(CustomProxyConfig);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CustomProxyConfig::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, CustomProxyConfig::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, CustomProxyConfig::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, CustomProxyConfig::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class BLINK_PLATFORM_EXPORT NetworkContextParams {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<NetworkContextParams, T>::value>;
  using DataView = NetworkContextParamsDataView;
  using Data_ = internal::NetworkContextParams_Data;
  using CorsMode = NetworkContextParams_CorsMode;

  template <typename... Args>
  static NetworkContextParamsPtr New(Args&&... args) {
    return NetworkContextParamsPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static NetworkContextParamsPtr From(const U& u) {
    return mojo::TypeConverter<NetworkContextParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NetworkContextParams>::Convert(*this);
  }


  NetworkContextParams();

  NetworkContextParams(
      const WTF::String& context_name,
      const WTF::String& user_agent,
      const WTF::String& accept_language,
      bool enable_brotli,
      const WTF::String& quic_user_agent_id,
      bool enable_referrers,
      bool validate_referrer_policy_on_initial_request,
      mojo::PendingRemote<::proxy_resolver::mojom::blink::ProxyResolverFactory> proxy_resolver_factory,
      const base::Optional<::base::FilePath>& cookie_path,
      bool enable_encrypted_cookies,
      bool restore_old_session_cookies,
      bool persist_session_cookies,
      bool http_cache_enabled,
      int32_t http_cache_max_size,
      const base::Optional<::base::FilePath>& http_cache_path,
      const base::Optional<::base::FilePath>& http_server_properties_path,
      const base::Optional<::base::FilePath>& transport_security_persister_path,
      bool enable_ftp_url_support,
      bool check_clear_text_permitted,
      bool disable_idle_sockets_close_on_memory_pressure,
      ::network::mojom::blink::SSLConfigPtr initial_ssl_config,
      mojo::PendingReceiver<::network::mojom::blink::SSLConfigClient> ssl_config_client_receiver,
      ::network::mojom::blink::ProxyConfigWithAnnotationPtr initial_proxy_config,
      mojo::PendingReceiver<::network::mojom::blink::ProxyConfigClient> proxy_config_client_receiver,
      CustomProxyConfigPtr initial_custom_proxy_config,
      mojo::PendingReceiver<CustomProxyConfigClient> custom_proxy_config_client_receiver,
      mojo::PendingRemote<::network::mojom::blink::ProxyConfigPollerClient> proxy_config_poller_client,
      mojo::PendingRemote<::network::mojom::blink::ProxyErrorClient> proxy_error_client,
      bool pac_quick_check_enabled,
      bool enable_certificate_reporting,
      bool enforce_chrome_ct_policy,
      bool enable_expect_ct_reporting,
      WTF::Vector<::network::mojom::blink::CTLogInfoPtr> ct_logs,
      ::base::Time ct_log_update_time,
      ::network::mojom::blink::CookieManagerParamsPtr cookie_manager_params,
      bool enable_domain_reliability,
      const WTF::String& domain_reliability_upload_reporter,
      bool discard_domain_reliablity_uploads,
      base::Optional<::base::TimeDelta> reporting_delivery_interval,
      bool skip_reporting_send_permission_check,
      bool primary_network_context,
      WTF::Vector<::network::mojom::blink::CorsOriginAccessPatternsPtr> cors_origin_access_list,
      WTF::Vector<WTF::String> cors_exempt_header_list,
      WTF::Vector<WTF::String> hsts_policy_bypass_list,
      WTF::Vector<WTF::String> cors_extra_safelisted_request_header_names,
      NetworkContextParams::CorsMode cors_mode,
      const base::Optional<::base::FilePath>& reporting_and_nel_store_path,
      HttpAuthStaticNetworkContextParamsPtr http_auth_static_network_context_params,
      bool reset_http_cache_backend);

  ~NetworkContextParams();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = NetworkContextParamsPtr>
  NetworkContextParamsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, NetworkContextParams::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        NetworkContextParams::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        NetworkContextParams::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::NetworkContextParams_UnserializedMessageContext<
            UserType, NetworkContextParams::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<NetworkContextParams::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return NetworkContextParams::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::NetworkContextParams_UnserializedMessageContext<
            UserType, NetworkContextParams::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<NetworkContextParams::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  WTF::String context_name;
  
  WTF::String user_agent;
  
  WTF::String accept_language;
  
  bool enable_brotli;
  
  WTF::String quic_user_agent_id;
  
  bool enable_referrers;
  
  bool validate_referrer_policy_on_initial_request;
  
  mojo::PendingRemote<::proxy_resolver::mojom::blink::ProxyResolverFactory> proxy_resolver_factory;
  
  base::Optional<::base::FilePath> cookie_path;
  
  bool enable_encrypted_cookies;
  
  bool restore_old_session_cookies;
  
  bool persist_session_cookies;
  
  bool http_cache_enabled;
  
  int32_t http_cache_max_size;
  
  base::Optional<::base::FilePath> http_cache_path;
  
  base::Optional<::base::FilePath> http_server_properties_path;
  
  base::Optional<::base::FilePath> transport_security_persister_path;
  
  bool enable_ftp_url_support;
  
  bool check_clear_text_permitted;
  
  bool disable_idle_sockets_close_on_memory_pressure;
  
  ::network::mojom::blink::SSLConfigPtr initial_ssl_config;
  
  mojo::PendingReceiver<::network::mojom::blink::SSLConfigClient> ssl_config_client_receiver;
  
  ::network::mojom::blink::ProxyConfigWithAnnotationPtr initial_proxy_config;
  
  mojo::PendingReceiver<::network::mojom::blink::ProxyConfigClient> proxy_config_client_receiver;
  
  CustomProxyConfigPtr initial_custom_proxy_config;
  
  mojo::PendingReceiver<CustomProxyConfigClient> custom_proxy_config_client_receiver;
  
  mojo::PendingRemote<::network::mojom::blink::ProxyConfigPollerClient> proxy_config_poller_client;
  
  mojo::PendingRemote<::network::mojom::blink::ProxyErrorClient> proxy_error_client;
  
  bool pac_quick_check_enabled;
  
  bool enable_certificate_reporting;
  
  bool enforce_chrome_ct_policy;
  
  bool enable_expect_ct_reporting;
  
  WTF::Vector<::network::mojom::blink::CTLogInfoPtr> ct_logs;
  
  ::base::Time ct_log_update_time;
  
  ::network::mojom::blink::CookieManagerParamsPtr cookie_manager_params;
  
  bool enable_domain_reliability;
  
  WTF::String domain_reliability_upload_reporter;
  
  bool discard_domain_reliablity_uploads;
  
  base::Optional<::base::TimeDelta> reporting_delivery_interval;
  
  bool skip_reporting_send_permission_check;
  
  bool primary_network_context;
  
  WTF::Vector<::network::mojom::blink::CorsOriginAccessPatternsPtr> cors_origin_access_list;
  
  WTF::Vector<WTF::String> cors_exempt_header_list;
  
  WTF::Vector<WTF::String> hsts_policy_bypass_list;
  
  WTF::Vector<WTF::String> cors_extra_safelisted_request_header_names;
  
  NetworkContextParams::CorsMode cors_mode;
  
  base::Optional<::base::FilePath> reporting_and_nel_store_path;
  
  HttpAuthStaticNetworkContextParamsPtr http_auth_static_network_context_params;
  
  bool reset_http_cache_backend;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(NetworkContextParams);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, NetworkContextParams::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, NetworkContextParams::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, NetworkContextParams::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, NetworkContextParams::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class BLINK_PLATFORM_EXPORT NetworkConditions {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<NetworkConditions, T>::value>;
  using DataView = NetworkConditionsDataView;
  using Data_ = internal::NetworkConditions_Data;

  template <typename... Args>
  static NetworkConditionsPtr New(Args&&... args) {
    return NetworkConditionsPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static NetworkConditionsPtr From(const U& u) {
    return mojo::TypeConverter<NetworkConditionsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NetworkConditions>::Convert(*this);
  }


  NetworkConditions();

  NetworkConditions(
      bool offline,
      ::base::TimeDelta latency,
      double download_throughput,
      double upload_throughput);

  ~NetworkConditions();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = NetworkConditionsPtr>
  NetworkConditionsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, NetworkConditions::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        NetworkConditions::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        NetworkConditions::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::NetworkConditions_UnserializedMessageContext<
            UserType, NetworkConditions::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<NetworkConditions::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return NetworkConditions::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::NetworkConditions_UnserializedMessageContext<
            UserType, NetworkConditions::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<NetworkConditions::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  bool offline;
  
  ::base::TimeDelta latency;
  
  double download_throughput;
  
  double upload_throughput;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, NetworkConditions::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, NetworkConditions::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, NetworkConditions::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, NetworkConditions::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class BLINK_PLATFORM_EXPORT ClearDataFilter {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ClearDataFilter, T>::value>;
  using DataView = ClearDataFilterDataView;
  using Data_ = internal::ClearDataFilter_Data;
  using Type = ClearDataFilter_Type;

  template <typename... Args>
  static ClearDataFilterPtr New(Args&&... args) {
    return ClearDataFilterPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ClearDataFilterPtr From(const U& u) {
    return mojo::TypeConverter<ClearDataFilterPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ClearDataFilter>::Convert(*this);
  }


  ClearDataFilter();

  ClearDataFilter(
      ClearDataFilter::Type type,
      WTF::Vector<WTF::String> domains,
      WTF::Vector<::scoped_refptr<const ::blink::SecurityOrigin>> origins);

  ~ClearDataFilter();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ClearDataFilterPtr>
  ClearDataFilterPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ClearDataFilter::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ClearDataFilter::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ClearDataFilter::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ClearDataFilter_UnserializedMessageContext<
            UserType, ClearDataFilter::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<ClearDataFilter::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ClearDataFilter::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ClearDataFilter_UnserializedMessageContext<
            UserType, ClearDataFilter::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ClearDataFilter::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ClearDataFilter::Type type;
  
  WTF::Vector<WTF::String> domains;
  
  WTF::Vector<::scoped_refptr<const ::blink::SecurityOrigin>> origins;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ClearDataFilter::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ClearDataFilter::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ClearDataFilter::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ClearDataFilter::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class BLINK_PLATFORM_EXPORT SignedExchangeReport {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SignedExchangeReport, T>::value>;
  using DataView = SignedExchangeReportDataView;
  using Data_ = internal::SignedExchangeReport_Data;

  template <typename... Args>
  static SignedExchangeReportPtr New(Args&&... args) {
    return SignedExchangeReportPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SignedExchangeReportPtr From(const U& u) {
    return mojo::TypeConverter<SignedExchangeReportPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SignedExchangeReport>::Convert(*this);
  }


  SignedExchangeReport();

  SignedExchangeReport(
      bool success,
      const WTF::String& type,
      const ::blink::KURL& outer_url,
      const ::blink::KURL& inner_url,
      const ::blink::KURL& cert_url,
      const WTF::String& referrer,
      const ::net::IPAddress& server_ip_address,
      const WTF::String& protocol,
      const WTF::String& method,
      int32_t status_code,
      ::base::TimeDelta elapsed_time);

  ~SignedExchangeReport();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SignedExchangeReportPtr>
  SignedExchangeReportPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SignedExchangeReport::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SignedExchangeReport::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SignedExchangeReport::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SignedExchangeReport_UnserializedMessageContext<
            UserType, SignedExchangeReport::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<SignedExchangeReport::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return SignedExchangeReport::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SignedExchangeReport_UnserializedMessageContext<
            UserType, SignedExchangeReport::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SignedExchangeReport::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  bool success;
  
  WTF::String type;
  
  ::blink::KURL outer_url;
  
  ::blink::KURL inner_url;
  
  ::blink::KURL cert_url;
  
  WTF::String referrer;
  
  ::net::IPAddress server_ip_address;
  
  WTF::String protocol;
  
  WTF::String method;
  
  int32_t status_code;
  
  ::base::TimeDelta elapsed_time;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SignedExchangeReport::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SignedExchangeReport::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SignedExchangeReport::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SignedExchangeReport::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class BLINK_PLATFORM_EXPORT URLLoaderFactoryOverride {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<URLLoaderFactoryOverride, T>::value>;
  using DataView = URLLoaderFactoryOverrideDataView;
  using Data_ = internal::URLLoaderFactoryOverride_Data;

  template <typename... Args>
  static URLLoaderFactoryOverridePtr New(Args&&... args) {
    return URLLoaderFactoryOverridePtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static URLLoaderFactoryOverridePtr From(const U& u) {
    return mojo::TypeConverter<URLLoaderFactoryOverridePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, URLLoaderFactoryOverride>::Convert(*this);
  }


  URLLoaderFactoryOverride();

  URLLoaderFactoryOverride(
      mojo::PendingRemote<::network::mojom::blink::URLLoaderFactory> overriding_factory,
      mojo::PendingReceiver<::network::mojom::blink::URLLoaderFactory> overridden_factory_receiver);

  ~URLLoaderFactoryOverride();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = URLLoaderFactoryOverridePtr>
  URLLoaderFactoryOverridePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, URLLoaderFactoryOverride::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        URLLoaderFactoryOverride::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        URLLoaderFactoryOverride::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::URLLoaderFactoryOverride_UnserializedMessageContext<
            UserType, URLLoaderFactoryOverride::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<URLLoaderFactoryOverride::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return URLLoaderFactoryOverride::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::URLLoaderFactoryOverride_UnserializedMessageContext<
            UserType, URLLoaderFactoryOverride::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<URLLoaderFactoryOverride::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  mojo::PendingRemote<::network::mojom::blink::URLLoaderFactory> overriding_factory;
  
  mojo::PendingReceiver<::network::mojom::blink::URLLoaderFactory> overridden_factory_receiver;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(URLLoaderFactoryOverride);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, URLLoaderFactoryOverride::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, URLLoaderFactoryOverride::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, URLLoaderFactoryOverride::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, URLLoaderFactoryOverride::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class BLINK_PLATFORM_EXPORT URLLoaderFactoryParams {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<URLLoaderFactoryParams, T>::value>;
  using DataView = URLLoaderFactoryParamsDataView;
  using Data_ = internal::URLLoaderFactoryParams_Data;

  template <typename... Args>
  static URLLoaderFactoryParamsPtr New(Args&&... args) {
    return URLLoaderFactoryParamsPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static URLLoaderFactoryParamsPtr From(const U& u) {
    return mojo::TypeConverter<URLLoaderFactoryParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, URLLoaderFactoryParams>::Convert(*this);
  }


  URLLoaderFactoryParams();

  URLLoaderFactoryParams(
      int32_t process_id,
      const ::scoped_refptr<const ::blink::SecurityOrigin>& request_initiator_site_lock,
      bool is_corb_enabled,
      bool ignore_isolated_world_origin,
      bool unsafe_non_webby_initiator,
      bool disable_web_security,
      ::network::mojom::blink::CrossOriginEmbedderPolicy cross_origin_embedder_policy,
      mojo::PendingRemote<TrustedURLLoaderHeaderClient> header_client,
      ::network::mojom::blink::CorsOriginAccessPatternsPtr factory_bound_access_patterns,
      ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key,
      bool disable_secure_dns,
      bool is_trusted,
      const base::Optional<::base::UnguessableToken>& top_frame_id,
      URLLoaderFactoryOverridePtr factory_override);

  ~URLLoaderFactoryParams();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = URLLoaderFactoryParamsPtr>
  URLLoaderFactoryParamsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, URLLoaderFactoryParams::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        URLLoaderFactoryParams::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        URLLoaderFactoryParams::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::URLLoaderFactoryParams_UnserializedMessageContext<
            UserType, URLLoaderFactoryParams::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<URLLoaderFactoryParams::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return URLLoaderFactoryParams::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::URLLoaderFactoryParams_UnserializedMessageContext<
            UserType, URLLoaderFactoryParams::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<URLLoaderFactoryParams::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  int32_t process_id;
  
  ::scoped_refptr<const ::blink::SecurityOrigin> request_initiator_site_lock;
  
  bool is_corb_enabled;
  
  bool ignore_isolated_world_origin;
  
  bool unsafe_non_webby_initiator;
  
  bool disable_web_security;
  
  ::network::mojom::blink::CrossOriginEmbedderPolicy cross_origin_embedder_policy;
  
  mojo::PendingRemote<TrustedURLLoaderHeaderClient> header_client;
  
  ::network::mojom::blink::CorsOriginAccessPatternsPtr factory_bound_access_patterns;
  
  ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key;
  
  bool disable_secure_dns;
  
  bool is_trusted;
  
  base::Optional<::base::UnguessableToken> top_frame_id;
  
  URLLoaderFactoryOverridePtr factory_override;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(URLLoaderFactoryParams);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, URLLoaderFactoryParams::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, URLLoaderFactoryParams::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, URLLoaderFactoryParams::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, URLLoaderFactoryParams::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename StructPtrType>
CustomProxyConfigPtr CustomProxyConfig::Clone() const {
  return New(
      mojo::Clone(rules),
      mojo::Clone(should_override_existing_config),
      mojo::Clone(allow_non_idempotent_methods),
      mojo::Clone(assume_https_proxies_support_quic),
      mojo::Clone(can_use_proxy_on_http_url_redirect_cycles),
      mojo::Clone(pre_cache_headers),
      mojo::Clone(post_cache_headers),
      mojo::Clone(connect_tunnel_headers)
  );
}

template <typename T, CustomProxyConfig::EnableIfSame<T>*>
bool CustomProxyConfig::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->rules, other_struct.rules))
    return false;
  if (!mojo::Equals(this->should_override_existing_config, other_struct.should_override_existing_config))
    return false;
  if (!mojo::Equals(this->allow_non_idempotent_methods, other_struct.allow_non_idempotent_methods))
    return false;
  if (!mojo::Equals(this->assume_https_proxies_support_quic, other_struct.assume_https_proxies_support_quic))
    return false;
  if (!mojo::Equals(this->can_use_proxy_on_http_url_redirect_cycles, other_struct.can_use_proxy_on_http_url_redirect_cycles))
    return false;
  if (!mojo::Equals(this->pre_cache_headers, other_struct.pre_cache_headers))
    return false;
  if (!mojo::Equals(this->post_cache_headers, other_struct.post_cache_headers))
    return false;
  if (!mojo::Equals(this->connect_tunnel_headers, other_struct.connect_tunnel_headers))
    return false;
  return true;
}

template <typename T, CustomProxyConfig::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.rules < rhs.rules)
    return true;
  if (rhs.rules < lhs.rules)
    return false;
  if (lhs.should_override_existing_config < rhs.should_override_existing_config)
    return true;
  if (rhs.should_override_existing_config < lhs.should_override_existing_config)
    return false;
  if (lhs.allow_non_idempotent_methods < rhs.allow_non_idempotent_methods)
    return true;
  if (rhs.allow_non_idempotent_methods < lhs.allow_non_idempotent_methods)
    return false;
  if (lhs.assume_https_proxies_support_quic < rhs.assume_https_proxies_support_quic)
    return true;
  if (rhs.assume_https_proxies_support_quic < lhs.assume_https_proxies_support_quic)
    return false;
  if (lhs.can_use_proxy_on_http_url_redirect_cycles < rhs.can_use_proxy_on_http_url_redirect_cycles)
    return true;
  if (rhs.can_use_proxy_on_http_url_redirect_cycles < lhs.can_use_proxy_on_http_url_redirect_cycles)
    return false;
  if (lhs.pre_cache_headers < rhs.pre_cache_headers)
    return true;
  if (rhs.pre_cache_headers < lhs.pre_cache_headers)
    return false;
  if (lhs.post_cache_headers < rhs.post_cache_headers)
    return true;
  if (rhs.post_cache_headers < lhs.post_cache_headers)
    return false;
  if (lhs.connect_tunnel_headers < rhs.connect_tunnel_headers)
    return true;
  if (rhs.connect_tunnel_headers < lhs.connect_tunnel_headers)
    return false;
  return false;
}
template <typename StructPtrType>
HttpAuthStaticNetworkContextParamsPtr HttpAuthStaticNetworkContextParams::Clone() const {
  return New(
      mojo::Clone(allow_default_credentials)
  );
}

template <typename T, HttpAuthStaticNetworkContextParams::EnableIfSame<T>*>
bool HttpAuthStaticNetworkContextParams::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->allow_default_credentials, other_struct.allow_default_credentials))
    return false;
  return true;
}

template <typename T, HttpAuthStaticNetworkContextParams::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.allow_default_credentials < rhs.allow_default_credentials)
    return true;
  if (rhs.allow_default_credentials < lhs.allow_default_credentials)
    return false;
  return false;
}
template <typename StructPtrType>
NetworkContextParamsPtr NetworkContextParams::Clone() const {
  return New(
      mojo::Clone(context_name),
      mojo::Clone(user_agent),
      mojo::Clone(accept_language),
      mojo::Clone(enable_brotli),
      mojo::Clone(quic_user_agent_id),
      mojo::Clone(enable_referrers),
      mojo::Clone(validate_referrer_policy_on_initial_request),
      mojo::Clone(proxy_resolver_factory),
      mojo::Clone(cookie_path),
      mojo::Clone(enable_encrypted_cookies),
      mojo::Clone(restore_old_session_cookies),
      mojo::Clone(persist_session_cookies),
      mojo::Clone(http_cache_enabled),
      mojo::Clone(http_cache_max_size),
      mojo::Clone(http_cache_path),
      mojo::Clone(http_server_properties_path),
      mojo::Clone(transport_security_persister_path),
      mojo::Clone(enable_ftp_url_support),
      mojo::Clone(check_clear_text_permitted),
      mojo::Clone(disable_idle_sockets_close_on_memory_pressure),
      mojo::Clone(initial_ssl_config),
      mojo::Clone(ssl_config_client_receiver),
      mojo::Clone(initial_proxy_config),
      mojo::Clone(proxy_config_client_receiver),
      mojo::Clone(initial_custom_proxy_config),
      mojo::Clone(custom_proxy_config_client_receiver),
      mojo::Clone(proxy_config_poller_client),
      mojo::Clone(proxy_error_client),
      mojo::Clone(pac_quick_check_enabled),
      mojo::Clone(enable_certificate_reporting),
      mojo::Clone(enforce_chrome_ct_policy),
      mojo::Clone(enable_expect_ct_reporting),
      mojo::Clone(ct_logs),
      mojo::Clone(ct_log_update_time),
      mojo::Clone(cookie_manager_params),
      mojo::Clone(enable_domain_reliability),
      mojo::Clone(domain_reliability_upload_reporter),
      mojo::Clone(discard_domain_reliablity_uploads),
      mojo::Clone(reporting_delivery_interval),
      mojo::Clone(skip_reporting_send_permission_check),
      mojo::Clone(primary_network_context),
      mojo::Clone(cors_origin_access_list),
      mojo::Clone(cors_exempt_header_list),
      mojo::Clone(hsts_policy_bypass_list),
      mojo::Clone(cors_extra_safelisted_request_header_names),
      mojo::Clone(cors_mode),
      mojo::Clone(reporting_and_nel_store_path),
      mojo::Clone(http_auth_static_network_context_params),
      mojo::Clone(reset_http_cache_backend)
  );
}

template <typename T, NetworkContextParams::EnableIfSame<T>*>
bool NetworkContextParams::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->context_name, other_struct.context_name))
    return false;
  if (!mojo::Equals(this->user_agent, other_struct.user_agent))
    return false;
  if (!mojo::Equals(this->accept_language, other_struct.accept_language))
    return false;
  if (!mojo::Equals(this->enable_brotli, other_struct.enable_brotli))
    return false;
  if (!mojo::Equals(this->quic_user_agent_id, other_struct.quic_user_agent_id))
    return false;
  if (!mojo::Equals(this->enable_referrers, other_struct.enable_referrers))
    return false;
  if (!mojo::Equals(this->validate_referrer_policy_on_initial_request, other_struct.validate_referrer_policy_on_initial_request))
    return false;
  if (!mojo::Equals(this->proxy_resolver_factory, other_struct.proxy_resolver_factory))
    return false;
  if (!mojo::Equals(this->cookie_path, other_struct.cookie_path))
    return false;
  if (!mojo::Equals(this->enable_encrypted_cookies, other_struct.enable_encrypted_cookies))
    return false;
  if (!mojo::Equals(this->restore_old_session_cookies, other_struct.restore_old_session_cookies))
    return false;
  if (!mojo::Equals(this->persist_session_cookies, other_struct.persist_session_cookies))
    return false;
  if (!mojo::Equals(this->http_cache_enabled, other_struct.http_cache_enabled))
    return false;
  if (!mojo::Equals(this->http_cache_max_size, other_struct.http_cache_max_size))
    return false;
  if (!mojo::Equals(this->http_cache_path, other_struct.http_cache_path))
    return false;
  if (!mojo::Equals(this->http_server_properties_path, other_struct.http_server_properties_path))
    return false;
  if (!mojo::Equals(this->transport_security_persister_path, other_struct.transport_security_persister_path))
    return false;
  if (!mojo::Equals(this->enable_ftp_url_support, other_struct.enable_ftp_url_support))
    return false;
  if (!mojo::Equals(this->check_clear_text_permitted, other_struct.check_clear_text_permitted))
    return false;
  if (!mojo::Equals(this->disable_idle_sockets_close_on_memory_pressure, other_struct.disable_idle_sockets_close_on_memory_pressure))
    return false;
  if (!mojo::Equals(this->initial_ssl_config, other_struct.initial_ssl_config))
    return false;
  if (!mojo::Equals(this->ssl_config_client_receiver, other_struct.ssl_config_client_receiver))
    return false;
  if (!mojo::Equals(this->initial_proxy_config, other_struct.initial_proxy_config))
    return false;
  if (!mojo::Equals(this->proxy_config_client_receiver, other_struct.proxy_config_client_receiver))
    return false;
  if (!mojo::Equals(this->initial_custom_proxy_config, other_struct.initial_custom_proxy_config))
    return false;
  if (!mojo::Equals(this->custom_proxy_config_client_receiver, other_struct.custom_proxy_config_client_receiver))
    return false;
  if (!mojo::Equals(this->proxy_config_poller_client, other_struct.proxy_config_poller_client))
    return false;
  if (!mojo::Equals(this->proxy_error_client, other_struct.proxy_error_client))
    return false;
  if (!mojo::Equals(this->pac_quick_check_enabled, other_struct.pac_quick_check_enabled))
    return false;
  if (!mojo::Equals(this->enable_certificate_reporting, other_struct.enable_certificate_reporting))
    return false;
  if (!mojo::Equals(this->enforce_chrome_ct_policy, other_struct.enforce_chrome_ct_policy))
    return false;
  if (!mojo::Equals(this->enable_expect_ct_reporting, other_struct.enable_expect_ct_reporting))
    return false;
  if (!mojo::Equals(this->ct_logs, other_struct.ct_logs))
    return false;
  if (!mojo::Equals(this->ct_log_update_time, other_struct.ct_log_update_time))
    return false;
  if (!mojo::Equals(this->cookie_manager_params, other_struct.cookie_manager_params))
    return false;
  if (!mojo::Equals(this->enable_domain_reliability, other_struct.enable_domain_reliability))
    return false;
  if (!mojo::Equals(this->domain_reliability_upload_reporter, other_struct.domain_reliability_upload_reporter))
    return false;
  if (!mojo::Equals(this->discard_domain_reliablity_uploads, other_struct.discard_domain_reliablity_uploads))
    return false;
  if (!mojo::Equals(this->reporting_delivery_interval, other_struct.reporting_delivery_interval))
    return false;
  if (!mojo::Equals(this->skip_reporting_send_permission_check, other_struct.skip_reporting_send_permission_check))
    return false;
  if (!mojo::Equals(this->primary_network_context, other_struct.primary_network_context))
    return false;
  if (!mojo::Equals(this->cors_origin_access_list, other_struct.cors_origin_access_list))
    return false;
  if (!mojo::Equals(this->cors_exempt_header_list, other_struct.cors_exempt_header_list))
    return false;
  if (!mojo::Equals(this->hsts_policy_bypass_list, other_struct.hsts_policy_bypass_list))
    return false;
  if (!mojo::Equals(this->cors_extra_safelisted_request_header_names, other_struct.cors_extra_safelisted_request_header_names))
    return false;
  if (!mojo::Equals(this->cors_mode, other_struct.cors_mode))
    return false;
  if (!mojo::Equals(this->reporting_and_nel_store_path, other_struct.reporting_and_nel_store_path))
    return false;
  if (!mojo::Equals(this->http_auth_static_network_context_params, other_struct.http_auth_static_network_context_params))
    return false;
  if (!mojo::Equals(this->reset_http_cache_backend, other_struct.reset_http_cache_backend))
    return false;
  return true;
}

template <typename T, NetworkContextParams::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.context_name < rhs.context_name)
    return true;
  if (rhs.context_name < lhs.context_name)
    return false;
  if (lhs.user_agent < rhs.user_agent)
    return true;
  if (rhs.user_agent < lhs.user_agent)
    return false;
  if (lhs.accept_language < rhs.accept_language)
    return true;
  if (rhs.accept_language < lhs.accept_language)
    return false;
  if (lhs.enable_brotli < rhs.enable_brotli)
    return true;
  if (rhs.enable_brotli < lhs.enable_brotli)
    return false;
  if (lhs.quic_user_agent_id < rhs.quic_user_agent_id)
    return true;
  if (rhs.quic_user_agent_id < lhs.quic_user_agent_id)
    return false;
  if (lhs.enable_referrers < rhs.enable_referrers)
    return true;
  if (rhs.enable_referrers < lhs.enable_referrers)
    return false;
  if (lhs.validate_referrer_policy_on_initial_request < rhs.validate_referrer_policy_on_initial_request)
    return true;
  if (rhs.validate_referrer_policy_on_initial_request < lhs.validate_referrer_policy_on_initial_request)
    return false;
  if (lhs.proxy_resolver_factory < rhs.proxy_resolver_factory)
    return true;
  if (rhs.proxy_resolver_factory < lhs.proxy_resolver_factory)
    return false;
  if (lhs.cookie_path < rhs.cookie_path)
    return true;
  if (rhs.cookie_path < lhs.cookie_path)
    return false;
  if (lhs.enable_encrypted_cookies < rhs.enable_encrypted_cookies)
    return true;
  if (rhs.enable_encrypted_cookies < lhs.enable_encrypted_cookies)
    return false;
  if (lhs.restore_old_session_cookies < rhs.restore_old_session_cookies)
    return true;
  if (rhs.restore_old_session_cookies < lhs.restore_old_session_cookies)
    return false;
  if (lhs.persist_session_cookies < rhs.persist_session_cookies)
    return true;
  if (rhs.persist_session_cookies < lhs.persist_session_cookies)
    return false;
  if (lhs.http_cache_enabled < rhs.http_cache_enabled)
    return true;
  if (rhs.http_cache_enabled < lhs.http_cache_enabled)
    return false;
  if (lhs.http_cache_max_size < rhs.http_cache_max_size)
    return true;
  if (rhs.http_cache_max_size < lhs.http_cache_max_size)
    return false;
  if (lhs.http_cache_path < rhs.http_cache_path)
    return true;
  if (rhs.http_cache_path < lhs.http_cache_path)
    return false;
  if (lhs.http_server_properties_path < rhs.http_server_properties_path)
    return true;
  if (rhs.http_server_properties_path < lhs.http_server_properties_path)
    return false;
  if (lhs.transport_security_persister_path < rhs.transport_security_persister_path)
    return true;
  if (rhs.transport_security_persister_path < lhs.transport_security_persister_path)
    return false;
  if (lhs.enable_ftp_url_support < rhs.enable_ftp_url_support)
    return true;
  if (rhs.enable_ftp_url_support < lhs.enable_ftp_url_support)
    return false;
  if (lhs.check_clear_text_permitted < rhs.check_clear_text_permitted)
    return true;
  if (rhs.check_clear_text_permitted < lhs.check_clear_text_permitted)
    return false;
  if (lhs.disable_idle_sockets_close_on_memory_pressure < rhs.disable_idle_sockets_close_on_memory_pressure)
    return true;
  if (rhs.disable_idle_sockets_close_on_memory_pressure < lhs.disable_idle_sockets_close_on_memory_pressure)
    return false;
  if (lhs.initial_ssl_config < rhs.initial_ssl_config)
    return true;
  if (rhs.initial_ssl_config < lhs.initial_ssl_config)
    return false;
  if (lhs.ssl_config_client_receiver < rhs.ssl_config_client_receiver)
    return true;
  if (rhs.ssl_config_client_receiver < lhs.ssl_config_client_receiver)
    return false;
  if (lhs.initial_proxy_config < rhs.initial_proxy_config)
    return true;
  if (rhs.initial_proxy_config < lhs.initial_proxy_config)
    return false;
  if (lhs.proxy_config_client_receiver < rhs.proxy_config_client_receiver)
    return true;
  if (rhs.proxy_config_client_receiver < lhs.proxy_config_client_receiver)
    return false;
  if (lhs.initial_custom_proxy_config < rhs.initial_custom_proxy_config)
    return true;
  if (rhs.initial_custom_proxy_config < lhs.initial_custom_proxy_config)
    return false;
  if (lhs.custom_proxy_config_client_receiver < rhs.custom_proxy_config_client_receiver)
    return true;
  if (rhs.custom_proxy_config_client_receiver < lhs.custom_proxy_config_client_receiver)
    return false;
  if (lhs.proxy_config_poller_client < rhs.proxy_config_poller_client)
    return true;
  if (rhs.proxy_config_poller_client < lhs.proxy_config_poller_client)
    return false;
  if (lhs.proxy_error_client < rhs.proxy_error_client)
    return true;
  if (rhs.proxy_error_client < lhs.proxy_error_client)
    return false;
  if (lhs.pac_quick_check_enabled < rhs.pac_quick_check_enabled)
    return true;
  if (rhs.pac_quick_check_enabled < lhs.pac_quick_check_enabled)
    return false;
  if (lhs.enable_certificate_reporting < rhs.enable_certificate_reporting)
    return true;
  if (rhs.enable_certificate_reporting < lhs.enable_certificate_reporting)
    return false;
  if (lhs.enforce_chrome_ct_policy < rhs.enforce_chrome_ct_policy)
    return true;
  if (rhs.enforce_chrome_ct_policy < lhs.enforce_chrome_ct_policy)
    return false;
  if (lhs.enable_expect_ct_reporting < rhs.enable_expect_ct_reporting)
    return true;
  if (rhs.enable_expect_ct_reporting < lhs.enable_expect_ct_reporting)
    return false;
  if (lhs.ct_logs < rhs.ct_logs)
    return true;
  if (rhs.ct_logs < lhs.ct_logs)
    return false;
  if (lhs.ct_log_update_time < rhs.ct_log_update_time)
    return true;
  if (rhs.ct_log_update_time < lhs.ct_log_update_time)
    return false;
  if (lhs.cookie_manager_params < rhs.cookie_manager_params)
    return true;
  if (rhs.cookie_manager_params < lhs.cookie_manager_params)
    return false;
  if (lhs.enable_domain_reliability < rhs.enable_domain_reliability)
    return true;
  if (rhs.enable_domain_reliability < lhs.enable_domain_reliability)
    return false;
  if (lhs.domain_reliability_upload_reporter < rhs.domain_reliability_upload_reporter)
    return true;
  if (rhs.domain_reliability_upload_reporter < lhs.domain_reliability_upload_reporter)
    return false;
  if (lhs.discard_domain_reliablity_uploads < rhs.discard_domain_reliablity_uploads)
    return true;
  if (rhs.discard_domain_reliablity_uploads < lhs.discard_domain_reliablity_uploads)
    return false;
  if (lhs.reporting_delivery_interval < rhs.reporting_delivery_interval)
    return true;
  if (rhs.reporting_delivery_interval < lhs.reporting_delivery_interval)
    return false;
  if (lhs.skip_reporting_send_permission_check < rhs.skip_reporting_send_permission_check)
    return true;
  if (rhs.skip_reporting_send_permission_check < lhs.skip_reporting_send_permission_check)
    return false;
  if (lhs.primary_network_context < rhs.primary_network_context)
    return true;
  if (rhs.primary_network_context < lhs.primary_network_context)
    return false;
  if (lhs.cors_origin_access_list < rhs.cors_origin_access_list)
    return true;
  if (rhs.cors_origin_access_list < lhs.cors_origin_access_list)
    return false;
  if (lhs.cors_exempt_header_list < rhs.cors_exempt_header_list)
    return true;
  if (rhs.cors_exempt_header_list < lhs.cors_exempt_header_list)
    return false;
  if (lhs.hsts_policy_bypass_list < rhs.hsts_policy_bypass_list)
    return true;
  if (rhs.hsts_policy_bypass_list < lhs.hsts_policy_bypass_list)
    return false;
  if (lhs.cors_extra_safelisted_request_header_names < rhs.cors_extra_safelisted_request_header_names)
    return true;
  if (rhs.cors_extra_safelisted_request_header_names < lhs.cors_extra_safelisted_request_header_names)
    return false;
  if (lhs.cors_mode < rhs.cors_mode)
    return true;
  if (rhs.cors_mode < lhs.cors_mode)
    return false;
  if (lhs.reporting_and_nel_store_path < rhs.reporting_and_nel_store_path)
    return true;
  if (rhs.reporting_and_nel_store_path < lhs.reporting_and_nel_store_path)
    return false;
  if (lhs.http_auth_static_network_context_params < rhs.http_auth_static_network_context_params)
    return true;
  if (rhs.http_auth_static_network_context_params < lhs.http_auth_static_network_context_params)
    return false;
  if (lhs.reset_http_cache_backend < rhs.reset_http_cache_backend)
    return true;
  if (rhs.reset_http_cache_backend < lhs.reset_http_cache_backend)
    return false;
  return false;
}
template <typename StructPtrType>
NetworkConditionsPtr NetworkConditions::Clone() const {
  return New(
      mojo::Clone(offline),
      mojo::Clone(latency),
      mojo::Clone(download_throughput),
      mojo::Clone(upload_throughput)
  );
}

template <typename T, NetworkConditions::EnableIfSame<T>*>
bool NetworkConditions::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->offline, other_struct.offline))
    return false;
  if (!mojo::Equals(this->latency, other_struct.latency))
    return false;
  if (!mojo::Equals(this->download_throughput, other_struct.download_throughput))
    return false;
  if (!mojo::Equals(this->upload_throughput, other_struct.upload_throughput))
    return false;
  return true;
}

template <typename T, NetworkConditions::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.offline < rhs.offline)
    return true;
  if (rhs.offline < lhs.offline)
    return false;
  if (lhs.latency < rhs.latency)
    return true;
  if (rhs.latency < lhs.latency)
    return false;
  if (lhs.download_throughput < rhs.download_throughput)
    return true;
  if (rhs.download_throughput < lhs.download_throughput)
    return false;
  if (lhs.upload_throughput < rhs.upload_throughput)
    return true;
  if (rhs.upload_throughput < lhs.upload_throughput)
    return false;
  return false;
}
template <typename StructPtrType>
ClearDataFilterPtr ClearDataFilter::Clone() const {
  return New(
      mojo::Clone(type),
      mojo::Clone(domains),
      mojo::Clone(origins)
  );
}

template <typename T, ClearDataFilter::EnableIfSame<T>*>
bool ClearDataFilter::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->type, other_struct.type))
    return false;
  if (!mojo::Equals(this->domains, other_struct.domains))
    return false;
  if (!mojo::Equals(this->origins, other_struct.origins))
    return false;
  return true;
}

template <typename T, ClearDataFilter::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.type < rhs.type)
    return true;
  if (rhs.type < lhs.type)
    return false;
  if (lhs.domains < rhs.domains)
    return true;
  if (rhs.domains < lhs.domains)
    return false;
  if (lhs.origins < rhs.origins)
    return true;
  if (rhs.origins < lhs.origins)
    return false;
  return false;
}
template <typename StructPtrType>
NetworkUsagePtr NetworkUsage::Clone() const {
  return New(
      mojo::Clone(process_id),
      mojo::Clone(routing_id),
      mojo::Clone(total_bytes_received),
      mojo::Clone(total_bytes_sent)
  );
}

template <typename T, NetworkUsage::EnableIfSame<T>*>
bool NetworkUsage::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->process_id, other_struct.process_id))
    return false;
  if (!mojo::Equals(this->routing_id, other_struct.routing_id))
    return false;
  if (!mojo::Equals(this->total_bytes_received, other_struct.total_bytes_received))
    return false;
  if (!mojo::Equals(this->total_bytes_sent, other_struct.total_bytes_sent))
    return false;
  return true;
}

template <typename T, NetworkUsage::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.process_id < rhs.process_id)
    return true;
  if (rhs.process_id < lhs.process_id)
    return false;
  if (lhs.routing_id < rhs.routing_id)
    return true;
  if (rhs.routing_id < lhs.routing_id)
    return false;
  if (lhs.total_bytes_received < rhs.total_bytes_received)
    return true;
  if (rhs.total_bytes_received < lhs.total_bytes_received)
    return false;
  if (lhs.total_bytes_sent < rhs.total_bytes_sent)
    return true;
  if (rhs.total_bytes_sent < lhs.total_bytes_sent)
    return false;
  return false;
}
template <typename StructPtrType>
SignedExchangeReportPtr SignedExchangeReport::Clone() const {
  return New(
      mojo::Clone(success),
      mojo::Clone(type),
      mojo::Clone(outer_url),
      mojo::Clone(inner_url),
      mojo::Clone(cert_url),
      mojo::Clone(referrer),
      mojo::Clone(server_ip_address),
      mojo::Clone(protocol),
      mojo::Clone(method),
      mojo::Clone(status_code),
      mojo::Clone(elapsed_time)
  );
}

template <typename T, SignedExchangeReport::EnableIfSame<T>*>
bool SignedExchangeReport::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->success, other_struct.success))
    return false;
  if (!mojo::Equals(this->type, other_struct.type))
    return false;
  if (!mojo::Equals(this->outer_url, other_struct.outer_url))
    return false;
  if (!mojo::Equals(this->inner_url, other_struct.inner_url))
    return false;
  if (!mojo::Equals(this->cert_url, other_struct.cert_url))
    return false;
  if (!mojo::Equals(this->referrer, other_struct.referrer))
    return false;
  if (!mojo::Equals(this->server_ip_address, other_struct.server_ip_address))
    return false;
  if (!mojo::Equals(this->protocol, other_struct.protocol))
    return false;
  if (!mojo::Equals(this->method, other_struct.method))
    return false;
  if (!mojo::Equals(this->status_code, other_struct.status_code))
    return false;
  if (!mojo::Equals(this->elapsed_time, other_struct.elapsed_time))
    return false;
  return true;
}

template <typename T, SignedExchangeReport::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.success < rhs.success)
    return true;
  if (rhs.success < lhs.success)
    return false;
  if (lhs.type < rhs.type)
    return true;
  if (rhs.type < lhs.type)
    return false;
  if (lhs.outer_url < rhs.outer_url)
    return true;
  if (rhs.outer_url < lhs.outer_url)
    return false;
  if (lhs.inner_url < rhs.inner_url)
    return true;
  if (rhs.inner_url < lhs.inner_url)
    return false;
  if (lhs.cert_url < rhs.cert_url)
    return true;
  if (rhs.cert_url < lhs.cert_url)
    return false;
  if (lhs.referrer < rhs.referrer)
    return true;
  if (rhs.referrer < lhs.referrer)
    return false;
  if (lhs.server_ip_address < rhs.server_ip_address)
    return true;
  if (rhs.server_ip_address < lhs.server_ip_address)
    return false;
  if (lhs.protocol < rhs.protocol)
    return true;
  if (rhs.protocol < lhs.protocol)
    return false;
  if (lhs.method < rhs.method)
    return true;
  if (rhs.method < lhs.method)
    return false;
  if (lhs.status_code < rhs.status_code)
    return true;
  if (rhs.status_code < lhs.status_code)
    return false;
  if (lhs.elapsed_time < rhs.elapsed_time)
    return true;
  if (rhs.elapsed_time < lhs.elapsed_time)
    return false;
  return false;
}
template <typename StructPtrType>
URLLoaderFactoryOverridePtr URLLoaderFactoryOverride::Clone() const {
  return New(
      mojo::Clone(overriding_factory),
      mojo::Clone(overridden_factory_receiver)
  );
}

template <typename T, URLLoaderFactoryOverride::EnableIfSame<T>*>
bool URLLoaderFactoryOverride::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->overriding_factory, other_struct.overriding_factory))
    return false;
  if (!mojo::Equals(this->overridden_factory_receiver, other_struct.overridden_factory_receiver))
    return false;
  return true;
}

template <typename T, URLLoaderFactoryOverride::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.overriding_factory < rhs.overriding_factory)
    return true;
  if (rhs.overriding_factory < lhs.overriding_factory)
    return false;
  if (lhs.overridden_factory_receiver < rhs.overridden_factory_receiver)
    return true;
  if (rhs.overridden_factory_receiver < lhs.overridden_factory_receiver)
    return false;
  return false;
}
template <typename StructPtrType>
URLLoaderFactoryParamsPtr URLLoaderFactoryParams::Clone() const {
  return New(
      mojo::Clone(process_id),
      mojo::Clone(request_initiator_site_lock),
      mojo::Clone(is_corb_enabled),
      mojo::Clone(ignore_isolated_world_origin),
      mojo::Clone(unsafe_non_webby_initiator),
      mojo::Clone(disable_web_security),
      mojo::Clone(cross_origin_embedder_policy),
      mojo::Clone(header_client),
      mojo::Clone(factory_bound_access_patterns),
      mojo::Clone(network_isolation_key),
      mojo::Clone(disable_secure_dns),
      mojo::Clone(is_trusted),
      mojo::Clone(top_frame_id),
      mojo::Clone(factory_override)
  );
}

template <typename T, URLLoaderFactoryParams::EnableIfSame<T>*>
bool URLLoaderFactoryParams::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->process_id, other_struct.process_id))
    return false;
  if (!mojo::Equals(this->request_initiator_site_lock, other_struct.request_initiator_site_lock))
    return false;
  if (!mojo::Equals(this->is_corb_enabled, other_struct.is_corb_enabled))
    return false;
  if (!mojo::Equals(this->ignore_isolated_world_origin, other_struct.ignore_isolated_world_origin))
    return false;
  if (!mojo::Equals(this->unsafe_non_webby_initiator, other_struct.unsafe_non_webby_initiator))
    return false;
  if (!mojo::Equals(this->disable_web_security, other_struct.disable_web_security))
    return false;
  if (!mojo::Equals(this->cross_origin_embedder_policy, other_struct.cross_origin_embedder_policy))
    return false;
  if (!mojo::Equals(this->header_client, other_struct.header_client))
    return false;
  if (!mojo::Equals(this->factory_bound_access_patterns, other_struct.factory_bound_access_patterns))
    return false;
  if (!mojo::Equals(this->network_isolation_key, other_struct.network_isolation_key))
    return false;
  if (!mojo::Equals(this->disable_secure_dns, other_struct.disable_secure_dns))
    return false;
  if (!mojo::Equals(this->is_trusted, other_struct.is_trusted))
    return false;
  if (!mojo::Equals(this->top_frame_id, other_struct.top_frame_id))
    return false;
  if (!mojo::Equals(this->factory_override, other_struct.factory_override))
    return false;
  return true;
}

template <typename T, URLLoaderFactoryParams::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.process_id < rhs.process_id)
    return true;
  if (rhs.process_id < lhs.process_id)
    return false;
  if (lhs.request_initiator_site_lock < rhs.request_initiator_site_lock)
    return true;
  if (rhs.request_initiator_site_lock < lhs.request_initiator_site_lock)
    return false;
  if (lhs.is_corb_enabled < rhs.is_corb_enabled)
    return true;
  if (rhs.is_corb_enabled < lhs.is_corb_enabled)
    return false;
  if (lhs.ignore_isolated_world_origin < rhs.ignore_isolated_world_origin)
    return true;
  if (rhs.ignore_isolated_world_origin < lhs.ignore_isolated_world_origin)
    return false;
  if (lhs.unsafe_non_webby_initiator < rhs.unsafe_non_webby_initiator)
    return true;
  if (rhs.unsafe_non_webby_initiator < lhs.unsafe_non_webby_initiator)
    return false;
  if (lhs.disable_web_security < rhs.disable_web_security)
    return true;
  if (rhs.disable_web_security < lhs.disable_web_security)
    return false;
  if (lhs.cross_origin_embedder_policy < rhs.cross_origin_embedder_policy)
    return true;
  if (rhs.cross_origin_embedder_policy < lhs.cross_origin_embedder_policy)
    return false;
  if (lhs.header_client < rhs.header_client)
    return true;
  if (rhs.header_client < lhs.header_client)
    return false;
  if (lhs.factory_bound_access_patterns < rhs.factory_bound_access_patterns)
    return true;
  if (rhs.factory_bound_access_patterns < lhs.factory_bound_access_patterns)
    return false;
  if (lhs.network_isolation_key < rhs.network_isolation_key)
    return true;
  if (rhs.network_isolation_key < lhs.network_isolation_key)
    return false;
  if (lhs.disable_secure_dns < rhs.disable_secure_dns)
    return true;
  if (rhs.disable_secure_dns < lhs.disable_secure_dns)
    return false;
  if (lhs.is_trusted < rhs.is_trusted)
    return true;
  if (rhs.is_trusted < lhs.is_trusted)
    return false;
  if (lhs.top_frame_id < rhs.top_frame_id)
    return true;
  if (rhs.top_frame_id < lhs.top_frame_id)
    return false;
  if (lhs.factory_override < rhs.factory_override)
    return true;
  if (rhs.factory_override < lhs.factory_override)
    return false;
  return false;
}


}  // namespace blink
}  // namespace mojom
}  // namespace network

namespace mojo {


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::CustomProxyConfig::DataView,
                                         ::network::mojom::blink::CustomProxyConfigPtr> {
  static bool IsNull(const ::network::mojom::blink::CustomProxyConfigPtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::CustomProxyConfigPtr* output) { output->reset(); }

  static const decltype(::network::mojom::blink::CustomProxyConfig::rules)& rules(
      const ::network::mojom::blink::CustomProxyConfigPtr& input) {
    return input->rules;
  }

  static decltype(::network::mojom::blink::CustomProxyConfig::should_override_existing_config) should_override_existing_config(
      const ::network::mojom::blink::CustomProxyConfigPtr& input) {
    return input->should_override_existing_config;
  }

  static decltype(::network::mojom::blink::CustomProxyConfig::allow_non_idempotent_methods) allow_non_idempotent_methods(
      const ::network::mojom::blink::CustomProxyConfigPtr& input) {
    return input->allow_non_idempotent_methods;
  }

  static decltype(::network::mojom::blink::CustomProxyConfig::assume_https_proxies_support_quic) assume_https_proxies_support_quic(
      const ::network::mojom::blink::CustomProxyConfigPtr& input) {
    return input->assume_https_proxies_support_quic;
  }

  static decltype(::network::mojom::blink::CustomProxyConfig::can_use_proxy_on_http_url_redirect_cycles) can_use_proxy_on_http_url_redirect_cycles(
      const ::network::mojom::blink::CustomProxyConfigPtr& input) {
    return input->can_use_proxy_on_http_url_redirect_cycles;
  }

  static const decltype(::network::mojom::blink::CustomProxyConfig::pre_cache_headers)& pre_cache_headers(
      const ::network::mojom::blink::CustomProxyConfigPtr& input) {
    return input->pre_cache_headers;
  }

  static const decltype(::network::mojom::blink::CustomProxyConfig::post_cache_headers)& post_cache_headers(
      const ::network::mojom::blink::CustomProxyConfigPtr& input) {
    return input->post_cache_headers;
  }

  static const decltype(::network::mojom::blink::CustomProxyConfig::connect_tunnel_headers)& connect_tunnel_headers(
      const ::network::mojom::blink::CustomProxyConfigPtr& input) {
    return input->connect_tunnel_headers;
  }

  static bool Read(::network::mojom::blink::CustomProxyConfig::DataView input, ::network::mojom::blink::CustomProxyConfigPtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::HttpAuthStaticNetworkContextParams::DataView,
                                         ::network::mojom::blink::HttpAuthStaticNetworkContextParamsPtr> {
  static bool IsNull(const ::network::mojom::blink::HttpAuthStaticNetworkContextParamsPtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::HttpAuthStaticNetworkContextParamsPtr* output) { output->reset(); }

  static decltype(::network::mojom::blink::HttpAuthStaticNetworkContextParams::allow_default_credentials) allow_default_credentials(
      const ::network::mojom::blink::HttpAuthStaticNetworkContextParamsPtr& input) {
    return input->allow_default_credentials;
  }

  static bool Read(::network::mojom::blink::HttpAuthStaticNetworkContextParams::DataView input, ::network::mojom::blink::HttpAuthStaticNetworkContextParamsPtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::NetworkContextParams::DataView,
                                         ::network::mojom::blink::NetworkContextParamsPtr> {
  static bool IsNull(const ::network::mojom::blink::NetworkContextParamsPtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::NetworkContextParamsPtr* output) { output->reset(); }

  static const decltype(::network::mojom::blink::NetworkContextParams::context_name)& context_name(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->context_name;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::user_agent)& user_agent(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->user_agent;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::accept_language)& accept_language(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->accept_language;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::enable_brotli) enable_brotli(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->enable_brotli;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::quic_user_agent_id)& quic_user_agent_id(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->quic_user_agent_id;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::enable_referrers) enable_referrers(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->enable_referrers;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::validate_referrer_policy_on_initial_request) validate_referrer_policy_on_initial_request(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->validate_referrer_policy_on_initial_request;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::proxy_resolver_factory)& proxy_resolver_factory(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->proxy_resolver_factory;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::cookie_path)& cookie_path(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->cookie_path;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::enable_encrypted_cookies) enable_encrypted_cookies(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->enable_encrypted_cookies;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::restore_old_session_cookies) restore_old_session_cookies(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->restore_old_session_cookies;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::persist_session_cookies) persist_session_cookies(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->persist_session_cookies;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::http_cache_enabled) http_cache_enabled(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->http_cache_enabled;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::http_cache_max_size) http_cache_max_size(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->http_cache_max_size;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::http_cache_path)& http_cache_path(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->http_cache_path;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::http_server_properties_path)& http_server_properties_path(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->http_server_properties_path;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::transport_security_persister_path)& transport_security_persister_path(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->transport_security_persister_path;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::enable_ftp_url_support) enable_ftp_url_support(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->enable_ftp_url_support;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::check_clear_text_permitted) check_clear_text_permitted(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->check_clear_text_permitted;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::disable_idle_sockets_close_on_memory_pressure) disable_idle_sockets_close_on_memory_pressure(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->disable_idle_sockets_close_on_memory_pressure;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::initial_ssl_config)& initial_ssl_config(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->initial_ssl_config;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::ssl_config_client_receiver)& ssl_config_client_receiver(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->ssl_config_client_receiver;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::initial_proxy_config)& initial_proxy_config(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->initial_proxy_config;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::proxy_config_client_receiver)& proxy_config_client_receiver(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->proxy_config_client_receiver;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::initial_custom_proxy_config)& initial_custom_proxy_config(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->initial_custom_proxy_config;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::custom_proxy_config_client_receiver)& custom_proxy_config_client_receiver(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->custom_proxy_config_client_receiver;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::proxy_config_poller_client)& proxy_config_poller_client(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->proxy_config_poller_client;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::proxy_error_client)& proxy_error_client(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->proxy_error_client;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::pac_quick_check_enabled) pac_quick_check_enabled(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->pac_quick_check_enabled;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::enable_certificate_reporting) enable_certificate_reporting(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->enable_certificate_reporting;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::enforce_chrome_ct_policy) enforce_chrome_ct_policy(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->enforce_chrome_ct_policy;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::enable_expect_ct_reporting) enable_expect_ct_reporting(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->enable_expect_ct_reporting;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::ct_logs)& ct_logs(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->ct_logs;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::ct_log_update_time)& ct_log_update_time(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->ct_log_update_time;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::cookie_manager_params)& cookie_manager_params(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->cookie_manager_params;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::enable_domain_reliability) enable_domain_reliability(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->enable_domain_reliability;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::domain_reliability_upload_reporter)& domain_reliability_upload_reporter(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->domain_reliability_upload_reporter;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::discard_domain_reliablity_uploads) discard_domain_reliablity_uploads(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->discard_domain_reliablity_uploads;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::reporting_delivery_interval)& reporting_delivery_interval(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->reporting_delivery_interval;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::skip_reporting_send_permission_check) skip_reporting_send_permission_check(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->skip_reporting_send_permission_check;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::primary_network_context) primary_network_context(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->primary_network_context;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::cors_origin_access_list)& cors_origin_access_list(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->cors_origin_access_list;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::cors_exempt_header_list)& cors_exempt_header_list(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->cors_exempt_header_list;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::hsts_policy_bypass_list)& hsts_policy_bypass_list(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->hsts_policy_bypass_list;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::cors_extra_safelisted_request_header_names)& cors_extra_safelisted_request_header_names(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->cors_extra_safelisted_request_header_names;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::cors_mode) cors_mode(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->cors_mode;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::reporting_and_nel_store_path)& reporting_and_nel_store_path(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->reporting_and_nel_store_path;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::http_auth_static_network_context_params)& http_auth_static_network_context_params(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->http_auth_static_network_context_params;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::reset_http_cache_backend) reset_http_cache_backend(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->reset_http_cache_backend;
  }

  static bool Read(::network::mojom::blink::NetworkContextParams::DataView input, ::network::mojom::blink::NetworkContextParamsPtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::NetworkConditions::DataView,
                                         ::network::mojom::blink::NetworkConditionsPtr> {
  static bool IsNull(const ::network::mojom::blink::NetworkConditionsPtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::NetworkConditionsPtr* output) { output->reset(); }

  static decltype(::network::mojom::blink::NetworkConditions::offline) offline(
      const ::network::mojom::blink::NetworkConditionsPtr& input) {
    return input->offline;
  }

  static const decltype(::network::mojom::blink::NetworkConditions::latency)& latency(
      const ::network::mojom::blink::NetworkConditionsPtr& input) {
    return input->latency;
  }

  static decltype(::network::mojom::blink::NetworkConditions::download_throughput) download_throughput(
      const ::network::mojom::blink::NetworkConditionsPtr& input) {
    return input->download_throughput;
  }

  static decltype(::network::mojom::blink::NetworkConditions::upload_throughput) upload_throughput(
      const ::network::mojom::blink::NetworkConditionsPtr& input) {
    return input->upload_throughput;
  }

  static bool Read(::network::mojom::blink::NetworkConditions::DataView input, ::network::mojom::blink::NetworkConditionsPtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::ClearDataFilter::DataView,
                                         ::network::mojom::blink::ClearDataFilterPtr> {
  static bool IsNull(const ::network::mojom::blink::ClearDataFilterPtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::ClearDataFilterPtr* output) { output->reset(); }

  static decltype(::network::mojom::blink::ClearDataFilter::type) type(
      const ::network::mojom::blink::ClearDataFilterPtr& input) {
    return input->type;
  }

  static const decltype(::network::mojom::blink::ClearDataFilter::domains)& domains(
      const ::network::mojom::blink::ClearDataFilterPtr& input) {
    return input->domains;
  }

  static const decltype(::network::mojom::blink::ClearDataFilter::origins)& origins(
      const ::network::mojom::blink::ClearDataFilterPtr& input) {
    return input->origins;
  }

  static bool Read(::network::mojom::blink::ClearDataFilter::DataView input, ::network::mojom::blink::ClearDataFilterPtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::NetworkUsage::DataView,
                                         ::network::mojom::blink::NetworkUsagePtr> {
  static bool IsNull(const ::network::mojom::blink::NetworkUsagePtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::NetworkUsagePtr* output) { output->reset(); }

  static decltype(::network::mojom::blink::NetworkUsage::process_id) process_id(
      const ::network::mojom::blink::NetworkUsagePtr& input) {
    return input->process_id;
  }

  static decltype(::network::mojom::blink::NetworkUsage::routing_id) routing_id(
      const ::network::mojom::blink::NetworkUsagePtr& input) {
    return input->routing_id;
  }

  static decltype(::network::mojom::blink::NetworkUsage::total_bytes_received) total_bytes_received(
      const ::network::mojom::blink::NetworkUsagePtr& input) {
    return input->total_bytes_received;
  }

  static decltype(::network::mojom::blink::NetworkUsage::total_bytes_sent) total_bytes_sent(
      const ::network::mojom::blink::NetworkUsagePtr& input) {
    return input->total_bytes_sent;
  }

  static bool Read(::network::mojom::blink::NetworkUsage::DataView input, ::network::mojom::blink::NetworkUsagePtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::SignedExchangeReport::DataView,
                                         ::network::mojom::blink::SignedExchangeReportPtr> {
  static bool IsNull(const ::network::mojom::blink::SignedExchangeReportPtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::SignedExchangeReportPtr* output) { output->reset(); }

  static decltype(::network::mojom::blink::SignedExchangeReport::success) success(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->success;
  }

  static const decltype(::network::mojom::blink::SignedExchangeReport::type)& type(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->type;
  }

  static const decltype(::network::mojom::blink::SignedExchangeReport::outer_url)& outer_url(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->outer_url;
  }

  static const decltype(::network::mojom::blink::SignedExchangeReport::inner_url)& inner_url(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->inner_url;
  }

  static const decltype(::network::mojom::blink::SignedExchangeReport::cert_url)& cert_url(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->cert_url;
  }

  static const decltype(::network::mojom::blink::SignedExchangeReport::referrer)& referrer(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->referrer;
  }

  static const decltype(::network::mojom::blink::SignedExchangeReport::server_ip_address)& server_ip_address(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->server_ip_address;
  }

  static const decltype(::network::mojom::blink::SignedExchangeReport::protocol)& protocol(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->protocol;
  }

  static const decltype(::network::mojom::blink::SignedExchangeReport::method)& method(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->method;
  }

  static decltype(::network::mojom::blink::SignedExchangeReport::status_code) status_code(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->status_code;
  }

  static const decltype(::network::mojom::blink::SignedExchangeReport::elapsed_time)& elapsed_time(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->elapsed_time;
  }

  static bool Read(::network::mojom::blink::SignedExchangeReport::DataView input, ::network::mojom::blink::SignedExchangeReportPtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::URLLoaderFactoryOverride::DataView,
                                         ::network::mojom::blink::URLLoaderFactoryOverridePtr> {
  static bool IsNull(const ::network::mojom::blink::URLLoaderFactoryOverridePtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::URLLoaderFactoryOverridePtr* output) { output->reset(); }

  static  decltype(::network::mojom::blink::URLLoaderFactoryOverride::overriding_factory)& overriding_factory(
       ::network::mojom::blink::URLLoaderFactoryOverridePtr& input) {
    return input->overriding_factory;
  }

  static  decltype(::network::mojom::blink::URLLoaderFactoryOverride::overridden_factory_receiver)& overridden_factory_receiver(
       ::network::mojom::blink::URLLoaderFactoryOverridePtr& input) {
    return input->overridden_factory_receiver;
  }

  static bool Read(::network::mojom::blink::URLLoaderFactoryOverride::DataView input, ::network::mojom::blink::URLLoaderFactoryOverridePtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::URLLoaderFactoryParams::DataView,
                                         ::network::mojom::blink::URLLoaderFactoryParamsPtr> {
  static bool IsNull(const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::URLLoaderFactoryParamsPtr* output) { output->reset(); }

  static decltype(::network::mojom::blink::URLLoaderFactoryParams::process_id) process_id(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->process_id;
  }

  static const decltype(::network::mojom::blink::URLLoaderFactoryParams::request_initiator_site_lock)& request_initiator_site_lock(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->request_initiator_site_lock;
  }

  static decltype(::network::mojom::blink::URLLoaderFactoryParams::is_corb_enabled) is_corb_enabled(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->is_corb_enabled;
  }

  static decltype(::network::mojom::blink::URLLoaderFactoryParams::ignore_isolated_world_origin) ignore_isolated_world_origin(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->ignore_isolated_world_origin;
  }

  static decltype(::network::mojom::blink::URLLoaderFactoryParams::unsafe_non_webby_initiator) unsafe_non_webby_initiator(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->unsafe_non_webby_initiator;
  }

  static decltype(::network::mojom::blink::URLLoaderFactoryParams::disable_web_security) disable_web_security(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->disable_web_security;
  }

  static decltype(::network::mojom::blink::URLLoaderFactoryParams::cross_origin_embedder_policy) cross_origin_embedder_policy(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->cross_origin_embedder_policy;
  }

  static  decltype(::network::mojom::blink::URLLoaderFactoryParams::header_client)& header_client(
       ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->header_client;
  }

  static const decltype(::network::mojom::blink::URLLoaderFactoryParams::factory_bound_access_patterns)& factory_bound_access_patterns(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->factory_bound_access_patterns;
  }

  static const decltype(::network::mojom::blink::URLLoaderFactoryParams::network_isolation_key)& network_isolation_key(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->network_isolation_key;
  }

  static decltype(::network::mojom::blink::URLLoaderFactoryParams::disable_secure_dns) disable_secure_dns(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->disable_secure_dns;
  }

  static decltype(::network::mojom::blink::URLLoaderFactoryParams::is_trusted) is_trusted(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->is_trusted;
  }

  static const decltype(::network::mojom::blink::URLLoaderFactoryParams::top_frame_id)& top_frame_id(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->top_frame_id;
  }

  static  decltype(::network::mojom::blink::URLLoaderFactoryParams::factory_override)& factory_override(
       ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->factory_override;
  }

  static bool Read(::network::mojom::blink::URLLoaderFactoryParams::DataView input, ::network::mojom::blink::URLLoaderFactoryParamsPtr* output);
};

}  // namespace mojo

#endif  // SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_CONTEXT_MOJOM_BLINK_H_