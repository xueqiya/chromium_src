// services/network/public/mojom/quic_transport.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_NETWORK_PUBLIC_MOJOM_QUIC_TRANSPORT_MOJOM_TEST_UTILS_H_
#define SERVICES_NETWORK_PUBLIC_MOJOM_QUIC_TRANSPORT_MOJOM_TEST_UTILS_H_

#include "services/network/public/mojom/quic_transport.mojom.h"


namespace network {
namespace mojom {


class  QuicTransportInterceptorForTesting : public QuicTransport {
  virtual QuicTransport* GetForwardingInterface() = 0;
  void SendDatagram(::base::span<const ::uint8_t> data, SendDatagramCallback callback) override;
  void CreateStream(mojo::ScopedDataPipeConsumerHandle readable, mojo::ScopedDataPipeProducerHandle writable, CreateStreamCallback callback) override;
  void AcceptBidirectionalStream(AcceptBidirectionalStreamCallback callback) override;
  void AcceptUnidirectionalStream(AcceptUnidirectionalStreamCallback callback) override;
  void SendFin(uint32_t stream_id) override;
};
class  QuicTransportAsyncWaiter {
 public:
  explicit QuicTransportAsyncWaiter(QuicTransport* proxy);
  ~QuicTransportAsyncWaiter();
  void SendDatagram(
      ::base::span<const ::uint8_t> data, bool* out_result);
  void CreateStream(
      mojo::ScopedDataPipeConsumerHandle readable, mojo::ScopedDataPipeProducerHandle writable, bool* out_succeeded, uint32_t* out_stream_id);
  void AcceptBidirectionalStream(
      uint32_t* out_stream_id, mojo::ScopedDataPipeConsumerHandle* out_readable, mojo::ScopedDataPipeProducerHandle* out_writable);
  void AcceptUnidirectionalStream(
      uint32_t* out_stream_id, mojo::ScopedDataPipeConsumerHandle* out_readable);

 private:
  QuicTransport* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(QuicTransportAsyncWaiter);
};


class  QuicTransportClientInterceptorForTesting : public QuicTransportClient {
  virtual QuicTransportClient* GetForwardingInterface() = 0;
  void OnDatagramReceived(::base::span<const ::uint8_t> data) override;
  void OnIncomingStreamClosed(uint32_t stream_id, bool fin_received) override;
};
class  QuicTransportClientAsyncWaiter {
 public:
  explicit QuicTransportClientAsyncWaiter(QuicTransportClient* proxy);
  ~QuicTransportClientAsyncWaiter();

 private:
  QuicTransportClient* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(QuicTransportClientAsyncWaiter);
};


class  QuicTransportHandshakeClientInterceptorForTesting : public QuicTransportHandshakeClient {
  virtual QuicTransportHandshakeClient* GetForwardingInterface() = 0;
  void OnConnectionEstablished(mojo::PendingRemote<QuicTransport> transport, mojo::PendingReceiver<QuicTransportClient> client) override;
  void OnHandshakeFailed() override;
};
class  QuicTransportHandshakeClientAsyncWaiter {
 public:
  explicit QuicTransportHandshakeClientAsyncWaiter(QuicTransportHandshakeClient* proxy);
  ~QuicTransportHandshakeClientAsyncWaiter();

 private:
  QuicTransportHandshakeClient* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(QuicTransportHandshakeClientAsyncWaiter);
};




}  // namespace mojom
}  // namespace network

#endif  // SERVICES_NETWORK_PUBLIC_MOJOM_QUIC_TRANSPORT_MOJOM_TEST_UTILS_H_