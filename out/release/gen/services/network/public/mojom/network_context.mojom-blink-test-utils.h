// services/network/public/mojom/network_context.mojom-blink-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_CONTEXT_MOJOM_BLINK_TEST_UTILS_H_
#define SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_CONTEXT_MOJOM_BLINK_TEST_UTILS_H_

#include "services/network/public/mojom/network_context.mojom-blink.h"
#include "third_party/blink/public/platform/web_common.h"


namespace network {
namespace mojom {
namespace blink {


class BLINK_PLATFORM_EXPORT CustomProxyConfigClientInterceptorForTesting : public CustomProxyConfigClient {
  virtual CustomProxyConfigClient* GetForwardingInterface() = 0;
  void OnCustomProxyConfigUpdated(CustomProxyConfigPtr proxy_config) override;
  void MarkProxiesAsBad(::base::TimeDelta bypass_duration, ::network::mojom::blink::ProxyListPtr bad_proxies, MarkProxiesAsBadCallback callback) override;
  void ClearBadProxiesCache() override;
};
class BLINK_PLATFORM_EXPORT CustomProxyConfigClientAsyncWaiter {
 public:
  explicit CustomProxyConfigClientAsyncWaiter(CustomProxyConfigClient* proxy);
  ~CustomProxyConfigClientAsyncWaiter();
  void MarkProxiesAsBad(
      ::base::TimeDelta bypass_duration, ::network::mojom::blink::ProxyListPtr bad_proxies);

 private:
  CustomProxyConfigClient* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(CustomProxyConfigClientAsyncWaiter);
};


class BLINK_PLATFORM_EXPORT TrustedHeaderClientInterceptorForTesting : public TrustedHeaderClient {
  virtual TrustedHeaderClient* GetForwardingInterface() = 0;
  void OnBeforeSendHeaders(const ::net::HttpRequestHeaders& headers, OnBeforeSendHeadersCallback callback) override;
  void OnHeadersReceived(const WTF::String& headers, const ::net::IPEndPoint& remote_endpoint, OnHeadersReceivedCallback callback) override;
};
class BLINK_PLATFORM_EXPORT TrustedHeaderClientAsyncWaiter {
 public:
  explicit TrustedHeaderClientAsyncWaiter(TrustedHeaderClient* proxy);
  ~TrustedHeaderClientAsyncWaiter();
  void OnBeforeSendHeaders(
      const ::net::HttpRequestHeaders& headers, int32_t* out_result, base::Optional<::net::HttpRequestHeaders>* out_headers);
  void OnHeadersReceived(
      const WTF::String& headers, const ::net::IPEndPoint& remote_endpoint, int32_t* out_result, WTF::String* out_headers, base::Optional<::blink::KURL>* out_preserve_fragment_on_redirect_url);

 private:
  TrustedHeaderClient* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(TrustedHeaderClientAsyncWaiter);
};


class BLINK_PLATFORM_EXPORT TrustedURLLoaderHeaderClientInterceptorForTesting : public TrustedURLLoaderHeaderClient {
  virtual TrustedURLLoaderHeaderClient* GetForwardingInterface() = 0;
  void OnLoaderCreated(int32_t request_id, mojo::PendingReceiver<TrustedHeaderClient> header_client) override;
  void OnLoaderForCorsPreflightCreated(const ::network::ResourceRequest& request, mojo::PendingReceiver<TrustedHeaderClient> header_client) override;
};
class BLINK_PLATFORM_EXPORT TrustedURLLoaderHeaderClientAsyncWaiter {
 public:
  explicit TrustedURLLoaderHeaderClientAsyncWaiter(TrustedURLLoaderHeaderClient* proxy);
  ~TrustedURLLoaderHeaderClientAsyncWaiter();

 private:
  TrustedURLLoaderHeaderClient* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(TrustedURLLoaderHeaderClientAsyncWaiter);
};


class BLINK_PLATFORM_EXPORT AuthChallengeResponderInterceptorForTesting : public AuthChallengeResponder {
  virtual AuthChallengeResponder* GetForwardingInterface() = 0;
  void OnAuthCredentials(::network::mojom::blink::AuthCredentialsPtr credentials) override;
};
class BLINK_PLATFORM_EXPORT AuthChallengeResponderAsyncWaiter {
 public:
  explicit AuthChallengeResponderAsyncWaiter(AuthChallengeResponder* proxy);
  ~AuthChallengeResponderAsyncWaiter();

 private:
  AuthChallengeResponder* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(AuthChallengeResponderAsyncWaiter);
};


class BLINK_PLATFORM_EXPORT ClientCertificateResponderInterceptorForTesting : public ClientCertificateResponder {
  virtual ClientCertificateResponder* GetForwardingInterface() = 0;
  void ContinueWithCertificate(::network::mojom::blink::X509CertificatePtr x509_certificate, const WTF::String& provider_name, const WTF::Vector<uint16_t>& algorithm_preferences, mojo::PendingRemote<SSLPrivateKey> ssl_private_key) override;
  void ContinueWithoutCertificate() override;
  void CancelRequest() override;
};
class BLINK_PLATFORM_EXPORT ClientCertificateResponderAsyncWaiter {
 public:
  explicit ClientCertificateResponderAsyncWaiter(ClientCertificateResponder* proxy);
  ~ClientCertificateResponderAsyncWaiter();

 private:
  ClientCertificateResponder* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(ClientCertificateResponderAsyncWaiter);
};


class BLINK_PLATFORM_EXPORT SSLPrivateKeyInterceptorForTesting : public SSLPrivateKey {
  virtual SSLPrivateKey* GetForwardingInterface() = 0;
  void Sign(uint16_t algorithm, const WTF::Vector<uint8_t>& input, SignCallback callback) override;
};
class BLINK_PLATFORM_EXPORT SSLPrivateKeyAsyncWaiter {
 public:
  explicit SSLPrivateKeyAsyncWaiter(SSLPrivateKey* proxy);
  ~SSLPrivateKeyAsyncWaiter();
  void Sign(
      uint16_t algorithm, const WTF::Vector<uint8_t>& input, int32_t* out_net_error, WTF::Vector<uint8_t>* out_signature);

 private:
  SSLPrivateKey* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(SSLPrivateKeyAsyncWaiter);
};


class BLINK_PLATFORM_EXPORT NetworkContextClientInterceptorForTesting : public NetworkContextClient {
  virtual NetworkContextClient* GetForwardingInterface() = 0;
  void OnAuthRequired(const base::Optional<::base::UnguessableToken>& window_id, int32_t process_id, int32_t routing_id, uint32_t request_id, const ::blink::KURL& url, bool first_auth_attempt, ::network::mojom::blink::AuthChallengeInfoPtr auth_info, ::network::mojom::blink::URLResponseHeadPtr head, mojo::PendingRemote<AuthChallengeResponder> auth_challenge_responder) override;
  void OnCertificateRequested(const base::Optional<::base::UnguessableToken>& window_id, int32_t process_id, int32_t routing_id, uint32_t request_id, ::network::mojom::blink::SSLCertRequestInfoPtr cert_info, mojo::PendingRemote<ClientCertificateResponder> cert_responder) override;
  void OnSSLCertificateError(int32_t process_id, int32_t routing_id, const ::blink::KURL& url, int32_t net_error, ::network::mojom::blink::SSLInfoPtr ssl_info, bool fatal, OnSSLCertificateErrorCallback callback) override;
  void OnFileUploadRequested(int32_t process_id, bool async, const WTF::Vector<::base::FilePath>& file_paths, OnFileUploadRequestedCallback callback) override;
  void OnCanSendReportingReports(const WTF::Vector<::scoped_refptr<const ::blink::SecurityOrigin>>& origins, OnCanSendReportingReportsCallback callback) override;
  void OnCanSendDomainReliabilityUpload(const ::blink::KURL& origin, OnCanSendDomainReliabilityUploadCallback callback) override;
  void OnClearSiteData(int32_t process_id, int32_t routing_id, const ::blink::KURL& url, const WTF::String& header_value, int32_t load_flags, OnClearSiteDataCallback callback) override;
  void OnCookiesChanged(bool is_service_worker, int32_t process_id, int32_t routing_id, const ::blink::KURL& url, const ::net::SiteForCookies& site_for_cookies, WTF::Vector<::network::mojom::blink::CookieWithStatusPtr> cookie_list) override;
  void OnCookiesRead(bool is_service_worker, int32_t process_id, int32_t routing_id, const ::blink::KURL& url, const ::net::SiteForCookies& site_for_cookies, WTF::Vector<::network::mojom::blink::CookieWithStatusPtr> cookie_list) override;
  void OnGenerateHttpNegotiateAuthToken(const WTF::String& server_auth_token, bool can_delegate, const WTF::String& auth_negotiate_android_account_type, const WTF::String& spn, OnGenerateHttpNegotiateAuthTokenCallback callback) override;
};
class BLINK_PLATFORM_EXPORT NetworkContextClientAsyncWaiter {
 public:
  explicit NetworkContextClientAsyncWaiter(NetworkContextClient* proxy);
  ~NetworkContextClientAsyncWaiter();
  void OnSSLCertificateError(
      int32_t process_id, int32_t routing_id, const ::blink::KURL& url, int32_t net_error, ::network::mojom::blink::SSLInfoPtr ssl_info, bool fatal, int32_t* out_net_error);
  void OnFileUploadRequested(
      int32_t process_id, bool async, const WTF::Vector<::base::FilePath>& file_paths, int32_t* out_net_error, WTF::Vector<::base::File>* out_files);
  void OnCanSendReportingReports(
      const WTF::Vector<::scoped_refptr<const ::blink::SecurityOrigin>>& origins, WTF::Vector<::scoped_refptr<const ::blink::SecurityOrigin>>* out_origins);
  void OnCanSendDomainReliabilityUpload(
      const ::blink::KURL& origin, bool* out_allowed);
  void OnClearSiteData(
      int32_t process_id, int32_t routing_id, const ::blink::KURL& url, const WTF::String& header_value, int32_t load_flags);
  void OnGenerateHttpNegotiateAuthToken(
      const WTF::String& server_auth_token, bool can_delegate, const WTF::String& auth_negotiate_android_account_type, const WTF::String& spn, int32_t* out_result, WTF::String* out_auth_token);

 private:
  NetworkContextClient* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(NetworkContextClientAsyncWaiter);
};


class BLINK_PLATFORM_EXPORT NetworkContextInterceptorForTesting : public NetworkContext {
  virtual NetworkContext* GetForwardingInterface() = 0;
  void SetClient(mojo::PendingRemote<NetworkContextClient> client) override;
  void CreateURLLoaderFactory(mojo::PendingReceiver<::network::mojom::blink::URLLoaderFactory> url_loader_factory, URLLoaderFactoryParamsPtr params) override;
  void ResetURLLoaderFactories() override;
  void GetCookieManager(mojo::PendingReceiver<::network::mojom::blink::CookieManager> cookie_manager) override;
  void GetRestrictedCookieManager(mojo::PendingReceiver<::network::mojom::blink::RestrictedCookieManager> restricted_cookie_manager, ::network::mojom::blink::RestrictedCookieManagerRole role, const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, const ::net::SiteForCookies& site_for_cookies, const ::scoped_refptr<const ::blink::SecurityOrigin>& top_frame_origin, bool is_service_worker, int32_t process_id, int32_t routing_id) override;
  void ClearNetworkingHistorySince(::base::Time start_time, ClearNetworkingHistorySinceCallback callback) override;
  void ClearHttpCache(::base::Time start_time, ::base::Time end_time, ClearDataFilterPtr filter, ClearHttpCacheCallback callback) override;
  void ComputeHttpCacheSize(::base::Time start_time, ::base::Time end_time, ComputeHttpCacheSizeCallback callback) override;
  void NotifyExternalCacheHit(const ::blink::KURL& url, const WTF::String& http_method, ::network::mojom::blink::NetworkIsolationKeyPtr key) override;
  void ClearHostCache(ClearDataFilterPtr filter, ClearHostCacheCallback callback) override;
  void ClearHttpAuthCache(::base::Time start_time, ClearHttpAuthCacheCallback callback) override;
  void ClearReportingCacheReports(ClearDataFilterPtr filter, ClearReportingCacheReportsCallback callback) override;
  void ClearReportingCacheClients(ClearDataFilterPtr filter, ClearReportingCacheClientsCallback callback) override;
  void ClearNetworkErrorLogging(ClearDataFilterPtr filter, ClearNetworkErrorLoggingCallback callback) override;
  void ClearDomainReliability(ClearDataFilterPtr filter, NetworkContext::DomainReliabilityClearMode mode, ClearDomainReliabilityCallback callback) override;
  void GetDomainReliabilityJSON(GetDomainReliabilityJSONCallback callback) override;
  void QueueReport(const WTF::String& type, const WTF::String& group, const ::blink::KURL& url, const WTF::String& user_agent, ::base::Value body) override;
  void QueueSignedExchangeReport(SignedExchangeReportPtr report) override;
  void CloseAllConnections(CloseAllConnectionsCallback callback) override;
  void CloseIdleConnections(CloseIdleConnectionsCallback callback) override;
  void SetNetworkConditions(const ::base::UnguessableToken& throttling_profile_id, NetworkConditionsPtr conditions) override;
  void SetAcceptLanguage(const WTF::String& new_accept_language) override;
  void SetEnableReferrers(bool enable_referrers) override;
  void SetCTPolicy(const WTF::Vector<WTF::String>& required_hosts, const WTF::Vector<WTF::String>& excluded_hosts, const WTF::Vector<WTF::String>& excluded_spkis, const WTF::Vector<WTF::String>& excluded_legacy_spkis) override;
  void AddExpectCT(const WTF::String& host, ::base::Time expiry, bool enforce, const ::blink::KURL& report_uri, AddExpectCTCallback callback) override;
  void SetExpectCTTestReport(const ::blink::KURL& report_uri, SetExpectCTTestReportCallback callback) override;
  void GetExpectCTState(const WTF::String& domain, GetExpectCTStateCallback callback) override;
  void CreateUDPSocket(mojo::PendingReceiver<::network::mojom::blink::UDPSocket> receiver, mojo::PendingRemote<::network::mojom::blink::UDPSocketListener> listener) override;
  void CreateTCPServerSocket(const ::net::IPEndPoint& local_addr, uint32_t backlog, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, mojo::PendingReceiver<::network::mojom::blink::TCPServerSocket> socket, CreateTCPServerSocketCallback callback) override;
  void CreateTCPConnectedSocket(const base::Optional<::net::IPEndPoint>& local_addr, ::network::mojom::blink::AddressListPtr remote_addr_list, ::network::mojom::blink::TCPConnectedSocketOptionsPtr tcp_connected_socket_options, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, mojo::PendingReceiver<::network::mojom::blink::TCPConnectedSocket> socket, mojo::PendingRemote<::network::mojom::blink::SocketObserver> observer, CreateTCPConnectedSocketCallback callback) override;
  void CreateTCPBoundSocket(const ::net::IPEndPoint& local_addr, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, mojo::PendingReceiver<::network::mojom::blink::TCPBoundSocket> socket, CreateTCPBoundSocketCallback callback) override;
  void CreateProxyResolvingSocketFactory(mojo::PendingReceiver<::network::mojom::blink::ProxyResolvingSocketFactory> factory) override;
  void LookUpProxyForURL(const ::blink::KURL& url, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, mojo::PendingRemote<::network::mojom::blink::ProxyLookupClient> proxy_lookup_client) override;
  void ForceReloadProxyConfig(ForceReloadProxyConfigCallback callback) override;
  void ClearBadProxiesCache(ClearBadProxiesCacheCallback callback) override;
  void CreateWebSocket(const ::blink::KURL& url, const WTF::Vector<WTF::String>& requested_protocols, const ::net::SiteForCookies& site_for_cookies, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, WTF::Vector<::network::mojom::blink::HttpHeaderPtr> additional_headers, int32_t process_id, int32_t render_frame_id, const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, uint32_t options, mojo::PendingRemote<::network::mojom::blink::WebSocketHandshakeClient> handshake_client, mojo::PendingRemote<::network::mojom::blink::AuthenticationHandler> auth_handler, mojo::PendingRemote<TrustedHeaderClient> header_client) override;
  void CreateQuicTransport(const ::blink::KURL& url, const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, mojo::PendingRemote<::network::mojom::blink::QuicTransportHandshakeClient> handshake_client) override;
  void CreateNetLogExporter(mojo::PendingReceiver<::network::mojom::blink::NetLogExporter> receiver) override;
  void PreconnectSockets(uint32_t num_streams, const ::blink::KURL& url, bool allow_credentials, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key) override;
  void CreateP2PSocketManager(mojo::PendingRemote<::network::mojom::blink::P2PTrustedSocketManagerClient> client, mojo::PendingReceiver<::network::mojom::blink::P2PTrustedSocketManager> trusted_socket_manager, mojo::PendingReceiver<::network::mojom::blink::P2PSocketManager> socket_manager) override;
  void CreateMdnsResponder(mojo::PendingReceiver<::network::mojom::blink::MdnsResponder> responder_receiver) override;
  void ResolveHost(::network::mojom::blink::HostPortPairPtr host, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, ::network::mojom::blink::ResolveHostParametersPtr optional_parameters, mojo::PendingRemote<::network::mojom::blink::ResolveHostClient> response_client) override;
  void CreateHostResolver(::network::mojom::blink::DnsConfigOverridesPtr config_overrides, mojo::PendingReceiver<::network::mojom::blink::HostResolver> host_resolver) override;
  void VerifyCertForSignedExchange(::network::mojom::blink::X509CertificatePtr certificate, const ::blink::KURL& url, const WTF::String& ocsp_response, const WTF::String& sct_list, VerifyCertForSignedExchangeCallback callback) override;
  void AddHSTS(const WTF::String& host, ::base::Time expiry, bool include_subdomains, AddHSTSCallback callback) override;
  void IsHSTSActiveForHost(const WTF::String& host, IsHSTSActiveForHostCallback callback) override;
  void GetHSTSState(const WTF::String& domain, GetHSTSStateCallback callback) override;
  void SetCorsOriginAccessListsForOrigin(const ::scoped_refptr<const ::blink::SecurityOrigin>& source_origin, WTF::Vector<::network::mojom::blink::CorsOriginPatternPtr> allow_patterns, WTF::Vector<::network::mojom::blink::CorsOriginPatternPtr> block_patterns, SetCorsOriginAccessListsForOriginCallback callback) override;
  void SetCorsExtraSafelistedRequestHeaderNames(const WTF::Vector<WTF::String>& cors_extra_safelisted_request_header_names) override;
  void DeleteDynamicDataForHost(const WTF::String& host, DeleteDynamicDataForHostCallback callback) override;
  void SetSplitAuthCacheByNetworkIsolationKey(bool split_auth_cache_by_network_isolation_key) override;
  void SaveHttpAuthCacheProxyEntries(SaveHttpAuthCacheProxyEntriesCallback callback) override;
  void LoadHttpAuthCacheProxyEntries(const ::base::UnguessableToken& cache_key, LoadHttpAuthCacheProxyEntriesCallback callback) override;
  void AddAuthCacheEntry(::network::mojom::blink::AuthChallengeInfoPtr challenge, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, ::network::mojom::blink::AuthCredentialsPtr credentials, AddAuthCacheEntryCallback callback) override;
  void LookupServerBasicAuthCredentials(const ::blink::KURL& url, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, LookupServerBasicAuthCredentialsCallback callback) override;
  void EnableStaticKeyPinningForTesting(EnableStaticKeyPinningForTestingCallback callback) override;
  void SetFailingHttpTransactionForTesting(int32_t rv, SetFailingHttpTransactionForTestingCallback callback) override;
  void VerifyCertificateForTesting(::network::mojom::blink::X509CertificatePtr certificate, const WTF::String& hostname, const WTF::String& ocsp_response, const WTF::String& sct_list, VerifyCertificateForTestingCallback callback) override;
  void AddDomainReliabilityContextForTesting(const ::blink::KURL& origin, const ::blink::KURL& upload_url, AddDomainReliabilityContextForTestingCallback callback) override;
  void ForceDomainReliabilityUploadsForTesting(ForceDomainReliabilityUploadsForTestingCallback callback) override;
  void GetOriginPolicyManager(mojo::PendingReceiver<::network::mojom::blink::OriginPolicyManager> origin_policy_manager) override;
};
class BLINK_PLATFORM_EXPORT NetworkContextAsyncWaiter {
 public:
  explicit NetworkContextAsyncWaiter(NetworkContext* proxy);
  ~NetworkContextAsyncWaiter();
  void ClearNetworkingHistorySince(
      ::base::Time start_time);
  void ClearHttpCache(
      ::base::Time start_time, ::base::Time end_time, ClearDataFilterPtr filter);
  void ComputeHttpCacheSize(
      ::base::Time start_time, ::base::Time end_time, bool* out_is_upper_bound, int64_t* out_size_or_error);
  void ClearHostCache(
      ClearDataFilterPtr filter);
  void ClearHttpAuthCache(
      ::base::Time start_time);
  void ClearReportingCacheReports(
      ClearDataFilterPtr filter);
  void ClearReportingCacheClients(
      ClearDataFilterPtr filter);
  void ClearNetworkErrorLogging(
      ClearDataFilterPtr filter);
  void ClearDomainReliability(
      ClearDataFilterPtr filter, NetworkContext::DomainReliabilityClearMode mode);
  void GetDomainReliabilityJSON(
      ::base::Value* out_data);
  void CloseAllConnections(
      );
  void CloseIdleConnections(
      );
  void AddExpectCT(
      const WTF::String& host, ::base::Time expiry, bool enforce, const ::blink::KURL& report_uri, bool* out_success);
  void SetExpectCTTestReport(
      const ::blink::KURL& report_uri, bool* out_success);
  void GetExpectCTState(
      const WTF::String& domain, ::base::Value* out_state);
  void CreateTCPServerSocket(
      const ::net::IPEndPoint& local_addr, uint32_t backlog, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, mojo::PendingReceiver<::network::mojom::blink::TCPServerSocket> socket, int32_t* out_result, base::Optional<::net::IPEndPoint>* out_local_addr_out);
  void CreateTCPConnectedSocket(
      const base::Optional<::net::IPEndPoint>& local_addr, ::network::mojom::blink::AddressListPtr remote_addr_list, ::network::mojom::blink::TCPConnectedSocketOptionsPtr tcp_connected_socket_options, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, mojo::PendingReceiver<::network::mojom::blink::TCPConnectedSocket> socket, mojo::PendingRemote<::network::mojom::blink::SocketObserver> observer, int32_t* out_result, base::Optional<::net::IPEndPoint>* out_local_addr, base::Optional<::net::IPEndPoint>* out_peer_addr, mojo::ScopedDataPipeConsumerHandle* out_receive_stream, mojo::ScopedDataPipeProducerHandle* out_send_stream);
  void CreateTCPBoundSocket(
      const ::net::IPEndPoint& local_addr, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, mojo::PendingReceiver<::network::mojom::blink::TCPBoundSocket> socket, int32_t* out_result, base::Optional<::net::IPEndPoint>* out_local_addr);
  void ForceReloadProxyConfig(
      );
  void ClearBadProxiesCache(
      );
  void VerifyCertForSignedExchange(
      ::network::mojom::blink::X509CertificatePtr certificate, const ::blink::KURL& url, const WTF::String& ocsp_response, const WTF::String& sct_list, int32_t* out_error_code, ::network::mojom::blink::CertVerifyResultPtr* out_cv_result, ::network::mojom::blink::CTVerifyResultPtr* out_ct_result);
  void AddHSTS(
      const WTF::String& host, ::base::Time expiry, bool include_subdomains);
  void IsHSTSActiveForHost(
      const WTF::String& host, bool* out_result);
  void GetHSTSState(
      const WTF::String& domain, ::base::Value* out_state);
  void SetCorsOriginAccessListsForOrigin(
      const ::scoped_refptr<const ::blink::SecurityOrigin>& source_origin, WTF::Vector<::network::mojom::blink::CorsOriginPatternPtr> allow_patterns, WTF::Vector<::network::mojom::blink::CorsOriginPatternPtr> block_patterns);
  void DeleteDynamicDataForHost(
      const WTF::String& host, bool* out_result);
  void SaveHttpAuthCacheProxyEntries(
      ::base::UnguessableToken* out_cache_key);
  void LoadHttpAuthCacheProxyEntries(
      const ::base::UnguessableToken& cache_key);
  void AddAuthCacheEntry(
      ::network::mojom::blink::AuthChallengeInfoPtr challenge, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, ::network::mojom::blink::AuthCredentialsPtr credentials);
  void LookupServerBasicAuthCredentials(
      const ::blink::KURL& url, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, ::network::mojom::blink::AuthCredentialsPtr* out_credentials);
  void EnableStaticKeyPinningForTesting(
      );
  void SetFailingHttpTransactionForTesting(
      int32_t rv);
  void VerifyCertificateForTesting(
      ::network::mojom::blink::X509CertificatePtr certificate, const WTF::String& hostname, const WTF::String& ocsp_response, const WTF::String& sct_list, int32_t* out_error_code);
  void AddDomainReliabilityContextForTesting(
      const ::blink::KURL& origin, const ::blink::KURL& upload_url);
  void ForceDomainReliabilityUploadsForTesting(
      );

 private:
  NetworkContext* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(NetworkContextAsyncWaiter);
};




}  // namespace blink
}  // namespace mojom
}  // namespace network

#endif  // SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_CONTEXT_MOJOM_BLINK_TEST_UTILS_H_