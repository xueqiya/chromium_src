// services/proxy_resolver/public/mojom/proxy_resolver.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif


#include "services/proxy_resolver/public/mojom/proxy_resolver.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"
#include "services/network/public/mojom/ip_address.mojom.h"
#include "services/network/public/mojom/network_isolation_key.mojom.h"
#include "url/mojom/url.mojom.h"


#ifndef SERVICES_PROXY_RESOLVER_PUBLIC_MOJOM_PROXY_RESOLVER_MOJOM_JUMBO_H_
#define SERVICES_PROXY_RESOLVER_PUBLIC_MOJOM_PROXY_RESOLVER_MOJOM_JUMBO_H_
#include "mojo/public/cpp/base/unguessable_token_mojom_traits.h"
#include "services/network/public/cpp/ip_address_mojom_traits.h"
#include "services/network/public/cpp/network_isolation_key_mojom_traits.h"
#include "services/proxy_resolver/public/cpp/mojo_host_mojom_traits.h"
#include "services/proxy_resolver/public/cpp/proxy_resolver_mojom_traits.h"
#include "url/mojom/origin_mojom_traits.h"
#include "url/mojom/url_gurl_mojom_traits.h"
#endif


namespace proxy_resolver {
namespace mojom {


void HostResolverRequestClientInterceptorForTesting::ReportResult(int32_t error, const std::vector<::net::IPAddress>& result) {
  GetForwardingInterface()->ReportResult(std::move(error), std::move(result));
}
HostResolverRequestClientAsyncWaiter::HostResolverRequestClientAsyncWaiter(
    HostResolverRequestClient* proxy) : proxy_(proxy) {}

HostResolverRequestClientAsyncWaiter::~HostResolverRequestClientAsyncWaiter() = default;




void ProxyResolverInterceptorForTesting::GetProxyForUrl(const ::GURL& url, const ::net::NetworkIsolationKey& network_isolation_key, mojo::PendingRemote<ProxyResolverRequestClient> client) {
  GetForwardingInterface()->GetProxyForUrl(std::move(url), std::move(network_isolation_key), std::move(client));
}
ProxyResolverAsyncWaiter::ProxyResolverAsyncWaiter(
    ProxyResolver* proxy) : proxy_(proxy) {}

ProxyResolverAsyncWaiter::~ProxyResolverAsyncWaiter() = default;




void ProxyResolverRequestClientInterceptorForTesting::ReportResult(int32_t error, const ::net::ProxyInfo& proxy_info) {
  GetForwardingInterface()->ReportResult(std::move(error), std::move(proxy_info));
}
void ProxyResolverRequestClientInterceptorForTesting::Alert(const std::string& error) {
  GetForwardingInterface()->Alert(std::move(error));
}
void ProxyResolverRequestClientInterceptorForTesting::OnError(int32_t line_number, const std::string& error) {
  GetForwardingInterface()->OnError(std::move(line_number), std::move(error));
}
void ProxyResolverRequestClientInterceptorForTesting::ResolveDns(const std::string& host, ::net::ProxyResolveDnsOperation operation, const ::net::NetworkIsolationKey& network_isolation_key, mojo::PendingRemote<HostResolverRequestClient> client) {
  GetForwardingInterface()->ResolveDns(std::move(host), std::move(operation), std::move(network_isolation_key), std::move(client));
}
ProxyResolverRequestClientAsyncWaiter::ProxyResolverRequestClientAsyncWaiter(
    ProxyResolverRequestClient* proxy) : proxy_(proxy) {}

ProxyResolverRequestClientAsyncWaiter::~ProxyResolverRequestClientAsyncWaiter() = default;




void ProxyResolverFactoryInterceptorForTesting::CreateResolver(const std::string& pac_script, mojo::PendingReceiver<ProxyResolver> receiver, mojo::PendingRemote<ProxyResolverFactoryRequestClient> client) {
  GetForwardingInterface()->CreateResolver(std::move(pac_script), std::move(receiver), std::move(client));
}
ProxyResolverFactoryAsyncWaiter::ProxyResolverFactoryAsyncWaiter(
    ProxyResolverFactory* proxy) : proxy_(proxy) {}

ProxyResolverFactoryAsyncWaiter::~ProxyResolverFactoryAsyncWaiter() = default;




void ProxyResolverFactoryRequestClientInterceptorForTesting::ReportResult(int32_t error) {
  GetForwardingInterface()->ReportResult(std::move(error));
}
void ProxyResolverFactoryRequestClientInterceptorForTesting::Alert(const std::string& error) {
  GetForwardingInterface()->Alert(std::move(error));
}
void ProxyResolverFactoryRequestClientInterceptorForTesting::OnError(int32_t line_number, const std::string& error) {
  GetForwardingInterface()->OnError(std::move(line_number), std::move(error));
}
void ProxyResolverFactoryRequestClientInterceptorForTesting::ResolveDns(const std::string& host, ::net::ProxyResolveDnsOperation operation, const ::net::NetworkIsolationKey& network_isolation_key, mojo::PendingRemote<HostResolverRequestClient> client) {
  GetForwardingInterface()->ResolveDns(std::move(host), std::move(operation), std::move(network_isolation_key), std::move(client));
}
ProxyResolverFactoryRequestClientAsyncWaiter::ProxyResolverFactoryRequestClientAsyncWaiter(
    ProxyResolverFactoryRequestClient* proxy) : proxy_(proxy) {}

ProxyResolverFactoryRequestClientAsyncWaiter::~ProxyResolverFactoryRequestClientAsyncWaiter() = default;






}  // namespace mojom
}  // namespace proxy_resolver

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif