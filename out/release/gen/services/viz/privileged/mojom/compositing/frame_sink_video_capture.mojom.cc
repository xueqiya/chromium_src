// services/viz/privileged/mojom/compositing/frame_sink_video_capture.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif

#include "services/viz/privileged/mojom/compositing/frame_sink_video_capture.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/hash/md5_constexpr.h"
#include "base/logging.h"
#include "base/run_loop.h"
#include "base/task/common/task_annotator.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_context.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"

#include "services/viz/privileged/mojom/compositing/frame_sink_video_capture.mojom-params-data.h"
#include "services/viz/privileged/mojom/compositing/frame_sink_video_capture.mojom-shared-message-ids.h"

#include "services/viz/privileged/mojom/compositing/frame_sink_video_capture.mojom-import-headers.h"


#ifndef SERVICES_VIZ_PRIVILEGED_MOJOM_COMPOSITING_FRAME_SINK_VIDEO_CAPTURE_MOJOM_JUMBO_H_
#define SERVICES_VIZ_PRIVILEGED_MOJOM_COMPOSITING_FRAME_SINK_VIDEO_CAPTURE_MOJOM_JUMBO_H_
#include "media/base/ipc/media_param_traits_macros.h"
#include "media/capture/mojom/video_capture_types_mojom_traits.h"
#include "media/mojo/mojom/video_transformation_mojom_traits.h"
#include "mojo/public/cpp/base/big_buffer_mojom_traits.h"
#include "mojo/public/cpp/base/shared_memory_mojom_traits.h"
#include "mojo/public/cpp/base/time_mojom_traits.h"
#include "mojo/public/cpp/base/values_mojom_traits.h"
#include "services/viz/public/cpp/compositing/frame_sink_id_mojom_traits.h"
#include "skia/public/mojom/bitmap_skbitmap_mojom_traits.h"
#include "skia/public/mojom/image_info_mojom_traits.h"
#include "ui/gfx/geometry/mojom/geometry_mojom_traits.h"
#include "ui/gfx/mojom/color_space_mojom_traits.h"
#endif
namespace viz {
namespace mojom {
const char FrameSinkVideoConsumerFrameCallbacks::Name_[] = "viz.mojom.FrameSinkVideoConsumerFrameCallbacks";

FrameSinkVideoConsumerFrameCallbacksProxy::FrameSinkVideoConsumerFrameCallbacksProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void FrameSinkVideoConsumerFrameCallbacksProxy::Done(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "viz::mojom::FrameSinkVideoConsumerFrameCallbacks::Done");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameSinkVideoConsumerFrameCallbacks_Done_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::viz::mojom::internal::FrameSinkVideoConsumerFrameCallbacks_Done_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameSinkVideoConsumerFrameCallbacks::Name_);
  message.set_method_name("Done");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameSinkVideoConsumerFrameCallbacksProxy::ProvideFeedback(
    double in_utilization) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "viz::mojom::FrameSinkVideoConsumerFrameCallbacks::ProvideFeedback");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameSinkVideoConsumerFrameCallbacks_ProvideFeedback_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::viz::mojom::internal::FrameSinkVideoConsumerFrameCallbacks_ProvideFeedback_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->utilization = in_utilization;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameSinkVideoConsumerFrameCallbacks::Name_);
  message.set_method_name("ProvideFeedback");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool FrameSinkVideoConsumerFrameCallbacksStubDispatch::Accept(
    FrameSinkVideoConsumerFrameCallbacks* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kFrameSinkVideoConsumerFrameCallbacks_Done_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)viz::mojom::FrameSinkVideoConsumerFrameCallbacks::Done",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)viz::mojom::FrameSinkVideoConsumerFrameCallbacks::Done");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameSinkVideoConsumerFrameCallbacks_Done_Params_Data* params =
          reinterpret_cast<internal::FrameSinkVideoConsumerFrameCallbacks_Done_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      FrameSinkVideoConsumerFrameCallbacks_Done_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameSinkVideoConsumerFrameCallbacks::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Done();
      return true;
    }
    case internal::kFrameSinkVideoConsumerFrameCallbacks_ProvideFeedback_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)viz::mojom::FrameSinkVideoConsumerFrameCallbacks::ProvideFeedback",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)viz::mojom::FrameSinkVideoConsumerFrameCallbacks::ProvideFeedback");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameSinkVideoConsumerFrameCallbacks_ProvideFeedback_Params_Data* params =
          reinterpret_cast<internal::FrameSinkVideoConsumerFrameCallbacks_ProvideFeedback_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      double p_utilization{};
      FrameSinkVideoConsumerFrameCallbacks_ProvideFeedback_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_utilization = input_data_view.utilization();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameSinkVideoConsumerFrameCallbacks::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ProvideFeedback(
std::move(p_utilization));
      return true;
    }
  }
  return false;
}

// static
bool FrameSinkVideoConsumerFrameCallbacksStubDispatch::AcceptWithResponder(
    FrameSinkVideoConsumerFrameCallbacks* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kFrameSinkVideoConsumerFrameCallbacks_Done_Name: {
      break;
    }
    case internal::kFrameSinkVideoConsumerFrameCallbacks_ProvideFeedback_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kFrameSinkVideoConsumerFrameCallbacksValidationInfo[] = {
    {&internal::FrameSinkVideoConsumerFrameCallbacks_Done_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameSinkVideoConsumerFrameCallbacks_ProvideFeedback_Params_Data::Validate,
     nullptr /* no response */},
};

bool FrameSinkVideoConsumerFrameCallbacksRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::viz::mojom::FrameSinkVideoConsumerFrameCallbacks::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kFrameSinkVideoConsumerFrameCallbacksValidationInfo);
}

const char FrameSinkVideoConsumer::Name_[] = "viz.mojom.FrameSinkVideoConsumer";

FrameSinkVideoConsumerProxy::FrameSinkVideoConsumerProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void FrameSinkVideoConsumerProxy::OnFrameCaptured(
    ::base::ReadOnlySharedMemoryRegion in_data, ::media::mojom::VideoFrameInfoPtr in_info, const ::gfx::Rect& in_content_rect, mojo::PendingRemote<FrameSinkVideoConsumerFrameCallbacks> in_callbacks) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "viz::mojom::FrameSinkVideoConsumer::OnFrameCaptured");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameSinkVideoConsumer_OnFrameCaptured_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::viz::mojom::internal::FrameSinkVideoConsumer_OnFrameCaptured_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->data)::BaseType::BufferWriter
      data_writer;
  mojo::internal::Serialize<::mojo_base::mojom::ReadOnlySharedMemoryRegionDataView>(
      in_data, buffer, &data_writer, &serialization_context);
  params->data.Set(
      data_writer.is_null() ? nullptr : data_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null data in FrameSinkVideoConsumer.OnFrameCaptured request");
  typename decltype(params->info)::BaseType::BufferWriter
      info_writer;
  mojo::internal::Serialize<::media::mojom::VideoFrameInfoDataView>(
      in_info, buffer, &info_writer, &serialization_context);
  params->info.Set(
      info_writer.is_null() ? nullptr : info_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null info in FrameSinkVideoConsumer.OnFrameCaptured request");
  typename decltype(params->content_rect)::BaseType::BufferWriter
      content_rect_writer;
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_content_rect, buffer, &content_rect_writer, &serialization_context);
  params->content_rect.Set(
      content_rect_writer.is_null() ? nullptr : content_rect_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->content_rect.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null content_rect in FrameSinkVideoConsumer.OnFrameCaptured request");
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::viz::mojom::FrameSinkVideoConsumerFrameCallbacksInterfaceBase>>(
      in_callbacks, &params->callbacks, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->callbacks),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid callbacks in FrameSinkVideoConsumer.OnFrameCaptured request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameSinkVideoConsumer::Name_);
  message.set_method_name("OnFrameCaptured");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameSinkVideoConsumerProxy::OnStopped(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "viz::mojom::FrameSinkVideoConsumer::OnStopped");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameSinkVideoConsumer_OnStopped_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::viz::mojom::internal::FrameSinkVideoConsumer_OnStopped_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameSinkVideoConsumer::Name_);
  message.set_method_name("OnStopped");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameSinkVideoConsumerProxy::OnLog(
    const std::string& in_message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "viz::mojom::FrameSinkVideoConsumer::OnLog");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameSinkVideoConsumer_OnLog_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::viz::mojom::internal::FrameSinkVideoConsumer_OnLog_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->message)::BaseType::BufferWriter
      message_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_message, buffer, &message_writer, &serialization_context);
  params->message.Set(
      message_writer.is_null() ? nullptr : message_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null message in FrameSinkVideoConsumer.OnLog request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameSinkVideoConsumer::Name_);
  message.set_method_name("OnLog");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool FrameSinkVideoConsumerStubDispatch::Accept(
    FrameSinkVideoConsumer* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kFrameSinkVideoConsumer_OnFrameCaptured_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)viz::mojom::FrameSinkVideoConsumer::OnFrameCaptured",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)viz::mojom::FrameSinkVideoConsumer::OnFrameCaptured");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameSinkVideoConsumer_OnFrameCaptured_Params_Data* params =
          reinterpret_cast<internal::FrameSinkVideoConsumer_OnFrameCaptured_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::base::ReadOnlySharedMemoryRegion p_data{};
      ::media::mojom::VideoFrameInfoPtr p_info{};
      ::gfx::Rect p_content_rect{};
      mojo::PendingRemote<FrameSinkVideoConsumerFrameCallbacks> p_callbacks{};
      FrameSinkVideoConsumer_OnFrameCaptured_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadData(&p_data))
        success = false;
      if (success && !input_data_view.ReadInfo(&p_info))
        success = false;
      if (success && !input_data_view.ReadContentRect(&p_content_rect))
        success = false;
      if (success) {
        p_callbacks =
            input_data_view.TakeCallbacks<decltype(p_callbacks)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameSinkVideoConsumer::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnFrameCaptured(
std::move(p_data), 
std::move(p_info), 
std::move(p_content_rect), 
std::move(p_callbacks));
      return true;
    }
    case internal::kFrameSinkVideoConsumer_OnStopped_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)viz::mojom::FrameSinkVideoConsumer::OnStopped",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)viz::mojom::FrameSinkVideoConsumer::OnStopped");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameSinkVideoConsumer_OnStopped_Params_Data* params =
          reinterpret_cast<internal::FrameSinkVideoConsumer_OnStopped_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      FrameSinkVideoConsumer_OnStopped_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameSinkVideoConsumer::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnStopped();
      return true;
    }
    case internal::kFrameSinkVideoConsumer_OnLog_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)viz::mojom::FrameSinkVideoConsumer::OnLog",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)viz::mojom::FrameSinkVideoConsumer::OnLog");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameSinkVideoConsumer_OnLog_Params_Data* params =
          reinterpret_cast<internal::FrameSinkVideoConsumer_OnLog_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      std::string p_message{};
      FrameSinkVideoConsumer_OnLog_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadMessage(&p_message))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameSinkVideoConsumer::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnLog(
std::move(p_message));
      return true;
    }
  }
  return false;
}

// static
bool FrameSinkVideoConsumerStubDispatch::AcceptWithResponder(
    FrameSinkVideoConsumer* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kFrameSinkVideoConsumer_OnFrameCaptured_Name: {
      break;
    }
    case internal::kFrameSinkVideoConsumer_OnStopped_Name: {
      break;
    }
    case internal::kFrameSinkVideoConsumer_OnLog_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kFrameSinkVideoConsumerValidationInfo[] = {
    {&internal::FrameSinkVideoConsumer_OnFrameCaptured_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameSinkVideoConsumer_OnStopped_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameSinkVideoConsumer_OnLog_Params_Data::Validate,
     nullptr /* no response */},
};

bool FrameSinkVideoConsumerRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::viz::mojom::FrameSinkVideoConsumer::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kFrameSinkVideoConsumerValidationInfo);
}

const char FrameSinkVideoCapturer::Name_[] = "viz.mojom.FrameSinkVideoCapturer";

FrameSinkVideoCapturerProxy::FrameSinkVideoCapturerProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void FrameSinkVideoCapturerProxy::SetFormat(
    ::media::VideoPixelFormat in_format, const ::gfx::ColorSpace& in_color_space) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "viz::mojom::FrameSinkVideoCapturer::SetFormat");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameSinkVideoCapturer_SetFormat_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::viz::mojom::internal::FrameSinkVideoCapturer_SetFormat_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::media::mojom::VideoPixelFormat>(
      in_format, &params->format);
  typename decltype(params->color_space)::BaseType::BufferWriter
      color_space_writer;
  mojo::internal::Serialize<::gfx::mojom::ColorSpaceDataView>(
      in_color_space, buffer, &color_space_writer, &serialization_context);
  params->color_space.Set(
      color_space_writer.is_null() ? nullptr : color_space_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->color_space.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null color_space in FrameSinkVideoCapturer.SetFormat request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameSinkVideoCapturer::Name_);
  message.set_method_name("SetFormat");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameSinkVideoCapturerProxy::SetMinCapturePeriod(
    ::base::TimeDelta in_min_period) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "viz::mojom::FrameSinkVideoCapturer::SetMinCapturePeriod");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameSinkVideoCapturer_SetMinCapturePeriod_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::viz::mojom::internal::FrameSinkVideoCapturer_SetMinCapturePeriod_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->min_period)::BaseType::BufferWriter
      min_period_writer;
  mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
      in_min_period, buffer, &min_period_writer, &serialization_context);
  params->min_period.Set(
      min_period_writer.is_null() ? nullptr : min_period_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->min_period.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null min_period in FrameSinkVideoCapturer.SetMinCapturePeriod request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameSinkVideoCapturer::Name_);
  message.set_method_name("SetMinCapturePeriod");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameSinkVideoCapturerProxy::SetMinSizeChangePeriod(
    ::base::TimeDelta in_min_period) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "viz::mojom::FrameSinkVideoCapturer::SetMinSizeChangePeriod");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameSinkVideoCapturer_SetMinSizeChangePeriod_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::viz::mojom::internal::FrameSinkVideoCapturer_SetMinSizeChangePeriod_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->min_period)::BaseType::BufferWriter
      min_period_writer;
  mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
      in_min_period, buffer, &min_period_writer, &serialization_context);
  params->min_period.Set(
      min_period_writer.is_null() ? nullptr : min_period_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->min_period.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null min_period in FrameSinkVideoCapturer.SetMinSizeChangePeriod request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameSinkVideoCapturer::Name_);
  message.set_method_name("SetMinSizeChangePeriod");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameSinkVideoCapturerProxy::SetResolutionConstraints(
    const ::gfx::Size& in_min_size, const ::gfx::Size& in_max_size, bool in_use_fixed_aspect_ratio) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "viz::mojom::FrameSinkVideoCapturer::SetResolutionConstraints");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameSinkVideoCapturer_SetResolutionConstraints_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::viz::mojom::internal::FrameSinkVideoCapturer_SetResolutionConstraints_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->min_size)::BaseType::BufferWriter
      min_size_writer;
  mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
      in_min_size, buffer, &min_size_writer, &serialization_context);
  params->min_size.Set(
      min_size_writer.is_null() ? nullptr : min_size_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->min_size.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null min_size in FrameSinkVideoCapturer.SetResolutionConstraints request");
  typename decltype(params->max_size)::BaseType::BufferWriter
      max_size_writer;
  mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
      in_max_size, buffer, &max_size_writer, &serialization_context);
  params->max_size.Set(
      max_size_writer.is_null() ? nullptr : max_size_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->max_size.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null max_size in FrameSinkVideoCapturer.SetResolutionConstraints request");
  params->use_fixed_aspect_ratio = in_use_fixed_aspect_ratio;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameSinkVideoCapturer::Name_);
  message.set_method_name("SetResolutionConstraints");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameSinkVideoCapturerProxy::SetAutoThrottlingEnabled(
    bool in_enabled) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "viz::mojom::FrameSinkVideoCapturer::SetAutoThrottlingEnabled");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameSinkVideoCapturer_SetAutoThrottlingEnabled_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::viz::mojom::internal::FrameSinkVideoCapturer_SetAutoThrottlingEnabled_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->enabled = in_enabled;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameSinkVideoCapturer::Name_);
  message.set_method_name("SetAutoThrottlingEnabled");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameSinkVideoCapturerProxy::ChangeTarget(
    const base::Optional<::viz::FrameSinkId>& in_frame_sink_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "viz::mojom::FrameSinkVideoCapturer::ChangeTarget");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameSinkVideoCapturer_ChangeTarget_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::viz::mojom::internal::FrameSinkVideoCapturer_ChangeTarget_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->frame_sink_id)::BaseType::BufferWriter
      frame_sink_id_writer;
  mojo::internal::Serialize<::viz::mojom::FrameSinkIdDataView>(
      in_frame_sink_id, buffer, &frame_sink_id_writer, &serialization_context);
  params->frame_sink_id.Set(
      frame_sink_id_writer.is_null() ? nullptr : frame_sink_id_writer.data());
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameSinkVideoCapturer::Name_);
  message.set_method_name("ChangeTarget");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameSinkVideoCapturerProxy::Start(
    mojo::PendingRemote<FrameSinkVideoConsumer> in_consumer) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "viz::mojom::FrameSinkVideoCapturer::Start");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameSinkVideoCapturer_Start_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::viz::mojom::internal::FrameSinkVideoCapturer_Start_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::viz::mojom::FrameSinkVideoConsumerInterfaceBase>>(
      in_consumer, &params->consumer, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->consumer),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid consumer in FrameSinkVideoCapturer.Start request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameSinkVideoCapturer::Name_);
  message.set_method_name("Start");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameSinkVideoCapturerProxy::Stop(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "viz::mojom::FrameSinkVideoCapturer::Stop");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameSinkVideoCapturer_Stop_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::viz::mojom::internal::FrameSinkVideoCapturer_Stop_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameSinkVideoCapturer::Name_);
  message.set_method_name("Stop");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameSinkVideoCapturerProxy::RequestRefreshFrame(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "viz::mojom::FrameSinkVideoCapturer::RequestRefreshFrame");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameSinkVideoCapturer_RequestRefreshFrame_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::viz::mojom::internal::FrameSinkVideoCapturer_RequestRefreshFrame_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameSinkVideoCapturer::Name_);
  message.set_method_name("RequestRefreshFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameSinkVideoCapturerProxy::CreateOverlay(
    int32_t in_stacking_index, mojo::PendingReceiver<FrameSinkVideoCaptureOverlay> in_receiver) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "viz::mojom::FrameSinkVideoCapturer::CreateOverlay");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameSinkVideoCapturer_CreateOverlay_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::viz::mojom::internal::FrameSinkVideoCapturer_CreateOverlay_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->stacking_index = in_stacking_index;
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::viz::mojom::FrameSinkVideoCaptureOverlayInterfaceBase>>(
      in_receiver, &params->receiver, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->receiver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid receiver in FrameSinkVideoCapturer.CreateOverlay request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameSinkVideoCapturer::Name_);
  message.set_method_name("CreateOverlay");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool FrameSinkVideoCapturerStubDispatch::Accept(
    FrameSinkVideoCapturer* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kFrameSinkVideoCapturer_SetFormat_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)viz::mojom::FrameSinkVideoCapturer::SetFormat",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)viz::mojom::FrameSinkVideoCapturer::SetFormat");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameSinkVideoCapturer_SetFormat_Params_Data* params =
          reinterpret_cast<internal::FrameSinkVideoCapturer_SetFormat_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::media::VideoPixelFormat p_format{};
      ::gfx::ColorSpace p_color_space{};
      FrameSinkVideoCapturer_SetFormat_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadFormat(&p_format))
        success = false;
      if (success && !input_data_view.ReadColorSpace(&p_color_space))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameSinkVideoCapturer::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetFormat(
std::move(p_format), 
std::move(p_color_space));
      return true;
    }
    case internal::kFrameSinkVideoCapturer_SetMinCapturePeriod_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)viz::mojom::FrameSinkVideoCapturer::SetMinCapturePeriod",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)viz::mojom::FrameSinkVideoCapturer::SetMinCapturePeriod");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameSinkVideoCapturer_SetMinCapturePeriod_Params_Data* params =
          reinterpret_cast<internal::FrameSinkVideoCapturer_SetMinCapturePeriod_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::base::TimeDelta p_min_period{};
      FrameSinkVideoCapturer_SetMinCapturePeriod_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadMinPeriod(&p_min_period))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameSinkVideoCapturer::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetMinCapturePeriod(
std::move(p_min_period));
      return true;
    }
    case internal::kFrameSinkVideoCapturer_SetMinSizeChangePeriod_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)viz::mojom::FrameSinkVideoCapturer::SetMinSizeChangePeriod",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)viz::mojom::FrameSinkVideoCapturer::SetMinSizeChangePeriod");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameSinkVideoCapturer_SetMinSizeChangePeriod_Params_Data* params =
          reinterpret_cast<internal::FrameSinkVideoCapturer_SetMinSizeChangePeriod_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::base::TimeDelta p_min_period{};
      FrameSinkVideoCapturer_SetMinSizeChangePeriod_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadMinPeriod(&p_min_period))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameSinkVideoCapturer::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetMinSizeChangePeriod(
std::move(p_min_period));
      return true;
    }
    case internal::kFrameSinkVideoCapturer_SetResolutionConstraints_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)viz::mojom::FrameSinkVideoCapturer::SetResolutionConstraints",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)viz::mojom::FrameSinkVideoCapturer::SetResolutionConstraints");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameSinkVideoCapturer_SetResolutionConstraints_Params_Data* params =
          reinterpret_cast<internal::FrameSinkVideoCapturer_SetResolutionConstraints_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::gfx::Size p_min_size{};
      ::gfx::Size p_max_size{};
      bool p_use_fixed_aspect_ratio{};
      FrameSinkVideoCapturer_SetResolutionConstraints_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadMinSize(&p_min_size))
        success = false;
      if (success && !input_data_view.ReadMaxSize(&p_max_size))
        success = false;
      if (success)
        p_use_fixed_aspect_ratio = input_data_view.use_fixed_aspect_ratio();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameSinkVideoCapturer::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetResolutionConstraints(
std::move(p_min_size), 
std::move(p_max_size), 
std::move(p_use_fixed_aspect_ratio));
      return true;
    }
    case internal::kFrameSinkVideoCapturer_SetAutoThrottlingEnabled_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)viz::mojom::FrameSinkVideoCapturer::SetAutoThrottlingEnabled",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)viz::mojom::FrameSinkVideoCapturer::SetAutoThrottlingEnabled");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameSinkVideoCapturer_SetAutoThrottlingEnabled_Params_Data* params =
          reinterpret_cast<internal::FrameSinkVideoCapturer_SetAutoThrottlingEnabled_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_enabled{};
      FrameSinkVideoCapturer_SetAutoThrottlingEnabled_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_enabled = input_data_view.enabled();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameSinkVideoCapturer::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetAutoThrottlingEnabled(
std::move(p_enabled));
      return true;
    }
    case internal::kFrameSinkVideoCapturer_ChangeTarget_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)viz::mojom::FrameSinkVideoCapturer::ChangeTarget",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)viz::mojom::FrameSinkVideoCapturer::ChangeTarget");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameSinkVideoCapturer_ChangeTarget_Params_Data* params =
          reinterpret_cast<internal::FrameSinkVideoCapturer_ChangeTarget_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      base::Optional<::viz::FrameSinkId> p_frame_sink_id{};
      FrameSinkVideoCapturer_ChangeTarget_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadFrameSinkId(&p_frame_sink_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameSinkVideoCapturer::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ChangeTarget(
std::move(p_frame_sink_id));
      return true;
    }
    case internal::kFrameSinkVideoCapturer_Start_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)viz::mojom::FrameSinkVideoCapturer::Start",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)viz::mojom::FrameSinkVideoCapturer::Start");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameSinkVideoCapturer_Start_Params_Data* params =
          reinterpret_cast<internal::FrameSinkVideoCapturer_Start_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      mojo::PendingRemote<FrameSinkVideoConsumer> p_consumer{};
      FrameSinkVideoCapturer_Start_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success) {
        p_consumer =
            input_data_view.TakeConsumer<decltype(p_consumer)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameSinkVideoCapturer::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Start(
std::move(p_consumer));
      return true;
    }
    case internal::kFrameSinkVideoCapturer_Stop_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)viz::mojom::FrameSinkVideoCapturer::Stop",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)viz::mojom::FrameSinkVideoCapturer::Stop");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameSinkVideoCapturer_Stop_Params_Data* params =
          reinterpret_cast<internal::FrameSinkVideoCapturer_Stop_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      FrameSinkVideoCapturer_Stop_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameSinkVideoCapturer::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Stop();
      return true;
    }
    case internal::kFrameSinkVideoCapturer_RequestRefreshFrame_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)viz::mojom::FrameSinkVideoCapturer::RequestRefreshFrame",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)viz::mojom::FrameSinkVideoCapturer::RequestRefreshFrame");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameSinkVideoCapturer_RequestRefreshFrame_Params_Data* params =
          reinterpret_cast<internal::FrameSinkVideoCapturer_RequestRefreshFrame_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      FrameSinkVideoCapturer_RequestRefreshFrame_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameSinkVideoCapturer::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RequestRefreshFrame();
      return true;
    }
    case internal::kFrameSinkVideoCapturer_CreateOverlay_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)viz::mojom::FrameSinkVideoCapturer::CreateOverlay",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)viz::mojom::FrameSinkVideoCapturer::CreateOverlay");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameSinkVideoCapturer_CreateOverlay_Params_Data* params =
          reinterpret_cast<internal::FrameSinkVideoCapturer_CreateOverlay_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int32_t p_stacking_index{};
      mojo::PendingReceiver<FrameSinkVideoCaptureOverlay> p_receiver{};
      FrameSinkVideoCapturer_CreateOverlay_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_stacking_index = input_data_view.stacking_index();
      if (success) {
        p_receiver =
            input_data_view.TakeReceiver<decltype(p_receiver)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameSinkVideoCapturer::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateOverlay(
std::move(p_stacking_index), 
std::move(p_receiver));
      return true;
    }
  }
  return false;
}

// static
bool FrameSinkVideoCapturerStubDispatch::AcceptWithResponder(
    FrameSinkVideoCapturer* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kFrameSinkVideoCapturer_SetFormat_Name: {
      break;
    }
    case internal::kFrameSinkVideoCapturer_SetMinCapturePeriod_Name: {
      break;
    }
    case internal::kFrameSinkVideoCapturer_SetMinSizeChangePeriod_Name: {
      break;
    }
    case internal::kFrameSinkVideoCapturer_SetResolutionConstraints_Name: {
      break;
    }
    case internal::kFrameSinkVideoCapturer_SetAutoThrottlingEnabled_Name: {
      break;
    }
    case internal::kFrameSinkVideoCapturer_ChangeTarget_Name: {
      break;
    }
    case internal::kFrameSinkVideoCapturer_Start_Name: {
      break;
    }
    case internal::kFrameSinkVideoCapturer_Stop_Name: {
      break;
    }
    case internal::kFrameSinkVideoCapturer_RequestRefreshFrame_Name: {
      break;
    }
    case internal::kFrameSinkVideoCapturer_CreateOverlay_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kFrameSinkVideoCapturerValidationInfo[] = {
    {&internal::FrameSinkVideoCapturer_SetFormat_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameSinkVideoCapturer_SetMinCapturePeriod_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameSinkVideoCapturer_SetMinSizeChangePeriod_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameSinkVideoCapturer_SetResolutionConstraints_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameSinkVideoCapturer_SetAutoThrottlingEnabled_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameSinkVideoCapturer_ChangeTarget_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameSinkVideoCapturer_Start_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameSinkVideoCapturer_Stop_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameSinkVideoCapturer_RequestRefreshFrame_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameSinkVideoCapturer_CreateOverlay_Params_Data::Validate,
     nullptr /* no response */},
};

bool FrameSinkVideoCapturerRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::viz::mojom::FrameSinkVideoCapturer::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kFrameSinkVideoCapturerValidationInfo);
}

const char FrameSinkVideoCaptureOverlay::Name_[] = "viz.mojom.FrameSinkVideoCaptureOverlay";

FrameSinkVideoCaptureOverlayProxy::FrameSinkVideoCaptureOverlayProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void FrameSinkVideoCaptureOverlayProxy::SetImageAndBounds(
    const ::SkBitmap& in_image, const ::gfx::RectF& in_bounds) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "viz::mojom::FrameSinkVideoCaptureOverlay::SetImageAndBounds");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameSinkVideoCaptureOverlay_SetImageAndBounds_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::viz::mojom::internal::FrameSinkVideoCaptureOverlay_SetImageAndBounds_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->image)::BaseType::BufferWriter
      image_writer;
  mojo::internal::Serialize<::skia::mojom::BitmapDataView>(
      in_image, buffer, &image_writer, &serialization_context);
  params->image.Set(
      image_writer.is_null() ? nullptr : image_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->image.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null image in FrameSinkVideoCaptureOverlay.SetImageAndBounds request");
  typename decltype(params->bounds)::BaseType::BufferWriter
      bounds_writer;
  mojo::internal::Serialize<::gfx::mojom::RectFDataView>(
      in_bounds, buffer, &bounds_writer, &serialization_context);
  params->bounds.Set(
      bounds_writer.is_null() ? nullptr : bounds_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bounds.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bounds in FrameSinkVideoCaptureOverlay.SetImageAndBounds request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameSinkVideoCaptureOverlay::Name_);
  message.set_method_name("SetImageAndBounds");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameSinkVideoCaptureOverlayProxy::SetBounds(
    const ::gfx::RectF& in_bounds) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "viz::mojom::FrameSinkVideoCaptureOverlay::SetBounds");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameSinkVideoCaptureOverlay_SetBounds_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::viz::mojom::internal::FrameSinkVideoCaptureOverlay_SetBounds_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->bounds)::BaseType::BufferWriter
      bounds_writer;
  mojo::internal::Serialize<::gfx::mojom::RectFDataView>(
      in_bounds, buffer, &bounds_writer, &serialization_context);
  params->bounds.Set(
      bounds_writer.is_null() ? nullptr : bounds_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bounds.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bounds in FrameSinkVideoCaptureOverlay.SetBounds request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameSinkVideoCaptureOverlay::Name_);
  message.set_method_name("SetBounds");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool FrameSinkVideoCaptureOverlayStubDispatch::Accept(
    FrameSinkVideoCaptureOverlay* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kFrameSinkVideoCaptureOverlay_SetImageAndBounds_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)viz::mojom::FrameSinkVideoCaptureOverlay::SetImageAndBounds",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)viz::mojom::FrameSinkVideoCaptureOverlay::SetImageAndBounds");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameSinkVideoCaptureOverlay_SetImageAndBounds_Params_Data* params =
          reinterpret_cast<internal::FrameSinkVideoCaptureOverlay_SetImageAndBounds_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::SkBitmap p_image{};
      ::gfx::RectF p_bounds{};
      FrameSinkVideoCaptureOverlay_SetImageAndBounds_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadImage(&p_image))
        success = false;
      if (success && !input_data_view.ReadBounds(&p_bounds))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameSinkVideoCaptureOverlay::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetImageAndBounds(
std::move(p_image), 
std::move(p_bounds));
      return true;
    }
    case internal::kFrameSinkVideoCaptureOverlay_SetBounds_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)viz::mojom::FrameSinkVideoCaptureOverlay::SetBounds",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)viz::mojom::FrameSinkVideoCaptureOverlay::SetBounds");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameSinkVideoCaptureOverlay_SetBounds_Params_Data* params =
          reinterpret_cast<internal::FrameSinkVideoCaptureOverlay_SetBounds_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::gfx::RectF p_bounds{};
      FrameSinkVideoCaptureOverlay_SetBounds_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadBounds(&p_bounds))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameSinkVideoCaptureOverlay::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetBounds(
std::move(p_bounds));
      return true;
    }
  }
  return false;
}

// static
bool FrameSinkVideoCaptureOverlayStubDispatch::AcceptWithResponder(
    FrameSinkVideoCaptureOverlay* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kFrameSinkVideoCaptureOverlay_SetImageAndBounds_Name: {
      break;
    }
    case internal::kFrameSinkVideoCaptureOverlay_SetBounds_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kFrameSinkVideoCaptureOverlayValidationInfo[] = {
    {&internal::FrameSinkVideoCaptureOverlay_SetImageAndBounds_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameSinkVideoCaptureOverlay_SetBounds_Params_Data::Validate,
     nullptr /* no response */},
};

bool FrameSinkVideoCaptureOverlayRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::viz::mojom::FrameSinkVideoCaptureOverlay::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kFrameSinkVideoCaptureOverlayValidationInfo);
}

}  // namespace mojom
}  // namespace viz

namespace mojo {

}  // namespace mojo

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif