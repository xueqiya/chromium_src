// services/viz/privileged/mojom/compositing/frame_sink_manager.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_VIZ_PRIVILEGED_MOJOM_COMPOSITING_FRAME_SINK_MANAGER_MOJOM_TEST_UTILS_H_
#define SERVICES_VIZ_PRIVILEGED_MOJOM_COMPOSITING_FRAME_SINK_MANAGER_MOJOM_TEST_UTILS_H_

#include "services/viz/privileged/mojom/compositing/frame_sink_manager.mojom.h"


namespace viz {
namespace mojom {


class  FrameSinkManagerInterceptorForTesting : public FrameSinkManager {
  virtual FrameSinkManager* GetForwardingInterface() = 0;
  void RegisterFrameSinkId(const ::viz::FrameSinkId& frame_sink_id, bool report_activation) override;
  void InvalidateFrameSinkId(const ::viz::FrameSinkId& frame_sink_id) override;
  void EnableSynchronizationReporting(const ::viz::FrameSinkId& frame_sink_id, const std::string& reporting_label) override;
  void SetFrameSinkDebugLabel(const ::viz::FrameSinkId& frame_sink_id, const std::string& debug_label) override;
  void CreateRootCompositorFrameSink(RootCompositorFrameSinkParamsPtr params) override;
  void CreateCompositorFrameSink(const ::viz::FrameSinkId& frame_sink_id, mojo::PendingReceiver<::viz::mojom::CompositorFrameSink> compositor_frame_sink, mojo::PendingRemote<::viz::mojom::CompositorFrameSinkClient> compositor_frame_sink_client) override;
  void DestroyCompositorFrameSink(const ::viz::FrameSinkId& frame_sink_id, DestroyCompositorFrameSinkCallback callback) override;
  void RegisterFrameSinkHierarchy(const ::viz::FrameSinkId& parent_frame_sink_id, const ::viz::FrameSinkId& child_frame_sink_id) override;
  void UnregisterFrameSinkHierarchy(const ::viz::FrameSinkId& parent_frame_sink_id, const ::viz::FrameSinkId& child_frame_sink_id) override;
  void AddVideoDetectorObserver(mojo::PendingRemote<::viz::mojom::VideoDetectorObserver> observer) override;
  void CreateVideoCapturer(mojo::PendingReceiver<::viz::mojom::FrameSinkVideoCapturer> receiver) override;
  void EvictSurfaces(const std::vector<::viz::SurfaceId>& surface_ids) override;
  void RequestCopyOfOutput(const ::viz::SurfaceId& surface_id, ::std::unique_ptr<::viz::CopyOutputRequest> request) override;
  void SetHitTestAsyncQueriedDebugRegions(const ::viz::FrameSinkId& root_frame_sink_id, const std::vector<::viz::FrameSinkId>& hit_test_async_queried_debug_queue) override;
  void CacheBackBuffer(uint32_t cache_id, const ::viz::FrameSinkId& root_frame_sink_id) override;
  void EvictBackBuffer(uint32_t cache_id, EvictBackBufferCallback callback) override;
};
class  FrameSinkManagerAsyncWaiter {
 public:
  explicit FrameSinkManagerAsyncWaiter(FrameSinkManager* proxy);
  ~FrameSinkManagerAsyncWaiter();
  void DestroyCompositorFrameSink(
      const ::viz::FrameSinkId& frame_sink_id);
  void EvictBackBuffer(
      uint32_t cache_id);

 private:
  FrameSinkManager* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(FrameSinkManagerAsyncWaiter);
};


class  FrameSinkManagerClientInterceptorForTesting : public FrameSinkManagerClient {
  virtual FrameSinkManagerClient* GetForwardingInterface() = 0;
  void OnFirstSurfaceActivation(const ::viz::SurfaceInfo& surface_info) override;
  void OnAggregatedHitTestRegionListUpdated(const ::viz::FrameSinkId& frame_sink_id, const std::vector<::viz::AggregatedHitTestRegion>& hit_test_data) override;
  void OnFrameTokenChanged(const ::viz::FrameSinkId& frame_sink_id, uint32_t frame_token) override;
};
class  FrameSinkManagerClientAsyncWaiter {
 public:
  explicit FrameSinkManagerClientAsyncWaiter(FrameSinkManagerClient* proxy);
  ~FrameSinkManagerClientAsyncWaiter();

 private:
  FrameSinkManagerClient* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(FrameSinkManagerClientAsyncWaiter);
};




}  // namespace mojom
}  // namespace viz

#endif  // SERVICES_VIZ_PRIVILEGED_MOJOM_COMPOSITING_FRAME_SINK_MANAGER_MOJOM_TEST_UTILS_H_