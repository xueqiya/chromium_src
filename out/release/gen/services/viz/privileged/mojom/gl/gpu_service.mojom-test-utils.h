// services/viz/privileged/mojom/gl/gpu_service.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_VIZ_PRIVILEGED_MOJOM_GL_GPU_SERVICE_MOJOM_TEST_UTILS_H_
#define SERVICES_VIZ_PRIVILEGED_MOJOM_GL_GPU_SERVICE_MOJOM_TEST_UTILS_H_

#include "services/viz/privileged/mojom/gl/gpu_service.mojom.h"


namespace viz {
namespace mojom {


class  GpuServiceInterceptorForTesting : public GpuService {
  virtual GpuService* GetForwardingInterface() = 0;
  void EstablishGpuChannel(int32_t client_id, uint64_t client_tracing_id, bool is_gpu_host, bool cache_shaders_on_disk, EstablishGpuChannelCallback callback) override;
  void CloseChannel(int32_t client_id) override;
  void CreateVideoEncodeAcceleratorProvider(mojo::PendingReceiver<::media::mojom::VideoEncodeAcceleratorProvider> vea_provider) override;
  void CreateGpuMemoryBuffer(::gfx::GpuMemoryBufferId id, const ::gfx::Size& size, ::gfx::BufferFormat format, ::gfx::BufferUsage usage, int32_t client_id, ::gpu::SurfaceHandle surface_handle, CreateGpuMemoryBufferCallback callback) override;
  void DestroyGpuMemoryBuffer(::gfx::GpuMemoryBufferId id, int32_t client_id, const ::gpu::SyncToken& sync_token) override;
  void GetVideoMemoryUsageStats(GetVideoMemoryUsageStatsCallback callback) override;
  void StartPeakMemoryMonitor(uint32_t sequence_num) override;
  void GetPeakMemoryUsage(uint32_t sequence_num, GetPeakMemoryUsageCallback callback) override;
  void RequestHDRStatus(RequestHDRStatusCallback callback) override;
  void LoadedShader(int32_t client_id, const std::string& key, const std::string& data) override;
  void WakeUpGpu() override;
  void GpuSwitched(::gl::GpuPreference active_gpu_heuristic) override;
  void DisplayAdded() override;
  void DisplayRemoved() override;
  void DestroyAllChannels() override;
  void OnBackgroundCleanup() override;
  void OnBackgrounded() override;
  void OnForegrounded() override;
  void Crash() override;
  void Hang() override;
  void ThrowJavaException() override;
  void Stop(StopCallback callback) override;
};
class  GpuServiceAsyncWaiter {
 public:
  explicit GpuServiceAsyncWaiter(GpuService* proxy);
  ~GpuServiceAsyncWaiter();
  void EstablishGpuChannel(
      int32_t client_id, uint64_t client_tracing_id, bool is_gpu_host, bool cache_shaders_on_disk, mojo::ScopedMessagePipeHandle* out_channel_handle);
  void CreateGpuMemoryBuffer(
      ::gfx::GpuMemoryBufferId id, const ::gfx::Size& size, ::gfx::BufferFormat format, ::gfx::BufferUsage usage, int32_t client_id, ::gpu::SurfaceHandle surface_handle, ::gfx::GpuMemoryBufferHandle* out_buffer_handle);
  void GetVideoMemoryUsageStats(
      ::gpu::VideoMemoryUsageStats* out_stats);
  void GetPeakMemoryUsage(
      uint32_t sequence_num, uint64_t* out_memory_usage);
  void RequestHDRStatus(
      bool* out_hdr_enabled);
  void Stop(
      );

 private:
  GpuService* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(GpuServiceAsyncWaiter);
};




}  // namespace mojom
}  // namespace viz

#endif  // SERVICES_VIZ_PRIVILEGED_MOJOM_GL_GPU_SERVICE_MOJOM_TEST_UTILS_H_