// services/data_decoder/public/mojom/web_bundle_parser.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_DATA_DECODER_PUBLIC_MOJOM_WEB_BUNDLE_PARSER_MOJOM_TEST_UTILS_H_
#define SERVICES_DATA_DECODER_PUBLIC_MOJOM_WEB_BUNDLE_PARSER_MOJOM_TEST_UTILS_H_

#include "services/data_decoder/public/mojom/web_bundle_parser.mojom.h"


namespace data_decoder {
namespace mojom {


class  WebBundleParserFactoryInterceptorForTesting : public WebBundleParserFactory {
  virtual WebBundleParserFactory* GetForwardingInterface() = 0;
  void GetParserForFile(mojo::PendingReceiver<WebBundleParser> receiver, ::base::File file) override;
  void GetParserForDataSource(mojo::PendingReceiver<WebBundleParser> receiver, mojo::PendingRemote<BundleDataSource> data_source) override;
};
class  WebBundleParserFactoryAsyncWaiter {
 public:
  explicit WebBundleParserFactoryAsyncWaiter(WebBundleParserFactory* proxy);
  ~WebBundleParserFactoryAsyncWaiter();

 private:
  WebBundleParserFactory* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(WebBundleParserFactoryAsyncWaiter);
};


class  WebBundleParserInterceptorForTesting : public WebBundleParser {
  virtual WebBundleParser* GetForwardingInterface() = 0;
  void ParseMetadata(ParseMetadataCallback callback) override;
  void ParseResponse(uint64_t response_offset, uint64_t response_length, ParseResponseCallback callback) override;
};
class  WebBundleParserAsyncWaiter {
 public:
  explicit WebBundleParserAsyncWaiter(WebBundleParser* proxy);
  ~WebBundleParserAsyncWaiter();
  void ParseMetadata(
      BundleMetadataPtr* out_Result, BundleMetadataParseErrorPtr* out_error);
  void ParseResponse(
      uint64_t response_offset, uint64_t response_length, BundleResponsePtr* out_Result, BundleResponseParseErrorPtr* out_error);

 private:
  WebBundleParser* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(WebBundleParserAsyncWaiter);
};


class  BundleDataSourceInterceptorForTesting : public BundleDataSource {
  virtual BundleDataSource* GetForwardingInterface() = 0;
  void Read(uint64_t offset, uint64_t length, ReadCallback callback) override;
};
class  BundleDataSourceAsyncWaiter {
 public:
  explicit BundleDataSourceAsyncWaiter(BundleDataSource* proxy);
  ~BundleDataSourceAsyncWaiter();
  void Read(
      uint64_t offset, uint64_t length, base::Optional<std::vector<uint8_t>>* out_buffer);

 private:
  BundleDataSource* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(BundleDataSourceAsyncWaiter);
};




}  // namespace mojom
}  // namespace data_decoder

#endif  // SERVICES_DATA_DECODER_PUBLIC_MOJOM_WEB_BUNDLE_PARSER_MOJOM_TEST_UTILS_H_