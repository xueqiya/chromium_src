// components/safe_browsing/core/common/safe_browsing_url_checker.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif


#include "components/safe_browsing/core/common/safe_browsing_url_checker.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"
#include "url/mojom/url.mojom.h"


#ifndef COMPONENTS_SAFE_BROWSING_CORE_COMMON_SAFE_BROWSING_URL_CHECKER_MOJOM_JUMBO_H_
#define COMPONENTS_SAFE_BROWSING_CORE_COMMON_SAFE_BROWSING_URL_CHECKER_MOJOM_JUMBO_H_
#include "url/mojom/url_gurl_mojom_traits.h"
#endif


namespace safe_browsing {
namespace mojom {


void SafeBrowsingUrlCheckerInterceptorForTesting::CheckUrl(const ::GURL& url, const std::string& method, CheckUrlCallback callback) {
  GetForwardingInterface()->CheckUrl(std::move(url), std::move(method), std::move(callback));
}
SafeBrowsingUrlCheckerAsyncWaiter::SafeBrowsingUrlCheckerAsyncWaiter(
    SafeBrowsingUrlChecker* proxy) : proxy_(proxy) {}

SafeBrowsingUrlCheckerAsyncWaiter::~SafeBrowsingUrlCheckerAsyncWaiter() = default;

void SafeBrowsingUrlCheckerAsyncWaiter::CheckUrl(
    const ::GURL& url, const std::string& method, mojo::PendingReceiver<UrlCheckNotifier>* out_slow_check_notifier, bool* out_proceed, bool* out_showed_interstitial) {
  base::RunLoop loop;
  proxy_->CheckUrl(std::move(url),std::move(method),
      base::BindOnce(
          [](base::RunLoop* loop,
             mojo::PendingReceiver<UrlCheckNotifier>* out_slow_check_notifier
,
             bool* out_proceed
,
             bool* out_showed_interstitial
,
             mojo::PendingReceiver<UrlCheckNotifier> slow_check_notifier,
             bool proceed,
             bool showed_interstitial) {*out_slow_check_notifier = std::move(slow_check_notifier);*out_proceed = std::move(proceed);*out_showed_interstitial = std::move(showed_interstitial);
            loop->Quit();
          },
          &loop,
          out_slow_check_notifier,
          out_proceed,
          out_showed_interstitial));
  loop.Run();
}



void UrlCheckNotifierInterceptorForTesting::OnCompleteCheck(bool proceed, bool showed_interstitial) {
  GetForwardingInterface()->OnCompleteCheck(std::move(proceed), std::move(showed_interstitial));
}
UrlCheckNotifierAsyncWaiter::UrlCheckNotifierAsyncWaiter(
    UrlCheckNotifier* proxy) : proxy_(proxy) {}

UrlCheckNotifierAsyncWaiter::~UrlCheckNotifierAsyncWaiter() = default;






}  // namespace mojom
}  // namespace safe_browsing

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif