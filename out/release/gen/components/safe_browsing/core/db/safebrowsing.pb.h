// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: safebrowsing.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_safebrowsing_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_safebrowsing_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_safebrowsing_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_safebrowsing_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[26]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace safe_browsing {
class Checksum;
class ChecksumDefaultTypeInternal;
extern ChecksumDefaultTypeInternal _Checksum_default_instance_;
class ChromeClientInfo;
class ChromeClientInfoDefaultTypeInternal;
extern ChromeClientInfoDefaultTypeInternal _ChromeClientInfo_default_instance_;
class ClientInfo;
class ClientInfoDefaultTypeInternal;
extern ClientInfoDefaultTypeInternal _ClientInfo_default_instance_;
class Duration;
class DurationDefaultTypeInternal;
extern DurationDefaultTypeInternal _Duration_default_instance_;
class FetchThreatListUpdatesRequest;
class FetchThreatListUpdatesRequestDefaultTypeInternal;
extern FetchThreatListUpdatesRequestDefaultTypeInternal _FetchThreatListUpdatesRequest_default_instance_;
class FetchThreatListUpdatesRequest_ListUpdateRequest;
class FetchThreatListUpdatesRequest_ListUpdateRequestDefaultTypeInternal;
extern FetchThreatListUpdatesRequest_ListUpdateRequestDefaultTypeInternal _FetchThreatListUpdatesRequest_ListUpdateRequest_default_instance_;
class FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints;
class FetchThreatListUpdatesRequest_ListUpdateRequest_ConstraintsDefaultTypeInternal;
extern FetchThreatListUpdatesRequest_ListUpdateRequest_ConstraintsDefaultTypeInternal _FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_default_instance_;
class FetchThreatListUpdatesResponse;
class FetchThreatListUpdatesResponseDefaultTypeInternal;
extern FetchThreatListUpdatesResponseDefaultTypeInternal _FetchThreatListUpdatesResponse_default_instance_;
class FetchThreatListUpdatesResponse_ListUpdateResponse;
class FetchThreatListUpdatesResponse_ListUpdateResponseDefaultTypeInternal;
extern FetchThreatListUpdatesResponse_ListUpdateResponseDefaultTypeInternal _FetchThreatListUpdatesResponse_ListUpdateResponse_default_instance_;
class FindFullHashesRequest;
class FindFullHashesRequestDefaultTypeInternal;
extern FindFullHashesRequestDefaultTypeInternal _FindFullHashesRequest_default_instance_;
class FindFullHashesResponse;
class FindFullHashesResponseDefaultTypeInternal;
extern FindFullHashesResponseDefaultTypeInternal _FindFullHashesResponse_default_instance_;
class FindThreatMatchesRequest;
class FindThreatMatchesRequestDefaultTypeInternal;
extern FindThreatMatchesRequestDefaultTypeInternal _FindThreatMatchesRequest_default_instance_;
class FindThreatMatchesResponse;
class FindThreatMatchesResponseDefaultTypeInternal;
extern FindThreatMatchesResponseDefaultTypeInternal _FindThreatMatchesResponse_default_instance_;
class ListThreatListsResponse;
class ListThreatListsResponseDefaultTypeInternal;
extern ListThreatListsResponseDefaultTypeInternal _ListThreatListsResponse_default_instance_;
class RawHashes;
class RawHashesDefaultTypeInternal;
extern RawHashesDefaultTypeInternal _RawHashes_default_instance_;
class RawIndices;
class RawIndicesDefaultTypeInternal;
extern RawIndicesDefaultTypeInternal _RawIndices_default_instance_;
class RiceDeltaEncoding;
class RiceDeltaEncodingDefaultTypeInternal;
extern RiceDeltaEncodingDefaultTypeInternal _RiceDeltaEncoding_default_instance_;
class ThreatEntry;
class ThreatEntryDefaultTypeInternal;
extern ThreatEntryDefaultTypeInternal _ThreatEntry_default_instance_;
class ThreatEntryMetadata;
class ThreatEntryMetadataDefaultTypeInternal;
extern ThreatEntryMetadataDefaultTypeInternal _ThreatEntryMetadata_default_instance_;
class ThreatEntryMetadata_MetadataEntry;
class ThreatEntryMetadata_MetadataEntryDefaultTypeInternal;
extern ThreatEntryMetadata_MetadataEntryDefaultTypeInternal _ThreatEntryMetadata_MetadataEntry_default_instance_;
class ThreatEntrySet;
class ThreatEntrySetDefaultTypeInternal;
extern ThreatEntrySetDefaultTypeInternal _ThreatEntrySet_default_instance_;
class ThreatHit;
class ThreatHitDefaultTypeInternal;
extern ThreatHitDefaultTypeInternal _ThreatHit_default_instance_;
class ThreatHit_ThreatSource;
class ThreatHit_ThreatSourceDefaultTypeInternal;
extern ThreatHit_ThreatSourceDefaultTypeInternal _ThreatHit_ThreatSource_default_instance_;
class ThreatInfo;
class ThreatInfoDefaultTypeInternal;
extern ThreatInfoDefaultTypeInternal _ThreatInfo_default_instance_;
class ThreatListDescriptor;
class ThreatListDescriptorDefaultTypeInternal;
extern ThreatListDescriptorDefaultTypeInternal _ThreatListDescriptor_default_instance_;
class ThreatMatch;
class ThreatMatchDefaultTypeInternal;
extern ThreatMatchDefaultTypeInternal _ThreatMatch_default_instance_;
}  // namespace safe_browsing
PROTOBUF_NAMESPACE_OPEN
template<> ::safe_browsing::Checksum* Arena::CreateMaybeMessage<::safe_browsing::Checksum>(Arena*);
template<> ::safe_browsing::ChromeClientInfo* Arena::CreateMaybeMessage<::safe_browsing::ChromeClientInfo>(Arena*);
template<> ::safe_browsing::ClientInfo* Arena::CreateMaybeMessage<::safe_browsing::ClientInfo>(Arena*);
template<> ::safe_browsing::Duration* Arena::CreateMaybeMessage<::safe_browsing::Duration>(Arena*);
template<> ::safe_browsing::FetchThreatListUpdatesRequest* Arena::CreateMaybeMessage<::safe_browsing::FetchThreatListUpdatesRequest>(Arena*);
template<> ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest* Arena::CreateMaybeMessage<::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest>(Arena*);
template<> ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* Arena::CreateMaybeMessage<::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints>(Arena*);
template<> ::safe_browsing::FetchThreatListUpdatesResponse* Arena::CreateMaybeMessage<::safe_browsing::FetchThreatListUpdatesResponse>(Arena*);
template<> ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse* Arena::CreateMaybeMessage<::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse>(Arena*);
template<> ::safe_browsing::FindFullHashesRequest* Arena::CreateMaybeMessage<::safe_browsing::FindFullHashesRequest>(Arena*);
template<> ::safe_browsing::FindFullHashesResponse* Arena::CreateMaybeMessage<::safe_browsing::FindFullHashesResponse>(Arena*);
template<> ::safe_browsing::FindThreatMatchesRequest* Arena::CreateMaybeMessage<::safe_browsing::FindThreatMatchesRequest>(Arena*);
template<> ::safe_browsing::FindThreatMatchesResponse* Arena::CreateMaybeMessage<::safe_browsing::FindThreatMatchesResponse>(Arena*);
template<> ::safe_browsing::ListThreatListsResponse* Arena::CreateMaybeMessage<::safe_browsing::ListThreatListsResponse>(Arena*);
template<> ::safe_browsing::RawHashes* Arena::CreateMaybeMessage<::safe_browsing::RawHashes>(Arena*);
template<> ::safe_browsing::RawIndices* Arena::CreateMaybeMessage<::safe_browsing::RawIndices>(Arena*);
template<> ::safe_browsing::RiceDeltaEncoding* Arena::CreateMaybeMessage<::safe_browsing::RiceDeltaEncoding>(Arena*);
template<> ::safe_browsing::ThreatEntry* Arena::CreateMaybeMessage<::safe_browsing::ThreatEntry>(Arena*);
template<> ::safe_browsing::ThreatEntryMetadata* Arena::CreateMaybeMessage<::safe_browsing::ThreatEntryMetadata>(Arena*);
template<> ::safe_browsing::ThreatEntryMetadata_MetadataEntry* Arena::CreateMaybeMessage<::safe_browsing::ThreatEntryMetadata_MetadataEntry>(Arena*);
template<> ::safe_browsing::ThreatEntrySet* Arena::CreateMaybeMessage<::safe_browsing::ThreatEntrySet>(Arena*);
template<> ::safe_browsing::ThreatHit* Arena::CreateMaybeMessage<::safe_browsing::ThreatHit>(Arena*);
template<> ::safe_browsing::ThreatHit_ThreatSource* Arena::CreateMaybeMessage<::safe_browsing::ThreatHit_ThreatSource>(Arena*);
template<> ::safe_browsing::ThreatInfo* Arena::CreateMaybeMessage<::safe_browsing::ThreatInfo>(Arena*);
template<> ::safe_browsing::ThreatListDescriptor* Arena::CreateMaybeMessage<::safe_browsing::ThreatListDescriptor>(Arena*);
template<> ::safe_browsing::ThreatMatch* Arena::CreateMaybeMessage<::safe_browsing::ThreatMatch>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace safe_browsing {

enum FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType : int {
  FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_RESPONSE_TYPE_UNSPECIFIED = 0,
  FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_PARTIAL_UPDATE = 1,
  FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_FULL_UPDATE = 2
};
bool FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(int value);
constexpr FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_MIN = FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_RESPONSE_TYPE_UNSPECIFIED;
constexpr FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_MAX = FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_FULL_UPDATE;
constexpr int FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_ARRAYSIZE = FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_MAX + 1;

const std::string& FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_Name(FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType value);
template<typename T>
inline const std::string& FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_Name.");
  return FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_Name(static_cast<FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType>(enum_t_value));
}
bool FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_Parse(
    const std::string& name, FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType* value);
enum ThreatHit_ThreatSourceType : int {
  ThreatHit_ThreatSourceType_THREAT_SOURCE_TYPE_UNSPECIFIED = 0,
  ThreatHit_ThreatSourceType_MATCHING_URL = 1,
  ThreatHit_ThreatSourceType_TAB_URL = 2,
  ThreatHit_ThreatSourceType_TAB_REDIRECT = 3
};
bool ThreatHit_ThreatSourceType_IsValid(int value);
constexpr ThreatHit_ThreatSourceType ThreatHit_ThreatSourceType_ThreatSourceType_MIN = ThreatHit_ThreatSourceType_THREAT_SOURCE_TYPE_UNSPECIFIED;
constexpr ThreatHit_ThreatSourceType ThreatHit_ThreatSourceType_ThreatSourceType_MAX = ThreatHit_ThreatSourceType_TAB_REDIRECT;
constexpr int ThreatHit_ThreatSourceType_ThreatSourceType_ARRAYSIZE = ThreatHit_ThreatSourceType_ThreatSourceType_MAX + 1;

const std::string& ThreatHit_ThreatSourceType_Name(ThreatHit_ThreatSourceType value);
template<typename T>
inline const std::string& ThreatHit_ThreatSourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ThreatHit_ThreatSourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ThreatHit_ThreatSourceType_Name.");
  return ThreatHit_ThreatSourceType_Name(static_cast<ThreatHit_ThreatSourceType>(enum_t_value));
}
bool ThreatHit_ThreatSourceType_Parse(
    const std::string& name, ThreatHit_ThreatSourceType* value);
enum ChromeClientInfo_SafeBrowsingReportingPopulation : int {
  ChromeClientInfo_SafeBrowsingReportingPopulation_UNSPECIFIED = 0,
  ChromeClientInfo_SafeBrowsingReportingPopulation_OPT_OUT = 1,
  ChromeClientInfo_SafeBrowsingReportingPopulation_EXTENDED = 2,
  ChromeClientInfo_SafeBrowsingReportingPopulation_SCOUT = 3
};
bool ChromeClientInfo_SafeBrowsingReportingPopulation_IsValid(int value);
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo_SafeBrowsingReportingPopulation_SafeBrowsingReportingPopulation_MIN = ChromeClientInfo_SafeBrowsingReportingPopulation_UNSPECIFIED;
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo_SafeBrowsingReportingPopulation_SafeBrowsingReportingPopulation_MAX = ChromeClientInfo_SafeBrowsingReportingPopulation_SCOUT;
constexpr int ChromeClientInfo_SafeBrowsingReportingPopulation_SafeBrowsingReportingPopulation_ARRAYSIZE = ChromeClientInfo_SafeBrowsingReportingPopulation_SafeBrowsingReportingPopulation_MAX + 1;

const std::string& ChromeClientInfo_SafeBrowsingReportingPopulation_Name(ChromeClientInfo_SafeBrowsingReportingPopulation value);
template<typename T>
inline const std::string& ChromeClientInfo_SafeBrowsingReportingPopulation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChromeClientInfo_SafeBrowsingReportingPopulation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChromeClientInfo_SafeBrowsingReportingPopulation_Name.");
  return ChromeClientInfo_SafeBrowsingReportingPopulation_Name(static_cast<ChromeClientInfo_SafeBrowsingReportingPopulation>(enum_t_value));
}
bool ChromeClientInfo_SafeBrowsingReportingPopulation_Parse(
    const std::string& name, ChromeClientInfo_SafeBrowsingReportingPopulation* value);
enum ThreatType : int {
  THREAT_TYPE_UNSPECIFIED = 0,
  MALWARE_THREAT = 1,
  SOCIAL_ENGINEERING_PUBLIC = 2,
  UNWANTED_SOFTWARE = 3,
  POTENTIALLY_HARMFUL_APPLICATION = 4,
  SOCIAL_ENGINEERING = 5,
  API_ABUSE = 6,
  MALICIOUS_BINARY = 7,
  CSD_WHITELIST = 8,
  CSD_DOWNLOAD_WHITELIST = 9,
  CLIENT_INCIDENT = 10,
  SUBRESOURCE_FILTER = 13,
  SUSPICIOUS = 14,
  BILLING = 15,
  HIGH_CONFIDENCE_ALLOWLIST = 16
};
bool ThreatType_IsValid(int value);
constexpr ThreatType ThreatType_MIN = THREAT_TYPE_UNSPECIFIED;
constexpr ThreatType ThreatType_MAX = HIGH_CONFIDENCE_ALLOWLIST;
constexpr int ThreatType_ARRAYSIZE = ThreatType_MAX + 1;

const std::string& ThreatType_Name(ThreatType value);
template<typename T>
inline const std::string& ThreatType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ThreatType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ThreatType_Name.");
  return ThreatType_Name(static_cast<ThreatType>(enum_t_value));
}
bool ThreatType_Parse(
    const std::string& name, ThreatType* value);
enum PlatformType : int {
  PLATFORM_TYPE_UNSPECIFIED = 0,
  WINDOWS_PLATFORM = 1,
  LINUX_PLATFORM = 2,
  ANDROID_PLATFORM = 3,
  OSX_PLATFORM = 4,
  IOS_PLATFORM = 5,
  ANY_PLATFORM = 6,
  ALL_PLATFORMS = 7,
  CHROME_PLATFORM = 8
};
bool PlatformType_IsValid(int value);
constexpr PlatformType PlatformType_MIN = PLATFORM_TYPE_UNSPECIFIED;
constexpr PlatformType PlatformType_MAX = CHROME_PLATFORM;
constexpr int PlatformType_ARRAYSIZE = PlatformType_MAX + 1;

const std::string& PlatformType_Name(PlatformType value);
template<typename T>
inline const std::string& PlatformType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlatformType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlatformType_Name.");
  return PlatformType_Name(static_cast<PlatformType>(enum_t_value));
}
bool PlatformType_Parse(
    const std::string& name, PlatformType* value);
enum CompressionType : int {
  COMPRESSION_TYPE_UNSPECIFIED = 0,
  RAW = 1,
  RICE = 2
};
bool CompressionType_IsValid(int value);
constexpr CompressionType CompressionType_MIN = COMPRESSION_TYPE_UNSPECIFIED;
constexpr CompressionType CompressionType_MAX = RICE;
constexpr int CompressionType_ARRAYSIZE = CompressionType_MAX + 1;

const std::string& CompressionType_Name(CompressionType value);
template<typename T>
inline const std::string& CompressionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompressionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompressionType_Name.");
  return CompressionType_Name(static_cast<CompressionType>(enum_t_value));
}
bool CompressionType_Parse(
    const std::string& name, CompressionType* value);
enum ThreatEntryType : int {
  THREAT_ENTRY_TYPE_UNSPECIFIED = 0,
  URL = 1,
  EXECUTABLE = 2,
  IP_RANGE = 3,
  CHROME_EXTENSION = 4,
  FILENAME = 5,
  CERT = 6
};
bool ThreatEntryType_IsValid(int value);
constexpr ThreatEntryType ThreatEntryType_MIN = THREAT_ENTRY_TYPE_UNSPECIFIED;
constexpr ThreatEntryType ThreatEntryType_MAX = CERT;
constexpr int ThreatEntryType_ARRAYSIZE = ThreatEntryType_MAX + 1;

const std::string& ThreatEntryType_Name(ThreatEntryType value);
template<typename T>
inline const std::string& ThreatEntryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ThreatEntryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ThreatEntryType_Name.");
  return ThreatEntryType_Name(static_cast<ThreatEntryType>(enum_t_value));
}
bool ThreatEntryType_Parse(
    const std::string& name, ThreatEntryType* value);
// ===================================================================

class ThreatInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ThreatInfo) */ {
 public:
  ThreatInfo();
  virtual ~ThreatInfo();

  ThreatInfo(const ThreatInfo& from);
  ThreatInfo(ThreatInfo&& from) noexcept
    : ThreatInfo() {
    *this = ::std::move(from);
  }

  inline ThreatInfo& operator=(const ThreatInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreatInfo& operator=(ThreatInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ThreatInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ThreatInfo* internal_default_instance() {
    return reinterpret_cast<const ThreatInfo*>(
               &_ThreatInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ThreatInfo& a, ThreatInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ThreatInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThreatInfo* New() const final {
    return CreateMaybeMessage<ThreatInfo>(nullptr);
  }

  ThreatInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThreatInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ThreatInfo& from);
  void MergeFrom(const ThreatInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ThreatInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThreatTypesFieldNumber = 1,
    kPlatformTypesFieldNumber = 2,
    kThreatEntriesFieldNumber = 3,
    kThreatEntryTypesFieldNumber = 4,
  };
  // repeated .safe_browsing.ThreatType threat_types = 1;
  int threat_types_size() const;
  void clear_threat_types();
  ::safe_browsing::ThreatType threat_types(int index) const;
  void set_threat_types(int index, ::safe_browsing::ThreatType value);
  void add_threat_types(::safe_browsing::ThreatType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& threat_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_threat_types();

  // repeated .safe_browsing.PlatformType platform_types = 2;
  int platform_types_size() const;
  void clear_platform_types();
  ::safe_browsing::PlatformType platform_types(int index) const;
  void set_platform_types(int index, ::safe_browsing::PlatformType value);
  void add_platform_types(::safe_browsing::PlatformType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& platform_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_platform_types();

  // repeated .safe_browsing.ThreatEntry threat_entries = 3;
  int threat_entries_size() const;
  void clear_threat_entries();
  ::safe_browsing::ThreatEntry* mutable_threat_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntry >*
      mutable_threat_entries();
  const ::safe_browsing::ThreatEntry& threat_entries(int index) const;
  ::safe_browsing::ThreatEntry* add_threat_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntry >&
      threat_entries() const;

  // repeated .safe_browsing.ThreatEntryType threat_entry_types = 4;
  int threat_entry_types_size() const;
  void clear_threat_entry_types();
  ::safe_browsing::ThreatEntryType threat_entry_types(int index) const;
  void set_threat_entry_types(int index, ::safe_browsing::ThreatEntryType value);
  void add_threat_entry_types(::safe_browsing::ThreatEntryType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& threat_entry_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_threat_entry_types();

  // @@protoc_insertion_point(class_scope:safe_browsing.ThreatInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> threat_types_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> platform_types_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntry > threat_entries_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> threat_entry_types_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ThreatMatch :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ThreatMatch) */ {
 public:
  ThreatMatch();
  virtual ~ThreatMatch();

  ThreatMatch(const ThreatMatch& from);
  ThreatMatch(ThreatMatch&& from) noexcept
    : ThreatMatch() {
    *this = ::std::move(from);
  }

  inline ThreatMatch& operator=(const ThreatMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreatMatch& operator=(ThreatMatch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ThreatMatch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ThreatMatch* internal_default_instance() {
    return reinterpret_cast<const ThreatMatch*>(
               &_ThreatMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ThreatMatch& a, ThreatMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(ThreatMatch* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThreatMatch* New() const final {
    return CreateMaybeMessage<ThreatMatch>(nullptr);
  }

  ThreatMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThreatMatch>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ThreatMatch& from);
  void MergeFrom(const ThreatMatch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatMatch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ThreatMatch";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThreatFieldNumber = 3,
    kThreatEntryMetadataFieldNumber = 4,
    kCacheDurationFieldNumber = 5,
    kThreatTypeFieldNumber = 1,
    kPlatformTypeFieldNumber = 2,
    kThreatEntryTypeFieldNumber = 6,
  };
  // optional .safe_browsing.ThreatEntry threat = 3;
  bool has_threat() const;
  void clear_threat();
  const ::safe_browsing::ThreatEntry& threat() const;
  ::safe_browsing::ThreatEntry* release_threat();
  ::safe_browsing::ThreatEntry* mutable_threat();
  void set_allocated_threat(::safe_browsing::ThreatEntry* threat);

  // optional .safe_browsing.ThreatEntryMetadata threat_entry_metadata = 4;
  bool has_threat_entry_metadata() const;
  void clear_threat_entry_metadata();
  const ::safe_browsing::ThreatEntryMetadata& threat_entry_metadata() const;
  ::safe_browsing::ThreatEntryMetadata* release_threat_entry_metadata();
  ::safe_browsing::ThreatEntryMetadata* mutable_threat_entry_metadata();
  void set_allocated_threat_entry_metadata(::safe_browsing::ThreatEntryMetadata* threat_entry_metadata);

  // optional .safe_browsing.Duration cache_duration = 5;
  bool has_cache_duration() const;
  void clear_cache_duration();
  const ::safe_browsing::Duration& cache_duration() const;
  ::safe_browsing::Duration* release_cache_duration();
  ::safe_browsing::Duration* mutable_cache_duration();
  void set_allocated_cache_duration(::safe_browsing::Duration* cache_duration);

  // optional .safe_browsing.ThreatType threat_type = 1;
  bool has_threat_type() const;
  void clear_threat_type();
  ::safe_browsing::ThreatType threat_type() const;
  void set_threat_type(::safe_browsing::ThreatType value);

  // optional .safe_browsing.PlatformType platform_type = 2;
  bool has_platform_type() const;
  void clear_platform_type();
  ::safe_browsing::PlatformType platform_type() const;
  void set_platform_type(::safe_browsing::PlatformType value);

  // optional .safe_browsing.ThreatEntryType threat_entry_type = 6;
  bool has_threat_entry_type() const;
  void clear_threat_entry_type();
  ::safe_browsing::ThreatEntryType threat_entry_type() const;
  void set_threat_entry_type(::safe_browsing::ThreatEntryType value);

  // @@protoc_insertion_point(class_scope:safe_browsing.ThreatMatch)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::safe_browsing::ThreatEntry* threat_;
  ::safe_browsing::ThreatEntryMetadata* threat_entry_metadata_;
  ::safe_browsing::Duration* cache_duration_;
  int threat_type_;
  int platform_type_;
  int threat_entry_type_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class FindThreatMatchesRequest :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.FindThreatMatchesRequest) */ {
 public:
  FindThreatMatchesRequest();
  virtual ~FindThreatMatchesRequest();

  FindThreatMatchesRequest(const FindThreatMatchesRequest& from);
  FindThreatMatchesRequest(FindThreatMatchesRequest&& from) noexcept
    : FindThreatMatchesRequest() {
    *this = ::std::move(from);
  }

  inline FindThreatMatchesRequest& operator=(const FindThreatMatchesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindThreatMatchesRequest& operator=(FindThreatMatchesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FindThreatMatchesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FindThreatMatchesRequest* internal_default_instance() {
    return reinterpret_cast<const FindThreatMatchesRequest*>(
               &_FindThreatMatchesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FindThreatMatchesRequest& a, FindThreatMatchesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FindThreatMatchesRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FindThreatMatchesRequest* New() const final {
    return CreateMaybeMessage<FindThreatMatchesRequest>(nullptr);
  }

  FindThreatMatchesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FindThreatMatchesRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const FindThreatMatchesRequest& from);
  void MergeFrom(const FindThreatMatchesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FindThreatMatchesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.FindThreatMatchesRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientFieldNumber = 1,
    kThreatInfoFieldNumber = 2,
  };
  // optional .safe_browsing.ClientInfo client = 1;
  bool has_client() const;
  void clear_client();
  const ::safe_browsing::ClientInfo& client() const;
  ::safe_browsing::ClientInfo* release_client();
  ::safe_browsing::ClientInfo* mutable_client();
  void set_allocated_client(::safe_browsing::ClientInfo* client);

  // optional .safe_browsing.ThreatInfo threat_info = 2;
  bool has_threat_info() const;
  void clear_threat_info();
  const ::safe_browsing::ThreatInfo& threat_info() const;
  ::safe_browsing::ThreatInfo* release_threat_info();
  ::safe_browsing::ThreatInfo* mutable_threat_info();
  void set_allocated_threat_info(::safe_browsing::ThreatInfo* threat_info);

  // @@protoc_insertion_point(class_scope:safe_browsing.FindThreatMatchesRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::safe_browsing::ClientInfo* client_;
  ::safe_browsing::ThreatInfo* threat_info_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class FindThreatMatchesResponse :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.FindThreatMatchesResponse) */ {
 public:
  FindThreatMatchesResponse();
  virtual ~FindThreatMatchesResponse();

  FindThreatMatchesResponse(const FindThreatMatchesResponse& from);
  FindThreatMatchesResponse(FindThreatMatchesResponse&& from) noexcept
    : FindThreatMatchesResponse() {
    *this = ::std::move(from);
  }

  inline FindThreatMatchesResponse& operator=(const FindThreatMatchesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindThreatMatchesResponse& operator=(FindThreatMatchesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FindThreatMatchesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FindThreatMatchesResponse* internal_default_instance() {
    return reinterpret_cast<const FindThreatMatchesResponse*>(
               &_FindThreatMatchesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FindThreatMatchesResponse& a, FindThreatMatchesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FindThreatMatchesResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FindThreatMatchesResponse* New() const final {
    return CreateMaybeMessage<FindThreatMatchesResponse>(nullptr);
  }

  FindThreatMatchesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FindThreatMatchesResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const FindThreatMatchesResponse& from);
  void MergeFrom(const FindThreatMatchesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FindThreatMatchesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.FindThreatMatchesResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchesFieldNumber = 1,
  };
  // repeated .safe_browsing.ThreatMatch matches = 1;
  int matches_size() const;
  void clear_matches();
  ::safe_browsing::ThreatMatch* mutable_matches(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatMatch >*
      mutable_matches();
  const ::safe_browsing::ThreatMatch& matches(int index) const;
  ::safe_browsing::ThreatMatch* add_matches();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatMatch >&
      matches() const;

  // @@protoc_insertion_point(class_scope:safe_browsing.FindThreatMatchesResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatMatch > matches_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints) */ {
 public:
  FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints();
  virtual ~FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints();

  FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from);
  FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints&& from) noexcept
    : FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints() {
    *this = ::std::move(from);
  }

  inline FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& operator=(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& operator=(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* internal_default_instance() {
    return reinterpret_cast<const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints*>(
               &_FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& a, FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* New() const final {
    return CreateMaybeMessage<FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints>(nullptr);
  }

  FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from);
  void MergeFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedCompressionsFieldNumber = 4,
    kRegionFieldNumber = 3,
    kMaxUpdateEntriesFieldNumber = 1,
    kMaxDatabaseEntriesFieldNumber = 2,
  };
  // repeated .safe_browsing.CompressionType supported_compressions = 4;
  int supported_compressions_size() const;
  void clear_supported_compressions();
  ::safe_browsing::CompressionType supported_compressions(int index) const;
  void set_supported_compressions(int index, ::safe_browsing::CompressionType value);
  void add_supported_compressions(::safe_browsing::CompressionType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& supported_compressions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_supported_compressions();

  // optional string region = 3;
  bool has_region() const;
  void clear_region();
  const std::string& region() const;
  void set_region(const std::string& value);
  void set_region(std::string&& value);
  void set_region(const char* value);
  void set_region(const char* value, size_t size);
  std::string* mutable_region();
  std::string* release_region();
  void set_allocated_region(std::string* region);

  // optional int32 max_update_entries = 1;
  bool has_max_update_entries() const;
  void clear_max_update_entries();
  ::PROTOBUF_NAMESPACE_ID::int32 max_update_entries() const;
  void set_max_update_entries(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 max_database_entries = 2;
  bool has_max_database_entries() const;
  void clear_max_database_entries();
  ::PROTOBUF_NAMESPACE_ID::int32 max_database_entries() const;
  void set_max_database_entries(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> supported_compressions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_update_entries_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_database_entries_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class FetchThreatListUpdatesRequest_ListUpdateRequest :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest) */ {
 public:
  FetchThreatListUpdatesRequest_ListUpdateRequest();
  virtual ~FetchThreatListUpdatesRequest_ListUpdateRequest();

  FetchThreatListUpdatesRequest_ListUpdateRequest(const FetchThreatListUpdatesRequest_ListUpdateRequest& from);
  FetchThreatListUpdatesRequest_ListUpdateRequest(FetchThreatListUpdatesRequest_ListUpdateRequest&& from) noexcept
    : FetchThreatListUpdatesRequest_ListUpdateRequest() {
    *this = ::std::move(from);
  }

  inline FetchThreatListUpdatesRequest_ListUpdateRequest& operator=(const FetchThreatListUpdatesRequest_ListUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchThreatListUpdatesRequest_ListUpdateRequest& operator=(FetchThreatListUpdatesRequest_ListUpdateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FetchThreatListUpdatesRequest_ListUpdateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FetchThreatListUpdatesRequest_ListUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const FetchThreatListUpdatesRequest_ListUpdateRequest*>(
               &_FetchThreatListUpdatesRequest_ListUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FetchThreatListUpdatesRequest_ListUpdateRequest& a, FetchThreatListUpdatesRequest_ListUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchThreatListUpdatesRequest_ListUpdateRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FetchThreatListUpdatesRequest_ListUpdateRequest* New() const final {
    return CreateMaybeMessage<FetchThreatListUpdatesRequest_ListUpdateRequest>(nullptr);
  }

  FetchThreatListUpdatesRequest_ListUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FetchThreatListUpdatesRequest_ListUpdateRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest& from);
  void MergeFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FetchThreatListUpdatesRequest_ListUpdateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints Constraints;

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 3,
    kConstraintsFieldNumber = 4,
    kThreatTypeFieldNumber = 1,
    kPlatformTypeFieldNumber = 2,
    kThreatEntryTypeFieldNumber = 5,
  };
  // optional bytes state = 3;
  bool has_state() const;
  void clear_state();
  const std::string& state() const;
  void set_state(const std::string& value);
  void set_state(std::string&& value);
  void set_state(const char* value);
  void set_state(const void* value, size_t size);
  std::string* mutable_state();
  std::string* release_state();
  void set_allocated_state(std::string* state);

  // optional .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
  bool has_constraints() const;
  void clear_constraints();
  const ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& constraints() const;
  ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* release_constraints();
  ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* mutable_constraints();
  void set_allocated_constraints(::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* constraints);

  // optional .safe_browsing.ThreatType threat_type = 1;
  bool has_threat_type() const;
  void clear_threat_type();
  ::safe_browsing::ThreatType threat_type() const;
  void set_threat_type(::safe_browsing::ThreatType value);

  // optional .safe_browsing.PlatformType platform_type = 2;
  bool has_platform_type() const;
  void clear_platform_type();
  ::safe_browsing::PlatformType platform_type() const;
  void set_platform_type(::safe_browsing::PlatformType value);

  // optional .safe_browsing.ThreatEntryType threat_entry_type = 5;
  bool has_threat_entry_type() const;
  void clear_threat_entry_type();
  ::safe_browsing::ThreatEntryType threat_entry_type() const;
  void set_threat_entry_type(::safe_browsing::ThreatEntryType value);

  // @@protoc_insertion_point(class_scope:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
  ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* constraints_;
  int threat_type_;
  int platform_type_;
  int threat_entry_type_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class FetchThreatListUpdatesRequest :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.FetchThreatListUpdatesRequest) */ {
 public:
  FetchThreatListUpdatesRequest();
  virtual ~FetchThreatListUpdatesRequest();

  FetchThreatListUpdatesRequest(const FetchThreatListUpdatesRequest& from);
  FetchThreatListUpdatesRequest(FetchThreatListUpdatesRequest&& from) noexcept
    : FetchThreatListUpdatesRequest() {
    *this = ::std::move(from);
  }

  inline FetchThreatListUpdatesRequest& operator=(const FetchThreatListUpdatesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchThreatListUpdatesRequest& operator=(FetchThreatListUpdatesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FetchThreatListUpdatesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FetchThreatListUpdatesRequest* internal_default_instance() {
    return reinterpret_cast<const FetchThreatListUpdatesRequest*>(
               &_FetchThreatListUpdatesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FetchThreatListUpdatesRequest& a, FetchThreatListUpdatesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchThreatListUpdatesRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FetchThreatListUpdatesRequest* New() const final {
    return CreateMaybeMessage<FetchThreatListUpdatesRequest>(nullptr);
  }

  FetchThreatListUpdatesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FetchThreatListUpdatesRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const FetchThreatListUpdatesRequest& from);
  void MergeFrom(const FetchThreatListUpdatesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FetchThreatListUpdatesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.FetchThreatListUpdatesRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef FetchThreatListUpdatesRequest_ListUpdateRequest ListUpdateRequest;

  // accessors -------------------------------------------------------

  enum : int {
    kListUpdateRequestsFieldNumber = 3,
    kClientFieldNumber = 1,
    kChromeClientInfoFieldNumber = 4,
  };
  // repeated .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
  int list_update_requests_size() const;
  void clear_list_update_requests();
  ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest* mutable_list_update_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest >*
      mutable_list_update_requests();
  const ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest& list_update_requests(int index) const;
  ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest* add_list_update_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest >&
      list_update_requests() const;

  // optional .safe_browsing.ClientInfo client = 1;
  bool has_client() const;
  void clear_client();
  const ::safe_browsing::ClientInfo& client() const;
  ::safe_browsing::ClientInfo* release_client();
  ::safe_browsing::ClientInfo* mutable_client();
  void set_allocated_client(::safe_browsing::ClientInfo* client);

  // optional .safe_browsing.ChromeClientInfo chrome_client_info = 4;
  bool has_chrome_client_info() const;
  void clear_chrome_client_info();
  const ::safe_browsing::ChromeClientInfo& chrome_client_info() const;
  ::safe_browsing::ChromeClientInfo* release_chrome_client_info();
  ::safe_browsing::ChromeClientInfo* mutable_chrome_client_info();
  void set_allocated_chrome_client_info(::safe_browsing::ChromeClientInfo* chrome_client_info);

  // @@protoc_insertion_point(class_scope:safe_browsing.FetchThreatListUpdatesRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest > list_update_requests_;
  ::safe_browsing::ClientInfo* client_;
  ::safe_browsing::ChromeClientInfo* chrome_client_info_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class FetchThreatListUpdatesResponse_ListUpdateResponse :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse) */ {
 public:
  FetchThreatListUpdatesResponse_ListUpdateResponse();
  virtual ~FetchThreatListUpdatesResponse_ListUpdateResponse();

  FetchThreatListUpdatesResponse_ListUpdateResponse(const FetchThreatListUpdatesResponse_ListUpdateResponse& from);
  FetchThreatListUpdatesResponse_ListUpdateResponse(FetchThreatListUpdatesResponse_ListUpdateResponse&& from) noexcept
    : FetchThreatListUpdatesResponse_ListUpdateResponse() {
    *this = ::std::move(from);
  }

  inline FetchThreatListUpdatesResponse_ListUpdateResponse& operator=(const FetchThreatListUpdatesResponse_ListUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchThreatListUpdatesResponse_ListUpdateResponse& operator=(FetchThreatListUpdatesResponse_ListUpdateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FetchThreatListUpdatesResponse_ListUpdateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FetchThreatListUpdatesResponse_ListUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const FetchThreatListUpdatesResponse_ListUpdateResponse*>(
               &_FetchThreatListUpdatesResponse_ListUpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FetchThreatListUpdatesResponse_ListUpdateResponse& a, FetchThreatListUpdatesResponse_ListUpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchThreatListUpdatesResponse_ListUpdateResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FetchThreatListUpdatesResponse_ListUpdateResponse* New() const final {
    return CreateMaybeMessage<FetchThreatListUpdatesResponse_ListUpdateResponse>(nullptr);
  }

  FetchThreatListUpdatesResponse_ListUpdateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FetchThreatListUpdatesResponse_ListUpdateResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const FetchThreatListUpdatesResponse_ListUpdateResponse& from);
  void MergeFrom(const FetchThreatListUpdatesResponse_ListUpdateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FetchThreatListUpdatesResponse_ListUpdateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType ResponseType;
  static constexpr ResponseType RESPONSE_TYPE_UNSPECIFIED =
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_RESPONSE_TYPE_UNSPECIFIED;
  static constexpr ResponseType PARTIAL_UPDATE =
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_PARTIAL_UPDATE;
  static constexpr ResponseType FULL_UPDATE =
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_FULL_UPDATE;
  static inline bool ResponseType_IsValid(int value) {
    return FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(value);
  }
  static constexpr ResponseType ResponseType_MIN =
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_MIN;
  static constexpr ResponseType ResponseType_MAX =
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_MAX;
  static constexpr int ResponseType_ARRAYSIZE =
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ResponseType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResponseType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResponseType_Name.");
    return FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_Name(enum_t_value);
  }
  static inline bool ResponseType_Parse(const std::string& name,
      ResponseType* value) {
    return FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionsFieldNumber = 5,
    kRemovalsFieldNumber = 6,
    kNewClientStateFieldNumber = 7,
    kChecksumFieldNumber = 8,
    kThreatTypeFieldNumber = 1,
    kThreatEntryTypeFieldNumber = 2,
    kPlatformTypeFieldNumber = 3,
    kResponseTypeFieldNumber = 4,
  };
  // repeated .safe_browsing.ThreatEntrySet additions = 5;
  int additions_size() const;
  void clear_additions();
  ::safe_browsing::ThreatEntrySet* mutable_additions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntrySet >*
      mutable_additions();
  const ::safe_browsing::ThreatEntrySet& additions(int index) const;
  ::safe_browsing::ThreatEntrySet* add_additions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntrySet >&
      additions() const;

  // repeated .safe_browsing.ThreatEntrySet removals = 6;
  int removals_size() const;
  void clear_removals();
  ::safe_browsing::ThreatEntrySet* mutable_removals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntrySet >*
      mutable_removals();
  const ::safe_browsing::ThreatEntrySet& removals(int index) const;
  ::safe_browsing::ThreatEntrySet* add_removals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntrySet >&
      removals() const;

  // optional bytes new_client_state = 7;
  bool has_new_client_state() const;
  void clear_new_client_state();
  const std::string& new_client_state() const;
  void set_new_client_state(const std::string& value);
  void set_new_client_state(std::string&& value);
  void set_new_client_state(const char* value);
  void set_new_client_state(const void* value, size_t size);
  std::string* mutable_new_client_state();
  std::string* release_new_client_state();
  void set_allocated_new_client_state(std::string* new_client_state);

  // optional .safe_browsing.Checksum checksum = 8;
  bool has_checksum() const;
  void clear_checksum();
  const ::safe_browsing::Checksum& checksum() const;
  ::safe_browsing::Checksum* release_checksum();
  ::safe_browsing::Checksum* mutable_checksum();
  void set_allocated_checksum(::safe_browsing::Checksum* checksum);

  // optional .safe_browsing.ThreatType threat_type = 1;
  bool has_threat_type() const;
  void clear_threat_type();
  ::safe_browsing::ThreatType threat_type() const;
  void set_threat_type(::safe_browsing::ThreatType value);

  // optional .safe_browsing.ThreatEntryType threat_entry_type = 2;
  bool has_threat_entry_type() const;
  void clear_threat_entry_type();
  ::safe_browsing::ThreatEntryType threat_entry_type() const;
  void set_threat_entry_type(::safe_browsing::ThreatEntryType value);

  // optional .safe_browsing.PlatformType platform_type = 3;
  bool has_platform_type() const;
  void clear_platform_type();
  ::safe_browsing::PlatformType platform_type() const;
  void set_platform_type(::safe_browsing::PlatformType value);

  // optional .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
  bool has_response_type() const;
  void clear_response_type();
  ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType response_type() const;
  void set_response_type(::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType value);

  // @@protoc_insertion_point(class_scope:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntrySet > additions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntrySet > removals_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_client_state_;
  ::safe_browsing::Checksum* checksum_;
  int threat_type_;
  int threat_entry_type_;
  int platform_type_;
  int response_type_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class FetchThreatListUpdatesResponse :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.FetchThreatListUpdatesResponse) */ {
 public:
  FetchThreatListUpdatesResponse();
  virtual ~FetchThreatListUpdatesResponse();

  FetchThreatListUpdatesResponse(const FetchThreatListUpdatesResponse& from);
  FetchThreatListUpdatesResponse(FetchThreatListUpdatesResponse&& from) noexcept
    : FetchThreatListUpdatesResponse() {
    *this = ::std::move(from);
  }

  inline FetchThreatListUpdatesResponse& operator=(const FetchThreatListUpdatesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchThreatListUpdatesResponse& operator=(FetchThreatListUpdatesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FetchThreatListUpdatesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FetchThreatListUpdatesResponse* internal_default_instance() {
    return reinterpret_cast<const FetchThreatListUpdatesResponse*>(
               &_FetchThreatListUpdatesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FetchThreatListUpdatesResponse& a, FetchThreatListUpdatesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchThreatListUpdatesResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FetchThreatListUpdatesResponse* New() const final {
    return CreateMaybeMessage<FetchThreatListUpdatesResponse>(nullptr);
  }

  FetchThreatListUpdatesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FetchThreatListUpdatesResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const FetchThreatListUpdatesResponse& from);
  void MergeFrom(const FetchThreatListUpdatesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FetchThreatListUpdatesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.FetchThreatListUpdatesResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef FetchThreatListUpdatesResponse_ListUpdateResponse ListUpdateResponse;

  // accessors -------------------------------------------------------

  enum : int {
    kListUpdateResponsesFieldNumber = 1,
    kMinimumWaitDurationFieldNumber = 2,
  };
  // repeated .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
  int list_update_responses_size() const;
  void clear_list_update_responses();
  ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse* mutable_list_update_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse >*
      mutable_list_update_responses();
  const ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse& list_update_responses(int index) const;
  ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse* add_list_update_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse >&
      list_update_responses() const;

  // optional .safe_browsing.Duration minimum_wait_duration = 2;
  bool has_minimum_wait_duration() const;
  void clear_minimum_wait_duration();
  const ::safe_browsing::Duration& minimum_wait_duration() const;
  ::safe_browsing::Duration* release_minimum_wait_duration();
  ::safe_browsing::Duration* mutable_minimum_wait_duration();
  void set_allocated_minimum_wait_duration(::safe_browsing::Duration* minimum_wait_duration);

  // @@protoc_insertion_point(class_scope:safe_browsing.FetchThreatListUpdatesResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse > list_update_responses_;
  ::safe_browsing::Duration* minimum_wait_duration_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class FindFullHashesRequest :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.FindFullHashesRequest) */ {
 public:
  FindFullHashesRequest();
  virtual ~FindFullHashesRequest();

  FindFullHashesRequest(const FindFullHashesRequest& from);
  FindFullHashesRequest(FindFullHashesRequest&& from) noexcept
    : FindFullHashesRequest() {
    *this = ::std::move(from);
  }

  inline FindFullHashesRequest& operator=(const FindFullHashesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindFullHashesRequest& operator=(FindFullHashesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FindFullHashesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FindFullHashesRequest* internal_default_instance() {
    return reinterpret_cast<const FindFullHashesRequest*>(
               &_FindFullHashesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FindFullHashesRequest& a, FindFullHashesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FindFullHashesRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FindFullHashesRequest* New() const final {
    return CreateMaybeMessage<FindFullHashesRequest>(nullptr);
  }

  FindFullHashesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FindFullHashesRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const FindFullHashesRequest& from);
  void MergeFrom(const FindFullHashesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FindFullHashesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.FindFullHashesRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientStatesFieldNumber = 2,
    kClientFieldNumber = 1,
    kThreatInfoFieldNumber = 3,
  };
  // repeated bytes client_states = 2;
  int client_states_size() const;
  void clear_client_states();
  const std::string& client_states(int index) const;
  std::string* mutable_client_states(int index);
  void set_client_states(int index, const std::string& value);
  void set_client_states(int index, std::string&& value);
  void set_client_states(int index, const char* value);
  void set_client_states(int index, const void* value, size_t size);
  std::string* add_client_states();
  void add_client_states(const std::string& value);
  void add_client_states(std::string&& value);
  void add_client_states(const char* value);
  void add_client_states(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& client_states() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_client_states();

  // optional .safe_browsing.ClientInfo client = 1;
  bool has_client() const;
  void clear_client();
  const ::safe_browsing::ClientInfo& client() const;
  ::safe_browsing::ClientInfo* release_client();
  ::safe_browsing::ClientInfo* mutable_client();
  void set_allocated_client(::safe_browsing::ClientInfo* client);

  // optional .safe_browsing.ThreatInfo threat_info = 3;
  bool has_threat_info() const;
  void clear_threat_info();
  const ::safe_browsing::ThreatInfo& threat_info() const;
  ::safe_browsing::ThreatInfo* release_threat_info();
  ::safe_browsing::ThreatInfo* mutable_threat_info();
  void set_allocated_threat_info(::safe_browsing::ThreatInfo* threat_info);

  // @@protoc_insertion_point(class_scope:safe_browsing.FindFullHashesRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> client_states_;
  ::safe_browsing::ClientInfo* client_;
  ::safe_browsing::ThreatInfo* threat_info_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class FindFullHashesResponse :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.FindFullHashesResponse) */ {
 public:
  FindFullHashesResponse();
  virtual ~FindFullHashesResponse();

  FindFullHashesResponse(const FindFullHashesResponse& from);
  FindFullHashesResponse(FindFullHashesResponse&& from) noexcept
    : FindFullHashesResponse() {
    *this = ::std::move(from);
  }

  inline FindFullHashesResponse& operator=(const FindFullHashesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindFullHashesResponse& operator=(FindFullHashesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FindFullHashesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FindFullHashesResponse* internal_default_instance() {
    return reinterpret_cast<const FindFullHashesResponse*>(
               &_FindFullHashesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FindFullHashesResponse& a, FindFullHashesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FindFullHashesResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FindFullHashesResponse* New() const final {
    return CreateMaybeMessage<FindFullHashesResponse>(nullptr);
  }

  FindFullHashesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FindFullHashesResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const FindFullHashesResponse& from);
  void MergeFrom(const FindFullHashesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FindFullHashesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.FindFullHashesResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchesFieldNumber = 1,
    kMinimumWaitDurationFieldNumber = 2,
    kNegativeCacheDurationFieldNumber = 3,
  };
  // repeated .safe_browsing.ThreatMatch matches = 1;
  int matches_size() const;
  void clear_matches();
  ::safe_browsing::ThreatMatch* mutable_matches(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatMatch >*
      mutable_matches();
  const ::safe_browsing::ThreatMatch& matches(int index) const;
  ::safe_browsing::ThreatMatch* add_matches();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatMatch >&
      matches() const;

  // optional .safe_browsing.Duration minimum_wait_duration = 2;
  bool has_minimum_wait_duration() const;
  void clear_minimum_wait_duration();
  const ::safe_browsing::Duration& minimum_wait_duration() const;
  ::safe_browsing::Duration* release_minimum_wait_duration();
  ::safe_browsing::Duration* mutable_minimum_wait_duration();
  void set_allocated_minimum_wait_duration(::safe_browsing::Duration* minimum_wait_duration);

  // optional .safe_browsing.Duration negative_cache_duration = 3;
  bool has_negative_cache_duration() const;
  void clear_negative_cache_duration();
  const ::safe_browsing::Duration& negative_cache_duration() const;
  ::safe_browsing::Duration* release_negative_cache_duration();
  ::safe_browsing::Duration* mutable_negative_cache_duration();
  void set_allocated_negative_cache_duration(::safe_browsing::Duration* negative_cache_duration);

  // @@protoc_insertion_point(class_scope:safe_browsing.FindFullHashesResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatMatch > matches_;
  ::safe_browsing::Duration* minimum_wait_duration_;
  ::safe_browsing::Duration* negative_cache_duration_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ThreatHit_ThreatSource :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ThreatHit.ThreatSource) */ {
 public:
  ThreatHit_ThreatSource();
  virtual ~ThreatHit_ThreatSource();

  ThreatHit_ThreatSource(const ThreatHit_ThreatSource& from);
  ThreatHit_ThreatSource(ThreatHit_ThreatSource&& from) noexcept
    : ThreatHit_ThreatSource() {
    *this = ::std::move(from);
  }

  inline ThreatHit_ThreatSource& operator=(const ThreatHit_ThreatSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreatHit_ThreatSource& operator=(ThreatHit_ThreatSource&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ThreatHit_ThreatSource& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ThreatHit_ThreatSource* internal_default_instance() {
    return reinterpret_cast<const ThreatHit_ThreatSource*>(
               &_ThreatHit_ThreatSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ThreatHit_ThreatSource& a, ThreatHit_ThreatSource& b) {
    a.Swap(&b);
  }
  inline void Swap(ThreatHit_ThreatSource* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThreatHit_ThreatSource* New() const final {
    return CreateMaybeMessage<ThreatHit_ThreatSource>(nullptr);
  }

  ThreatHit_ThreatSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThreatHit_ThreatSource>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ThreatHit_ThreatSource& from);
  void MergeFrom(const ThreatHit_ThreatSource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatHit_ThreatSource* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ThreatHit.ThreatSource";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kRemoteIpFieldNumber = 3,
    kReferrerFieldNumber = 4,
    kTypeFieldNumber = 2,
  };
  // optional string url = 1;
  bool has_url() const;
  void clear_url();
  const std::string& url() const;
  void set_url(const std::string& value);
  void set_url(std::string&& value);
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  std::string* mutable_url();
  std::string* release_url();
  void set_allocated_url(std::string* url);

  // optional string remote_ip = 3;
  bool has_remote_ip() const;
  void clear_remote_ip();
  const std::string& remote_ip() const;
  void set_remote_ip(const std::string& value);
  void set_remote_ip(std::string&& value);
  void set_remote_ip(const char* value);
  void set_remote_ip(const char* value, size_t size);
  std::string* mutable_remote_ip();
  std::string* release_remote_ip();
  void set_allocated_remote_ip(std::string* remote_ip);

  // optional string referrer = 4;
  bool has_referrer() const;
  void clear_referrer();
  const std::string& referrer() const;
  void set_referrer(const std::string& value);
  void set_referrer(std::string&& value);
  void set_referrer(const char* value);
  void set_referrer(const char* value, size_t size);
  std::string* mutable_referrer();
  std::string* release_referrer();
  void set_allocated_referrer(std::string* referrer);

  // optional .safe_browsing.ThreatHit.ThreatSourceType type = 2;
  bool has_type() const;
  void clear_type();
  ::safe_browsing::ThreatHit_ThreatSourceType type() const;
  void set_type(::safe_browsing::ThreatHit_ThreatSourceType value);

  // @@protoc_insertion_point(class_scope:safe_browsing.ThreatHit.ThreatSource)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr referrer_;
  int type_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ThreatHit :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ThreatHit) */ {
 public:
  ThreatHit();
  virtual ~ThreatHit();

  ThreatHit(const ThreatHit& from);
  ThreatHit(ThreatHit&& from) noexcept
    : ThreatHit() {
    *this = ::std::move(from);
  }

  inline ThreatHit& operator=(const ThreatHit& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreatHit& operator=(ThreatHit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ThreatHit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ThreatHit* internal_default_instance() {
    return reinterpret_cast<const ThreatHit*>(
               &_ThreatHit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ThreatHit& a, ThreatHit& b) {
    a.Swap(&b);
  }
  inline void Swap(ThreatHit* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThreatHit* New() const final {
    return CreateMaybeMessage<ThreatHit>(nullptr);
  }

  ThreatHit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThreatHit>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ThreatHit& from);
  void MergeFrom(const ThreatHit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatHit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ThreatHit";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ThreatHit_ThreatSource ThreatSource;

  typedef ThreatHit_ThreatSourceType ThreatSourceType;
  static constexpr ThreatSourceType THREAT_SOURCE_TYPE_UNSPECIFIED =
    ThreatHit_ThreatSourceType_THREAT_SOURCE_TYPE_UNSPECIFIED;
  static constexpr ThreatSourceType MATCHING_URL =
    ThreatHit_ThreatSourceType_MATCHING_URL;
  static constexpr ThreatSourceType TAB_URL =
    ThreatHit_ThreatSourceType_TAB_URL;
  static constexpr ThreatSourceType TAB_REDIRECT =
    ThreatHit_ThreatSourceType_TAB_REDIRECT;
  static inline bool ThreatSourceType_IsValid(int value) {
    return ThreatHit_ThreatSourceType_IsValid(value);
  }
  static constexpr ThreatSourceType ThreatSourceType_MIN =
    ThreatHit_ThreatSourceType_ThreatSourceType_MIN;
  static constexpr ThreatSourceType ThreatSourceType_MAX =
    ThreatHit_ThreatSourceType_ThreatSourceType_MAX;
  static constexpr int ThreatSourceType_ARRAYSIZE =
    ThreatHit_ThreatSourceType_ThreatSourceType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ThreatSourceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ThreatSourceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ThreatSourceType_Name.");
    return ThreatHit_ThreatSourceType_Name(enum_t_value);
  }
  static inline bool ThreatSourceType_Parse(const std::string& name,
      ThreatSourceType* value) {
    return ThreatHit_ThreatSourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResourcesFieldNumber = 4,
    kEntryFieldNumber = 3,
    kThreatTypeFieldNumber = 1,
    kPlatformTypeFieldNumber = 2,
  };
  // repeated .safe_browsing.ThreatHit.ThreatSource resources = 4;
  int resources_size() const;
  void clear_resources();
  ::safe_browsing::ThreatHit_ThreatSource* mutable_resources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatHit_ThreatSource >*
      mutable_resources();
  const ::safe_browsing::ThreatHit_ThreatSource& resources(int index) const;
  ::safe_browsing::ThreatHit_ThreatSource* add_resources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatHit_ThreatSource >&
      resources() const;

  // optional .safe_browsing.ThreatEntry entry = 3;
  bool has_entry() const;
  void clear_entry();
  const ::safe_browsing::ThreatEntry& entry() const;
  ::safe_browsing::ThreatEntry* release_entry();
  ::safe_browsing::ThreatEntry* mutable_entry();
  void set_allocated_entry(::safe_browsing::ThreatEntry* entry);

  // optional .safe_browsing.ThreatType threat_type = 1;
  bool has_threat_type() const;
  void clear_threat_type();
  ::safe_browsing::ThreatType threat_type() const;
  void set_threat_type(::safe_browsing::ThreatType value);

  // optional .safe_browsing.PlatformType platform_type = 2;
  bool has_platform_type() const;
  void clear_platform_type();
  ::safe_browsing::PlatformType platform_type() const;
  void set_platform_type(::safe_browsing::PlatformType value);

  // @@protoc_insertion_point(class_scope:safe_browsing.ThreatHit)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatHit_ThreatSource > resources_;
  ::safe_browsing::ThreatEntry* entry_;
  int threat_type_;
  int platform_type_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ClientInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ClientInfo) */ {
 public:
  ClientInfo();
  virtual ~ClientInfo();

  ClientInfo(const ClientInfo& from);
  ClientInfo(ClientInfo&& from) noexcept
    : ClientInfo() {
    *this = ::std::move(from);
  }

  inline ClientInfo& operator=(const ClientInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientInfo& operator=(ClientInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ClientInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientInfo* internal_default_instance() {
    return reinterpret_cast<const ClientInfo*>(
               &_ClientInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ClientInfo& a, ClientInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientInfo* New() const final {
    return CreateMaybeMessage<ClientInfo>(nullptr);
  }

  ClientInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ClientInfo& from);
  void MergeFrom(const ClientInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ClientInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kClientVersionFieldNumber = 2,
  };
  // optional string client_id = 1;
  bool has_client_id() const;
  void clear_client_id();
  const std::string& client_id() const;
  void set_client_id(const std::string& value);
  void set_client_id(std::string&& value);
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  std::string* mutable_client_id();
  std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);

  // optional string client_version = 2;
  bool has_client_version() const;
  void clear_client_version();
  const std::string& client_version() const;
  void set_client_version(const std::string& value);
  void set_client_version(std::string&& value);
  void set_client_version(const char* value);
  void set_client_version(const char* value, size_t size);
  std::string* mutable_client_version();
  std::string* release_client_version();
  void set_allocated_client_version(std::string* client_version);

  // @@protoc_insertion_point(class_scope:safe_browsing.ClientInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_version_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ChromeClientInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ChromeClientInfo) */ {
 public:
  ChromeClientInfo();
  virtual ~ChromeClientInfo();

  ChromeClientInfo(const ChromeClientInfo& from);
  ChromeClientInfo(ChromeClientInfo&& from) noexcept
    : ChromeClientInfo() {
    *this = ::std::move(from);
  }

  inline ChromeClientInfo& operator=(const ChromeClientInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChromeClientInfo& operator=(ChromeClientInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ChromeClientInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChromeClientInfo* internal_default_instance() {
    return reinterpret_cast<const ChromeClientInfo*>(
               &_ChromeClientInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ChromeClientInfo& a, ChromeClientInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ChromeClientInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChromeClientInfo* New() const final {
    return CreateMaybeMessage<ChromeClientInfo>(nullptr);
  }

  ChromeClientInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChromeClientInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ChromeClientInfo& from);
  void MergeFrom(const ChromeClientInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChromeClientInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ChromeClientInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ChromeClientInfo_SafeBrowsingReportingPopulation SafeBrowsingReportingPopulation;
  static constexpr SafeBrowsingReportingPopulation UNSPECIFIED =
    ChromeClientInfo_SafeBrowsingReportingPopulation_UNSPECIFIED;
  static constexpr SafeBrowsingReportingPopulation OPT_OUT =
    ChromeClientInfo_SafeBrowsingReportingPopulation_OPT_OUT;
  static constexpr SafeBrowsingReportingPopulation EXTENDED =
    ChromeClientInfo_SafeBrowsingReportingPopulation_EXTENDED;
  static constexpr SafeBrowsingReportingPopulation SCOUT =
    ChromeClientInfo_SafeBrowsingReportingPopulation_SCOUT;
  static inline bool SafeBrowsingReportingPopulation_IsValid(int value) {
    return ChromeClientInfo_SafeBrowsingReportingPopulation_IsValid(value);
  }
  static constexpr SafeBrowsingReportingPopulation SafeBrowsingReportingPopulation_MIN =
    ChromeClientInfo_SafeBrowsingReportingPopulation_SafeBrowsingReportingPopulation_MIN;
  static constexpr SafeBrowsingReportingPopulation SafeBrowsingReportingPopulation_MAX =
    ChromeClientInfo_SafeBrowsingReportingPopulation_SafeBrowsingReportingPopulation_MAX;
  static constexpr int SafeBrowsingReportingPopulation_ARRAYSIZE =
    ChromeClientInfo_SafeBrowsingReportingPopulation_SafeBrowsingReportingPopulation_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SafeBrowsingReportingPopulation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SafeBrowsingReportingPopulation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SafeBrowsingReportingPopulation_Name.");
    return ChromeClientInfo_SafeBrowsingReportingPopulation_Name(enum_t_value);
  }
  static inline bool SafeBrowsingReportingPopulation_Parse(const std::string& name,
      SafeBrowsingReportingPopulation* value) {
    return ChromeClientInfo_SafeBrowsingReportingPopulation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kReportingPopulationFieldNumber = 1,
  };
  // optional .safe_browsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
  bool has_reporting_population() const;
  void clear_reporting_population();
  ::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation reporting_population() const;
  void set_reporting_population(::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation value);

  // @@protoc_insertion_point(class_scope:safe_browsing.ChromeClientInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int reporting_population_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class Checksum :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.Checksum) */ {
 public:
  Checksum();
  virtual ~Checksum();

  Checksum(const Checksum& from);
  Checksum(Checksum&& from) noexcept
    : Checksum() {
    *this = ::std::move(from);
  }

  inline Checksum& operator=(const Checksum& from) {
    CopyFrom(from);
    return *this;
  }
  inline Checksum& operator=(Checksum&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Checksum& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Checksum* internal_default_instance() {
    return reinterpret_cast<const Checksum*>(
               &_Checksum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Checksum& a, Checksum& b) {
    a.Swap(&b);
  }
  inline void Swap(Checksum* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Checksum* New() const final {
    return CreateMaybeMessage<Checksum>(nullptr);
  }

  Checksum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Checksum>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Checksum& from);
  void MergeFrom(const Checksum& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Checksum* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.Checksum";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSha256FieldNumber = 1,
  };
  // optional bytes sha256 = 1;
  bool has_sha256() const;
  void clear_sha256();
  const std::string& sha256() const;
  void set_sha256(const std::string& value);
  void set_sha256(std::string&& value);
  void set_sha256(const char* value);
  void set_sha256(const void* value, size_t size);
  std::string* mutable_sha256();
  std::string* release_sha256();
  void set_allocated_sha256(std::string* sha256);

  // @@protoc_insertion_point(class_scope:safe_browsing.Checksum)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sha256_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ThreatEntry :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ThreatEntry) */ {
 public:
  ThreatEntry();
  virtual ~ThreatEntry();

  ThreatEntry(const ThreatEntry& from);
  ThreatEntry(ThreatEntry&& from) noexcept
    : ThreatEntry() {
    *this = ::std::move(from);
  }

  inline ThreatEntry& operator=(const ThreatEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreatEntry& operator=(ThreatEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ThreatEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ThreatEntry* internal_default_instance() {
    return reinterpret_cast<const ThreatEntry*>(
               &_ThreatEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ThreatEntry& a, ThreatEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(ThreatEntry* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThreatEntry* New() const final {
    return CreateMaybeMessage<ThreatEntry>(nullptr);
  }

  ThreatEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThreatEntry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ThreatEntry& from);
  void MergeFrom(const ThreatEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ThreatEntry";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
    kUrlFieldNumber = 2,
  };
  // optional bytes hash = 1;
  bool has_hash() const;
  void clear_hash();
  const std::string& hash() const;
  void set_hash(const std::string& value);
  void set_hash(std::string&& value);
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  std::string* mutable_hash();
  std::string* release_hash();
  void set_allocated_hash(std::string* hash);

  // optional string url = 2;
  bool has_url() const;
  void clear_url();
  const std::string& url() const;
  void set_url(const std::string& value);
  void set_url(std::string&& value);
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  std::string* mutable_url();
  std::string* release_url();
  void set_allocated_url(std::string* url);

  // @@protoc_insertion_point(class_scope:safe_browsing.ThreatEntry)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ThreatEntrySet :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ThreatEntrySet) */ {
 public:
  ThreatEntrySet();
  virtual ~ThreatEntrySet();

  ThreatEntrySet(const ThreatEntrySet& from);
  ThreatEntrySet(ThreatEntrySet&& from) noexcept
    : ThreatEntrySet() {
    *this = ::std::move(from);
  }

  inline ThreatEntrySet& operator=(const ThreatEntrySet& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreatEntrySet& operator=(ThreatEntrySet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ThreatEntrySet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ThreatEntrySet* internal_default_instance() {
    return reinterpret_cast<const ThreatEntrySet*>(
               &_ThreatEntrySet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ThreatEntrySet& a, ThreatEntrySet& b) {
    a.Swap(&b);
  }
  inline void Swap(ThreatEntrySet* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThreatEntrySet* New() const final {
    return CreateMaybeMessage<ThreatEntrySet>(nullptr);
  }

  ThreatEntrySet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThreatEntrySet>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ThreatEntrySet& from);
  void MergeFrom(const ThreatEntrySet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatEntrySet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ThreatEntrySet";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRawHashesFieldNumber = 2,
    kRawIndicesFieldNumber = 3,
    kRiceHashesFieldNumber = 4,
    kRiceIndicesFieldNumber = 5,
    kCompressionTypeFieldNumber = 1,
  };
  // optional .safe_browsing.RawHashes raw_hashes = 2;
  bool has_raw_hashes() const;
  void clear_raw_hashes();
  const ::safe_browsing::RawHashes& raw_hashes() const;
  ::safe_browsing::RawHashes* release_raw_hashes();
  ::safe_browsing::RawHashes* mutable_raw_hashes();
  void set_allocated_raw_hashes(::safe_browsing::RawHashes* raw_hashes);

  // optional .safe_browsing.RawIndices raw_indices = 3;
  bool has_raw_indices() const;
  void clear_raw_indices();
  const ::safe_browsing::RawIndices& raw_indices() const;
  ::safe_browsing::RawIndices* release_raw_indices();
  ::safe_browsing::RawIndices* mutable_raw_indices();
  void set_allocated_raw_indices(::safe_browsing::RawIndices* raw_indices);

  // optional .safe_browsing.RiceDeltaEncoding rice_hashes = 4;
  bool has_rice_hashes() const;
  void clear_rice_hashes();
  const ::safe_browsing::RiceDeltaEncoding& rice_hashes() const;
  ::safe_browsing::RiceDeltaEncoding* release_rice_hashes();
  ::safe_browsing::RiceDeltaEncoding* mutable_rice_hashes();
  void set_allocated_rice_hashes(::safe_browsing::RiceDeltaEncoding* rice_hashes);

  // optional .safe_browsing.RiceDeltaEncoding rice_indices = 5;
  bool has_rice_indices() const;
  void clear_rice_indices();
  const ::safe_browsing::RiceDeltaEncoding& rice_indices() const;
  ::safe_browsing::RiceDeltaEncoding* release_rice_indices();
  ::safe_browsing::RiceDeltaEncoding* mutable_rice_indices();
  void set_allocated_rice_indices(::safe_browsing::RiceDeltaEncoding* rice_indices);

  // optional .safe_browsing.CompressionType compression_type = 1;
  bool has_compression_type() const;
  void clear_compression_type();
  ::safe_browsing::CompressionType compression_type() const;
  void set_compression_type(::safe_browsing::CompressionType value);

  // @@protoc_insertion_point(class_scope:safe_browsing.ThreatEntrySet)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::safe_browsing::RawHashes* raw_hashes_;
  ::safe_browsing::RawIndices* raw_indices_;
  ::safe_browsing::RiceDeltaEncoding* rice_hashes_;
  ::safe_browsing::RiceDeltaEncoding* rice_indices_;
  int compression_type_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class RawIndices :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.RawIndices) */ {
 public:
  RawIndices();
  virtual ~RawIndices();

  RawIndices(const RawIndices& from);
  RawIndices(RawIndices&& from) noexcept
    : RawIndices() {
    *this = ::std::move(from);
  }

  inline RawIndices& operator=(const RawIndices& from) {
    CopyFrom(from);
    return *this;
  }
  inline RawIndices& operator=(RawIndices&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RawIndices& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawIndices* internal_default_instance() {
    return reinterpret_cast<const RawIndices*>(
               &_RawIndices_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RawIndices& a, RawIndices& b) {
    a.Swap(&b);
  }
  inline void Swap(RawIndices* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RawIndices* New() const final {
    return CreateMaybeMessage<RawIndices>(nullptr);
  }

  RawIndices* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RawIndices>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RawIndices& from);
  void MergeFrom(const RawIndices& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RawIndices* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.RawIndices";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndicesFieldNumber = 1,
  };
  // repeated int32 indices = 1;
  int indices_size() const;
  void clear_indices();
  ::PROTOBUF_NAMESPACE_ID::int32 indices(int index) const;
  void set_indices(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_indices(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      indices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_indices();

  // @@protoc_insertion_point(class_scope:safe_browsing.RawIndices)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > indices_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class RawHashes :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.RawHashes) */ {
 public:
  RawHashes();
  virtual ~RawHashes();

  RawHashes(const RawHashes& from);
  RawHashes(RawHashes&& from) noexcept
    : RawHashes() {
    *this = ::std::move(from);
  }

  inline RawHashes& operator=(const RawHashes& from) {
    CopyFrom(from);
    return *this;
  }
  inline RawHashes& operator=(RawHashes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RawHashes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawHashes* internal_default_instance() {
    return reinterpret_cast<const RawHashes*>(
               &_RawHashes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RawHashes& a, RawHashes& b) {
    a.Swap(&b);
  }
  inline void Swap(RawHashes* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RawHashes* New() const final {
    return CreateMaybeMessage<RawHashes>(nullptr);
  }

  RawHashes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RawHashes>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RawHashes& from);
  void MergeFrom(const RawHashes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RawHashes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.RawHashes";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRawHashesFieldNumber = 2,
    kPrefixSizeFieldNumber = 1,
  };
  // optional bytes raw_hashes = 2;
  bool has_raw_hashes() const;
  void clear_raw_hashes();
  const std::string& raw_hashes() const;
  void set_raw_hashes(const std::string& value);
  void set_raw_hashes(std::string&& value);
  void set_raw_hashes(const char* value);
  void set_raw_hashes(const void* value, size_t size);
  std::string* mutable_raw_hashes();
  std::string* release_raw_hashes();
  void set_allocated_raw_hashes(std::string* raw_hashes);

  // optional int32 prefix_size = 1;
  bool has_prefix_size() const;
  void clear_prefix_size();
  ::PROTOBUF_NAMESPACE_ID::int32 prefix_size() const;
  void set_prefix_size(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:safe_browsing.RawHashes)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_hashes_;
  ::PROTOBUF_NAMESPACE_ID::int32 prefix_size_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class RiceDeltaEncoding :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.RiceDeltaEncoding) */ {
 public:
  RiceDeltaEncoding();
  virtual ~RiceDeltaEncoding();

  RiceDeltaEncoding(const RiceDeltaEncoding& from);
  RiceDeltaEncoding(RiceDeltaEncoding&& from) noexcept
    : RiceDeltaEncoding() {
    *this = ::std::move(from);
  }

  inline RiceDeltaEncoding& operator=(const RiceDeltaEncoding& from) {
    CopyFrom(from);
    return *this;
  }
  inline RiceDeltaEncoding& operator=(RiceDeltaEncoding&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RiceDeltaEncoding& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RiceDeltaEncoding* internal_default_instance() {
    return reinterpret_cast<const RiceDeltaEncoding*>(
               &_RiceDeltaEncoding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RiceDeltaEncoding& a, RiceDeltaEncoding& b) {
    a.Swap(&b);
  }
  inline void Swap(RiceDeltaEncoding* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RiceDeltaEncoding* New() const final {
    return CreateMaybeMessage<RiceDeltaEncoding>(nullptr);
  }

  RiceDeltaEncoding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RiceDeltaEncoding>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RiceDeltaEncoding& from);
  void MergeFrom(const RiceDeltaEncoding& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RiceDeltaEncoding* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.RiceDeltaEncoding";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncodedDataFieldNumber = 4,
    kFirstValueFieldNumber = 1,
    kRiceParameterFieldNumber = 2,
    kNumEntriesFieldNumber = 3,
  };
  // optional bytes encoded_data = 4;
  bool has_encoded_data() const;
  void clear_encoded_data();
  const std::string& encoded_data() const;
  void set_encoded_data(const std::string& value);
  void set_encoded_data(std::string&& value);
  void set_encoded_data(const char* value);
  void set_encoded_data(const void* value, size_t size);
  std::string* mutable_encoded_data();
  std::string* release_encoded_data();
  void set_allocated_encoded_data(std::string* encoded_data);

  // optional int64 first_value = 1;
  bool has_first_value() const;
  void clear_first_value();
  ::PROTOBUF_NAMESPACE_ID::int64 first_value() const;
  void set_first_value(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int32 rice_parameter = 2;
  bool has_rice_parameter() const;
  void clear_rice_parameter();
  ::PROTOBUF_NAMESPACE_ID::int32 rice_parameter() const;
  void set_rice_parameter(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_entries = 3;
  bool has_num_entries() const;
  void clear_num_entries();
  ::PROTOBUF_NAMESPACE_ID::int32 num_entries() const;
  void set_num_entries(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:safe_browsing.RiceDeltaEncoding)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoded_data_;
  ::PROTOBUF_NAMESPACE_ID::int64 first_value_;
  ::PROTOBUF_NAMESPACE_ID::int32 rice_parameter_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_entries_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ThreatEntryMetadata_MetadataEntry :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ThreatEntryMetadata.MetadataEntry) */ {
 public:
  ThreatEntryMetadata_MetadataEntry();
  virtual ~ThreatEntryMetadata_MetadataEntry();

  ThreatEntryMetadata_MetadataEntry(const ThreatEntryMetadata_MetadataEntry& from);
  ThreatEntryMetadata_MetadataEntry(ThreatEntryMetadata_MetadataEntry&& from) noexcept
    : ThreatEntryMetadata_MetadataEntry() {
    *this = ::std::move(from);
  }

  inline ThreatEntryMetadata_MetadataEntry& operator=(const ThreatEntryMetadata_MetadataEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreatEntryMetadata_MetadataEntry& operator=(ThreatEntryMetadata_MetadataEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ThreatEntryMetadata_MetadataEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ThreatEntryMetadata_MetadataEntry* internal_default_instance() {
    return reinterpret_cast<const ThreatEntryMetadata_MetadataEntry*>(
               &_ThreatEntryMetadata_MetadataEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ThreatEntryMetadata_MetadataEntry& a, ThreatEntryMetadata_MetadataEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(ThreatEntryMetadata_MetadataEntry* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThreatEntryMetadata_MetadataEntry* New() const final {
    return CreateMaybeMessage<ThreatEntryMetadata_MetadataEntry>(nullptr);
  }

  ThreatEntryMetadata_MetadataEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThreatEntryMetadata_MetadataEntry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ThreatEntryMetadata_MetadataEntry& from);
  void MergeFrom(const ThreatEntryMetadata_MetadataEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatEntryMetadata_MetadataEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ThreatEntryMetadata.MetadataEntry";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional bytes key = 1;
  bool has_key() const;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);

  // optional bytes value = 2;
  bool has_value() const;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:safe_browsing.ThreatEntryMetadata.MetadataEntry)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ThreatEntryMetadata :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ThreatEntryMetadata) */ {
 public:
  ThreatEntryMetadata();
  virtual ~ThreatEntryMetadata();

  ThreatEntryMetadata(const ThreatEntryMetadata& from);
  ThreatEntryMetadata(ThreatEntryMetadata&& from) noexcept
    : ThreatEntryMetadata() {
    *this = ::std::move(from);
  }

  inline ThreatEntryMetadata& operator=(const ThreatEntryMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreatEntryMetadata& operator=(ThreatEntryMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ThreatEntryMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ThreatEntryMetadata* internal_default_instance() {
    return reinterpret_cast<const ThreatEntryMetadata*>(
               &_ThreatEntryMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ThreatEntryMetadata& a, ThreatEntryMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(ThreatEntryMetadata* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThreatEntryMetadata* New() const final {
    return CreateMaybeMessage<ThreatEntryMetadata>(nullptr);
  }

  ThreatEntryMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThreatEntryMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ThreatEntryMetadata& from);
  void MergeFrom(const ThreatEntryMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatEntryMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ThreatEntryMetadata";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ThreatEntryMetadata_MetadataEntry MetadataEntry;

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .safe_browsing.ThreatEntryMetadata.MetadataEntry entries = 1;
  int entries_size() const;
  void clear_entries();
  ::safe_browsing::ThreatEntryMetadata_MetadataEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntryMetadata_MetadataEntry >*
      mutable_entries();
  const ::safe_browsing::ThreatEntryMetadata_MetadataEntry& entries(int index) const;
  ::safe_browsing::ThreatEntryMetadata_MetadataEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntryMetadata_MetadataEntry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:safe_browsing.ThreatEntryMetadata)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntryMetadata_MetadataEntry > entries_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ThreatListDescriptor :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ThreatListDescriptor) */ {
 public:
  ThreatListDescriptor();
  virtual ~ThreatListDescriptor();

  ThreatListDescriptor(const ThreatListDescriptor& from);
  ThreatListDescriptor(ThreatListDescriptor&& from) noexcept
    : ThreatListDescriptor() {
    *this = ::std::move(from);
  }

  inline ThreatListDescriptor& operator=(const ThreatListDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreatListDescriptor& operator=(ThreatListDescriptor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ThreatListDescriptor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ThreatListDescriptor* internal_default_instance() {
    return reinterpret_cast<const ThreatListDescriptor*>(
               &_ThreatListDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ThreatListDescriptor& a, ThreatListDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(ThreatListDescriptor* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThreatListDescriptor* New() const final {
    return CreateMaybeMessage<ThreatListDescriptor>(nullptr);
  }

  ThreatListDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThreatListDescriptor>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ThreatListDescriptor& from);
  void MergeFrom(const ThreatListDescriptor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatListDescriptor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ThreatListDescriptor";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThreatTypeFieldNumber = 1,
    kPlatformTypeFieldNumber = 2,
    kThreatEntryTypeFieldNumber = 3,
  };
  // optional .safe_browsing.ThreatType threat_type = 1;
  bool has_threat_type() const;
  void clear_threat_type();
  ::safe_browsing::ThreatType threat_type() const;
  void set_threat_type(::safe_browsing::ThreatType value);

  // optional .safe_browsing.PlatformType platform_type = 2;
  bool has_platform_type() const;
  void clear_platform_type();
  ::safe_browsing::PlatformType platform_type() const;
  void set_platform_type(::safe_browsing::PlatformType value);

  // optional .safe_browsing.ThreatEntryType threat_entry_type = 3;
  bool has_threat_entry_type() const;
  void clear_threat_entry_type();
  ::safe_browsing::ThreatEntryType threat_entry_type() const;
  void set_threat_entry_type(::safe_browsing::ThreatEntryType value);

  // @@protoc_insertion_point(class_scope:safe_browsing.ThreatListDescriptor)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int threat_type_;
  int platform_type_;
  int threat_entry_type_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ListThreatListsResponse :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ListThreatListsResponse) */ {
 public:
  ListThreatListsResponse();
  virtual ~ListThreatListsResponse();

  ListThreatListsResponse(const ListThreatListsResponse& from);
  ListThreatListsResponse(ListThreatListsResponse&& from) noexcept
    : ListThreatListsResponse() {
    *this = ::std::move(from);
  }

  inline ListThreatListsResponse& operator=(const ListThreatListsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListThreatListsResponse& operator=(ListThreatListsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ListThreatListsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListThreatListsResponse* internal_default_instance() {
    return reinterpret_cast<const ListThreatListsResponse*>(
               &_ListThreatListsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ListThreatListsResponse& a, ListThreatListsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListThreatListsResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListThreatListsResponse* New() const final {
    return CreateMaybeMessage<ListThreatListsResponse>(nullptr);
  }

  ListThreatListsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListThreatListsResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ListThreatListsResponse& from);
  void MergeFrom(const ListThreatListsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListThreatListsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ListThreatListsResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThreatListsFieldNumber = 1,
  };
  // repeated .safe_browsing.ThreatListDescriptor threat_lists = 1;
  int threat_lists_size() const;
  void clear_threat_lists();
  ::safe_browsing::ThreatListDescriptor* mutable_threat_lists(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatListDescriptor >*
      mutable_threat_lists();
  const ::safe_browsing::ThreatListDescriptor& threat_lists(int index) const;
  ::safe_browsing::ThreatListDescriptor* add_threat_lists();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatListDescriptor >&
      threat_lists() const;

  // @@protoc_insertion_point(class_scope:safe_browsing.ListThreatListsResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatListDescriptor > threat_lists_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class Duration :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.Duration) */ {
 public:
  Duration();
  virtual ~Duration();

  Duration(const Duration& from);
  Duration(Duration&& from) noexcept
    : Duration() {
    *this = ::std::move(from);
  }

  inline Duration& operator=(const Duration& from) {
    CopyFrom(from);
    return *this;
  }
  inline Duration& operator=(Duration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Duration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Duration* internal_default_instance() {
    return reinterpret_cast<const Duration*>(
               &_Duration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Duration& a, Duration& b) {
    a.Swap(&b);
  }
  inline void Swap(Duration* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Duration* New() const final {
    return CreateMaybeMessage<Duration>(nullptr);
  }

  Duration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Duration>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Duration& from);
  void MergeFrom(const Duration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Duration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.Duration";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 1,
    kNanosFieldNumber = 2,
  };
  // optional int64 seconds = 1;
  bool has_seconds() const;
  void clear_seconds();
  ::PROTOBUF_NAMESPACE_ID::int64 seconds() const;
  void set_seconds(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int32 nanos = 2;
  bool has_nanos() const;
  void clear_nanos();
  ::PROTOBUF_NAMESPACE_ID::int32 nanos() const;
  void set_nanos(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:safe_browsing.Duration)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 seconds_;
  ::PROTOBUF_NAMESPACE_ID::int32 nanos_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ThreatInfo

// repeated .safe_browsing.ThreatType threat_types = 1;
inline int ThreatInfo::threat_types_size() const {
  return threat_types_.size();
}
inline void ThreatInfo::clear_threat_types() {
  threat_types_.Clear();
}
inline ::safe_browsing::ThreatType ThreatInfo::threat_types(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatInfo.threat_types)
  return static_cast< ::safe_browsing::ThreatType >(threat_types_.Get(index));
}
inline void ThreatInfo::set_threat_types(int index, ::safe_browsing::ThreatType value) {
  assert(::safe_browsing::ThreatType_IsValid(value));
  threat_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatInfo.threat_types)
}
inline void ThreatInfo::add_threat_types(::safe_browsing::ThreatType value) {
  assert(::safe_browsing::ThreatType_IsValid(value));
  threat_types_.Add(value);
  // @@protoc_insertion_point(field_add:safe_browsing.ThreatInfo.threat_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ThreatInfo::threat_types() const {
  // @@protoc_insertion_point(field_list:safe_browsing.ThreatInfo.threat_types)
  return threat_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ThreatInfo::mutable_threat_types() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.ThreatInfo.threat_types)
  return &threat_types_;
}

// repeated .safe_browsing.PlatformType platform_types = 2;
inline int ThreatInfo::platform_types_size() const {
  return platform_types_.size();
}
inline void ThreatInfo::clear_platform_types() {
  platform_types_.Clear();
}
inline ::safe_browsing::PlatformType ThreatInfo::platform_types(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatInfo.platform_types)
  return static_cast< ::safe_browsing::PlatformType >(platform_types_.Get(index));
}
inline void ThreatInfo::set_platform_types(int index, ::safe_browsing::PlatformType value) {
  assert(::safe_browsing::PlatformType_IsValid(value));
  platform_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatInfo.platform_types)
}
inline void ThreatInfo::add_platform_types(::safe_browsing::PlatformType value) {
  assert(::safe_browsing::PlatformType_IsValid(value));
  platform_types_.Add(value);
  // @@protoc_insertion_point(field_add:safe_browsing.ThreatInfo.platform_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ThreatInfo::platform_types() const {
  // @@protoc_insertion_point(field_list:safe_browsing.ThreatInfo.platform_types)
  return platform_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ThreatInfo::mutable_platform_types() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.ThreatInfo.platform_types)
  return &platform_types_;
}

// repeated .safe_browsing.ThreatEntryType threat_entry_types = 4;
inline int ThreatInfo::threat_entry_types_size() const {
  return threat_entry_types_.size();
}
inline void ThreatInfo::clear_threat_entry_types() {
  threat_entry_types_.Clear();
}
inline ::safe_browsing::ThreatEntryType ThreatInfo::threat_entry_types(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatInfo.threat_entry_types)
  return static_cast< ::safe_browsing::ThreatEntryType >(threat_entry_types_.Get(index));
}
inline void ThreatInfo::set_threat_entry_types(int index, ::safe_browsing::ThreatEntryType value) {
  assert(::safe_browsing::ThreatEntryType_IsValid(value));
  threat_entry_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatInfo.threat_entry_types)
}
inline void ThreatInfo::add_threat_entry_types(::safe_browsing::ThreatEntryType value) {
  assert(::safe_browsing::ThreatEntryType_IsValid(value));
  threat_entry_types_.Add(value);
  // @@protoc_insertion_point(field_add:safe_browsing.ThreatInfo.threat_entry_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ThreatInfo::threat_entry_types() const {
  // @@protoc_insertion_point(field_list:safe_browsing.ThreatInfo.threat_entry_types)
  return threat_entry_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ThreatInfo::mutable_threat_entry_types() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.ThreatInfo.threat_entry_types)
  return &threat_entry_types_;
}

// repeated .safe_browsing.ThreatEntry threat_entries = 3;
inline int ThreatInfo::threat_entries_size() const {
  return threat_entries_.size();
}
inline void ThreatInfo::clear_threat_entries() {
  threat_entries_.Clear();
}
inline ::safe_browsing::ThreatEntry* ThreatInfo::mutable_threat_entries(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatInfo.threat_entries)
  return threat_entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntry >*
ThreatInfo::mutable_threat_entries() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.ThreatInfo.threat_entries)
  return &threat_entries_;
}
inline const ::safe_browsing::ThreatEntry& ThreatInfo::threat_entries(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatInfo.threat_entries)
  return threat_entries_.Get(index);
}
inline ::safe_browsing::ThreatEntry* ThreatInfo::add_threat_entries() {
  // @@protoc_insertion_point(field_add:safe_browsing.ThreatInfo.threat_entries)
  return threat_entries_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntry >&
ThreatInfo::threat_entries() const {
  // @@protoc_insertion_point(field_list:safe_browsing.ThreatInfo.threat_entries)
  return threat_entries_;
}

// -------------------------------------------------------------------

// ThreatMatch

// optional .safe_browsing.ThreatType threat_type = 1;
inline bool ThreatMatch::has_threat_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ThreatMatch::clear_threat_type() {
  threat_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::safe_browsing::ThreatType ThreatMatch::threat_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatMatch.threat_type)
  return static_cast< ::safe_browsing::ThreatType >(threat_type_);
}
inline void ThreatMatch::set_threat_type(::safe_browsing::ThreatType value) {
  assert(::safe_browsing::ThreatType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  threat_type_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatMatch.threat_type)
}

// optional .safe_browsing.PlatformType platform_type = 2;
inline bool ThreatMatch::has_platform_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ThreatMatch::clear_platform_type() {
  platform_type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::safe_browsing::PlatformType ThreatMatch::platform_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatMatch.platform_type)
  return static_cast< ::safe_browsing::PlatformType >(platform_type_);
}
inline void ThreatMatch::set_platform_type(::safe_browsing::PlatformType value) {
  assert(::safe_browsing::PlatformType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  platform_type_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatMatch.platform_type)
}

// optional .safe_browsing.ThreatEntryType threat_entry_type = 6;
inline bool ThreatMatch::has_threat_entry_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ThreatMatch::clear_threat_entry_type() {
  threat_entry_type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::safe_browsing::ThreatEntryType ThreatMatch::threat_entry_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatMatch.threat_entry_type)
  return static_cast< ::safe_browsing::ThreatEntryType >(threat_entry_type_);
}
inline void ThreatMatch::set_threat_entry_type(::safe_browsing::ThreatEntryType value) {
  assert(::safe_browsing::ThreatEntryType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  threat_entry_type_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatMatch.threat_entry_type)
}

// optional .safe_browsing.ThreatEntry threat = 3;
inline bool ThreatMatch::has_threat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatMatch::clear_threat() {
  if (threat_ != nullptr) threat_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::safe_browsing::ThreatEntry& ThreatMatch::threat() const {
  const ::safe_browsing::ThreatEntry* p = threat_;
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatMatch.threat)
  return p != nullptr ? *p : *reinterpret_cast<const ::safe_browsing::ThreatEntry*>(
      &::safe_browsing::_ThreatEntry_default_instance_);
}
inline ::safe_browsing::ThreatEntry* ThreatMatch::release_threat() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatMatch.threat)
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::ThreatEntry* temp = threat_;
  threat_ = nullptr;
  return temp;
}
inline ::safe_browsing::ThreatEntry* ThreatMatch::mutable_threat() {
  _has_bits_[0] |= 0x00000001u;
  if (threat_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::ThreatEntry>(GetArenaNoVirtual());
    threat_ = p;
  }
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatMatch.threat)
  return threat_;
}
inline void ThreatMatch::set_allocated_threat(::safe_browsing::ThreatEntry* threat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete threat_;
  }
  if (threat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      threat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, threat, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  threat_ = threat;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatMatch.threat)
}

// optional .safe_browsing.ThreatEntryMetadata threat_entry_metadata = 4;
inline bool ThreatMatch::has_threat_entry_metadata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatMatch::clear_threat_entry_metadata() {
  if (threat_entry_metadata_ != nullptr) threat_entry_metadata_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::safe_browsing::ThreatEntryMetadata& ThreatMatch::threat_entry_metadata() const {
  const ::safe_browsing::ThreatEntryMetadata* p = threat_entry_metadata_;
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatMatch.threat_entry_metadata)
  return p != nullptr ? *p : *reinterpret_cast<const ::safe_browsing::ThreatEntryMetadata*>(
      &::safe_browsing::_ThreatEntryMetadata_default_instance_);
}
inline ::safe_browsing::ThreatEntryMetadata* ThreatMatch::release_threat_entry_metadata() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatMatch.threat_entry_metadata)
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::ThreatEntryMetadata* temp = threat_entry_metadata_;
  threat_entry_metadata_ = nullptr;
  return temp;
}
inline ::safe_browsing::ThreatEntryMetadata* ThreatMatch::mutable_threat_entry_metadata() {
  _has_bits_[0] |= 0x00000002u;
  if (threat_entry_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::ThreatEntryMetadata>(GetArenaNoVirtual());
    threat_entry_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatMatch.threat_entry_metadata)
  return threat_entry_metadata_;
}
inline void ThreatMatch::set_allocated_threat_entry_metadata(::safe_browsing::ThreatEntryMetadata* threat_entry_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete threat_entry_metadata_;
  }
  if (threat_entry_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      threat_entry_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, threat_entry_metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  threat_entry_metadata_ = threat_entry_metadata;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatMatch.threat_entry_metadata)
}

// optional .safe_browsing.Duration cache_duration = 5;
inline bool ThreatMatch::has_cache_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThreatMatch::clear_cache_duration() {
  if (cache_duration_ != nullptr) cache_duration_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::safe_browsing::Duration& ThreatMatch::cache_duration() const {
  const ::safe_browsing::Duration* p = cache_duration_;
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatMatch.cache_duration)
  return p != nullptr ? *p : *reinterpret_cast<const ::safe_browsing::Duration*>(
      &::safe_browsing::_Duration_default_instance_);
}
inline ::safe_browsing::Duration* ThreatMatch::release_cache_duration() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatMatch.cache_duration)
  _has_bits_[0] &= ~0x00000004u;
  ::safe_browsing::Duration* temp = cache_duration_;
  cache_duration_ = nullptr;
  return temp;
}
inline ::safe_browsing::Duration* ThreatMatch::mutable_cache_duration() {
  _has_bits_[0] |= 0x00000004u;
  if (cache_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::Duration>(GetArenaNoVirtual());
    cache_duration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatMatch.cache_duration)
  return cache_duration_;
}
inline void ThreatMatch::set_allocated_cache_duration(::safe_browsing::Duration* cache_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cache_duration_;
  }
  if (cache_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cache_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cache_duration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  cache_duration_ = cache_duration;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatMatch.cache_duration)
}

// -------------------------------------------------------------------

// FindThreatMatchesRequest

// optional .safe_browsing.ClientInfo client = 1;
inline bool FindThreatMatchesRequest::has_client() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FindThreatMatchesRequest::clear_client() {
  if (client_ != nullptr) client_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::safe_browsing::ClientInfo& FindThreatMatchesRequest::client() const {
  const ::safe_browsing::ClientInfo* p = client_;
  // @@protoc_insertion_point(field_get:safe_browsing.FindThreatMatchesRequest.client)
  return p != nullptr ? *p : *reinterpret_cast<const ::safe_browsing::ClientInfo*>(
      &::safe_browsing::_ClientInfo_default_instance_);
}
inline ::safe_browsing::ClientInfo* FindThreatMatchesRequest::release_client() {
  // @@protoc_insertion_point(field_release:safe_browsing.FindThreatMatchesRequest.client)
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::ClientInfo* temp = client_;
  client_ = nullptr;
  return temp;
}
inline ::safe_browsing::ClientInfo* FindThreatMatchesRequest::mutable_client() {
  _has_bits_[0] |= 0x00000001u;
  if (client_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::ClientInfo>(GetArenaNoVirtual());
    client_ = p;
  }
  // @@protoc_insertion_point(field_mutable:safe_browsing.FindThreatMatchesRequest.client)
  return client_;
}
inline void FindThreatMatchesRequest::set_allocated_client(::safe_browsing::ClientInfo* client) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete client_;
  }
  if (client) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      client = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_ = client;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FindThreatMatchesRequest.client)
}

// optional .safe_browsing.ThreatInfo threat_info = 2;
inline bool FindThreatMatchesRequest::has_threat_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FindThreatMatchesRequest::clear_threat_info() {
  if (threat_info_ != nullptr) threat_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::safe_browsing::ThreatInfo& FindThreatMatchesRequest::threat_info() const {
  const ::safe_browsing::ThreatInfo* p = threat_info_;
  // @@protoc_insertion_point(field_get:safe_browsing.FindThreatMatchesRequest.threat_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::safe_browsing::ThreatInfo*>(
      &::safe_browsing::_ThreatInfo_default_instance_);
}
inline ::safe_browsing::ThreatInfo* FindThreatMatchesRequest::release_threat_info() {
  // @@protoc_insertion_point(field_release:safe_browsing.FindThreatMatchesRequest.threat_info)
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::ThreatInfo* temp = threat_info_;
  threat_info_ = nullptr;
  return temp;
}
inline ::safe_browsing::ThreatInfo* FindThreatMatchesRequest::mutable_threat_info() {
  _has_bits_[0] |= 0x00000002u;
  if (threat_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::ThreatInfo>(GetArenaNoVirtual());
    threat_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:safe_browsing.FindThreatMatchesRequest.threat_info)
  return threat_info_;
}
inline void FindThreatMatchesRequest::set_allocated_threat_info(::safe_browsing::ThreatInfo* threat_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete threat_info_;
  }
  if (threat_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      threat_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, threat_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  threat_info_ = threat_info;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FindThreatMatchesRequest.threat_info)
}

// -------------------------------------------------------------------

// FindThreatMatchesResponse

// repeated .safe_browsing.ThreatMatch matches = 1;
inline int FindThreatMatchesResponse::matches_size() const {
  return matches_.size();
}
inline void FindThreatMatchesResponse::clear_matches() {
  matches_.Clear();
}
inline ::safe_browsing::ThreatMatch* FindThreatMatchesResponse::mutable_matches(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.FindThreatMatchesResponse.matches)
  return matches_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatMatch >*
FindThreatMatchesResponse::mutable_matches() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.FindThreatMatchesResponse.matches)
  return &matches_;
}
inline const ::safe_browsing::ThreatMatch& FindThreatMatchesResponse::matches(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.FindThreatMatchesResponse.matches)
  return matches_.Get(index);
}
inline ::safe_browsing::ThreatMatch* FindThreatMatchesResponse::add_matches() {
  // @@protoc_insertion_point(field_add:safe_browsing.FindThreatMatchesResponse.matches)
  return matches_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatMatch >&
FindThreatMatchesResponse::matches() const {
  // @@protoc_insertion_point(field_list:safe_browsing.FindThreatMatchesResponse.matches)
  return matches_;
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints

// optional int32 max_update_entries = 1;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::has_max_update_entries() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_max_update_entries() {
  max_update_entries_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::max_update_entries() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_update_entries)
  return max_update_entries_;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_max_update_entries(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  max_update_entries_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_update_entries)
}

// optional int32 max_database_entries = 2;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::has_max_database_entries() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_max_database_entries() {
  max_database_entries_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::max_database_entries() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_database_entries)
  return max_database_entries_;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_max_database_entries(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  max_database_entries_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_database_entries)
}

// optional string region = 3;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_region() {
  region_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::region() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
  return region_.GetNoArena();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_region(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  region_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_region(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  region_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_region(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  region_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_region(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  region_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}
inline std::string* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::mutable_region() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
  return region_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::release_region() {
  // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
  if (!has_region()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return region_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  region_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region);
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}

// repeated .safe_browsing.CompressionType supported_compressions = 4;
inline int FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::supported_compressions_size() const {
  return supported_compressions_.size();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_supported_compressions() {
  supported_compressions_.Clear();
}
inline ::safe_browsing::CompressionType FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::supported_compressions(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
  return static_cast< ::safe_browsing::CompressionType >(supported_compressions_.Get(index));
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_supported_compressions(int index, ::safe_browsing::CompressionType value) {
  assert(::safe_browsing::CompressionType_IsValid(value));
  supported_compressions_.Set(index, value);
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::add_supported_compressions(::safe_browsing::CompressionType value) {
  assert(::safe_browsing::CompressionType_IsValid(value));
  supported_compressions_.Add(value);
  // @@protoc_insertion_point(field_add:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::supported_compressions() const {
  // @@protoc_insertion_point(field_list:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
  return supported_compressions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::mutable_supported_compressions() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
  return &supported_compressions_;
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesRequest_ListUpdateRequest

// optional .safe_browsing.ThreatType threat_type = 1;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_threat_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_threat_type() {
  threat_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::safe_browsing::ThreatType FetchThreatListUpdatesRequest_ListUpdateRequest::threat_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_type)
  return static_cast< ::safe_browsing::ThreatType >(threat_type_);
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_threat_type(::safe_browsing::ThreatType value) {
  assert(::safe_browsing::ThreatType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  threat_type_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_type)
}

// optional .safe_browsing.PlatformType platform_type = 2;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_platform_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_platform_type() {
  platform_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::safe_browsing::PlatformType FetchThreatListUpdatesRequest_ListUpdateRequest::platform_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.platform_type)
  return static_cast< ::safe_browsing::PlatformType >(platform_type_);
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_platform_type(::safe_browsing::PlatformType value) {
  assert(::safe_browsing::PlatformType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  platform_type_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.platform_type)
}

// optional .safe_browsing.ThreatEntryType threat_entry_type = 5;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_threat_entry_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_threat_entry_type() {
  threat_entry_type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::safe_browsing::ThreatEntryType FetchThreatListUpdatesRequest_ListUpdateRequest::threat_entry_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_entry_type)
  return static_cast< ::safe_browsing::ThreatEntryType >(threat_entry_type_);
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_threat_entry_type(::safe_browsing::ThreatEntryType value) {
  assert(::safe_browsing::ThreatEntryType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  threat_entry_type_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_entry_type)
}

// optional bytes state = 3;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_state() {
  state_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FetchThreatListUpdatesRequest_ListUpdateRequest::state() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
  return state_.GetNoArena();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_state(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  state_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_state(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  state_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_state(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  state_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_state(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  state_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}
inline std::string* FetchThreatListUpdatesRequest_ListUpdateRequest::mutable_state() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
  return state_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FetchThreatListUpdatesRequest_ListUpdateRequest::release_state() {
  // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
  if (!has_state()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return state_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  state_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}

// optional .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_constraints() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_constraints() {
  if (constraints_ != nullptr) constraints_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& FetchThreatListUpdatesRequest_ListUpdateRequest::constraints() const {
  const ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* p = constraints_;
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
  return p != nullptr ? *p : *reinterpret_cast<const ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints*>(
      &::safe_browsing::_FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_default_instance_);
}
inline ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* FetchThreatListUpdatesRequest_ListUpdateRequest::release_constraints() {
  // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* temp = constraints_;
  constraints_ = nullptr;
  return temp;
}
inline ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* FetchThreatListUpdatesRequest_ListUpdateRequest::mutable_constraints() {
  _has_bits_[0] |= 0x00000002u;
  if (constraints_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints>(GetArenaNoVirtual());
    constraints_ = p;
  }
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
  return constraints_;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_allocated_constraints(::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* constraints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete constraints_;
  }
  if (constraints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      constraints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, constraints, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  constraints_ = constraints;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesRequest

// optional .safe_browsing.ClientInfo client = 1;
inline bool FetchThreatListUpdatesRequest::has_client() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchThreatListUpdatesRequest::clear_client() {
  if (client_ != nullptr) client_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::safe_browsing::ClientInfo& FetchThreatListUpdatesRequest::client() const {
  const ::safe_browsing::ClientInfo* p = client_;
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.client)
  return p != nullptr ? *p : *reinterpret_cast<const ::safe_browsing::ClientInfo*>(
      &::safe_browsing::_ClientInfo_default_instance_);
}
inline ::safe_browsing::ClientInfo* FetchThreatListUpdatesRequest::release_client() {
  // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesRequest.client)
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::ClientInfo* temp = client_;
  client_ = nullptr;
  return temp;
}
inline ::safe_browsing::ClientInfo* FetchThreatListUpdatesRequest::mutable_client() {
  _has_bits_[0] |= 0x00000001u;
  if (client_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::ClientInfo>(GetArenaNoVirtual());
    client_ = p;
  }
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesRequest.client)
  return client_;
}
inline void FetchThreatListUpdatesRequest::set_allocated_client(::safe_browsing::ClientInfo* client) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete client_;
  }
  if (client) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      client = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_ = client;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesRequest.client)
}

// repeated .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
inline int FetchThreatListUpdatesRequest::list_update_requests_size() const {
  return list_update_requests_.size();
}
inline void FetchThreatListUpdatesRequest::clear_list_update_requests() {
  list_update_requests_.Clear();
}
inline ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest* FetchThreatListUpdatesRequest::mutable_list_update_requests(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesRequest.list_update_requests)
  return list_update_requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest >*
FetchThreatListUpdatesRequest::mutable_list_update_requests() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.FetchThreatListUpdatesRequest.list_update_requests)
  return &list_update_requests_;
}
inline const ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest& FetchThreatListUpdatesRequest::list_update_requests(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.list_update_requests)
  return list_update_requests_.Get(index);
}
inline ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest* FetchThreatListUpdatesRequest::add_list_update_requests() {
  // @@protoc_insertion_point(field_add:safe_browsing.FetchThreatListUpdatesRequest.list_update_requests)
  return list_update_requests_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest >&
FetchThreatListUpdatesRequest::list_update_requests() const {
  // @@protoc_insertion_point(field_list:safe_browsing.FetchThreatListUpdatesRequest.list_update_requests)
  return list_update_requests_;
}

// optional .safe_browsing.ChromeClientInfo chrome_client_info = 4;
inline bool FetchThreatListUpdatesRequest::has_chrome_client_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FetchThreatListUpdatesRequest::clear_chrome_client_info() {
  if (chrome_client_info_ != nullptr) chrome_client_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::safe_browsing::ChromeClientInfo& FetchThreatListUpdatesRequest::chrome_client_info() const {
  const ::safe_browsing::ChromeClientInfo* p = chrome_client_info_;
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.chrome_client_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::safe_browsing::ChromeClientInfo*>(
      &::safe_browsing::_ChromeClientInfo_default_instance_);
}
inline ::safe_browsing::ChromeClientInfo* FetchThreatListUpdatesRequest::release_chrome_client_info() {
  // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesRequest.chrome_client_info)
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::ChromeClientInfo* temp = chrome_client_info_;
  chrome_client_info_ = nullptr;
  return temp;
}
inline ::safe_browsing::ChromeClientInfo* FetchThreatListUpdatesRequest::mutable_chrome_client_info() {
  _has_bits_[0] |= 0x00000002u;
  if (chrome_client_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::ChromeClientInfo>(GetArenaNoVirtual());
    chrome_client_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesRequest.chrome_client_info)
  return chrome_client_info_;
}
inline void FetchThreatListUpdatesRequest::set_allocated_chrome_client_info(::safe_browsing::ChromeClientInfo* chrome_client_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete chrome_client_info_;
  }
  if (chrome_client_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      chrome_client_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chrome_client_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  chrome_client_info_ = chrome_client_info;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesRequest.chrome_client_info)
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesResponse_ListUpdateResponse

// optional .safe_browsing.ThreatType threat_type = 1;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_threat_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_threat_type() {
  threat_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::safe_browsing::ThreatType FetchThreatListUpdatesResponse_ListUpdateResponse::threat_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_type)
  return static_cast< ::safe_browsing::ThreatType >(threat_type_);
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_threat_type(::safe_browsing::ThreatType value) {
  assert(::safe_browsing::ThreatType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  threat_type_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_type)
}

// optional .safe_browsing.ThreatEntryType threat_entry_type = 2;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_threat_entry_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_threat_entry_type() {
  threat_entry_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::safe_browsing::ThreatEntryType FetchThreatListUpdatesResponse_ListUpdateResponse::threat_entry_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_entry_type)
  return static_cast< ::safe_browsing::ThreatEntryType >(threat_entry_type_);
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_threat_entry_type(::safe_browsing::ThreatEntryType value) {
  assert(::safe_browsing::ThreatEntryType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  threat_entry_type_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_entry_type)
}

// optional .safe_browsing.PlatformType platform_type = 3;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_platform_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_platform_type() {
  platform_type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::safe_browsing::PlatformType FetchThreatListUpdatesResponse_ListUpdateResponse::platform_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.platform_type)
  return static_cast< ::safe_browsing::PlatformType >(platform_type_);
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_platform_type(::safe_browsing::PlatformType value) {
  assert(::safe_browsing::PlatformType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  platform_type_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.platform_type)
}

// optional .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_response_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_response_type() {
  response_type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::response_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.response_type)
  return static_cast< ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType >(response_type_);
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_response_type(::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType value) {
  assert(::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  response_type_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.response_type)
}

// repeated .safe_browsing.ThreatEntrySet additions = 5;
inline int FetchThreatListUpdatesResponse_ListUpdateResponse::additions_size() const {
  return additions_.size();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_additions() {
  additions_.Clear();
}
inline ::safe_browsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_additions(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return additions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntrySet >*
FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_additions() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return &additions_;
}
inline const ::safe_browsing::ThreatEntrySet& FetchThreatListUpdatesResponse_ListUpdateResponse::additions(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return additions_.Get(index);
}
inline ::safe_browsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::add_additions() {
  // @@protoc_insertion_point(field_add:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return additions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntrySet >&
FetchThreatListUpdatesResponse_ListUpdateResponse::additions() const {
  // @@protoc_insertion_point(field_list:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return additions_;
}

// repeated .safe_browsing.ThreatEntrySet removals = 6;
inline int FetchThreatListUpdatesResponse_ListUpdateResponse::removals_size() const {
  return removals_.size();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_removals() {
  removals_.Clear();
}
inline ::safe_browsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_removals(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return removals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntrySet >*
FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_removals() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return &removals_;
}
inline const ::safe_browsing::ThreatEntrySet& FetchThreatListUpdatesResponse_ListUpdateResponse::removals(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return removals_.Get(index);
}
inline ::safe_browsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::add_removals() {
  // @@protoc_insertion_point(field_add:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return removals_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntrySet >&
FetchThreatListUpdatesResponse_ListUpdateResponse::removals() const {
  // @@protoc_insertion_point(field_list:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return removals_;
}

// optional bytes new_client_state = 7;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_new_client_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_new_client_state() {
  new_client_state_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FetchThreatListUpdatesResponse_ListUpdateResponse::new_client_state() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
  return new_client_state_.GetNoArena();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_new_client_state(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  new_client_state_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_new_client_state(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  new_client_state_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_new_client_state(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  new_client_state_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_new_client_state(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  new_client_state_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}
inline std::string* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_new_client_state() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
  return new_client_state_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FetchThreatListUpdatesResponse_ListUpdateResponse::release_new_client_state() {
  // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
  if (!has_new_client_state()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return new_client_state_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_allocated_new_client_state(std::string* new_client_state) {
  if (new_client_state != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  new_client_state_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_client_state);
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}

// optional .safe_browsing.Checksum checksum = 8;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_checksum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_checksum() {
  if (checksum_ != nullptr) checksum_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::safe_browsing::Checksum& FetchThreatListUpdatesResponse_ListUpdateResponse::checksum() const {
  const ::safe_browsing::Checksum* p = checksum_;
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
  return p != nullptr ? *p : *reinterpret_cast<const ::safe_browsing::Checksum*>(
      &::safe_browsing::_Checksum_default_instance_);
}
inline ::safe_browsing::Checksum* FetchThreatListUpdatesResponse_ListUpdateResponse::release_checksum() {
  // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::Checksum* temp = checksum_;
  checksum_ = nullptr;
  return temp;
}
inline ::safe_browsing::Checksum* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_checksum() {
  _has_bits_[0] |= 0x00000002u;
  if (checksum_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::Checksum>(GetArenaNoVirtual());
    checksum_ = p;
  }
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
  return checksum_;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_allocated_checksum(::safe_browsing::Checksum* checksum) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete checksum_;
  }
  if (checksum) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      checksum = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, checksum, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  checksum_ = checksum;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesResponse

// repeated .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
inline int FetchThreatListUpdatesResponse::list_update_responses_size() const {
  return list_update_responses_.size();
}
inline void FetchThreatListUpdatesResponse::clear_list_update_responses() {
  list_update_responses_.Clear();
}
inline ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse* FetchThreatListUpdatesResponse::mutable_list_update_responses(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesResponse.list_update_responses)
  return list_update_responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse >*
FetchThreatListUpdatesResponse::mutable_list_update_responses() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.FetchThreatListUpdatesResponse.list_update_responses)
  return &list_update_responses_;
}
inline const ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse& FetchThreatListUpdatesResponse::list_update_responses(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.list_update_responses)
  return list_update_responses_.Get(index);
}
inline ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse* FetchThreatListUpdatesResponse::add_list_update_responses() {
  // @@protoc_insertion_point(field_add:safe_browsing.FetchThreatListUpdatesResponse.list_update_responses)
  return list_update_responses_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse >&
FetchThreatListUpdatesResponse::list_update_responses() const {
  // @@protoc_insertion_point(field_list:safe_browsing.FetchThreatListUpdatesResponse.list_update_responses)
  return list_update_responses_;
}

// optional .safe_browsing.Duration minimum_wait_duration = 2;
inline bool FetchThreatListUpdatesResponse::has_minimum_wait_duration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchThreatListUpdatesResponse::clear_minimum_wait_duration() {
  if (minimum_wait_duration_ != nullptr) minimum_wait_duration_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::safe_browsing::Duration& FetchThreatListUpdatesResponse::minimum_wait_duration() const {
  const ::safe_browsing::Duration* p = minimum_wait_duration_;
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
  return p != nullptr ? *p : *reinterpret_cast<const ::safe_browsing::Duration*>(
      &::safe_browsing::_Duration_default_instance_);
}
inline ::safe_browsing::Duration* FetchThreatListUpdatesResponse::release_minimum_wait_duration() {
  // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::Duration* temp = minimum_wait_duration_;
  minimum_wait_duration_ = nullptr;
  return temp;
}
inline ::safe_browsing::Duration* FetchThreatListUpdatesResponse::mutable_minimum_wait_duration() {
  _has_bits_[0] |= 0x00000001u;
  if (minimum_wait_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::Duration>(GetArenaNoVirtual());
    minimum_wait_duration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
  return minimum_wait_duration_;
}
inline void FetchThreatListUpdatesResponse::set_allocated_minimum_wait_duration(::safe_browsing::Duration* minimum_wait_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete minimum_wait_duration_;
  }
  if (minimum_wait_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      minimum_wait_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, minimum_wait_duration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  minimum_wait_duration_ = minimum_wait_duration;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
}

// -------------------------------------------------------------------

// FindFullHashesRequest

// optional .safe_browsing.ClientInfo client = 1;
inline bool FindFullHashesRequest::has_client() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FindFullHashesRequest::clear_client() {
  if (client_ != nullptr) client_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::safe_browsing::ClientInfo& FindFullHashesRequest::client() const {
  const ::safe_browsing::ClientInfo* p = client_;
  // @@protoc_insertion_point(field_get:safe_browsing.FindFullHashesRequest.client)
  return p != nullptr ? *p : *reinterpret_cast<const ::safe_browsing::ClientInfo*>(
      &::safe_browsing::_ClientInfo_default_instance_);
}
inline ::safe_browsing::ClientInfo* FindFullHashesRequest::release_client() {
  // @@protoc_insertion_point(field_release:safe_browsing.FindFullHashesRequest.client)
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::ClientInfo* temp = client_;
  client_ = nullptr;
  return temp;
}
inline ::safe_browsing::ClientInfo* FindFullHashesRequest::mutable_client() {
  _has_bits_[0] |= 0x00000001u;
  if (client_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::ClientInfo>(GetArenaNoVirtual());
    client_ = p;
  }
  // @@protoc_insertion_point(field_mutable:safe_browsing.FindFullHashesRequest.client)
  return client_;
}
inline void FindFullHashesRequest::set_allocated_client(::safe_browsing::ClientInfo* client) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete client_;
  }
  if (client) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      client = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_ = client;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FindFullHashesRequest.client)
}

// repeated bytes client_states = 2;
inline int FindFullHashesRequest::client_states_size() const {
  return client_states_.size();
}
inline void FindFullHashesRequest::clear_client_states() {
  client_states_.Clear();
}
inline const std::string& FindFullHashesRequest::client_states(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.FindFullHashesRequest.client_states)
  return client_states_.Get(index);
}
inline std::string* FindFullHashesRequest::mutable_client_states(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.FindFullHashesRequest.client_states)
  return client_states_.Mutable(index);
}
inline void FindFullHashesRequest::set_client_states(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:safe_browsing.FindFullHashesRequest.client_states)
  client_states_.Mutable(index)->assign(value);
}
inline void FindFullHashesRequest::set_client_states(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:safe_browsing.FindFullHashesRequest.client_states)
  client_states_.Mutable(index)->assign(std::move(value));
}
inline void FindFullHashesRequest::set_client_states(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  client_states_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:safe_browsing.FindFullHashesRequest.client_states)
}
inline void FindFullHashesRequest::set_client_states(int index, const void* value, size_t size) {
  client_states_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:safe_browsing.FindFullHashesRequest.client_states)
}
inline std::string* FindFullHashesRequest::add_client_states() {
  // @@protoc_insertion_point(field_add_mutable:safe_browsing.FindFullHashesRequest.client_states)
  return client_states_.Add();
}
inline void FindFullHashesRequest::add_client_states(const std::string& value) {
  client_states_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:safe_browsing.FindFullHashesRequest.client_states)
}
inline void FindFullHashesRequest::add_client_states(std::string&& value) {
  client_states_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:safe_browsing.FindFullHashesRequest.client_states)
}
inline void FindFullHashesRequest::add_client_states(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  client_states_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:safe_browsing.FindFullHashesRequest.client_states)
}
inline void FindFullHashesRequest::add_client_states(const void* value, size_t size) {
  client_states_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:safe_browsing.FindFullHashesRequest.client_states)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FindFullHashesRequest::client_states() const {
  // @@protoc_insertion_point(field_list:safe_browsing.FindFullHashesRequest.client_states)
  return client_states_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FindFullHashesRequest::mutable_client_states() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.FindFullHashesRequest.client_states)
  return &client_states_;
}

// optional .safe_browsing.ThreatInfo threat_info = 3;
inline bool FindFullHashesRequest::has_threat_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FindFullHashesRequest::clear_threat_info() {
  if (threat_info_ != nullptr) threat_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::safe_browsing::ThreatInfo& FindFullHashesRequest::threat_info() const {
  const ::safe_browsing::ThreatInfo* p = threat_info_;
  // @@protoc_insertion_point(field_get:safe_browsing.FindFullHashesRequest.threat_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::safe_browsing::ThreatInfo*>(
      &::safe_browsing::_ThreatInfo_default_instance_);
}
inline ::safe_browsing::ThreatInfo* FindFullHashesRequest::release_threat_info() {
  // @@protoc_insertion_point(field_release:safe_browsing.FindFullHashesRequest.threat_info)
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::ThreatInfo* temp = threat_info_;
  threat_info_ = nullptr;
  return temp;
}
inline ::safe_browsing::ThreatInfo* FindFullHashesRequest::mutable_threat_info() {
  _has_bits_[0] |= 0x00000002u;
  if (threat_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::ThreatInfo>(GetArenaNoVirtual());
    threat_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:safe_browsing.FindFullHashesRequest.threat_info)
  return threat_info_;
}
inline void FindFullHashesRequest::set_allocated_threat_info(::safe_browsing::ThreatInfo* threat_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete threat_info_;
  }
  if (threat_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      threat_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, threat_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  threat_info_ = threat_info;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FindFullHashesRequest.threat_info)
}

// -------------------------------------------------------------------

// FindFullHashesResponse

// repeated .safe_browsing.ThreatMatch matches = 1;
inline int FindFullHashesResponse::matches_size() const {
  return matches_.size();
}
inline void FindFullHashesResponse::clear_matches() {
  matches_.Clear();
}
inline ::safe_browsing::ThreatMatch* FindFullHashesResponse::mutable_matches(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.FindFullHashesResponse.matches)
  return matches_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatMatch >*
FindFullHashesResponse::mutable_matches() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.FindFullHashesResponse.matches)
  return &matches_;
}
inline const ::safe_browsing::ThreatMatch& FindFullHashesResponse::matches(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.FindFullHashesResponse.matches)
  return matches_.Get(index);
}
inline ::safe_browsing::ThreatMatch* FindFullHashesResponse::add_matches() {
  // @@protoc_insertion_point(field_add:safe_browsing.FindFullHashesResponse.matches)
  return matches_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatMatch >&
FindFullHashesResponse::matches() const {
  // @@protoc_insertion_point(field_list:safe_browsing.FindFullHashesResponse.matches)
  return matches_;
}

// optional .safe_browsing.Duration minimum_wait_duration = 2;
inline bool FindFullHashesResponse::has_minimum_wait_duration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FindFullHashesResponse::clear_minimum_wait_duration() {
  if (minimum_wait_duration_ != nullptr) minimum_wait_duration_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::safe_browsing::Duration& FindFullHashesResponse::minimum_wait_duration() const {
  const ::safe_browsing::Duration* p = minimum_wait_duration_;
  // @@protoc_insertion_point(field_get:safe_browsing.FindFullHashesResponse.minimum_wait_duration)
  return p != nullptr ? *p : *reinterpret_cast<const ::safe_browsing::Duration*>(
      &::safe_browsing::_Duration_default_instance_);
}
inline ::safe_browsing::Duration* FindFullHashesResponse::release_minimum_wait_duration() {
  // @@protoc_insertion_point(field_release:safe_browsing.FindFullHashesResponse.minimum_wait_duration)
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::Duration* temp = minimum_wait_duration_;
  minimum_wait_duration_ = nullptr;
  return temp;
}
inline ::safe_browsing::Duration* FindFullHashesResponse::mutable_minimum_wait_duration() {
  _has_bits_[0] |= 0x00000001u;
  if (minimum_wait_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::Duration>(GetArenaNoVirtual());
    minimum_wait_duration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:safe_browsing.FindFullHashesResponse.minimum_wait_duration)
  return minimum_wait_duration_;
}
inline void FindFullHashesResponse::set_allocated_minimum_wait_duration(::safe_browsing::Duration* minimum_wait_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete minimum_wait_duration_;
  }
  if (minimum_wait_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      minimum_wait_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, minimum_wait_duration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  minimum_wait_duration_ = minimum_wait_duration;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FindFullHashesResponse.minimum_wait_duration)
}

// optional .safe_browsing.Duration negative_cache_duration = 3;
inline bool FindFullHashesResponse::has_negative_cache_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FindFullHashesResponse::clear_negative_cache_duration() {
  if (negative_cache_duration_ != nullptr) negative_cache_duration_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::safe_browsing::Duration& FindFullHashesResponse::negative_cache_duration() const {
  const ::safe_browsing::Duration* p = negative_cache_duration_;
  // @@protoc_insertion_point(field_get:safe_browsing.FindFullHashesResponse.negative_cache_duration)
  return p != nullptr ? *p : *reinterpret_cast<const ::safe_browsing::Duration*>(
      &::safe_browsing::_Duration_default_instance_);
}
inline ::safe_browsing::Duration* FindFullHashesResponse::release_negative_cache_duration() {
  // @@protoc_insertion_point(field_release:safe_browsing.FindFullHashesResponse.negative_cache_duration)
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::Duration* temp = negative_cache_duration_;
  negative_cache_duration_ = nullptr;
  return temp;
}
inline ::safe_browsing::Duration* FindFullHashesResponse::mutable_negative_cache_duration() {
  _has_bits_[0] |= 0x00000002u;
  if (negative_cache_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::Duration>(GetArenaNoVirtual());
    negative_cache_duration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:safe_browsing.FindFullHashesResponse.negative_cache_duration)
  return negative_cache_duration_;
}
inline void FindFullHashesResponse::set_allocated_negative_cache_duration(::safe_browsing::Duration* negative_cache_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete negative_cache_duration_;
  }
  if (negative_cache_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      negative_cache_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, negative_cache_duration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  negative_cache_duration_ = negative_cache_duration;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FindFullHashesResponse.negative_cache_duration)
}

// -------------------------------------------------------------------

// ThreatHit_ThreatSource

// optional string url = 1;
inline bool ThreatHit_ThreatSource::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatHit_ThreatSource::clear_url() {
  url_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ThreatHit_ThreatSource::url() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.ThreatSource.url)
  return url_.GetNoArena();
}
inline void ThreatHit_ThreatSource::set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatHit.ThreatSource.url)
}
inline void ThreatHit_ThreatSource::set_url(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  url_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safe_browsing.ThreatHit.ThreatSource.url)
}
inline void ThreatHit_ThreatSource::set_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safe_browsing.ThreatHit.ThreatSource.url)
}
inline void ThreatHit_ThreatSource::set_url(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safe_browsing.ThreatHit.ThreatSource.url)
}
inline std::string* ThreatHit_ThreatSource::mutable_url() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatHit.ThreatSource.url)
  return url_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ThreatHit_ThreatSource::release_url() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatHit.ThreatSource.url)
  if (!has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return url_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ThreatHit_ThreatSource::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  url_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatHit.ThreatSource.url)
}

// optional .safe_browsing.ThreatHit.ThreatSourceType type = 2;
inline bool ThreatHit_ThreatSource::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ThreatHit_ThreatSource::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::safe_browsing::ThreatHit_ThreatSourceType ThreatHit_ThreatSource::type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.ThreatSource.type)
  return static_cast< ::safe_browsing::ThreatHit_ThreatSourceType >(type_);
}
inline void ThreatHit_ThreatSource::set_type(::safe_browsing::ThreatHit_ThreatSourceType value) {
  assert(::safe_browsing::ThreatHit_ThreatSourceType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  type_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatHit.ThreatSource.type)
}

// optional string remote_ip = 3;
inline bool ThreatHit_ThreatSource::has_remote_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatHit_ThreatSource::clear_remote_ip() {
  remote_ip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ThreatHit_ThreatSource::remote_ip() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.ThreatSource.remote_ip)
  return remote_ip_.GetNoArena();
}
inline void ThreatHit_ThreatSource::set_remote_ip(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  remote_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatHit.ThreatSource.remote_ip)
}
inline void ThreatHit_ThreatSource::set_remote_ip(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  remote_ip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safe_browsing.ThreatHit.ThreatSource.remote_ip)
}
inline void ThreatHit_ThreatSource::set_remote_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  remote_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safe_browsing.ThreatHit.ThreatSource.remote_ip)
}
inline void ThreatHit_ThreatSource::set_remote_ip(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  remote_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safe_browsing.ThreatHit.ThreatSource.remote_ip)
}
inline std::string* ThreatHit_ThreatSource::mutable_remote_ip() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatHit.ThreatSource.remote_ip)
  return remote_ip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ThreatHit_ThreatSource::release_remote_ip() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatHit.ThreatSource.remote_ip)
  if (!has_remote_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return remote_ip_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ThreatHit_ThreatSource::set_allocated_remote_ip(std::string* remote_ip) {
  if (remote_ip != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  remote_ip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), remote_ip);
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatHit.ThreatSource.remote_ip)
}

// optional string referrer = 4;
inline bool ThreatHit_ThreatSource::has_referrer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThreatHit_ThreatSource::clear_referrer() {
  referrer_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ThreatHit_ThreatSource::referrer() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.ThreatSource.referrer)
  return referrer_.GetNoArena();
}
inline void ThreatHit_ThreatSource::set_referrer(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  referrer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatHit.ThreatSource.referrer)
}
inline void ThreatHit_ThreatSource::set_referrer(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  referrer_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safe_browsing.ThreatHit.ThreatSource.referrer)
}
inline void ThreatHit_ThreatSource::set_referrer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  referrer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safe_browsing.ThreatHit.ThreatSource.referrer)
}
inline void ThreatHit_ThreatSource::set_referrer(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  referrer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safe_browsing.ThreatHit.ThreatSource.referrer)
}
inline std::string* ThreatHit_ThreatSource::mutable_referrer() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatHit.ThreatSource.referrer)
  return referrer_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ThreatHit_ThreatSource::release_referrer() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatHit.ThreatSource.referrer)
  if (!has_referrer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return referrer_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ThreatHit_ThreatSource::set_allocated_referrer(std::string* referrer) {
  if (referrer != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  referrer_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), referrer);
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatHit.ThreatSource.referrer)
}

// -------------------------------------------------------------------

// ThreatHit

// optional .safe_browsing.ThreatType threat_type = 1;
inline bool ThreatHit::has_threat_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatHit::clear_threat_type() {
  threat_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::safe_browsing::ThreatType ThreatHit::threat_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.threat_type)
  return static_cast< ::safe_browsing::ThreatType >(threat_type_);
}
inline void ThreatHit::set_threat_type(::safe_browsing::ThreatType value) {
  assert(::safe_browsing::ThreatType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  threat_type_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatHit.threat_type)
}

// optional .safe_browsing.PlatformType platform_type = 2;
inline bool ThreatHit::has_platform_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThreatHit::clear_platform_type() {
  platform_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::safe_browsing::PlatformType ThreatHit::platform_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.platform_type)
  return static_cast< ::safe_browsing::PlatformType >(platform_type_);
}
inline void ThreatHit::set_platform_type(::safe_browsing::PlatformType value) {
  assert(::safe_browsing::PlatformType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  platform_type_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatHit.platform_type)
}

// optional .safe_browsing.ThreatEntry entry = 3;
inline bool ThreatHit::has_entry() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatHit::clear_entry() {
  if (entry_ != nullptr) entry_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::safe_browsing::ThreatEntry& ThreatHit::entry() const {
  const ::safe_browsing::ThreatEntry* p = entry_;
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.entry)
  return p != nullptr ? *p : *reinterpret_cast<const ::safe_browsing::ThreatEntry*>(
      &::safe_browsing::_ThreatEntry_default_instance_);
}
inline ::safe_browsing::ThreatEntry* ThreatHit::release_entry() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatHit.entry)
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::ThreatEntry* temp = entry_;
  entry_ = nullptr;
  return temp;
}
inline ::safe_browsing::ThreatEntry* ThreatHit::mutable_entry() {
  _has_bits_[0] |= 0x00000001u;
  if (entry_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::ThreatEntry>(GetArenaNoVirtual());
    entry_ = p;
  }
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatHit.entry)
  return entry_;
}
inline void ThreatHit::set_allocated_entry(::safe_browsing::ThreatEntry* entry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete entry_;
  }
  if (entry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      entry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, entry, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  entry_ = entry;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatHit.entry)
}

// repeated .safe_browsing.ThreatHit.ThreatSource resources = 4;
inline int ThreatHit::resources_size() const {
  return resources_.size();
}
inline void ThreatHit::clear_resources() {
  resources_.Clear();
}
inline ::safe_browsing::ThreatHit_ThreatSource* ThreatHit::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatHit.resources)
  return resources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatHit_ThreatSource >*
ThreatHit::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.ThreatHit.resources)
  return &resources_;
}
inline const ::safe_browsing::ThreatHit_ThreatSource& ThreatHit::resources(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.resources)
  return resources_.Get(index);
}
inline ::safe_browsing::ThreatHit_ThreatSource* ThreatHit::add_resources() {
  // @@protoc_insertion_point(field_add:safe_browsing.ThreatHit.resources)
  return resources_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatHit_ThreatSource >&
ThreatHit::resources() const {
  // @@protoc_insertion_point(field_list:safe_browsing.ThreatHit.resources)
  return resources_;
}

// -------------------------------------------------------------------

// ClientInfo

// optional string client_id = 1;
inline bool ClientInfo::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientInfo::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientInfo::client_id() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ClientInfo.client_id)
  return client_id_.GetNoArena();
}
inline void ClientInfo::set_client_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safe_browsing.ClientInfo.client_id)
}
inline void ClientInfo::set_client_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  client_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safe_browsing.ClientInfo.client_id)
}
inline void ClientInfo::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safe_browsing.ClientInfo.client_id)
}
inline void ClientInfo::set_client_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safe_browsing.ClientInfo.client_id)
}
inline std::string* ClientInfo::mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:safe_browsing.ClientInfo.client_id)
  return client_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ClientInfo::release_client_id() {
  // @@protoc_insertion_point(field_release:safe_browsing.ClientInfo.client_id)
  if (!has_client_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return client_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ClientInfo::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ClientInfo.client_id)
}

// optional string client_version = 2;
inline bool ClientInfo::has_client_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientInfo::clear_client_version() {
  client_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ClientInfo::client_version() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ClientInfo.client_version)
  return client_version_.GetNoArena();
}
inline void ClientInfo::set_client_version(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  client_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safe_browsing.ClientInfo.client_version)
}
inline void ClientInfo::set_client_version(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  client_version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safe_browsing.ClientInfo.client_version)
}
inline void ClientInfo::set_client_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  client_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safe_browsing.ClientInfo.client_version)
}
inline void ClientInfo::set_client_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  client_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safe_browsing.ClientInfo.client_version)
}
inline std::string* ClientInfo::mutable_client_version() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:safe_browsing.ClientInfo.client_version)
  return client_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ClientInfo::release_client_version() {
  // @@protoc_insertion_point(field_release:safe_browsing.ClientInfo.client_version)
  if (!has_client_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return client_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ClientInfo::set_allocated_client_version(std::string* client_version) {
  if (client_version != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  client_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_version);
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ClientInfo.client_version)
}

// -------------------------------------------------------------------

// ChromeClientInfo

// optional .safe_browsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
inline bool ChromeClientInfo::has_reporting_population() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChromeClientInfo::clear_reporting_population() {
  reporting_population_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::reporting_population() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ChromeClientInfo.reporting_population)
  return static_cast< ::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation >(reporting_population_);
}
inline void ChromeClientInfo::set_reporting_population(::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation value) {
  assert(::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  reporting_population_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.ChromeClientInfo.reporting_population)
}

// -------------------------------------------------------------------

// Checksum

// optional bytes sha256 = 1;
inline bool Checksum::has_sha256() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Checksum::clear_sha256() {
  sha256_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Checksum::sha256() const {
  // @@protoc_insertion_point(field_get:safe_browsing.Checksum.sha256)
  return sha256_.GetNoArena();
}
inline void Checksum::set_sha256(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sha256_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safe_browsing.Checksum.sha256)
}
inline void Checksum::set_sha256(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  sha256_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safe_browsing.Checksum.sha256)
}
inline void Checksum::set_sha256(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  sha256_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safe_browsing.Checksum.sha256)
}
inline void Checksum::set_sha256(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  sha256_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safe_browsing.Checksum.sha256)
}
inline std::string* Checksum::mutable_sha256() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:safe_browsing.Checksum.sha256)
  return sha256_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Checksum::release_sha256() {
  // @@protoc_insertion_point(field_release:safe_browsing.Checksum.sha256)
  if (!has_sha256()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return sha256_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Checksum::set_allocated_sha256(std::string* sha256) {
  if (sha256 != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sha256_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sha256);
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.Checksum.sha256)
}

// -------------------------------------------------------------------

// ThreatEntry

// optional bytes hash = 1;
inline bool ThreatEntry::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatEntry::clear_hash() {
  hash_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ThreatEntry::hash() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntry.hash)
  return hash_.GetNoArena();
}
inline void ThreatEntry::set_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatEntry.hash)
}
inline void ThreatEntry::set_hash(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safe_browsing.ThreatEntry.hash)
}
inline void ThreatEntry::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safe_browsing.ThreatEntry.hash)
}
inline void ThreatEntry::set_hash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safe_browsing.ThreatEntry.hash)
}
inline std::string* ThreatEntry::mutable_hash() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntry.hash)
  return hash_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ThreatEntry::release_hash() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntry.hash)
  if (!has_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return hash_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ThreatEntry::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hash_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntry.hash)
}

// optional string url = 2;
inline bool ThreatEntry::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatEntry::clear_url() {
  url_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ThreatEntry::url() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntry.url)
  return url_.GetNoArena();
}
inline void ThreatEntry::set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatEntry.url)
}
inline void ThreatEntry::set_url(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  url_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safe_browsing.ThreatEntry.url)
}
inline void ThreatEntry::set_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safe_browsing.ThreatEntry.url)
}
inline void ThreatEntry::set_url(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safe_browsing.ThreatEntry.url)
}
inline std::string* ThreatEntry::mutable_url() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntry.url)
  return url_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ThreatEntry::release_url() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntry.url)
  if (!has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return url_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ThreatEntry::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  url_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntry.url)
}

// -------------------------------------------------------------------

// ThreatEntrySet

// optional .safe_browsing.CompressionType compression_type = 1;
inline bool ThreatEntrySet::has_compression_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ThreatEntrySet::clear_compression_type() {
  compression_type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::safe_browsing::CompressionType ThreatEntrySet::compression_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntrySet.compression_type)
  return static_cast< ::safe_browsing::CompressionType >(compression_type_);
}
inline void ThreatEntrySet::set_compression_type(::safe_browsing::CompressionType value) {
  assert(::safe_browsing::CompressionType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  compression_type_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatEntrySet.compression_type)
}

// optional .safe_browsing.RawHashes raw_hashes = 2;
inline bool ThreatEntrySet::has_raw_hashes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatEntrySet::clear_raw_hashes() {
  if (raw_hashes_ != nullptr) raw_hashes_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::safe_browsing::RawHashes& ThreatEntrySet::raw_hashes() const {
  const ::safe_browsing::RawHashes* p = raw_hashes_;
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntrySet.raw_hashes)
  return p != nullptr ? *p : *reinterpret_cast<const ::safe_browsing::RawHashes*>(
      &::safe_browsing::_RawHashes_default_instance_);
}
inline ::safe_browsing::RawHashes* ThreatEntrySet::release_raw_hashes() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntrySet.raw_hashes)
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::RawHashes* temp = raw_hashes_;
  raw_hashes_ = nullptr;
  return temp;
}
inline ::safe_browsing::RawHashes* ThreatEntrySet::mutable_raw_hashes() {
  _has_bits_[0] |= 0x00000001u;
  if (raw_hashes_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::RawHashes>(GetArenaNoVirtual());
    raw_hashes_ = p;
  }
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntrySet.raw_hashes)
  return raw_hashes_;
}
inline void ThreatEntrySet::set_allocated_raw_hashes(::safe_browsing::RawHashes* raw_hashes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete raw_hashes_;
  }
  if (raw_hashes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      raw_hashes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw_hashes, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  raw_hashes_ = raw_hashes;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntrySet.raw_hashes)
}

// optional .safe_browsing.RawIndices raw_indices = 3;
inline bool ThreatEntrySet::has_raw_indices() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatEntrySet::clear_raw_indices() {
  if (raw_indices_ != nullptr) raw_indices_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::safe_browsing::RawIndices& ThreatEntrySet::raw_indices() const {
  const ::safe_browsing::RawIndices* p = raw_indices_;
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntrySet.raw_indices)
  return p != nullptr ? *p : *reinterpret_cast<const ::safe_browsing::RawIndices*>(
      &::safe_browsing::_RawIndices_default_instance_);
}
inline ::safe_browsing::RawIndices* ThreatEntrySet::release_raw_indices() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntrySet.raw_indices)
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::RawIndices* temp = raw_indices_;
  raw_indices_ = nullptr;
  return temp;
}
inline ::safe_browsing::RawIndices* ThreatEntrySet::mutable_raw_indices() {
  _has_bits_[0] |= 0x00000002u;
  if (raw_indices_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::RawIndices>(GetArenaNoVirtual());
    raw_indices_ = p;
  }
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntrySet.raw_indices)
  return raw_indices_;
}
inline void ThreatEntrySet::set_allocated_raw_indices(::safe_browsing::RawIndices* raw_indices) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete raw_indices_;
  }
  if (raw_indices) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      raw_indices = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw_indices, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  raw_indices_ = raw_indices;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntrySet.raw_indices)
}

// optional .safe_browsing.RiceDeltaEncoding rice_hashes = 4;
inline bool ThreatEntrySet::has_rice_hashes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThreatEntrySet::clear_rice_hashes() {
  if (rice_hashes_ != nullptr) rice_hashes_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::safe_browsing::RiceDeltaEncoding& ThreatEntrySet::rice_hashes() const {
  const ::safe_browsing::RiceDeltaEncoding* p = rice_hashes_;
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntrySet.rice_hashes)
  return p != nullptr ? *p : *reinterpret_cast<const ::safe_browsing::RiceDeltaEncoding*>(
      &::safe_browsing::_RiceDeltaEncoding_default_instance_);
}
inline ::safe_browsing::RiceDeltaEncoding* ThreatEntrySet::release_rice_hashes() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntrySet.rice_hashes)
  _has_bits_[0] &= ~0x00000004u;
  ::safe_browsing::RiceDeltaEncoding* temp = rice_hashes_;
  rice_hashes_ = nullptr;
  return temp;
}
inline ::safe_browsing::RiceDeltaEncoding* ThreatEntrySet::mutable_rice_hashes() {
  _has_bits_[0] |= 0x00000004u;
  if (rice_hashes_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::RiceDeltaEncoding>(GetArenaNoVirtual());
    rice_hashes_ = p;
  }
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntrySet.rice_hashes)
  return rice_hashes_;
}
inline void ThreatEntrySet::set_allocated_rice_hashes(::safe_browsing::RiceDeltaEncoding* rice_hashes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rice_hashes_;
  }
  if (rice_hashes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rice_hashes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rice_hashes, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  rice_hashes_ = rice_hashes;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntrySet.rice_hashes)
}

// optional .safe_browsing.RiceDeltaEncoding rice_indices = 5;
inline bool ThreatEntrySet::has_rice_indices() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ThreatEntrySet::clear_rice_indices() {
  if (rice_indices_ != nullptr) rice_indices_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::safe_browsing::RiceDeltaEncoding& ThreatEntrySet::rice_indices() const {
  const ::safe_browsing::RiceDeltaEncoding* p = rice_indices_;
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntrySet.rice_indices)
  return p != nullptr ? *p : *reinterpret_cast<const ::safe_browsing::RiceDeltaEncoding*>(
      &::safe_browsing::_RiceDeltaEncoding_default_instance_);
}
inline ::safe_browsing::RiceDeltaEncoding* ThreatEntrySet::release_rice_indices() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntrySet.rice_indices)
  _has_bits_[0] &= ~0x00000008u;
  ::safe_browsing::RiceDeltaEncoding* temp = rice_indices_;
  rice_indices_ = nullptr;
  return temp;
}
inline ::safe_browsing::RiceDeltaEncoding* ThreatEntrySet::mutable_rice_indices() {
  _has_bits_[0] |= 0x00000008u;
  if (rice_indices_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::RiceDeltaEncoding>(GetArenaNoVirtual());
    rice_indices_ = p;
  }
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntrySet.rice_indices)
  return rice_indices_;
}
inline void ThreatEntrySet::set_allocated_rice_indices(::safe_browsing::RiceDeltaEncoding* rice_indices) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rice_indices_;
  }
  if (rice_indices) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rice_indices = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rice_indices, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  rice_indices_ = rice_indices;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntrySet.rice_indices)
}

// -------------------------------------------------------------------

// RawIndices

// repeated int32 indices = 1;
inline int RawIndices::indices_size() const {
  return indices_.size();
}
inline void RawIndices::clear_indices() {
  indices_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RawIndices::indices(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.RawIndices.indices)
  return indices_.Get(index);
}
inline void RawIndices::set_indices(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  indices_.Set(index, value);
  // @@protoc_insertion_point(field_set:safe_browsing.RawIndices.indices)
}
inline void RawIndices::add_indices(::PROTOBUF_NAMESPACE_ID::int32 value) {
  indices_.Add(value);
  // @@protoc_insertion_point(field_add:safe_browsing.RawIndices.indices)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
RawIndices::indices() const {
  // @@protoc_insertion_point(field_list:safe_browsing.RawIndices.indices)
  return indices_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
RawIndices::mutable_indices() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.RawIndices.indices)
  return &indices_;
}

// -------------------------------------------------------------------

// RawHashes

// optional int32 prefix_size = 1;
inline bool RawHashes::has_prefix_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RawHashes::clear_prefix_size() {
  prefix_size_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RawHashes::prefix_size() const {
  // @@protoc_insertion_point(field_get:safe_browsing.RawHashes.prefix_size)
  return prefix_size_;
}
inline void RawHashes::set_prefix_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  prefix_size_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.RawHashes.prefix_size)
}

// optional bytes raw_hashes = 2;
inline bool RawHashes::has_raw_hashes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RawHashes::clear_raw_hashes() {
  raw_hashes_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RawHashes::raw_hashes() const {
  // @@protoc_insertion_point(field_get:safe_browsing.RawHashes.raw_hashes)
  return raw_hashes_.GetNoArena();
}
inline void RawHashes::set_raw_hashes(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  raw_hashes_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safe_browsing.RawHashes.raw_hashes)
}
inline void RawHashes::set_raw_hashes(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  raw_hashes_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safe_browsing.RawHashes.raw_hashes)
}
inline void RawHashes::set_raw_hashes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  raw_hashes_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safe_browsing.RawHashes.raw_hashes)
}
inline void RawHashes::set_raw_hashes(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  raw_hashes_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safe_browsing.RawHashes.raw_hashes)
}
inline std::string* RawHashes::mutable_raw_hashes() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:safe_browsing.RawHashes.raw_hashes)
  return raw_hashes_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RawHashes::release_raw_hashes() {
  // @@protoc_insertion_point(field_release:safe_browsing.RawHashes.raw_hashes)
  if (!has_raw_hashes()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return raw_hashes_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RawHashes::set_allocated_raw_hashes(std::string* raw_hashes) {
  if (raw_hashes != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  raw_hashes_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), raw_hashes);
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.RawHashes.raw_hashes)
}

// -------------------------------------------------------------------

// RiceDeltaEncoding

// optional int64 first_value = 1;
inline bool RiceDeltaEncoding::has_first_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RiceDeltaEncoding::clear_first_value() {
  first_value_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RiceDeltaEncoding::first_value() const {
  // @@protoc_insertion_point(field_get:safe_browsing.RiceDeltaEncoding.first_value)
  return first_value_;
}
inline void RiceDeltaEncoding::set_first_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  first_value_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.RiceDeltaEncoding.first_value)
}

// optional int32 rice_parameter = 2;
inline bool RiceDeltaEncoding::has_rice_parameter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RiceDeltaEncoding::clear_rice_parameter() {
  rice_parameter_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RiceDeltaEncoding::rice_parameter() const {
  // @@protoc_insertion_point(field_get:safe_browsing.RiceDeltaEncoding.rice_parameter)
  return rice_parameter_;
}
inline void RiceDeltaEncoding::set_rice_parameter(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  rice_parameter_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.RiceDeltaEncoding.rice_parameter)
}

// optional int32 num_entries = 3;
inline bool RiceDeltaEncoding::has_num_entries() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RiceDeltaEncoding::clear_num_entries() {
  num_entries_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RiceDeltaEncoding::num_entries() const {
  // @@protoc_insertion_point(field_get:safe_browsing.RiceDeltaEncoding.num_entries)
  return num_entries_;
}
inline void RiceDeltaEncoding::set_num_entries(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  num_entries_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.RiceDeltaEncoding.num_entries)
}

// optional bytes encoded_data = 4;
inline bool RiceDeltaEncoding::has_encoded_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RiceDeltaEncoding::clear_encoded_data() {
  encoded_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RiceDeltaEncoding::encoded_data() const {
  // @@protoc_insertion_point(field_get:safe_browsing.RiceDeltaEncoding.encoded_data)
  return encoded_data_.GetNoArena();
}
inline void RiceDeltaEncoding::set_encoded_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  encoded_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safe_browsing.RiceDeltaEncoding.encoded_data)
}
inline void RiceDeltaEncoding::set_encoded_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  encoded_data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safe_browsing.RiceDeltaEncoding.encoded_data)
}
inline void RiceDeltaEncoding::set_encoded_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  encoded_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safe_browsing.RiceDeltaEncoding.encoded_data)
}
inline void RiceDeltaEncoding::set_encoded_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  encoded_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safe_browsing.RiceDeltaEncoding.encoded_data)
}
inline std::string* RiceDeltaEncoding::mutable_encoded_data() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:safe_browsing.RiceDeltaEncoding.encoded_data)
  return encoded_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RiceDeltaEncoding::release_encoded_data() {
  // @@protoc_insertion_point(field_release:safe_browsing.RiceDeltaEncoding.encoded_data)
  if (!has_encoded_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return encoded_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RiceDeltaEncoding::set_allocated_encoded_data(std::string* encoded_data) {
  if (encoded_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  encoded_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encoded_data);
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.RiceDeltaEncoding.encoded_data)
}

// -------------------------------------------------------------------

// ThreatEntryMetadata_MetadataEntry

// optional bytes key = 1;
inline bool ThreatEntryMetadata_MetadataEntry::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatEntryMetadata_MetadataEntry::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ThreatEntryMetadata_MetadataEntry::key() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntryMetadata.MetadataEntry.key)
  return key_.GetNoArena();
}
inline void ThreatEntryMetadata_MetadataEntry::set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatEntryMetadata.MetadataEntry.key)
}
inline void ThreatEntryMetadata_MetadataEntry::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safe_browsing.ThreatEntryMetadata.MetadataEntry.key)
}
inline void ThreatEntryMetadata_MetadataEntry::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safe_browsing.ThreatEntryMetadata.MetadataEntry.key)
}
inline void ThreatEntryMetadata_MetadataEntry::set_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safe_browsing.ThreatEntryMetadata.MetadataEntry.key)
}
inline std::string* ThreatEntryMetadata_MetadataEntry::mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntryMetadata.MetadataEntry.key)
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ThreatEntryMetadata_MetadataEntry::release_key() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntryMetadata.MetadataEntry.key)
  if (!has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ThreatEntryMetadata_MetadataEntry::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntryMetadata.MetadataEntry.key)
}

// optional bytes value = 2;
inline bool ThreatEntryMetadata_MetadataEntry::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatEntryMetadata_MetadataEntry::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ThreatEntryMetadata_MetadataEntry::value() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntryMetadata.MetadataEntry.value)
  return value_.GetNoArena();
}
inline void ThreatEntryMetadata_MetadataEntry::set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatEntryMetadata.MetadataEntry.value)
}
inline void ThreatEntryMetadata_MetadataEntry::set_value(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safe_browsing.ThreatEntryMetadata.MetadataEntry.value)
}
inline void ThreatEntryMetadata_MetadataEntry::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safe_browsing.ThreatEntryMetadata.MetadataEntry.value)
}
inline void ThreatEntryMetadata_MetadataEntry::set_value(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safe_browsing.ThreatEntryMetadata.MetadataEntry.value)
}
inline std::string* ThreatEntryMetadata_MetadataEntry::mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntryMetadata.MetadataEntry.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ThreatEntryMetadata_MetadataEntry::release_value() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntryMetadata.MetadataEntry.value)
  if (!has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return value_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ThreatEntryMetadata_MetadataEntry::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntryMetadata.MetadataEntry.value)
}

// -------------------------------------------------------------------

// ThreatEntryMetadata

// repeated .safe_browsing.ThreatEntryMetadata.MetadataEntry entries = 1;
inline int ThreatEntryMetadata::entries_size() const {
  return entries_.size();
}
inline void ThreatEntryMetadata::clear_entries() {
  entries_.Clear();
}
inline ::safe_browsing::ThreatEntryMetadata_MetadataEntry* ThreatEntryMetadata::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntryMetadata.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntryMetadata_MetadataEntry >*
ThreatEntryMetadata::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.ThreatEntryMetadata.entries)
  return &entries_;
}
inline const ::safe_browsing::ThreatEntryMetadata_MetadataEntry& ThreatEntryMetadata::entries(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntryMetadata.entries)
  return entries_.Get(index);
}
inline ::safe_browsing::ThreatEntryMetadata_MetadataEntry* ThreatEntryMetadata::add_entries() {
  // @@protoc_insertion_point(field_add:safe_browsing.ThreatEntryMetadata.entries)
  return entries_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntryMetadata_MetadataEntry >&
ThreatEntryMetadata::entries() const {
  // @@protoc_insertion_point(field_list:safe_browsing.ThreatEntryMetadata.entries)
  return entries_;
}

// -------------------------------------------------------------------

// ThreatListDescriptor

// optional .safe_browsing.ThreatType threat_type = 1;
inline bool ThreatListDescriptor::has_threat_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatListDescriptor::clear_threat_type() {
  threat_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::safe_browsing::ThreatType ThreatListDescriptor::threat_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatListDescriptor.threat_type)
  return static_cast< ::safe_browsing::ThreatType >(threat_type_);
}
inline void ThreatListDescriptor::set_threat_type(::safe_browsing::ThreatType value) {
  assert(::safe_browsing::ThreatType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  threat_type_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatListDescriptor.threat_type)
}

// optional .safe_browsing.PlatformType platform_type = 2;
inline bool ThreatListDescriptor::has_platform_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatListDescriptor::clear_platform_type() {
  platform_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::safe_browsing::PlatformType ThreatListDescriptor::platform_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatListDescriptor.platform_type)
  return static_cast< ::safe_browsing::PlatformType >(platform_type_);
}
inline void ThreatListDescriptor::set_platform_type(::safe_browsing::PlatformType value) {
  assert(::safe_browsing::PlatformType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  platform_type_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatListDescriptor.platform_type)
}

// optional .safe_browsing.ThreatEntryType threat_entry_type = 3;
inline bool ThreatListDescriptor::has_threat_entry_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThreatListDescriptor::clear_threat_entry_type() {
  threat_entry_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::safe_browsing::ThreatEntryType ThreatListDescriptor::threat_entry_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatListDescriptor.threat_entry_type)
  return static_cast< ::safe_browsing::ThreatEntryType >(threat_entry_type_);
}
inline void ThreatListDescriptor::set_threat_entry_type(::safe_browsing::ThreatEntryType value) {
  assert(::safe_browsing::ThreatEntryType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  threat_entry_type_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatListDescriptor.threat_entry_type)
}

// -------------------------------------------------------------------

// ListThreatListsResponse

// repeated .safe_browsing.ThreatListDescriptor threat_lists = 1;
inline int ListThreatListsResponse::threat_lists_size() const {
  return threat_lists_.size();
}
inline void ListThreatListsResponse::clear_threat_lists() {
  threat_lists_.Clear();
}
inline ::safe_browsing::ThreatListDescriptor* ListThreatListsResponse::mutable_threat_lists(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.ListThreatListsResponse.threat_lists)
  return threat_lists_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatListDescriptor >*
ListThreatListsResponse::mutable_threat_lists() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.ListThreatListsResponse.threat_lists)
  return &threat_lists_;
}
inline const ::safe_browsing::ThreatListDescriptor& ListThreatListsResponse::threat_lists(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.ListThreatListsResponse.threat_lists)
  return threat_lists_.Get(index);
}
inline ::safe_browsing::ThreatListDescriptor* ListThreatListsResponse::add_threat_lists() {
  // @@protoc_insertion_point(field_add:safe_browsing.ListThreatListsResponse.threat_lists)
  return threat_lists_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatListDescriptor >&
ListThreatListsResponse::threat_lists() const {
  // @@protoc_insertion_point(field_list:safe_browsing.ListThreatListsResponse.threat_lists)
  return threat_lists_;
}

// -------------------------------------------------------------------

// Duration

// optional int64 seconds = 1;
inline bool Duration::has_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Duration::clear_seconds() {
  seconds_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Duration::seconds() const {
  // @@protoc_insertion_point(field_get:safe_browsing.Duration.seconds)
  return seconds_;
}
inline void Duration::set_seconds(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  seconds_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.Duration.seconds)
}

// optional int32 nanos = 2;
inline bool Duration::has_nanos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Duration::clear_nanos() {
  nanos_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Duration::nanos() const {
  // @@protoc_insertion_point(field_get:safe_browsing.Duration.nanos)
  return nanos_;
}
inline void Duration::set_nanos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  nanos_ = value;
  // @@protoc_insertion_point(field_set:safe_browsing.Duration.nanos)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace safe_browsing

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType> : ::std::true_type {};
template <> struct is_proto_enum< ::safe_browsing::ThreatHit_ThreatSourceType> : ::std::true_type {};
template <> struct is_proto_enum< ::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation> : ::std::true_type {};
template <> struct is_proto_enum< ::safe_browsing::ThreatType> : ::std::true_type {};
template <> struct is_proto_enum< ::safe_browsing::PlatformType> : ::std::true_type {};
template <> struct is_proto_enum< ::safe_browsing::CompressionType> : ::std::true_type {};
template <> struct is_proto_enum< ::safe_browsing::ThreatEntryType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_safebrowsing_2eproto
