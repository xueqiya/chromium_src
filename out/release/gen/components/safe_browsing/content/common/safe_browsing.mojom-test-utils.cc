// components/safe_browsing/content/common/safe_browsing.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif


#include "components/safe_browsing/content/common/safe_browsing.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"
#include "components/safe_browsing/core/common/safe_browsing_url_checker.mojom.h"
#include "content/public/common/resource_type.mojom.h"
#include "services/network/public/mojom/http_request_headers.mojom.h"
#include "url/mojom/url.mojom.h"


#ifndef COMPONENTS_SAFE_BROWSING_CONTENT_COMMON_SAFE_BROWSING_MOJOM_JUMBO_H_
#define COMPONENTS_SAFE_BROWSING_CONTENT_COMMON_SAFE_BROWSING_MOJOM_JUMBO_H_
#include "content/public/common/resource_type_mojom_traits.h"
#include "services/network/public/cpp/http_request_headers_mojom_traits.h"
#include "url/mojom/url_gurl_mojom_traits.h"
#endif


namespace safe_browsing {
namespace mojom {


void SafeBrowsingInterceptorForTesting::CreateCheckerAndCheck(int32_t render_frame_id, mojo::PendingReceiver<::safe_browsing::mojom::SafeBrowsingUrlChecker> receiver, const ::GURL& url, const std::string& method, const ::net::HttpRequestHeaders& headers, int32_t load_flags, ::content::ResourceType resource_type, bool has_user_gesture, bool originated_from_service_worker, CreateCheckerAndCheckCallback callback) {
  GetForwardingInterface()->CreateCheckerAndCheck(std::move(render_frame_id), std::move(receiver), std::move(url), std::move(method), std::move(headers), std::move(load_flags), std::move(resource_type), std::move(has_user_gesture), std::move(originated_from_service_worker), std::move(callback));
}
void SafeBrowsingInterceptorForTesting::Clone(mojo::PendingReceiver<SafeBrowsing> receiver) {
  GetForwardingInterface()->Clone(std::move(receiver));
}
SafeBrowsingAsyncWaiter::SafeBrowsingAsyncWaiter(
    SafeBrowsing* proxy) : proxy_(proxy) {}

SafeBrowsingAsyncWaiter::~SafeBrowsingAsyncWaiter() = default;

void SafeBrowsingAsyncWaiter::CreateCheckerAndCheck(
    int32_t render_frame_id, mojo::PendingReceiver<::safe_browsing::mojom::SafeBrowsingUrlChecker> receiver, const ::GURL& url, const std::string& method, const ::net::HttpRequestHeaders& headers, int32_t load_flags, ::content::ResourceType resource_type, bool has_user_gesture, bool originated_from_service_worker, mojo::PendingReceiver<::safe_browsing::mojom::UrlCheckNotifier>* out_slow_check_notifier, bool* out_proceed, bool* out_showed_interstitial) {
  base::RunLoop loop;
  proxy_->CreateCheckerAndCheck(std::move(render_frame_id),std::move(receiver),std::move(url),std::move(method),std::move(headers),std::move(load_flags),std::move(resource_type),std::move(has_user_gesture),std::move(originated_from_service_worker),
      base::BindOnce(
          [](base::RunLoop* loop,
             mojo::PendingReceiver<::safe_browsing::mojom::UrlCheckNotifier>* out_slow_check_notifier
,
             bool* out_proceed
,
             bool* out_showed_interstitial
,
             mojo::PendingReceiver<::safe_browsing::mojom::UrlCheckNotifier> slow_check_notifier,
             bool proceed,
             bool showed_interstitial) {*out_slow_check_notifier = std::move(slow_check_notifier);*out_proceed = std::move(proceed);*out_showed_interstitial = std::move(showed_interstitial);
            loop->Quit();
          },
          &loop,
          out_slow_check_notifier,
          out_proceed,
          out_showed_interstitial));
  loop.Run();
}



void ThreatReporterInterceptorForTesting::GetThreatDOMDetails(GetThreatDOMDetailsCallback callback) {
  GetForwardingInterface()->GetThreatDOMDetails(std::move(callback));
}
ThreatReporterAsyncWaiter::ThreatReporterAsyncWaiter(
    ThreatReporter* proxy) : proxy_(proxy) {}

ThreatReporterAsyncWaiter::~ThreatReporterAsyncWaiter() = default;

void ThreatReporterAsyncWaiter::GetThreatDOMDetails(
    std::vector<ThreatDOMDetailsNodePtr>* out_nodes) {
  base::RunLoop loop;
  proxy_->GetThreatDOMDetails(
      base::BindOnce(
          [](base::RunLoop* loop,
             std::vector<ThreatDOMDetailsNodePtr>* out_nodes
,
             std::vector<ThreatDOMDetailsNodePtr> nodes) {*out_nodes = std::move(nodes);
            loop->Quit();
          },
          &loop,
          out_nodes));
  loop.Run();
}



void PhishingModelSetterInterceptorForTesting::SetPhishingModel(const std::string& model) {
  GetForwardingInterface()->SetPhishingModel(std::move(model));
}
PhishingModelSetterAsyncWaiter::PhishingModelSetterAsyncWaiter(
    PhishingModelSetter* proxy) : proxy_(proxy) {}

PhishingModelSetterAsyncWaiter::~PhishingModelSetterAsyncWaiter() = default;






}  // namespace mojom
}  // namespace safe_browsing

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif