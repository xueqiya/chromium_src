// This file is generated by TypeBuilder_h.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef ui_devtools_protocol_Tracing_h
#define ui_devtools_protocol_Tracing_h

#include "components/ui_devtools/devtools_export.h"
#include "components/ui_devtools/Protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.

namespace ui_devtools {
namespace protocol {
namespace Tracing {

// ------------- Forward and enum declarations.
class DataCollectedNotification;
class TracingCompleteNotification;
class BufferUsageNotification;

// ------------- Type and builder declarations.

class UI_DEVTOOLS_EXPORT DataCollectedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(DataCollectedNotification);
public:
    static std::unique_ptr<DataCollectedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~DataCollectedNotification() override { }

    protocol::Array<protocol::DictionaryValue>* getValue() { return m_value.get(); }
    void setValue(std::unique_ptr<protocol::Array<protocol::DictionaryValue>> value) { m_value = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<DataCollectedNotification> clone() const;

    template<int STATE>
    class DataCollectedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ValueSet = 1 << 1,
            AllFieldsSet = (ValueSet | 0)};


        DataCollectedNotificationBuilder<STATE | ValueSet>& setValue(std::unique_ptr<protocol::Array<protocol::DictionaryValue>> value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue(std::move(value));
            return castState<ValueSet>();
        }

        std::unique_ptr<DataCollectedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class DataCollectedNotification;
        DataCollectedNotificationBuilder() : m_result(new DataCollectedNotification()) { }

        template<int STEP> DataCollectedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<DataCollectedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Tracing::DataCollectedNotification> m_result;
    };

    static DataCollectedNotificationBuilder<0> create()
    {
        return DataCollectedNotificationBuilder<0>();
    }

private:
    DataCollectedNotification()
    {
    }

    std::unique_ptr<protocol::Array<protocol::DictionaryValue>> m_value;
};


class UI_DEVTOOLS_EXPORT TracingCompleteNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(TracingCompleteNotification);
public:
    static std::unique_ptr<TracingCompleteNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~TracingCompleteNotification() override { }

    bool hasDataLossOccurred() { return m_dataLossOccurred.isJust(); }
    bool getDataLossOccurred(bool defaultValue) { return m_dataLossOccurred.isJust() ? m_dataLossOccurred.fromJust() : defaultValue; }
    void setDataLossOccurred(bool value) { m_dataLossOccurred = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<TracingCompleteNotification> clone() const;

    template<int STATE>
    class TracingCompleteNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            AllFieldsSet = (0)};


        TracingCompleteNotificationBuilder<STATE>& setDataLossOccurred(bool value)
        {
            m_result->setDataLossOccurred(value);
            return *this;
        }

        std::unique_ptr<TracingCompleteNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class TracingCompleteNotification;
        TracingCompleteNotificationBuilder() : m_result(new TracingCompleteNotification()) { }

        template<int STEP> TracingCompleteNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<TracingCompleteNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Tracing::TracingCompleteNotification> m_result;
    };

    static TracingCompleteNotificationBuilder<0> create()
    {
        return TracingCompleteNotificationBuilder<0>();
    }

private:
    TracingCompleteNotification()
    {
    }

    Maybe<bool> m_dataLossOccurred;
};


class UI_DEVTOOLS_EXPORT BufferUsageNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(BufferUsageNotification);
public:
    static std::unique_ptr<BufferUsageNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~BufferUsageNotification() override { }

    bool hasPercentFull() { return m_percentFull.isJust(); }
    double getPercentFull(double defaultValue) { return m_percentFull.isJust() ? m_percentFull.fromJust() : defaultValue; }
    void setPercentFull(double value) { m_percentFull = value; }

    bool hasEventCount() { return m_eventCount.isJust(); }
    double getEventCount(double defaultValue) { return m_eventCount.isJust() ? m_eventCount.fromJust() : defaultValue; }
    void setEventCount(double value) { m_eventCount = value; }

    bool hasValue() { return m_value.isJust(); }
    double getValue(double defaultValue) { return m_value.isJust() ? m_value.fromJust() : defaultValue; }
    void setValue(double value) { m_value = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<BufferUsageNotification> clone() const;

    template<int STATE>
    class BufferUsageNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            AllFieldsSet = (0)};


        BufferUsageNotificationBuilder<STATE>& setPercentFull(double value)
        {
            m_result->setPercentFull(value);
            return *this;
        }

        BufferUsageNotificationBuilder<STATE>& setEventCount(double value)
        {
            m_result->setEventCount(value);
            return *this;
        }

        BufferUsageNotificationBuilder<STATE>& setValue(double value)
        {
            m_result->setValue(value);
            return *this;
        }

        std::unique_ptr<BufferUsageNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class BufferUsageNotification;
        BufferUsageNotificationBuilder() : m_result(new BufferUsageNotification()) { }

        template<int STEP> BufferUsageNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<BufferUsageNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Tracing::BufferUsageNotification> m_result;
    };

    static BufferUsageNotificationBuilder<0> create()
    {
        return BufferUsageNotificationBuilder<0>();
    }

private:
    BufferUsageNotification()
    {
    }

    Maybe<double> m_percentFull;
    Maybe<double> m_eventCount;
    Maybe<double> m_value;
};


// ------------- Backend interface.

class UI_DEVTOOLS_EXPORT Backend {
public:
    virtual ~Backend() { }

    class UI_DEVTOOLS_EXPORT StartCallback {
    public:
        virtual void sendSuccess() = 0;
        virtual void sendFailure(const DispatchResponse&) = 0;
        virtual void fallThrough() = 0;
        virtual ~StartCallback() { }
    };
    virtual void start(Maybe<String> in_categories, Maybe<String> in_options, Maybe<double> in_bufferUsageReportingInterval, std::unique_ptr<StartCallback> callback) = 0;
    virtual DispatchResponse end() = 0;
    virtual DispatchResponse disable() = 0;
    virtual DispatchResponse enable() = 0;

};

// ------------- Frontend interface.

class UI_DEVTOOLS_EXPORT Frontend {
public:
    explicit Frontend(FrontendChannel* frontendChannel) : m_frontendChannel(frontendChannel) { }
    void dataCollected(std::unique_ptr<protocol::Array<protocol::DictionaryValue>> value);
    void tracingComplete(Maybe<bool> dataLossOccurred = Maybe<bool>());
    void bufferUsage(Maybe<double> percentFull = Maybe<double>(), Maybe<double> eventCount = Maybe<double>(), Maybe<double> value = Maybe<double>());

    void flush();
    void sendRawCBORNotification(std::vector<uint8_t>);
private:
    FrontendChannel* m_frontendChannel;
};

// ------------- Dispatcher.

class UI_DEVTOOLS_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher() { }
};

// ------------- Metainfo.

class UI_DEVTOOLS_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace Tracing
} // namespace ui_devtools
} // namespace protocol

#endif // !defined(ui_devtools_protocol_Tracing_h)
