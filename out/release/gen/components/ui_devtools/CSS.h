// This file is generated by TypeBuilder_h.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef ui_devtools_protocol_CSS_h
#define ui_devtools_protocol_CSS_h

#include "components/ui_devtools/devtools_export.h"
#include "components/ui_devtools/Protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.
#include "components/ui_devtools/DOM.h"

namespace ui_devtools {
namespace protocol {
namespace CSS {

// ------------- Forward and enum declarations.
using StyleSheetId = String;
class SourceRange;
class ShorthandEntry;
class CSSStyle;
class CSSProperty;
class RuleMatch;
class Value;
class SelectorList;
class CSSStyleSheetHeader;
class CSSRule;
class StyleDeclarationEdit;
class StyleSheetChangedNotification;
class StyleSheetAddedNotification;

// ------------- Type and builder declarations.

class UI_DEVTOOLS_EXPORT SourceRange : public Serializable{
    PROTOCOL_DISALLOW_COPY(SourceRange);
public:
    static std::unique_ptr<SourceRange> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~SourceRange() override { }

    int getStartLine() { return m_startLine; }
    void setStartLine(int value) { m_startLine = value; }

    int getStartColumn() { return m_startColumn; }
    void setStartColumn(int value) { m_startColumn = value; }

    int getEndLine() { return m_endLine; }
    void setEndLine(int value) { m_endLine = value; }

    int getEndColumn() { return m_endColumn; }
    void setEndColumn(int value) { m_endColumn = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<SourceRange> clone() const;

    template<int STATE>
    class SourceRangeBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            StartLineSet = 1 << 1,
            StartColumnSet = 1 << 2,
            EndLineSet = 1 << 3,
            EndColumnSet = 1 << 4,
            AllFieldsSet = (StartLineSet | StartColumnSet | EndLineSet | EndColumnSet | 0)};


        SourceRangeBuilder<STATE | StartLineSet>& setStartLine(int value)
        {
            static_assert(!(STATE & StartLineSet), "property startLine should not be set yet");
            m_result->setStartLine(value);
            return castState<StartLineSet>();
        }

        SourceRangeBuilder<STATE | StartColumnSet>& setStartColumn(int value)
        {
            static_assert(!(STATE & StartColumnSet), "property startColumn should not be set yet");
            m_result->setStartColumn(value);
            return castState<StartColumnSet>();
        }

        SourceRangeBuilder<STATE | EndLineSet>& setEndLine(int value)
        {
            static_assert(!(STATE & EndLineSet), "property endLine should not be set yet");
            m_result->setEndLine(value);
            return castState<EndLineSet>();
        }

        SourceRangeBuilder<STATE | EndColumnSet>& setEndColumn(int value)
        {
            static_assert(!(STATE & EndColumnSet), "property endColumn should not be set yet");
            m_result->setEndColumn(value);
            return castState<EndColumnSet>();
        }

        std::unique_ptr<SourceRange> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SourceRange;
        SourceRangeBuilder() : m_result(new SourceRange()) { }

        template<int STEP> SourceRangeBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SourceRangeBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::CSS::SourceRange> m_result;
    };

    static SourceRangeBuilder<0> create()
    {
        return SourceRangeBuilder<0>();
    }

private:
    SourceRange()
    {
          m_startLine = 0;
          m_startColumn = 0;
          m_endLine = 0;
          m_endColumn = 0;
    }

    int m_startLine;
    int m_startColumn;
    int m_endLine;
    int m_endColumn;
};


class UI_DEVTOOLS_EXPORT ShorthandEntry : public Serializable{
    PROTOCOL_DISALLOW_COPY(ShorthandEntry);
public:
    static std::unique_ptr<ShorthandEntry> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~ShorthandEntry() override { }

    String getName() { return m_name; }
    void setName(const String& value) { m_name = value; }

    String getValue() { return m_value; }
    void setValue(const String& value) { m_value = value; }

    bool hasImportant() { return m_important.isJust(); }
    bool getImportant(bool defaultValue) { return m_important.isJust() ? m_important.fromJust() : defaultValue; }
    void setImportant(bool value) { m_important = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<ShorthandEntry> clone() const;

    template<int STATE>
    class ShorthandEntryBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            NameSet = 1 << 1,
            ValueSet = 1 << 2,
            AllFieldsSet = (NameSet | ValueSet | 0)};


        ShorthandEntryBuilder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setName(value);
            return castState<NameSet>();
        }

        ShorthandEntryBuilder<STATE | ValueSet>& setValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue(value);
            return castState<ValueSet>();
        }

        ShorthandEntryBuilder<STATE>& setImportant(bool value)
        {
            m_result->setImportant(value);
            return *this;
        }

        std::unique_ptr<ShorthandEntry> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ShorthandEntry;
        ShorthandEntryBuilder() : m_result(new ShorthandEntry()) { }

        template<int STEP> ShorthandEntryBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ShorthandEntryBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::CSS::ShorthandEntry> m_result;
    };

    static ShorthandEntryBuilder<0> create()
    {
        return ShorthandEntryBuilder<0>();
    }

private:
    ShorthandEntry()
    {
    }

    String m_name;
    String m_value;
    Maybe<bool> m_important;
};


class UI_DEVTOOLS_EXPORT CSSStyle : public Serializable{
    PROTOCOL_DISALLOW_COPY(CSSStyle);
public:
    static std::unique_ptr<CSSStyle> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~CSSStyle() override { }

    bool hasStyleSheetId() { return m_styleSheetId.isJust(); }
    String getStyleSheetId(const String& defaultValue) { return m_styleSheetId.isJust() ? m_styleSheetId.fromJust() : defaultValue; }
    void setStyleSheetId(const String& value) { m_styleSheetId = value; }

    protocol::Array<protocol::CSS::CSSProperty>* getCssProperties() { return m_cssProperties.get(); }
    void setCssProperties(std::unique_ptr<protocol::Array<protocol::CSS::CSSProperty>> value) { m_cssProperties = std::move(value); }

    protocol::Array<protocol::CSS::ShorthandEntry>* getShorthandEntries() { return m_shorthandEntries.get(); }
    void setShorthandEntries(std::unique_ptr<protocol::Array<protocol::CSS::ShorthandEntry>> value) { m_shorthandEntries = std::move(value); }

    bool hasRange() { return m_range.isJust(); }
    protocol::CSS::SourceRange* getRange(protocol::CSS::SourceRange* defaultValue) { return m_range.isJust() ? m_range.fromJust() : defaultValue; }
    void setRange(std::unique_ptr<protocol::CSS::SourceRange> value) { m_range = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<CSSStyle> clone() const;

    template<int STATE>
    class CSSStyleBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            CssPropertiesSet = 1 << 1,
            ShorthandEntriesSet = 1 << 2,
            AllFieldsSet = (CssPropertiesSet | ShorthandEntriesSet | 0)};


        CSSStyleBuilder<STATE>& setStyleSheetId(const String& value)
        {
            m_result->setStyleSheetId(value);
            return *this;
        }

        CSSStyleBuilder<STATE | CssPropertiesSet>& setCssProperties(std::unique_ptr<protocol::Array<protocol::CSS::CSSProperty>> value)
        {
            static_assert(!(STATE & CssPropertiesSet), "property cssProperties should not be set yet");
            m_result->setCssProperties(std::move(value));
            return castState<CssPropertiesSet>();
        }

        CSSStyleBuilder<STATE | ShorthandEntriesSet>& setShorthandEntries(std::unique_ptr<protocol::Array<protocol::CSS::ShorthandEntry>> value)
        {
            static_assert(!(STATE & ShorthandEntriesSet), "property shorthandEntries should not be set yet");
            m_result->setShorthandEntries(std::move(value));
            return castState<ShorthandEntriesSet>();
        }

        CSSStyleBuilder<STATE>& setRange(std::unique_ptr<protocol::CSS::SourceRange> value)
        {
            m_result->setRange(std::move(value));
            return *this;
        }

        std::unique_ptr<CSSStyle> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class CSSStyle;
        CSSStyleBuilder() : m_result(new CSSStyle()) { }

        template<int STEP> CSSStyleBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<CSSStyleBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::CSS::CSSStyle> m_result;
    };

    static CSSStyleBuilder<0> create()
    {
        return CSSStyleBuilder<0>();
    }

private:
    CSSStyle()
    {
    }

    Maybe<String> m_styleSheetId;
    std::unique_ptr<protocol::Array<protocol::CSS::CSSProperty>> m_cssProperties;
    std::unique_ptr<protocol::Array<protocol::CSS::ShorthandEntry>> m_shorthandEntries;
    Maybe<protocol::CSS::SourceRange> m_range;
};


class UI_DEVTOOLS_EXPORT CSSProperty : public Serializable{
    PROTOCOL_DISALLOW_COPY(CSSProperty);
public:
    static std::unique_ptr<CSSProperty> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~CSSProperty() override { }

    String getName() { return m_name; }
    void setName(const String& value) { m_name = value; }

    String getValue() { return m_value; }
    void setValue(const String& value) { m_value = value; }

    bool hasRange() { return m_range.isJust(); }
    protocol::CSS::SourceRange* getRange(protocol::CSS::SourceRange* defaultValue) { return m_range.isJust() ? m_range.fromJust() : defaultValue; }
    void setRange(std::unique_ptr<protocol::CSS::SourceRange> value) { m_range = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<CSSProperty> clone() const;

    template<int STATE>
    class CSSPropertyBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            NameSet = 1 << 1,
            ValueSet = 1 << 2,
            AllFieldsSet = (NameSet | ValueSet | 0)};


        CSSPropertyBuilder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setName(value);
            return castState<NameSet>();
        }

        CSSPropertyBuilder<STATE | ValueSet>& setValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue(value);
            return castState<ValueSet>();
        }

        CSSPropertyBuilder<STATE>& setRange(std::unique_ptr<protocol::CSS::SourceRange> value)
        {
            m_result->setRange(std::move(value));
            return *this;
        }

        std::unique_ptr<CSSProperty> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class CSSProperty;
        CSSPropertyBuilder() : m_result(new CSSProperty()) { }

        template<int STEP> CSSPropertyBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<CSSPropertyBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::CSS::CSSProperty> m_result;
    };

    static CSSPropertyBuilder<0> create()
    {
        return CSSPropertyBuilder<0>();
    }

private:
    CSSProperty()
    {
    }

    String m_name;
    String m_value;
    Maybe<protocol::CSS::SourceRange> m_range;
};


class UI_DEVTOOLS_EXPORT RuleMatch : public Serializable{
    PROTOCOL_DISALLOW_COPY(RuleMatch);
public:
    static std::unique_ptr<RuleMatch> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~RuleMatch() override { }

    protocol::CSS::CSSRule* getRule() { return m_rule.get(); }
    void setRule(std::unique_ptr<protocol::CSS::CSSRule> value) { m_rule = std::move(value); }

    protocol::Array<int>* getMatchingSelectors() { return m_matchingSelectors.get(); }
    void setMatchingSelectors(std::unique_ptr<protocol::Array<int>> value) { m_matchingSelectors = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<RuleMatch> clone() const;

    template<int STATE>
    class RuleMatchBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            RuleSet = 1 << 1,
            MatchingSelectorsSet = 1 << 2,
            AllFieldsSet = (RuleSet | MatchingSelectorsSet | 0)};


        RuleMatchBuilder<STATE | RuleSet>& setRule(std::unique_ptr<protocol::CSS::CSSRule> value)
        {
            static_assert(!(STATE & RuleSet), "property rule should not be set yet");
            m_result->setRule(std::move(value));
            return castState<RuleSet>();
        }

        RuleMatchBuilder<STATE | MatchingSelectorsSet>& setMatchingSelectors(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & MatchingSelectorsSet), "property matchingSelectors should not be set yet");
            m_result->setMatchingSelectors(std::move(value));
            return castState<MatchingSelectorsSet>();
        }

        std::unique_ptr<RuleMatch> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class RuleMatch;
        RuleMatchBuilder() : m_result(new RuleMatch()) { }

        template<int STEP> RuleMatchBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<RuleMatchBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::CSS::RuleMatch> m_result;
    };

    static RuleMatchBuilder<0> create()
    {
        return RuleMatchBuilder<0>();
    }

private:
    RuleMatch()
    {
    }

    std::unique_ptr<protocol::CSS::CSSRule> m_rule;
    std::unique_ptr<protocol::Array<int>> m_matchingSelectors;
};


class UI_DEVTOOLS_EXPORT Value : public Serializable{
    PROTOCOL_DISALLOW_COPY(Value);
public:
    static std::unique_ptr<Value> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~Value() override { }

    String getText() { return m_text; }
    void setText(const String& value) { m_text = value; }

    bool hasRange() { return m_range.isJust(); }
    protocol::CSS::SourceRange* getRange(protocol::CSS::SourceRange* defaultValue) { return m_range.isJust() ? m_range.fromJust() : defaultValue; }
    void setRange(std::unique_ptr<protocol::CSS::SourceRange> value) { m_range = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<Value> clone() const;

    template<int STATE>
    class ValueBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            TextSet = 1 << 1,
            AllFieldsSet = (TextSet | 0)};


        ValueBuilder<STATE | TextSet>& setText(const String& value)
        {
            static_assert(!(STATE & TextSet), "property text should not be set yet");
            m_result->setText(value);
            return castState<TextSet>();
        }

        ValueBuilder<STATE>& setRange(std::unique_ptr<protocol::CSS::SourceRange> value)
        {
            m_result->setRange(std::move(value));
            return *this;
        }

        std::unique_ptr<Value> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class Value;
        ValueBuilder() : m_result(new Value()) { }

        template<int STEP> ValueBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ValueBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::CSS::Value> m_result;
    };

    static ValueBuilder<0> create()
    {
        return ValueBuilder<0>();
    }

private:
    Value()
    {
    }

    String m_text;
    Maybe<protocol::CSS::SourceRange> m_range;
};


class UI_DEVTOOLS_EXPORT SelectorList : public Serializable{
    PROTOCOL_DISALLOW_COPY(SelectorList);
public:
    static std::unique_ptr<SelectorList> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~SelectorList() override { }

    protocol::Array<protocol::CSS::Value>* getSelectors() { return m_selectors.get(); }
    void setSelectors(std::unique_ptr<protocol::Array<protocol::CSS::Value>> value) { m_selectors = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<SelectorList> clone() const;

    template<int STATE>
    class SelectorListBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            SelectorsSet = 1 << 1,
            AllFieldsSet = (SelectorsSet | 0)};


        SelectorListBuilder<STATE | SelectorsSet>& setSelectors(std::unique_ptr<protocol::Array<protocol::CSS::Value>> value)
        {
            static_assert(!(STATE & SelectorsSet), "property selectors should not be set yet");
            m_result->setSelectors(std::move(value));
            return castState<SelectorsSet>();
        }

        std::unique_ptr<SelectorList> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SelectorList;
        SelectorListBuilder() : m_result(new SelectorList()) { }

        template<int STEP> SelectorListBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SelectorListBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::CSS::SelectorList> m_result;
    };

    static SelectorListBuilder<0> create()
    {
        return SelectorListBuilder<0>();
    }

private:
    SelectorList()
    {
    }

    std::unique_ptr<protocol::Array<protocol::CSS::Value>> m_selectors;
};


class UI_DEVTOOLS_EXPORT CSSStyleSheetHeader : public Serializable{
    PROTOCOL_DISALLOW_COPY(CSSStyleSheetHeader);
public:
    static std::unique_ptr<CSSStyleSheetHeader> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~CSSStyleSheetHeader() override { }

    String getStyleSheetId() { return m_styleSheetId; }
    void setStyleSheetId(const String& value) { m_styleSheetId = value; }

    String getSourceURL() { return m_sourceURL; }
    void setSourceURL(const String& value) { m_sourceURL = value; }

    double getStartLine() { return m_startLine; }
    void setStartLine(double value) { m_startLine = value; }

    double getStartColumn() { return m_startColumn; }
    void setStartColumn(double value) { m_startColumn = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<CSSStyleSheetHeader> clone() const;

    template<int STATE>
    class CSSStyleSheetHeaderBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            StyleSheetIdSet = 1 << 1,
            SourceURLSet = 1 << 2,
            StartLineSet = 1 << 3,
            StartColumnSet = 1 << 4,
            AllFieldsSet = (StyleSheetIdSet | SourceURLSet | StartLineSet | StartColumnSet | 0)};


        CSSStyleSheetHeaderBuilder<STATE | StyleSheetIdSet>& setStyleSheetId(const String& value)
        {
            static_assert(!(STATE & StyleSheetIdSet), "property styleSheetId should not be set yet");
            m_result->setStyleSheetId(value);
            return castState<StyleSheetIdSet>();
        }

        CSSStyleSheetHeaderBuilder<STATE | SourceURLSet>& setSourceURL(const String& value)
        {
            static_assert(!(STATE & SourceURLSet), "property sourceURL should not be set yet");
            m_result->setSourceURL(value);
            return castState<SourceURLSet>();
        }

        CSSStyleSheetHeaderBuilder<STATE | StartLineSet>& setStartLine(double value)
        {
            static_assert(!(STATE & StartLineSet), "property startLine should not be set yet");
            m_result->setStartLine(value);
            return castState<StartLineSet>();
        }

        CSSStyleSheetHeaderBuilder<STATE | StartColumnSet>& setStartColumn(double value)
        {
            static_assert(!(STATE & StartColumnSet), "property startColumn should not be set yet");
            m_result->setStartColumn(value);
            return castState<StartColumnSet>();
        }

        std::unique_ptr<CSSStyleSheetHeader> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class CSSStyleSheetHeader;
        CSSStyleSheetHeaderBuilder() : m_result(new CSSStyleSheetHeader()) { }

        template<int STEP> CSSStyleSheetHeaderBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<CSSStyleSheetHeaderBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::CSS::CSSStyleSheetHeader> m_result;
    };

    static CSSStyleSheetHeaderBuilder<0> create()
    {
        return CSSStyleSheetHeaderBuilder<0>();
    }

private:
    CSSStyleSheetHeader()
    {
          m_startLine = 0;
          m_startColumn = 0;
    }

    String m_styleSheetId;
    String m_sourceURL;
    double m_startLine;
    double m_startColumn;
};


class UI_DEVTOOLS_EXPORT CSSRule : public Serializable{
    PROTOCOL_DISALLOW_COPY(CSSRule);
public:
    static std::unique_ptr<CSSRule> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~CSSRule() override { }

    bool hasStyleSheetId() { return m_styleSheetId.isJust(); }
    String getStyleSheetId(const String& defaultValue) { return m_styleSheetId.isJust() ? m_styleSheetId.fromJust() : defaultValue; }
    void setStyleSheetId(const String& value) { m_styleSheetId = value; }

    protocol::CSS::SelectorList* getSelectorList() { return m_selectorList.get(); }
    void setSelectorList(std::unique_ptr<protocol::CSS::SelectorList> value) { m_selectorList = std::move(value); }

    protocol::CSS::CSSStyle* getStyle() { return m_style.get(); }
    void setStyle(std::unique_ptr<protocol::CSS::CSSStyle> value) { m_style = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<CSSRule> clone() const;

    template<int STATE>
    class CSSRuleBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            SelectorListSet = 1 << 1,
            StyleSet = 1 << 2,
            AllFieldsSet = (SelectorListSet | StyleSet | 0)};


        CSSRuleBuilder<STATE>& setStyleSheetId(const String& value)
        {
            m_result->setStyleSheetId(value);
            return *this;
        }

        CSSRuleBuilder<STATE | SelectorListSet>& setSelectorList(std::unique_ptr<protocol::CSS::SelectorList> value)
        {
            static_assert(!(STATE & SelectorListSet), "property selectorList should not be set yet");
            m_result->setSelectorList(std::move(value));
            return castState<SelectorListSet>();
        }

        CSSRuleBuilder<STATE | StyleSet>& setStyle(std::unique_ptr<protocol::CSS::CSSStyle> value)
        {
            static_assert(!(STATE & StyleSet), "property style should not be set yet");
            m_result->setStyle(std::move(value));
            return castState<StyleSet>();
        }

        std::unique_ptr<CSSRule> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class CSSRule;
        CSSRuleBuilder() : m_result(new CSSRule()) { }

        template<int STEP> CSSRuleBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<CSSRuleBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::CSS::CSSRule> m_result;
    };

    static CSSRuleBuilder<0> create()
    {
        return CSSRuleBuilder<0>();
    }

private:
    CSSRule()
    {
    }

    Maybe<String> m_styleSheetId;
    std::unique_ptr<protocol::CSS::SelectorList> m_selectorList;
    std::unique_ptr<protocol::CSS::CSSStyle> m_style;
};


class UI_DEVTOOLS_EXPORT StyleDeclarationEdit : public Serializable{
    PROTOCOL_DISALLOW_COPY(StyleDeclarationEdit);
public:
    static std::unique_ptr<StyleDeclarationEdit> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~StyleDeclarationEdit() override { }

    String getStyleSheetId() { return m_styleSheetId; }
    void setStyleSheetId(const String& value) { m_styleSheetId = value; }

    protocol::CSS::SourceRange* getRange() { return m_range.get(); }
    void setRange(std::unique_ptr<protocol::CSS::SourceRange> value) { m_range = std::move(value); }

    String getText() { return m_text; }
    void setText(const String& value) { m_text = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<StyleDeclarationEdit> clone() const;

    template<int STATE>
    class StyleDeclarationEditBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            StyleSheetIdSet = 1 << 1,
            RangeSet = 1 << 2,
            TextSet = 1 << 3,
            AllFieldsSet = (StyleSheetIdSet | RangeSet | TextSet | 0)};


        StyleDeclarationEditBuilder<STATE | StyleSheetIdSet>& setStyleSheetId(const String& value)
        {
            static_assert(!(STATE & StyleSheetIdSet), "property styleSheetId should not be set yet");
            m_result->setStyleSheetId(value);
            return castState<StyleSheetIdSet>();
        }

        StyleDeclarationEditBuilder<STATE | RangeSet>& setRange(std::unique_ptr<protocol::CSS::SourceRange> value)
        {
            static_assert(!(STATE & RangeSet), "property range should not be set yet");
            m_result->setRange(std::move(value));
            return castState<RangeSet>();
        }

        StyleDeclarationEditBuilder<STATE | TextSet>& setText(const String& value)
        {
            static_assert(!(STATE & TextSet), "property text should not be set yet");
            m_result->setText(value);
            return castState<TextSet>();
        }

        std::unique_ptr<StyleDeclarationEdit> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class StyleDeclarationEdit;
        StyleDeclarationEditBuilder() : m_result(new StyleDeclarationEdit()) { }

        template<int STEP> StyleDeclarationEditBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<StyleDeclarationEditBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::CSS::StyleDeclarationEdit> m_result;
    };

    static StyleDeclarationEditBuilder<0> create()
    {
        return StyleDeclarationEditBuilder<0>();
    }

private:
    StyleDeclarationEdit()
    {
    }

    String m_styleSheetId;
    std::unique_ptr<protocol::CSS::SourceRange> m_range;
    String m_text;
};


class UI_DEVTOOLS_EXPORT StyleSheetChangedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(StyleSheetChangedNotification);
public:
    static std::unique_ptr<StyleSheetChangedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~StyleSheetChangedNotification() override { }

    String getStyleSheetId() { return m_styleSheetId; }
    void setStyleSheetId(const String& value) { m_styleSheetId = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<StyleSheetChangedNotification> clone() const;

    template<int STATE>
    class StyleSheetChangedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            StyleSheetIdSet = 1 << 1,
            AllFieldsSet = (StyleSheetIdSet | 0)};


        StyleSheetChangedNotificationBuilder<STATE | StyleSheetIdSet>& setStyleSheetId(const String& value)
        {
            static_assert(!(STATE & StyleSheetIdSet), "property styleSheetId should not be set yet");
            m_result->setStyleSheetId(value);
            return castState<StyleSheetIdSet>();
        }

        std::unique_ptr<StyleSheetChangedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class StyleSheetChangedNotification;
        StyleSheetChangedNotificationBuilder() : m_result(new StyleSheetChangedNotification()) { }

        template<int STEP> StyleSheetChangedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<StyleSheetChangedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::CSS::StyleSheetChangedNotification> m_result;
    };

    static StyleSheetChangedNotificationBuilder<0> create()
    {
        return StyleSheetChangedNotificationBuilder<0>();
    }

private:
    StyleSheetChangedNotification()
    {
    }

    String m_styleSheetId;
};


class UI_DEVTOOLS_EXPORT StyleSheetAddedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(StyleSheetAddedNotification);
public:
    static std::unique_ptr<StyleSheetAddedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~StyleSheetAddedNotification() override { }

    protocol::CSS::CSSStyleSheetHeader* getHeader() { return m_header.get(); }
    void setHeader(std::unique_ptr<protocol::CSS::CSSStyleSheetHeader> value) { m_header = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<StyleSheetAddedNotification> clone() const;

    template<int STATE>
    class StyleSheetAddedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            HeaderSet = 1 << 1,
            AllFieldsSet = (HeaderSet | 0)};


        StyleSheetAddedNotificationBuilder<STATE | HeaderSet>& setHeader(std::unique_ptr<protocol::CSS::CSSStyleSheetHeader> value)
        {
            static_assert(!(STATE & HeaderSet), "property header should not be set yet");
            m_result->setHeader(std::move(value));
            return castState<HeaderSet>();
        }

        std::unique_ptr<StyleSheetAddedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class StyleSheetAddedNotification;
        StyleSheetAddedNotificationBuilder() : m_result(new StyleSheetAddedNotification()) { }

        template<int STEP> StyleSheetAddedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<StyleSheetAddedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::CSS::StyleSheetAddedNotification> m_result;
    };

    static StyleSheetAddedNotificationBuilder<0> create()
    {
        return StyleSheetAddedNotificationBuilder<0>();
    }

private:
    StyleSheetAddedNotification()
    {
    }

    std::unique_ptr<protocol::CSS::CSSStyleSheetHeader> m_header;
};


// ------------- Backend interface.

class UI_DEVTOOLS_EXPORT Backend {
public:
    virtual ~Backend() { }

    virtual DispatchResponse disable() = 0;
    virtual DispatchResponse enable() = 0;
    virtual DispatchResponse getMatchedStylesForNode(int in_nodeId, Maybe<protocol::Array<protocol::CSS::RuleMatch>>* out_matchedCSSRules) = 0;
    virtual DispatchResponse getStyleSheetText(const String& in_styleSheetId, String* out_text) = 0;
    virtual DispatchResponse setStyleTexts(std::unique_ptr<protocol::Array<protocol::CSS::StyleDeclarationEdit>> in_edits, std::unique_ptr<protocol::Array<protocol::CSS::CSSStyle>>* out_styles) = 0;

};

// ------------- Frontend interface.

class UI_DEVTOOLS_EXPORT Frontend {
public:
    explicit Frontend(FrontendChannel* frontendChannel) : m_frontendChannel(frontendChannel) { }
    void styleSheetChanged(const String& styleSheetId);
    void styleSheetAdded(std::unique_ptr<protocol::CSS::CSSStyleSheetHeader> header);

    void flush();
    void sendRawCBORNotification(std::vector<uint8_t>);
private:
    FrontendChannel* m_frontendChannel;
};

// ------------- Dispatcher.

class UI_DEVTOOLS_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher() { }
};

// ------------- Metainfo.

class UI_DEVTOOLS_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace CSS
} // namespace ui_devtools
} // namespace protocol

#endif // !defined(ui_devtools_protocol_CSS_h)
