// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_URLPATTERNINDEX_URL_PATTERN_INDEX_FLAT_H_
#define FLATBUFFERS_GENERATED_URLPATTERNINDEX_URL_PATTERN_INDEX_FLAT_H_

#include "flatbuffers/flatbuffers.h"

namespace url_pattern_index {
namespace flat {

struct UrlRule;

struct NGramToRules;

struct UrlPatternIndex;

enum UrlPatternType {
  UrlPatternType_SUBSTRING = 0,
  UrlPatternType_WILDCARDED = 1,
  UrlPatternType_REGEXP = 2,
  UrlPatternType_MIN = UrlPatternType_SUBSTRING,
  UrlPatternType_MAX = UrlPatternType_REGEXP
};

inline const UrlPatternType (&EnumValuesUrlPatternType())[3] {
  static const UrlPatternType values[] = {
    UrlPatternType_SUBSTRING,
    UrlPatternType_WILDCARDED,
    UrlPatternType_REGEXP
  };
  return values;
}

inline const char * const *EnumNamesUrlPatternType() {
  static const char * const names[4] = {
    "SUBSTRING",
    "WILDCARDED",
    "REGEXP",
    nullptr
  };
  return names;
}

inline const char *EnumNameUrlPatternType(UrlPatternType e) {
  if (e < UrlPatternType_SUBSTRING || e > UrlPatternType_REGEXP) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUrlPatternType()[index];
}

enum AnchorType {
  AnchorType_NONE = 0,
  AnchorType_BOUNDARY = 1,
  AnchorType_SUBDOMAIN = 2,
  AnchorType_MIN = AnchorType_NONE,
  AnchorType_MAX = AnchorType_SUBDOMAIN
};

inline const AnchorType (&EnumValuesAnchorType())[3] {
  static const AnchorType values[] = {
    AnchorType_NONE,
    AnchorType_BOUNDARY,
    AnchorType_SUBDOMAIN
  };
  return values;
}

inline const char * const *EnumNamesAnchorType() {
  static const char * const names[4] = {
    "NONE",
    "BOUNDARY",
    "SUBDOMAIN",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnchorType(AnchorType e) {
  if (e < AnchorType_NONE || e > AnchorType_SUBDOMAIN) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnchorType()[index];
}

enum OptionFlag {
  OptionFlag_IS_WHITELIST = 1,
  OptionFlag_APPLIES_TO_FIRST_PARTY = 2,
  OptionFlag_APPLIES_TO_THIRD_PARTY = 4,
  OptionFlag_IS_CASE_INSENSITIVE = 8,
  OptionFlag_NONE = 0,
  OptionFlag_ANY = 15
};

inline const OptionFlag (&EnumValuesOptionFlag())[4] {
  static const OptionFlag values[] = {
    OptionFlag_IS_WHITELIST,
    OptionFlag_APPLIES_TO_FIRST_PARTY,
    OptionFlag_APPLIES_TO_THIRD_PARTY,
    OptionFlag_IS_CASE_INSENSITIVE
  };
  return values;
}

inline const char * const *EnumNamesOptionFlag() {
  static const char * const names[9] = {
    "IS_WHITELIST",
    "APPLIES_TO_FIRST_PARTY",
    "",
    "APPLIES_TO_THIRD_PARTY",
    "",
    "",
    "",
    "IS_CASE_INSENSITIVE",
    nullptr
  };
  return names;
}

inline const char *EnumNameOptionFlag(OptionFlag e) {
  if (e < OptionFlag_IS_WHITELIST || e > OptionFlag_IS_CASE_INSENSITIVE) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(OptionFlag_IS_WHITELIST);
  return EnumNamesOptionFlag()[index];
}

enum ActivationType {
  ActivationType_DOCUMENT = 1,
  ActivationType_GENERIC_BLOCK = 2,
  ActivationType_NONE = 0,
  ActivationType_ANY = 3
};

inline const ActivationType (&EnumValuesActivationType())[2] {
  static const ActivationType values[] = {
    ActivationType_DOCUMENT,
    ActivationType_GENERIC_BLOCK
  };
  return values;
}

inline const char * const *EnumNamesActivationType() {
  static const char * const names[3] = {
    "DOCUMENT",
    "GENERIC_BLOCK",
    nullptr
  };
  return names;
}

inline const char *EnumNameActivationType(ActivationType e) {
  if (e < ActivationType_DOCUMENT || e > ActivationType_GENERIC_BLOCK) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(ActivationType_DOCUMENT);
  return EnumNamesActivationType()[index];
}

enum ElementType {
  ElementType_OTHER = 1,
  ElementType_SCRIPT = 2,
  ElementType_IMAGE = 4,
  ElementType_STYLESHEET = 8,
  ElementType_OBJECT = 16,
  ElementType_XMLHTTPREQUEST = 32,
  ElementType_OBJECT_SUBREQUEST = 64,
  ElementType_SUBDOCUMENT = 128,
  ElementType_PING = 256,
  ElementType_MEDIA = 512,
  ElementType_FONT = 1024,
  ElementType_WEBSOCKET = 2048,
  ElementType_CSP_REPORT = 4096,
  ElementType_MAIN_FRAME = 8192,
  ElementType_NONE = 0,
  ElementType_ANY = 16383
};

inline const ElementType (&EnumValuesElementType())[14] {
  static const ElementType values[] = {
    ElementType_OTHER,
    ElementType_SCRIPT,
    ElementType_IMAGE,
    ElementType_STYLESHEET,
    ElementType_OBJECT,
    ElementType_XMLHTTPREQUEST,
    ElementType_OBJECT_SUBREQUEST,
    ElementType_SUBDOCUMENT,
    ElementType_PING,
    ElementType_MEDIA,
    ElementType_FONT,
    ElementType_WEBSOCKET,
    ElementType_CSP_REPORT,
    ElementType_MAIN_FRAME
  };
  return values;
}

inline const char *EnumNameElementType(ElementType e) {
  switch (e) {
    case ElementType_OTHER: return "OTHER";
    case ElementType_SCRIPT: return "SCRIPT";
    case ElementType_IMAGE: return "IMAGE";
    case ElementType_STYLESHEET: return "STYLESHEET";
    case ElementType_OBJECT: return "OBJECT";
    case ElementType_XMLHTTPREQUEST: return "XMLHTTPREQUEST";
    case ElementType_OBJECT_SUBREQUEST: return "OBJECT_SUBREQUEST";
    case ElementType_SUBDOCUMENT: return "SUBDOCUMENT";
    case ElementType_PING: return "PING";
    case ElementType_MEDIA: return "MEDIA";
    case ElementType_FONT: return "FONT";
    case ElementType_WEBSOCKET: return "WEBSOCKET";
    case ElementType_CSP_REPORT: return "CSP_REPORT";
    case ElementType_MAIN_FRAME: return "MAIN_FRAME";
    default: return "";
  }
}

struct UrlRule FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPTIONS = 4,
    VT_ELEMENT_TYPES = 6,
    VT_ACTIVATION_TYPES = 8,
    VT_URL_PATTERN_TYPE = 10,
    VT_ANCHOR_LEFT = 12,
    VT_ANCHOR_RIGHT = 14,
    VT_DOMAINS_INCLUDED = 16,
    VT_DOMAINS_EXCLUDED = 18,
    VT_URL_PATTERN = 20,
    VT_ID = 22,
    VT_PRIORITY = 24
  };
  uint8_t options() const {
    return GetField<uint8_t>(VT_OPTIONS, 0);
  }
  uint16_t element_types() const {
    return GetField<uint16_t>(VT_ELEMENT_TYPES, 8191);
  }
  uint8_t activation_types() const {
    return GetField<uint8_t>(VT_ACTIVATION_TYPES, 0);
  }
  url_pattern_index::flat::UrlPatternType url_pattern_type() const {
    return static_cast<url_pattern_index::flat::UrlPatternType>(GetField<uint8_t>(VT_URL_PATTERN_TYPE, 0));
  }
  url_pattern_index::flat::AnchorType anchor_left() const {
    return static_cast<url_pattern_index::flat::AnchorType>(GetField<uint8_t>(VT_ANCHOR_LEFT, 0));
  }
  url_pattern_index::flat::AnchorType anchor_right() const {
    return static_cast<url_pattern_index::flat::AnchorType>(GetField<uint8_t>(VT_ANCHOR_RIGHT, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *domains_included() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DOMAINS_INCLUDED);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *domains_excluded() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DOMAINS_EXCLUDED);
  }
  const flatbuffers::String *url_pattern() const {
    return GetPointer<const flatbuffers::String *>(VT_URL_PATTERN);
  }
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  uint64_t priority() const {
    return GetField<uint64_t>(VT_PRIORITY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OPTIONS) &&
           VerifyField<uint16_t>(verifier, VT_ELEMENT_TYPES) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVATION_TYPES) &&
           VerifyField<uint8_t>(verifier, VT_URL_PATTERN_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_ANCHOR_LEFT) &&
           VerifyField<uint8_t>(verifier, VT_ANCHOR_RIGHT) &&
           VerifyOffset(verifier, VT_DOMAINS_INCLUDED) &&
           verifier.VerifyVector(domains_included()) &&
           verifier.VerifyVectorOfStrings(domains_included()) &&
           VerifyOffset(verifier, VT_DOMAINS_EXCLUDED) &&
           verifier.VerifyVector(domains_excluded()) &&
           verifier.VerifyVectorOfStrings(domains_excluded()) &&
           VerifyOffset(verifier, VT_URL_PATTERN) &&
           verifier.VerifyString(url_pattern()) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<uint64_t>(verifier, VT_PRIORITY) &&
           verifier.EndTable();
  }
};

struct UrlRuleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_options(uint8_t options) {
    fbb_.AddElement<uint8_t>(UrlRule::VT_OPTIONS, options, 0);
  }
  void add_element_types(uint16_t element_types) {
    fbb_.AddElement<uint16_t>(UrlRule::VT_ELEMENT_TYPES, element_types, 8191);
  }
  void add_activation_types(uint8_t activation_types) {
    fbb_.AddElement<uint8_t>(UrlRule::VT_ACTIVATION_TYPES, activation_types, 0);
  }
  void add_url_pattern_type(url_pattern_index::flat::UrlPatternType url_pattern_type) {
    fbb_.AddElement<uint8_t>(UrlRule::VT_URL_PATTERN_TYPE, static_cast<uint8_t>(url_pattern_type), 0);
  }
  void add_anchor_left(url_pattern_index::flat::AnchorType anchor_left) {
    fbb_.AddElement<uint8_t>(UrlRule::VT_ANCHOR_LEFT, static_cast<uint8_t>(anchor_left), 0);
  }
  void add_anchor_right(url_pattern_index::flat::AnchorType anchor_right) {
    fbb_.AddElement<uint8_t>(UrlRule::VT_ANCHOR_RIGHT, static_cast<uint8_t>(anchor_right), 0);
  }
  void add_domains_included(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> domains_included) {
    fbb_.AddOffset(UrlRule::VT_DOMAINS_INCLUDED, domains_included);
  }
  void add_domains_excluded(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> domains_excluded) {
    fbb_.AddOffset(UrlRule::VT_DOMAINS_EXCLUDED, domains_excluded);
  }
  void add_url_pattern(flatbuffers::Offset<flatbuffers::String> url_pattern) {
    fbb_.AddOffset(UrlRule::VT_URL_PATTERN, url_pattern);
  }
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(UrlRule::VT_ID, id, 0);
  }
  void add_priority(uint64_t priority) {
    fbb_.AddElement<uint64_t>(UrlRule::VT_PRIORITY, priority, 0);
  }
  explicit UrlRuleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UrlRuleBuilder &operator=(const UrlRuleBuilder &);
  flatbuffers::Offset<UrlRule> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UrlRule>(end);
    return o;
  }
};

inline flatbuffers::Offset<UrlRule> CreateUrlRule(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t options = 0,
    uint16_t element_types = 8191,
    uint8_t activation_types = 0,
    url_pattern_index::flat::UrlPatternType url_pattern_type = url_pattern_index::flat::UrlPatternType_SUBSTRING,
    url_pattern_index::flat::AnchorType anchor_left = url_pattern_index::flat::AnchorType_NONE,
    url_pattern_index::flat::AnchorType anchor_right = url_pattern_index::flat::AnchorType_NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> domains_included = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> domains_excluded = 0,
    flatbuffers::Offset<flatbuffers::String> url_pattern = 0,
    uint32_t id = 0,
    uint64_t priority = 0) {
  UrlRuleBuilder builder_(_fbb);
  builder_.add_priority(priority);
  builder_.add_id(id);
  builder_.add_url_pattern(url_pattern);
  builder_.add_domains_excluded(domains_excluded);
  builder_.add_domains_included(domains_included);
  builder_.add_element_types(element_types);
  builder_.add_anchor_right(anchor_right);
  builder_.add_anchor_left(anchor_left);
  builder_.add_url_pattern_type(url_pattern_type);
  builder_.add_activation_types(activation_types);
  builder_.add_options(options);
  return builder_.Finish();
}

inline flatbuffers::Offset<UrlRule> CreateUrlRuleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t options = 0,
    uint16_t element_types = 8191,
    uint8_t activation_types = 0,
    url_pattern_index::flat::UrlPatternType url_pattern_type = url_pattern_index::flat::UrlPatternType_SUBSTRING,
    url_pattern_index::flat::AnchorType anchor_left = url_pattern_index::flat::AnchorType_NONE,
    url_pattern_index::flat::AnchorType anchor_right = url_pattern_index::flat::AnchorType_NONE,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *domains_included = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *domains_excluded = nullptr,
    const char *url_pattern = nullptr,
    uint32_t id = 0,
    uint64_t priority = 0) {
  auto domains_included__ = domains_included ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*domains_included) : 0;
  auto domains_excluded__ = domains_excluded ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*domains_excluded) : 0;
  auto url_pattern__ = url_pattern ? _fbb.CreateString(url_pattern) : 0;
  return url_pattern_index::flat::CreateUrlRule(
      _fbb,
      options,
      element_types,
      activation_types,
      url_pattern_type,
      anchor_left,
      anchor_right,
      domains_included__,
      domains_excluded__,
      url_pattern__,
      id,
      priority);
}

struct NGramToRules FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NGRAM = 4,
    VT_RULE_LIST = 6
  };
  uint64_t ngram() const {
    return GetField<uint64_t>(VT_NGRAM, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<url_pattern_index::flat::UrlRule>> *rule_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<url_pattern_index::flat::UrlRule>> *>(VT_RULE_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_NGRAM) &&
           VerifyOffset(verifier, VT_RULE_LIST) &&
           verifier.VerifyVector(rule_list()) &&
           verifier.VerifyVectorOfTables(rule_list()) &&
           verifier.EndTable();
  }
};

struct NGramToRulesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ngram(uint64_t ngram) {
    fbb_.AddElement<uint64_t>(NGramToRules::VT_NGRAM, ngram, 0);
  }
  void add_rule_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<url_pattern_index::flat::UrlRule>>> rule_list) {
    fbb_.AddOffset(NGramToRules::VT_RULE_LIST, rule_list);
  }
  explicit NGramToRulesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NGramToRulesBuilder &operator=(const NGramToRulesBuilder &);
  flatbuffers::Offset<NGramToRules> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NGramToRules>(end);
    return o;
  }
};

inline flatbuffers::Offset<NGramToRules> CreateNGramToRules(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t ngram = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<url_pattern_index::flat::UrlRule>>> rule_list = 0) {
  NGramToRulesBuilder builder_(_fbb);
  builder_.add_ngram(ngram);
  builder_.add_rule_list(rule_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<NGramToRules> CreateNGramToRulesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t ngram = 0,
    const std::vector<flatbuffers::Offset<url_pattern_index::flat::UrlRule>> *rule_list = nullptr) {
  auto rule_list__ = rule_list ? _fbb.CreateVector<flatbuffers::Offset<url_pattern_index::flat::UrlRule>>(*rule_list) : 0;
  return url_pattern_index::flat::CreateNGramToRules(
      _fbb,
      ngram,
      rule_list__);
}

struct UrlPatternIndex FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_N = 4,
    VT_NGRAM_INDEX = 6,
    VT_NGRAM_INDEX_EMPTY_SLOT = 8,
    VT_FALLBACK_RULES = 10
  };
  uint32_t n() const {
    return GetField<uint32_t>(VT_N, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<url_pattern_index::flat::NGramToRules>> *ngram_index() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<url_pattern_index::flat::NGramToRules>> *>(VT_NGRAM_INDEX);
  }
  const url_pattern_index::flat::NGramToRules *ngram_index_empty_slot() const {
    return GetPointer<const url_pattern_index::flat::NGramToRules *>(VT_NGRAM_INDEX_EMPTY_SLOT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<url_pattern_index::flat::UrlRule>> *fallback_rules() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<url_pattern_index::flat::UrlRule>> *>(VT_FALLBACK_RULES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_N) &&
           VerifyOffset(verifier, VT_NGRAM_INDEX) &&
           verifier.VerifyVector(ngram_index()) &&
           verifier.VerifyVectorOfTables(ngram_index()) &&
           VerifyOffset(verifier, VT_NGRAM_INDEX_EMPTY_SLOT) &&
           verifier.VerifyTable(ngram_index_empty_slot()) &&
           VerifyOffset(verifier, VT_FALLBACK_RULES) &&
           verifier.VerifyVector(fallback_rules()) &&
           verifier.VerifyVectorOfTables(fallback_rules()) &&
           verifier.EndTable();
  }
};

struct UrlPatternIndexBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_n(uint32_t n) {
    fbb_.AddElement<uint32_t>(UrlPatternIndex::VT_N, n, 0);
  }
  void add_ngram_index(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<url_pattern_index::flat::NGramToRules>>> ngram_index) {
    fbb_.AddOffset(UrlPatternIndex::VT_NGRAM_INDEX, ngram_index);
  }
  void add_ngram_index_empty_slot(flatbuffers::Offset<url_pattern_index::flat::NGramToRules> ngram_index_empty_slot) {
    fbb_.AddOffset(UrlPatternIndex::VT_NGRAM_INDEX_EMPTY_SLOT, ngram_index_empty_slot);
  }
  void add_fallback_rules(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<url_pattern_index::flat::UrlRule>>> fallback_rules) {
    fbb_.AddOffset(UrlPatternIndex::VT_FALLBACK_RULES, fallback_rules);
  }
  explicit UrlPatternIndexBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UrlPatternIndexBuilder &operator=(const UrlPatternIndexBuilder &);
  flatbuffers::Offset<UrlPatternIndex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UrlPatternIndex>(end);
    return o;
  }
};

inline flatbuffers::Offset<UrlPatternIndex> CreateUrlPatternIndex(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t n = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<url_pattern_index::flat::NGramToRules>>> ngram_index = 0,
    flatbuffers::Offset<url_pattern_index::flat::NGramToRules> ngram_index_empty_slot = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<url_pattern_index::flat::UrlRule>>> fallback_rules = 0) {
  UrlPatternIndexBuilder builder_(_fbb);
  builder_.add_fallback_rules(fallback_rules);
  builder_.add_ngram_index_empty_slot(ngram_index_empty_slot);
  builder_.add_ngram_index(ngram_index);
  builder_.add_n(n);
  return builder_.Finish();
}

inline flatbuffers::Offset<UrlPatternIndex> CreateUrlPatternIndexDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t n = 0,
    const std::vector<flatbuffers::Offset<url_pattern_index::flat::NGramToRules>> *ngram_index = nullptr,
    flatbuffers::Offset<url_pattern_index::flat::NGramToRules> ngram_index_empty_slot = 0,
    const std::vector<flatbuffers::Offset<url_pattern_index::flat::UrlRule>> *fallback_rules = nullptr) {
  auto ngram_index__ = ngram_index ? _fbb.CreateVector<flatbuffers::Offset<url_pattern_index::flat::NGramToRules>>(*ngram_index) : 0;
  auto fallback_rules__ = fallback_rules ? _fbb.CreateVector<flatbuffers::Offset<url_pattern_index::flat::UrlRule>>(*fallback_rules) : 0;
  return url_pattern_index::flat::CreateUrlPatternIndex(
      _fbb,
      n,
      ngram_index__,
      ngram_index_empty_slot,
      fallback_rules__);
}

inline const url_pattern_index::flat::UrlPatternIndex *GetUrlPatternIndex(const void *buf) {
  return flatbuffers::GetRoot<url_pattern_index::flat::UrlPatternIndex>(buf);
}

inline const url_pattern_index::flat::UrlPatternIndex *GetSizePrefixedUrlPatternIndex(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<url_pattern_index::flat::UrlPatternIndex>(buf);
}

inline bool VerifyUrlPatternIndexBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<url_pattern_index::flat::UrlPatternIndex>(nullptr);
}

inline bool VerifySizePrefixedUrlPatternIndexBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<url_pattern_index::flat::UrlPatternIndex>(nullptr);
}

inline void FinishUrlPatternIndexBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<url_pattern_index::flat::UrlPatternIndex> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedUrlPatternIndexBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<url_pattern_index::flat::UrlPatternIndex> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flat
}  // namespace url_pattern_index

#endif  // FLATBUFFERS_GENERATED_URLPATTERNINDEX_URL_PATTERN_INDEX_FLAT_H_
