// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rules.proto

#include "rules.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_rules_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_CssRule_rules_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_rules_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DomainListItem_rules_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_rules_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UrlRule_rules_2eproto;
namespace url_pattern_index {
namespace proto {
class DomainListItemDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DomainListItem> _instance;
} _DomainListItem_default_instance_;
class UrlRuleDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UrlRule> _instance;
} _UrlRule_default_instance_;
class CssRuleDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CssRule> _instance;
} _CssRule_default_instance_;
class CommentDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Comment> _instance;
} _Comment_default_instance_;
class FilteringRulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FilteringRules> _instance;
} _FilteringRules_default_instance_;
}  // namespace proto
}  // namespace url_pattern_index
static void InitDefaultsscc_info_Comment_rules_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::url_pattern_index::proto::_Comment_default_instance_;
    new (ptr) ::url_pattern_index::proto::Comment();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::url_pattern_index::proto::Comment::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Comment_rules_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Comment_rules_2eproto}, {}};

static void InitDefaultsscc_info_CssRule_rules_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::url_pattern_index::proto::_CssRule_default_instance_;
    new (ptr) ::url_pattern_index::proto::CssRule();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::url_pattern_index::proto::CssRule::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_CssRule_rules_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_CssRule_rules_2eproto}, {
      &scc_info_DomainListItem_rules_2eproto.base,}};

static void InitDefaultsscc_info_DomainListItem_rules_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::url_pattern_index::proto::_DomainListItem_default_instance_;
    new (ptr) ::url_pattern_index::proto::DomainListItem();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::url_pattern_index::proto::DomainListItem::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DomainListItem_rules_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_DomainListItem_rules_2eproto}, {}};

static void InitDefaultsscc_info_FilteringRules_rules_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::url_pattern_index::proto::_FilteringRules_default_instance_;
    new (ptr) ::url_pattern_index::proto::FilteringRules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::url_pattern_index::proto::FilteringRules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_FilteringRules_rules_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_FilteringRules_rules_2eproto}, {
      &scc_info_UrlRule_rules_2eproto.base,
      &scc_info_CssRule_rules_2eproto.base,}};

static void InitDefaultsscc_info_UrlRule_rules_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::url_pattern_index::proto::_UrlRule_default_instance_;
    new (ptr) ::url_pattern_index::proto::UrlRule();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::url_pattern_index::proto::UrlRule::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UrlRule_rules_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_UrlRule_rules_2eproto}, {
      &scc_info_DomainListItem_rules_2eproto.base,}};

namespace url_pattern_index {
namespace proto {
bool RuleType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RuleType_strings[4] = {};

static const char RuleType_names[] =
  "RULE_TYPE_COMMENT"
  "RULE_TYPE_CSS"
  "RULE_TYPE_UNSPECIFIED"
  "RULE_TYPE_URL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RuleType_entries[] = {
  { {RuleType_names + 0, 17}, 1 },
  { {RuleType_names + 17, 13}, 3 },
  { {RuleType_names + 30, 21}, 0 },
  { {RuleType_names + 51, 13}, 2 },
};

static const int RuleType_entries_by_number[] = {
  2, // 0 -> RULE_TYPE_UNSPECIFIED
  0, // 1 -> RULE_TYPE_COMMENT
  3, // 2 -> RULE_TYPE_URL
  1, // 3 -> RULE_TYPE_CSS
};

const std::string& RuleType_Name(
    RuleType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RuleType_entries,
          RuleType_entries_by_number,
          4, RuleType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RuleType_entries,
      RuleType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RuleType_strings[idx].get();
}
bool RuleType_Parse(
    const std::string& name, RuleType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RuleType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<RuleType>(int_value);
  }
  return success;
}
bool UrlPatternType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UrlPatternType_strings[4] = {};

static const char UrlPatternType_names[] =
  "URL_PATTERN_TYPE_REGEXP"
  "URL_PATTERN_TYPE_SUBSTRING"
  "URL_PATTERN_TYPE_UNSPECIFIED"
  "URL_PATTERN_TYPE_WILDCARDED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UrlPatternType_entries[] = {
  { {UrlPatternType_names + 0, 23}, 3 },
  { {UrlPatternType_names + 23, 26}, 1 },
  { {UrlPatternType_names + 49, 28}, 0 },
  { {UrlPatternType_names + 77, 27}, 2 },
};

static const int UrlPatternType_entries_by_number[] = {
  2, // 0 -> URL_PATTERN_TYPE_UNSPECIFIED
  1, // 1 -> URL_PATTERN_TYPE_SUBSTRING
  3, // 2 -> URL_PATTERN_TYPE_WILDCARDED
  0, // 3 -> URL_PATTERN_TYPE_REGEXP
};

const std::string& UrlPatternType_Name(
    UrlPatternType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UrlPatternType_entries,
          UrlPatternType_entries_by_number,
          4, UrlPatternType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UrlPatternType_entries,
      UrlPatternType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UrlPatternType_strings[idx].get();
}
bool UrlPatternType_Parse(
    const std::string& name, UrlPatternType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UrlPatternType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<UrlPatternType>(int_value);
  }
  return success;
}
bool AnchorType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AnchorType_strings[4] = {};

static const char AnchorType_names[] =
  "ANCHOR_TYPE_BOUNDARY"
  "ANCHOR_TYPE_NONE"
  "ANCHOR_TYPE_SUBDOMAIN"
  "ANCHOR_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AnchorType_entries[] = {
  { {AnchorType_names + 0, 20}, 2 },
  { {AnchorType_names + 20, 16}, 1 },
  { {AnchorType_names + 36, 21}, 3 },
  { {AnchorType_names + 57, 23}, 0 },
};

static const int AnchorType_entries_by_number[] = {
  3, // 0 -> ANCHOR_TYPE_UNSPECIFIED
  1, // 1 -> ANCHOR_TYPE_NONE
  0, // 2 -> ANCHOR_TYPE_BOUNDARY
  2, // 3 -> ANCHOR_TYPE_SUBDOMAIN
};

const std::string& AnchorType_Name(
    AnchorType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AnchorType_entries,
          AnchorType_entries_by_number,
          4, AnchorType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AnchorType_entries,
      AnchorType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AnchorType_strings[idx].get();
}
bool AnchorType_Parse(
    const std::string& name, AnchorType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AnchorType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<AnchorType>(int_value);
  }
  return success;
}
bool ElementType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8191:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ElementType_strings[15] = {};

static const char ElementType_names[] =
  "ELEMENT_TYPE_ALL"
  "ELEMENT_TYPE_FONT"
  "ELEMENT_TYPE_IMAGE"
  "ELEMENT_TYPE_MAX"
  "ELEMENT_TYPE_MEDIA"
  "ELEMENT_TYPE_OBJECT"
  "ELEMENT_TYPE_OBJECT_SUBREQUEST"
  "ELEMENT_TYPE_OTHER"
  "ELEMENT_TYPE_PING"
  "ELEMENT_TYPE_POPUP"
  "ELEMENT_TYPE_SCRIPT"
  "ELEMENT_TYPE_STYLESHEET"
  "ELEMENT_TYPE_SUBDOCUMENT"
  "ELEMENT_TYPE_UNSPECIFIED"
  "ELEMENT_TYPE_WEBSOCKET"
  "ELEMENT_TYPE_XMLHTTPREQUEST";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ElementType_entries[] = {
  { {ElementType_names + 0, 16}, 8191 },
  { {ElementType_names + 16, 17}, 1024 },
  { {ElementType_names + 33, 18}, 4 },
  { {ElementType_names + 51, 16}, 4096 },
  { {ElementType_names + 67, 18}, 512 },
  { {ElementType_names + 85, 19}, 16 },
  { {ElementType_names + 104, 30}, 64 },
  { {ElementType_names + 134, 18}, 1 },
  { {ElementType_names + 152, 17}, 256 },
  { {ElementType_names + 169, 18}, 2048 },
  { {ElementType_names + 187, 19}, 2 },
  { {ElementType_names + 206, 23}, 8 },
  { {ElementType_names + 229, 24}, 128 },
  { {ElementType_names + 253, 24}, 0 },
  { {ElementType_names + 277, 22}, 4096 },
  { {ElementType_names + 299, 27}, 32 },
};

static const int ElementType_entries_by_number[] = {
  13, // 0 -> ELEMENT_TYPE_UNSPECIFIED
  7, // 1 -> ELEMENT_TYPE_OTHER
  10, // 2 -> ELEMENT_TYPE_SCRIPT
  2, // 4 -> ELEMENT_TYPE_IMAGE
  11, // 8 -> ELEMENT_TYPE_STYLESHEET
  5, // 16 -> ELEMENT_TYPE_OBJECT
  15, // 32 -> ELEMENT_TYPE_XMLHTTPREQUEST
  6, // 64 -> ELEMENT_TYPE_OBJECT_SUBREQUEST
  12, // 128 -> ELEMENT_TYPE_SUBDOCUMENT
  8, // 256 -> ELEMENT_TYPE_PING
  4, // 512 -> ELEMENT_TYPE_MEDIA
  1, // 1024 -> ELEMENT_TYPE_FONT
  9, // 2048 -> ELEMENT_TYPE_POPUP
  14, // 4096 -> ELEMENT_TYPE_WEBSOCKET
  0, // 8191 -> ELEMENT_TYPE_ALL
};

const std::string& ElementType_Name(
    ElementType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ElementType_entries,
          ElementType_entries_by_number,
          15, ElementType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ElementType_entries,
      ElementType_entries_by_number,
      15, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ElementType_strings[idx].get();
}
bool ElementType_Parse(
    const std::string& name, ElementType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ElementType_entries, 16, name, &int_value);
  if (success) {
    *value = static_cast<ElementType>(int_value);
  }
  return success;
}
bool ActivationType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
    case 15:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ActivationType_strings[6] = {};

static const char ActivationType_names[] =
  "ACTIVATION_TYPE_ALL"
  "ACTIVATION_TYPE_DOCUMENT"
  "ACTIVATION_TYPE_ELEMHIDE"
  "ACTIVATION_TYPE_GENERICBLOCK"
  "ACTIVATION_TYPE_GENERICHIDE"
  "ACTIVATION_TYPE_MAX"
  "ACTIVATION_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ActivationType_entries[] = {
  { {ActivationType_names + 0, 19}, 15 },
  { {ActivationType_names + 19, 24}, 1 },
  { {ActivationType_names + 43, 24}, 2 },
  { {ActivationType_names + 67, 28}, 8 },
  { {ActivationType_names + 95, 27}, 4 },
  { {ActivationType_names + 122, 19}, 8 },
  { {ActivationType_names + 141, 27}, 0 },
};

static const int ActivationType_entries_by_number[] = {
  6, // 0 -> ACTIVATION_TYPE_UNSPECIFIED
  1, // 1 -> ACTIVATION_TYPE_DOCUMENT
  2, // 2 -> ACTIVATION_TYPE_ELEMHIDE
  4, // 4 -> ACTIVATION_TYPE_GENERICHIDE
  3, // 8 -> ACTIVATION_TYPE_GENERICBLOCK
  0, // 15 -> ACTIVATION_TYPE_ALL
};

const std::string& ActivationType_Name(
    ActivationType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ActivationType_entries,
          ActivationType_entries_by_number,
          6, ActivationType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ActivationType_entries,
      ActivationType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ActivationType_strings[idx].get();
}
bool ActivationType_Parse(
    const std::string& name, ActivationType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ActivationType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<ActivationType>(int_value);
  }
  return success;
}
bool RuleSemantics_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RuleSemantics_strings[3] = {};

static const char RuleSemantics_names[] =
  "RULE_SEMANTICS_BLACKLIST"
  "RULE_SEMANTICS_UNSPECIFIED"
  "RULE_SEMANTICS_WHITELIST";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RuleSemantics_entries[] = {
  { {RuleSemantics_names + 0, 24}, 1 },
  { {RuleSemantics_names + 24, 26}, 0 },
  { {RuleSemantics_names + 50, 24}, 2 },
};

static const int RuleSemantics_entries_by_number[] = {
  1, // 0 -> RULE_SEMANTICS_UNSPECIFIED
  0, // 1 -> RULE_SEMANTICS_BLACKLIST
  2, // 2 -> RULE_SEMANTICS_WHITELIST
};

const std::string& RuleSemantics_Name(
    RuleSemantics value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RuleSemantics_entries,
          RuleSemantics_entries_by_number,
          3, RuleSemantics_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RuleSemantics_entries,
      RuleSemantics_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RuleSemantics_strings[idx].get();
}
bool RuleSemantics_Parse(
    const std::string& name, RuleSemantics* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RuleSemantics_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<RuleSemantics>(int_value);
  }
  return success;
}
bool SourceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SourceType_strings[4] = {};

static const char SourceType_names[] =
  "SOURCE_TYPE_ANY"
  "SOURCE_TYPE_FIRST_PARTY"
  "SOURCE_TYPE_THIRD_PARTY"
  "SOURCE_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SourceType_entries[] = {
  { {SourceType_names + 0, 15}, 1 },
  { {SourceType_names + 15, 23}, 3 },
  { {SourceType_names + 38, 23}, 2 },
  { {SourceType_names + 61, 23}, 0 },
};

static const int SourceType_entries_by_number[] = {
  3, // 0 -> SOURCE_TYPE_UNSPECIFIED
  0, // 1 -> SOURCE_TYPE_ANY
  2, // 2 -> SOURCE_TYPE_THIRD_PARTY
  1, // 3 -> SOURCE_TYPE_FIRST_PARTY
};

const std::string& SourceType_Name(
    SourceType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SourceType_entries,
          SourceType_entries_by_number,
          4, SourceType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SourceType_entries,
      SourceType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SourceType_strings[idx].get();
}
bool SourceType_Parse(
    const std::string& name, SourceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SourceType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<SourceType>(int_value);
  }
  return success;
}

// ===================================================================

void DomainListItem::InitAsDefaultInstance() {
}
class DomainListItem::_Internal {
 public:
  using HasBits = decltype(std::declval<DomainListItem>()._has_bits_);
  static void set_has_domain(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_exclude(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DomainListItem::DomainListItem()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:url_pattern_index.proto.DomainListItem)
}
DomainListItem::DomainListItem(const DomainListItem& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  domain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_domain()) {
    domain_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.domain_);
  }
  exclude_ = from.exclude_;
  // @@protoc_insertion_point(copy_constructor:url_pattern_index.proto.DomainListItem)
}

void DomainListItem::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_DomainListItem_rules_2eproto.base);
  domain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  exclude_ = false;
}

DomainListItem::~DomainListItem() {
  // @@protoc_insertion_point(destructor:url_pattern_index.proto.DomainListItem)
  SharedDtor();
}

void DomainListItem::SharedDtor() {
  domain_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DomainListItem::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DomainListItem& DomainListItem::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DomainListItem_rules_2eproto.base);
  return *internal_default_instance();
}


void DomainListItem::Clear() {
// @@protoc_insertion_point(message_clear_start:url_pattern_index.proto.DomainListItem)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    domain_.ClearNonDefaultToEmptyNoArena();
  }
  exclude_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* DomainListItem::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string domain = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_domain(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool exclude = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_exclude(&has_bits);
          exclude_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool DomainListItem::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:url_pattern_index.proto.DomainListItem)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string domain = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_domain()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool exclude = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_exclude(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &exclude_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:url_pattern_index.proto.DomainListItem)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:url_pattern_index.proto.DomainListItem)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void DomainListItem::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:url_pattern_index.proto.DomainListItem)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string domain = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->domain(), output);
  }

  // optional bool exclude = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->exclude(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:url_pattern_index.proto.DomainListItem)
}

size_t DomainListItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:url_pattern_index.proto.DomainListItem)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string domain = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->domain());
    }

    // optional bool exclude = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DomainListItem::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DomainListItem*>(
      &from));
}

void DomainListItem::MergeFrom(const DomainListItem& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:url_pattern_index.proto.DomainListItem)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      domain_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.domain_);
    }
    if (cached_has_bits & 0x00000002u) {
      exclude_ = from.exclude_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DomainListItem::CopyFrom(const DomainListItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:url_pattern_index.proto.DomainListItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DomainListItem::IsInitialized() const {
  return true;
}

void DomainListItem::InternalSwap(DomainListItem* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  domain_.Swap(&other->domain_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(exclude_, other->exclude_);
}

std::string DomainListItem::GetTypeName() const {
  return "url_pattern_index.proto.DomainListItem";
}


// ===================================================================

void UrlRule::InitAsDefaultInstance() {
}
class UrlRule::_Internal {
 public:
  using HasBits = decltype(std::declval<UrlRule>()._has_bits_);
  static void set_has_semantics(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_source_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_element_types(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_activation_types(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_url_pattern_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_anchor_left(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_anchor_right(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_match_case(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_url_pattern(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UrlRule::UrlRule()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:url_pattern_index.proto.UrlRule)
}
UrlRule::UrlRule(const UrlRule& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      domains_(from.domains_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  url_pattern_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_url_pattern()) {
    url_pattern_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.url_pattern_);
  }
  ::memcpy(&semantics_, &from.semantics_,
    static_cast<size_t>(reinterpret_cast<char*>(&match_case_) -
    reinterpret_cast<char*>(&semantics_)) + sizeof(match_case_));
  // @@protoc_insertion_point(copy_constructor:url_pattern_index.proto.UrlRule)
}

void UrlRule::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UrlRule_rules_2eproto.base);
  url_pattern_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&semantics_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&match_case_) -
      reinterpret_cast<char*>(&semantics_)) + sizeof(match_case_));
}

UrlRule::~UrlRule() {
  // @@protoc_insertion_point(destructor:url_pattern_index.proto.UrlRule)
  SharedDtor();
}

void UrlRule::SharedDtor() {
  url_pattern_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UrlRule::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UrlRule& UrlRule::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UrlRule_rules_2eproto.base);
  return *internal_default_instance();
}


void UrlRule::Clear() {
// @@protoc_insertion_point(message_clear_start:url_pattern_index.proto.UrlRule)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  domains_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    url_pattern_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&semantics_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&anchor_right_) -
        reinterpret_cast<char*>(&semantics_)) + sizeof(anchor_right_));
  }
  match_case_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UrlRule::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .url_pattern_index.proto.RuleSemantics semantics = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::url_pattern_index::proto::RuleSemantics_IsValid(val))) {
            set_semantics(static_cast<::url_pattern_index::proto::RuleSemantics>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .url_pattern_index.proto.SourceType source_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::url_pattern_index::proto::SourceType_IsValid(val))) {
            set_source_type(static_cast<::url_pattern_index::proto::SourceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional int32 element_types = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_element_types(&has_bits);
          element_types_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 activation_types = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_activation_types(&has_bits);
          activation_types_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .url_pattern_index.proto.DomainListItem domains = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_domains(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 42);
        } else goto handle_unusual;
        continue;
      // optional .url_pattern_index.proto.UrlPatternType url_pattern_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::url_pattern_index::proto::UrlPatternType_IsValid(val))) {
            set_url_pattern_type(static_cast<::url_pattern_index::proto::UrlPatternType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .url_pattern_index.proto.AnchorType anchor_left = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::url_pattern_index::proto::AnchorType_IsValid(val))) {
            set_anchor_left(static_cast<::url_pattern_index::proto::AnchorType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .url_pattern_index.proto.AnchorType anchor_right = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::url_pattern_index::proto::AnchorType_IsValid(val))) {
            set_anchor_right(static_cast<::url_pattern_index::proto::AnchorType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool match_case = 9 [deprecated = true];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_match_case(&has_bits);
          match_case_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string url_pattern = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_url_pattern(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UrlRule::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:url_pattern_index.proto.UrlRule)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .url_pattern_index.proto.RuleSemantics semantics = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::url_pattern_index::proto::RuleSemantics_IsValid(value)) {
            set_semantics(static_cast< ::url_pattern_index::proto::RuleSemantics >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .url_pattern_index.proto.SourceType source_type = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::url_pattern_index::proto::SourceType_IsValid(value)) {
            set_source_type(static_cast< ::url_pattern_index::proto::SourceType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 element_types = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_element_types(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &element_types_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 activation_types = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_activation_types(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &activation_types_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .url_pattern_index.proto.DomainListItem domains = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_domains()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .url_pattern_index.proto.UrlPatternType url_pattern_type = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::url_pattern_index::proto::UrlPatternType_IsValid(value)) {
            set_url_pattern_type(static_cast< ::url_pattern_index::proto::UrlPatternType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(48u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .url_pattern_index.proto.AnchorType anchor_left = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::url_pattern_index::proto::AnchorType_IsValid(value)) {
            set_anchor_left(static_cast< ::url_pattern_index::proto::AnchorType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(56u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .url_pattern_index.proto.AnchorType anchor_right = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::url_pattern_index::proto::AnchorType_IsValid(value)) {
            set_anchor_right(static_cast< ::url_pattern_index::proto::AnchorType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(64u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool match_case = 9 [deprecated = true];
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          _Internal::set_has_match_case(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &match_case_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string url_pattern = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (82 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_url_pattern()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:url_pattern_index.proto.UrlRule)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:url_pattern_index.proto.UrlRule)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UrlRule::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:url_pattern_index.proto.UrlRule)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .url_pattern_index.proto.RuleSemantics semantics = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->semantics(), output);
  }

  // optional .url_pattern_index.proto.SourceType source_type = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->source_type(), output);
  }

  // optional int32 element_types = 3;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->element_types(), output);
  }

  // optional int32 activation_types = 4;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->activation_types(), output);
  }

  // repeated .url_pattern_index.proto.DomainListItem domains = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->domains_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      5,
      this->domains(static_cast<int>(i)),
      output);
  }

  // optional .url_pattern_index.proto.UrlPatternType url_pattern_type = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      6, this->url_pattern_type(), output);
  }

  // optional .url_pattern_index.proto.AnchorType anchor_left = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      7, this->anchor_left(), output);
  }

  // optional .url_pattern_index.proto.AnchorType anchor_right = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      8, this->anchor_right(), output);
  }

  // optional bool match_case = 9 [deprecated = true];
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(9, this->match_case(), output);
  }

  // optional string url_pattern = 10;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->url_pattern(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:url_pattern_index.proto.UrlRule)
}

size_t UrlRule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:url_pattern_index.proto.UrlRule)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .url_pattern_index.proto.DomainListItem domains = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->domains_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->domains(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string url_pattern = 10;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->url_pattern());
    }

    // optional .url_pattern_index.proto.RuleSemantics semantics = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->semantics());
    }

    // optional .url_pattern_index.proto.SourceType source_type = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->source_type());
    }

    // optional int32 element_types = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->element_types());
    }

    // optional int32 activation_types = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->activation_types());
    }

    // optional .url_pattern_index.proto.UrlPatternType url_pattern_type = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->url_pattern_type());
    }

    // optional .url_pattern_index.proto.AnchorType anchor_left = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->anchor_left());
    }

    // optional .url_pattern_index.proto.AnchorType anchor_right = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->anchor_right());
    }

  }
  // optional bool match_case = 9 [deprecated = true];
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 1;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UrlRule::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UrlRule*>(
      &from));
}

void UrlRule::MergeFrom(const UrlRule& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:url_pattern_index.proto.UrlRule)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  domains_.MergeFrom(from.domains_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      url_pattern_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.url_pattern_);
    }
    if (cached_has_bits & 0x00000002u) {
      semantics_ = from.semantics_;
    }
    if (cached_has_bits & 0x00000004u) {
      source_type_ = from.source_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      element_types_ = from.element_types_;
    }
    if (cached_has_bits & 0x00000010u) {
      activation_types_ = from.activation_types_;
    }
    if (cached_has_bits & 0x00000020u) {
      url_pattern_type_ = from.url_pattern_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      anchor_left_ = from.anchor_left_;
    }
    if (cached_has_bits & 0x00000080u) {
      anchor_right_ = from.anchor_right_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    set_match_case(from.match_case());
  }
}

void UrlRule::CopyFrom(const UrlRule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:url_pattern_index.proto.UrlRule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UrlRule::IsInitialized() const {
  return true;
}

void UrlRule::InternalSwap(UrlRule* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&domains_)->InternalSwap(CastToBase(&other->domains_));
  url_pattern_.Swap(&other->url_pattern_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(semantics_, other->semantics_);
  swap(source_type_, other->source_type_);
  swap(element_types_, other->element_types_);
  swap(activation_types_, other->activation_types_);
  swap(url_pattern_type_, other->url_pattern_type_);
  swap(anchor_left_, other->anchor_left_);
  swap(anchor_right_, other->anchor_right_);
  swap(match_case_, other->match_case_);
}

std::string UrlRule::GetTypeName() const {
  return "url_pattern_index.proto.UrlRule";
}


// ===================================================================

void CssRule::InitAsDefaultInstance() {
}
class CssRule::_Internal {
 public:
  using HasBits = decltype(std::declval<CssRule>()._has_bits_);
  static void set_has_semantics(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_css_selector(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CssRule::CssRule()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:url_pattern_index.proto.CssRule)
}
CssRule::CssRule(const CssRule& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      domains_(from.domains_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  css_selector_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_css_selector()) {
    css_selector_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.css_selector_);
  }
  semantics_ = from.semantics_;
  // @@protoc_insertion_point(copy_constructor:url_pattern_index.proto.CssRule)
}

void CssRule::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CssRule_rules_2eproto.base);
  css_selector_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  semantics_ = 0;
}

CssRule::~CssRule() {
  // @@protoc_insertion_point(destructor:url_pattern_index.proto.CssRule)
  SharedDtor();
}

void CssRule::SharedDtor() {
  css_selector_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CssRule::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CssRule& CssRule::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CssRule_rules_2eproto.base);
  return *internal_default_instance();
}


void CssRule::Clear() {
// @@protoc_insertion_point(message_clear_start:url_pattern_index.proto.CssRule)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  domains_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    css_selector_.ClearNonDefaultToEmptyNoArena();
  }
  semantics_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CssRule::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .url_pattern_index.proto.RuleSemantics semantics = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::url_pattern_index::proto::RuleSemantics_IsValid(val))) {
            set_semantics(static_cast<::url_pattern_index::proto::RuleSemantics>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated .url_pattern_index.proto.DomainListItem domains = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_domains(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      // optional string css_selector = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_css_selector(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CssRule::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:url_pattern_index.proto.CssRule)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .url_pattern_index.proto.RuleSemantics semantics = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::url_pattern_index::proto::RuleSemantics_IsValid(value)) {
            set_semantics(static_cast< ::url_pattern_index::proto::RuleSemantics >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .url_pattern_index.proto.DomainListItem domains = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_domains()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string css_selector = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_css_selector()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:url_pattern_index.proto.CssRule)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:url_pattern_index.proto.CssRule)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CssRule::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:url_pattern_index.proto.CssRule)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .url_pattern_index.proto.RuleSemantics semantics = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->semantics(), output);
  }

  // repeated .url_pattern_index.proto.DomainListItem domains = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->domains_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2,
      this->domains(static_cast<int>(i)),
      output);
  }

  // optional string css_selector = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->css_selector(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:url_pattern_index.proto.CssRule)
}

size_t CssRule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:url_pattern_index.proto.CssRule)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .url_pattern_index.proto.DomainListItem domains = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->domains_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->domains(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string css_selector = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->css_selector());
    }

    // optional .url_pattern_index.proto.RuleSemantics semantics = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->semantics());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CssRule::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CssRule*>(
      &from));
}

void CssRule::MergeFrom(const CssRule& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:url_pattern_index.proto.CssRule)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  domains_.MergeFrom(from.domains_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      css_selector_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.css_selector_);
    }
    if (cached_has_bits & 0x00000002u) {
      semantics_ = from.semantics_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CssRule::CopyFrom(const CssRule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:url_pattern_index.proto.CssRule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CssRule::IsInitialized() const {
  return true;
}

void CssRule::InternalSwap(CssRule* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&domains_)->InternalSwap(CastToBase(&other->domains_));
  css_selector_.Swap(&other->css_selector_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(semantics_, other->semantics_);
}

std::string CssRule::GetTypeName() const {
  return "url_pattern_index.proto.CssRule";
}


// ===================================================================

void Comment::InitAsDefaultInstance() {
}
class Comment::_Internal {
 public:
  using HasBits = decltype(std::declval<Comment>()._has_bits_);
  static void set_has_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Comment::Comment()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:url_pattern_index.proto.Comment)
}
Comment::Comment(const Comment& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_text()) {
    text_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.text_);
  }
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_key()) {
    key_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.key_);
  }
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_value()) {
    value_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.value_);
  }
  // @@protoc_insertion_point(copy_constructor:url_pattern_index.proto.Comment)
}

void Comment::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Comment_rules_2eproto.base);
  text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

Comment::~Comment() {
  // @@protoc_insertion_point(destructor:url_pattern_index.proto.Comment)
  SharedDtor();
}

void Comment::SharedDtor() {
  text_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Comment::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Comment& Comment::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Comment_rules_2eproto.base);
  return *internal_default_instance();
}


void Comment::Clear() {
// @@protoc_insertion_point(message_clear_start:url_pattern_index.proto.Comment)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      text_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      key_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      value_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Comment::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_text(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_key(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_value(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Comment::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:url_pattern_index.proto.Comment)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string text = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string key = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string value = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:url_pattern_index.proto.Comment)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:url_pattern_index.proto.Comment)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Comment::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:url_pattern_index.proto.Comment)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string text = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->text(), output);
  }

  // optional string key = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->key(), output);
  }

  // optional string value = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->value(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:url_pattern_index.proto.Comment)
}

size_t Comment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:url_pattern_index.proto.Comment)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string text = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->text());
    }

    // optional string key = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->key());
    }

    // optional string value = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->value());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Comment::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Comment*>(
      &from));
}

void Comment::MergeFrom(const Comment& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:url_pattern_index.proto.Comment)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      text_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.text_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      key_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      value_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
  }
}

void Comment::CopyFrom(const Comment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:url_pattern_index.proto.Comment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Comment::IsInitialized() const {
  return true;
}

void Comment::InternalSwap(Comment* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  text_.Swap(&other->text_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  key_.Swap(&other->key_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  value_.Swap(&other->value_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string Comment::GetTypeName() const {
  return "url_pattern_index.proto.Comment";
}


// ===================================================================

void FilteringRules::InitAsDefaultInstance() {
}
class FilteringRules::_Internal {
 public:
  using HasBits = decltype(std::declval<FilteringRules>()._has_bits_);
};

FilteringRules::FilteringRules()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:url_pattern_index.proto.FilteringRules)
}
FilteringRules::FilteringRules(const FilteringRules& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      url_rules_(from.url_rules_),
      css_rules_(from.css_rules_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:url_pattern_index.proto.FilteringRules)
}

void FilteringRules::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FilteringRules_rules_2eproto.base);
}

FilteringRules::~FilteringRules() {
  // @@protoc_insertion_point(destructor:url_pattern_index.proto.FilteringRules)
  SharedDtor();
}

void FilteringRules::SharedDtor() {
}

void FilteringRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FilteringRules& FilteringRules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FilteringRules_rules_2eproto.base);
  return *internal_default_instance();
}


void FilteringRules::Clear() {
// @@protoc_insertion_point(message_clear_start:url_pattern_index.proto.FilteringRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  url_rules_.Clear();
  css_rules_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* FilteringRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .url_pattern_index.proto.UrlRule url_rules = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_url_rules(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      // repeated .url_pattern_index.proto.CssRule css_rules = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_css_rules(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool FilteringRules::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:url_pattern_index.proto.FilteringRules)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .url_pattern_index.proto.UrlRule url_rules = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_url_rules()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .url_pattern_index.proto.CssRule css_rules = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_css_rules()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:url_pattern_index.proto.FilteringRules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:url_pattern_index.proto.FilteringRules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void FilteringRules::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:url_pattern_index.proto.FilteringRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .url_pattern_index.proto.UrlRule url_rules = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->url_rules_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1,
      this->url_rules(static_cast<int>(i)),
      output);
  }

  // repeated .url_pattern_index.proto.CssRule css_rules = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->css_rules_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2,
      this->css_rules(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:url_pattern_index.proto.FilteringRules)
}

size_t FilteringRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:url_pattern_index.proto.FilteringRules)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .url_pattern_index.proto.UrlRule url_rules = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->url_rules_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->url_rules(static_cast<int>(i)));
    }
  }

  // repeated .url_pattern_index.proto.CssRule css_rules = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->css_rules_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->css_rules(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FilteringRules::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FilteringRules*>(
      &from));
}

void FilteringRules::MergeFrom(const FilteringRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:url_pattern_index.proto.FilteringRules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  url_rules_.MergeFrom(from.url_rules_);
  css_rules_.MergeFrom(from.css_rules_);
}

void FilteringRules::CopyFrom(const FilteringRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:url_pattern_index.proto.FilteringRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FilteringRules::IsInitialized() const {
  return true;
}

void FilteringRules::InternalSwap(FilteringRules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&url_rules_)->InternalSwap(CastToBase(&other->url_rules_));
  CastToBase(&css_rules_)->InternalSwap(CastToBase(&other->css_rules_));
}

std::string FilteringRules::GetTypeName() const {
  return "url_pattern_index.proto.FilteringRules";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace url_pattern_index
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::url_pattern_index::proto::DomainListItem* Arena::CreateMaybeMessage< ::url_pattern_index::proto::DomainListItem >(Arena* arena) {
  return Arena::CreateInternal< ::url_pattern_index::proto::DomainListItem >(arena);
}
template<> PROTOBUF_NOINLINE ::url_pattern_index::proto::UrlRule* Arena::CreateMaybeMessage< ::url_pattern_index::proto::UrlRule >(Arena* arena) {
  return Arena::CreateInternal< ::url_pattern_index::proto::UrlRule >(arena);
}
template<> PROTOBUF_NOINLINE ::url_pattern_index::proto::CssRule* Arena::CreateMaybeMessage< ::url_pattern_index::proto::CssRule >(Arena* arena) {
  return Arena::CreateInternal< ::url_pattern_index::proto::CssRule >(arena);
}
template<> PROTOBUF_NOINLINE ::url_pattern_index::proto::Comment* Arena::CreateMaybeMessage< ::url_pattern_index::proto::Comment >(Arena* arena) {
  return Arena::CreateInternal< ::url_pattern_index::proto::Comment >(arena);
}
template<> PROTOBUF_NOINLINE ::url_pattern_index::proto::FilteringRules* Arena::CreateMaybeMessage< ::url_pattern_index::proto::FilteringRules >(Arena* arena) {
  return Arena::CreateInternal< ::url_pattern_index::proto::FilteringRules >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
