// components/autofill/core/common/mojom/autofill_types.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif

#include "components/autofill/core/common/mojom/autofill_types.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/hash/md5_constexpr.h"
#include "base/logging.h"
#include "base/run_loop.h"
#include "base/task/common/task_annotator.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_context.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"

#include "components/autofill/core/common/mojom/autofill_types.mojom-params-data.h"
#include "components/autofill/core/common/mojom/autofill_types.mojom-shared-message-ids.h"

#include "components/autofill/core/common/mojom/autofill_types.mojom-import-headers.h"


#ifndef COMPONENTS_AUTOFILL_CORE_COMMON_MOJOM_AUTOFILL_TYPES_MOJOM_JUMBO_H_
#define COMPONENTS_AUTOFILL_CORE_COMMON_MOJOM_AUTOFILL_TYPES_MOJOM_JUMBO_H_
#include "components/autofill/core/common/mojom/autofill_types_mojom_traits.h"
#include "mojo/public/cpp/base/string16_mojom_traits.h"
#include "mojo/public/cpp/base/text_direction_mojom_traits.h"
#include "mojo/public/cpp/base/time_mojom_traits.h"
#include "mojo/public/cpp/base/unguessable_token_mojom_traits.h"
#include "ui/gfx/geometry/mojom/geometry_mojom_traits.h"
#include "url/mojom/origin_mojom_traits.h"
#include "url/mojom/url_gurl_mojom_traits.h"
#endif
namespace autofill {
namespace mojom {
FormFieldData::FormFieldData()
    : label(),
      name(),
      id_attribute(),
      name_attribute(),
      value(),
      form_control_type(),
      autocomplete_attribute(),
      placeholder(),
      css_classes(),
      aria_label(),
      aria_description(),
      unique_renderer_id(),
      properties_mask(),
      form_control_ax_id(),
      max_length(),
      is_autofilled(),
      section(),
      check_status(),
      is_focusable(),
      should_autocomplete(),
      role(),
      text_direction(),
      is_enabled(),
      is_readonly(),
      typed_value(),
      option_values(),
      option_contents(),
      label_source() {}

FormFieldData::FormFieldData(
    const ::base::string16& label_in,
    const ::base::string16& name_in,
    const ::base::string16& id_attribute_in,
    const ::base::string16& name_attribute_in,
    const ::base::string16& value_in,
    const std::string& form_control_type_in,
    const std::string& autocomplete_attribute_in,
    const ::base::string16& placeholder_in,
    const ::base::string16& css_classes_in,
    const ::base::string16& aria_label_in,
    const ::base::string16& aria_description_in,
    uint32_t unique_renderer_id_in,
    uint32_t properties_mask_in,
    int32_t form_control_ax_id_in,
    uint64_t max_length_in,
    bool is_autofilled_in,
    const std::string& section_in,
    FormFieldData::CheckStatus check_status_in,
    bool is_focusable_in,
    bool should_autocomplete_in,
    FormFieldData::RoleAttribute role_in,
    ::base::i18n::TextDirection text_direction_in,
    bool is_enabled_in,
    bool is_readonly_in,
    const ::base::string16& typed_value_in,
    std::vector<::base::string16> option_values_in,
    std::vector<::base::string16> option_contents_in,
    FormFieldData::LabelSource label_source_in)
    : label(std::move(label_in)),
      name(std::move(name_in)),
      id_attribute(std::move(id_attribute_in)),
      name_attribute(std::move(name_attribute_in)),
      value(std::move(value_in)),
      form_control_type(std::move(form_control_type_in)),
      autocomplete_attribute(std::move(autocomplete_attribute_in)),
      placeholder(std::move(placeholder_in)),
      css_classes(std::move(css_classes_in)),
      aria_label(std::move(aria_label_in)),
      aria_description(std::move(aria_description_in)),
      unique_renderer_id(std::move(unique_renderer_id_in)),
      properties_mask(std::move(properties_mask_in)),
      form_control_ax_id(std::move(form_control_ax_id_in)),
      max_length(std::move(max_length_in)),
      is_autofilled(std::move(is_autofilled_in)),
      section(std::move(section_in)),
      check_status(std::move(check_status_in)),
      is_focusable(std::move(is_focusable_in)),
      should_autocomplete(std::move(should_autocomplete_in)),
      role(std::move(role_in)),
      text_direction(std::move(text_direction_in)),
      is_enabled(std::move(is_enabled_in)),
      is_readonly(std::move(is_readonly_in)),
      typed_value(std::move(typed_value_in)),
      option_values(std::move(option_values_in)),
      option_contents(std::move(option_contents_in)),
      label_source(std::move(label_source_in)) {}

FormFieldData::~FormFieldData() = default;

bool FormFieldData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ButtonTitleInfo::ButtonTitleInfo()
    : title(),
      type() {}

ButtonTitleInfo::ButtonTitleInfo(
    const ::base::string16& title_in,
    ButtonTitleType type_in)
    : title(std::move(title_in)),
      type(std::move(type_in)) {}

ButtonTitleInfo::~ButtonTitleInfo() = default;

bool ButtonTitleInfo::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
FormData::FormData()
    : id_attribute(),
      name_attribute(),
      name(),
      button_titles(),
      url(),
      action(),
      is_action_empty(),
      main_frame_origin(),
      is_form_tag(),
      is_formless_checkout(),
      unique_renderer_id(),
      submission_event(),
      fields(),
      username_predictions(),
      is_gaia_with_skip_save_password_form() {}

FormData::FormData(
    const ::base::string16& id_attribute_in,
    const ::base::string16& name_attribute_in,
    const ::base::string16& name_in,
    std::vector<ButtonTitleInfoPtr> button_titles_in,
    const ::GURL& url_in,
    const ::GURL& action_in,
    bool is_action_empty_in,
    const ::url::Origin& main_frame_origin_in,
    bool is_form_tag_in,
    bool is_formless_checkout_in,
    uint32_t unique_renderer_id_in,
    SubmissionIndicatorEvent submission_event_in,
    std::vector<::autofill::FormFieldData> fields_in,
    std::vector<uint32_t> username_predictions_in,
    bool is_gaia_with_skip_save_password_form_in)
    : id_attribute(std::move(id_attribute_in)),
      name_attribute(std::move(name_attribute_in)),
      name(std::move(name_in)),
      button_titles(std::move(button_titles_in)),
      url(std::move(url_in)),
      action(std::move(action_in)),
      is_action_empty(std::move(is_action_empty_in)),
      main_frame_origin(std::move(main_frame_origin_in)),
      is_form_tag(std::move(is_form_tag_in)),
      is_formless_checkout(std::move(is_formless_checkout_in)),
      unique_renderer_id(std::move(unique_renderer_id_in)),
      submission_event(std::move(submission_event_in)),
      fields(std::move(fields_in)),
      username_predictions(std::move(username_predictions_in)),
      is_gaia_with_skip_save_password_form(std::move(is_gaia_with_skip_save_password_form_in)) {}

FormData::~FormData() = default;

bool FormData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
FormFieldDataPredictions::FormFieldDataPredictions()
    : field(),
      signature(),
      heuristic_type(),
      server_type(),
      overall_type(),
      parseable_name(),
      section() {}

FormFieldDataPredictions::FormFieldDataPredictions(
    const ::autofill::FormFieldData& field_in,
    const std::string& signature_in,
    const std::string& heuristic_type_in,
    const std::string& server_type_in,
    const std::string& overall_type_in,
    const std::string& parseable_name_in,
    const std::string& section_in)
    : field(std::move(field_in)),
      signature(std::move(signature_in)),
      heuristic_type(std::move(heuristic_type_in)),
      server_type(std::move(server_type_in)),
      overall_type(std::move(overall_type_in)),
      parseable_name(std::move(parseable_name_in)),
      section(std::move(section_in)) {}

FormFieldDataPredictions::~FormFieldDataPredictions() = default;

bool FormFieldDataPredictions::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
FormDataPredictions::FormDataPredictions()
    : data(),
      signature(),
      fields() {}

FormDataPredictions::FormDataPredictions(
    const ::autofill::FormData& data_in,
    const std::string& signature_in,
    std::vector<::autofill::FormFieldDataPredictions> fields_in)
    : data(std::move(data_in)),
      signature(std::move(signature_in)),
      fields(std::move(fields_in)) {}

FormDataPredictions::~FormDataPredictions() = default;

bool FormDataPredictions::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
PasswordAndMetadata::PasswordAndMetadata()
    : password(),
      realm(),
      uses_account_store() {}

PasswordAndMetadata::PasswordAndMetadata(
    const ::base::string16& password_in,
    const std::string& realm_in,
    bool uses_account_store_in)
    : password(std::move(password_in)),
      realm(std::move(realm_in)),
      uses_account_store(std::move(uses_account_store_in)) {}

PasswordAndMetadata::~PasswordAndMetadata() = default;

bool PasswordAndMetadata::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
PasswordFormFillData::PasswordFormFillData()
    : form_renderer_id(),
      origin(),
      action(),
      username_field(),
      password_field(),
      username_may_use_prefilled_placeholder(),
      preferred_realm(),
      uses_account_store(),
      additional_logins(),
      wait_for_username(),
      has_renderer_ids() {}

PasswordFormFillData::PasswordFormFillData(
    uint32_t form_renderer_id_in,
    const ::GURL& origin_in,
    const ::GURL& action_in,
    const ::autofill::FormFieldData& username_field_in,
    const ::autofill::FormFieldData& password_field_in,
    bool username_may_use_prefilled_placeholder_in,
    const std::string& preferred_realm_in,
    bool uses_account_store_in,
    const base::flat_map<::base::string16, ::autofill::PasswordAndMetadata>& additional_logins_in,
    bool wait_for_username_in,
    bool has_renderer_ids_in)
    : form_renderer_id(std::move(form_renderer_id_in)),
      origin(std::move(origin_in)),
      action(std::move(action_in)),
      username_field(std::move(username_field_in)),
      password_field(std::move(password_field_in)),
      username_may_use_prefilled_placeholder(std::move(username_may_use_prefilled_placeholder_in)),
      preferred_realm(std::move(preferred_realm_in)),
      uses_account_store(std::move(uses_account_store_in)),
      additional_logins(std::move(additional_logins_in)),
      wait_for_username(std::move(wait_for_username_in)),
      has_renderer_ids(std::move(has_renderer_ids_in)) {}

PasswordFormFillData::~PasswordFormFillData() = default;

bool PasswordFormFillData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
PasswordFormGenerationData::PasswordFormGenerationData()
    : new_password_renderer_id(),
      confirmation_password_renderer_id() {}

PasswordFormGenerationData::PasswordFormGenerationData(
    uint32_t new_password_renderer_id_in,
    uint32_t confirmation_password_renderer_id_in)
    : new_password_renderer_id(std::move(new_password_renderer_id_in)),
      confirmation_password_renderer_id(std::move(confirmation_password_renderer_id_in)) {}

PasswordFormGenerationData::~PasswordFormGenerationData() = default;

bool PasswordFormGenerationData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
PasswordGenerationUIData::PasswordGenerationUIData()
    : bounds(),
      max_length(),
      generation_element(),
      generation_element_id(),
      is_generation_element_password_type(),
      text_direction(),
      form_data() {}

PasswordGenerationUIData::PasswordGenerationUIData(
    const ::gfx::RectF& bounds_in,
    int32_t max_length_in,
    const ::base::string16& generation_element_in,
    uint32_t generation_element_id_in,
    bool is_generation_element_password_type_in,
    ::base::i18n::TextDirection text_direction_in,
    const ::autofill::FormData& form_data_in)
    : bounds(std::move(bounds_in)),
      max_length(std::move(max_length_in)),
      generation_element(std::move(generation_element_in)),
      generation_element_id(std::move(generation_element_id_in)),
      is_generation_element_password_type(std::move(is_generation_element_password_type_in)),
      text_direction(std::move(text_direction_in)),
      form_data(std::move(form_data_in)) {}

PasswordGenerationUIData::~PasswordGenerationUIData() = default;

bool PasswordGenerationUIData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ValueElementPair::ValueElementPair()
    : value(),
      field_name() {}

ValueElementPair::ValueElementPair(
    const ::base::string16& value_in,
    const ::base::string16& field_name_in)
    : value(std::move(value_in)),
      field_name(std::move(field_name_in)) {}

ValueElementPair::~ValueElementPair() = default;

bool ValueElementPair::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
PasswordForm::PasswordForm()
    : scheme(),
      signon_realm(),
      origin_with_path(),
      action(),
      affiliated_web_realm(),
      submit_element(),
      username_element(),
      username_marked_by_site(),
      username_value(),
      all_possible_usernames(),
      all_possible_passwords(),
      form_has_autofilled_value(),
      password_element(),
      password_value(),
      new_password_element(),
      new_password_value(),
      new_password_marked_by_site(),
      confirmation_password_element(),
      date_created(),
      date_synced(),
      blacklisted_by_user(),
      type(),
      times_used(),
      form_data(),
      generation_upload_status(),
      display_name(),
      icon_url(),
      federation_origin(),
      skip_zero_click(),
      was_parsed_using_autofill_predictions(),
      is_public_suffix_match(),
      is_affiliation_based_match(),
      submission_event(),
      only_for_fallback() {}

PasswordForm::PasswordForm(
    PasswordForm::Scheme scheme_in,
    const std::string& signon_realm_in,
    const ::GURL& origin_with_path_in,
    const ::GURL& action_in,
    const std::string& affiliated_web_realm_in,
    const ::base::string16& submit_element_in,
    const ::base::string16& username_element_in,
    bool username_marked_by_site_in,
    const ::base::string16& username_value_in,
    std::vector<::autofill::ValueElementPair> all_possible_usernames_in,
    std::vector<::autofill::ValueElementPair> all_possible_passwords_in,
    bool form_has_autofilled_value_in,
    const ::base::string16& password_element_in,
    const ::base::string16& password_value_in,
    const ::base::string16& new_password_element_in,
    const ::base::string16& new_password_value_in,
    bool new_password_marked_by_site_in,
    const ::base::string16& confirmation_password_element_in,
    ::base::Time date_created_in,
    ::base::Time date_synced_in,
    bool blacklisted_by_user_in,
    PasswordForm::Type type_in,
    int32_t times_used_in,
    const ::autofill::FormData& form_data_in,
    PasswordForm::GenerationUploadStatus generation_upload_status_in,
    const ::base::string16& display_name_in,
    const ::GURL& icon_url_in,
    const ::url::Origin& federation_origin_in,
    bool skip_zero_click_in,
    bool was_parsed_using_autofill_predictions_in,
    bool is_public_suffix_match_in,
    bool is_affiliation_based_match_in,
    SubmissionIndicatorEvent submission_event_in,
    bool only_for_fallback_in)
    : scheme(std::move(scheme_in)),
      signon_realm(std::move(signon_realm_in)),
      origin_with_path(std::move(origin_with_path_in)),
      action(std::move(action_in)),
      affiliated_web_realm(std::move(affiliated_web_realm_in)),
      submit_element(std::move(submit_element_in)),
      username_element(std::move(username_element_in)),
      username_marked_by_site(std::move(username_marked_by_site_in)),
      username_value(std::move(username_value_in)),
      all_possible_usernames(std::move(all_possible_usernames_in)),
      all_possible_passwords(std::move(all_possible_passwords_in)),
      form_has_autofilled_value(std::move(form_has_autofilled_value_in)),
      password_element(std::move(password_element_in)),
      password_value(std::move(password_value_in)),
      new_password_element(std::move(new_password_element_in)),
      new_password_value(std::move(new_password_value_in)),
      new_password_marked_by_site(std::move(new_password_marked_by_site_in)),
      confirmation_password_element(std::move(confirmation_password_element_in)),
      date_created(std::move(date_created_in)),
      date_synced(std::move(date_synced_in)),
      blacklisted_by_user(std::move(blacklisted_by_user_in)),
      type(std::move(type_in)),
      times_used(std::move(times_used_in)),
      form_data(std::move(form_data_in)),
      generation_upload_status(std::move(generation_upload_status_in)),
      display_name(std::move(display_name_in)),
      icon_url(std::move(icon_url_in)),
      federation_origin(std::move(federation_origin_in)),
      skip_zero_click(std::move(skip_zero_click_in)),
      was_parsed_using_autofill_predictions(std::move(was_parsed_using_autofill_predictions_in)),
      is_public_suffix_match(std::move(is_public_suffix_match_in)),
      is_affiliation_based_match(std::move(is_affiliation_based_match_in)),
      submission_event(std::move(submission_event_in)),
      only_for_fallback(std::move(only_for_fallback_in)) {}

PasswordForm::~PasswordForm() = default;

bool PasswordForm::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ParsingResult::ParsingResult()
    : username_renderer_id(),
      password_renderer_id(),
      new_password_renderer_id(),
      confirm_password_renderer_id() {}

ParsingResult::ParsingResult(
    uint32_t username_renderer_id_in,
    uint32_t password_renderer_id_in,
    uint32_t new_password_renderer_id_in,
    uint32_t confirm_password_renderer_id_in)
    : username_renderer_id(std::move(username_renderer_id_in)),
      password_renderer_id(std::move(password_renderer_id_in)),
      new_password_renderer_id(std::move(new_password_renderer_id_in)),
      confirm_password_renderer_id(std::move(confirm_password_renderer_id_in)) {}

ParsingResult::~ParsingResult() = default;

bool ParsingResult::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
}  // namespace mojom
}  // namespace autofill

namespace mojo {


// static
bool StructTraits<::autofill::mojom::FormFieldData::DataView, ::autofill::mojom::FormFieldDataPtr>::Read(
    ::autofill::mojom::FormFieldData::DataView input,
    ::autofill::mojom::FormFieldDataPtr* output) {
  bool success = true;
  ::autofill::mojom::FormFieldDataPtr result(::autofill::mojom::FormFieldData::New());
  
      if (success && !input.ReadLabel(&result->label))
        success = false;
      if (success && !input.ReadName(&result->name))
        success = false;
      if (success && !input.ReadIdAttribute(&result->id_attribute))
        success = false;
      if (success && !input.ReadNameAttribute(&result->name_attribute))
        success = false;
      if (success && !input.ReadValue(&result->value))
        success = false;
      if (success && !input.ReadFormControlType(&result->form_control_type))
        success = false;
      if (success && !input.ReadAutocompleteAttribute(&result->autocomplete_attribute))
        success = false;
      if (success && !input.ReadPlaceholder(&result->placeholder))
        success = false;
      if (success && !input.ReadCssClasses(&result->css_classes))
        success = false;
      if (success && !input.ReadAriaLabel(&result->aria_label))
        success = false;
      if (success && !input.ReadAriaDescription(&result->aria_description))
        success = false;
      if (success)
        result->unique_renderer_id = input.unique_renderer_id();
      if (success)
        result->properties_mask = input.properties_mask();
      if (success)
        result->form_control_ax_id = input.form_control_ax_id();
      if (success)
        result->max_length = input.max_length();
      if (success)
        result->is_autofilled = input.is_autofilled();
      if (success && !input.ReadSection(&result->section))
        success = false;
      if (success && !input.ReadCheckStatus(&result->check_status))
        success = false;
      if (success)
        result->is_focusable = input.is_focusable();
      if (success)
        result->should_autocomplete = input.should_autocomplete();
      if (success && !input.ReadRole(&result->role))
        success = false;
      if (success && !input.ReadTextDirection(&result->text_direction))
        success = false;
      if (success)
        result->is_enabled = input.is_enabled();
      if (success)
        result->is_readonly = input.is_readonly();
      if (success && !input.ReadTypedValue(&result->typed_value))
        success = false;
      if (success && !input.ReadOptionValues(&result->option_values))
        success = false;
      if (success && !input.ReadOptionContents(&result->option_contents))
        success = false;
      if (success && !input.ReadLabelSource(&result->label_source))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::ButtonTitleInfo::DataView, ::autofill::mojom::ButtonTitleInfoPtr>::Read(
    ::autofill::mojom::ButtonTitleInfo::DataView input,
    ::autofill::mojom::ButtonTitleInfoPtr* output) {
  bool success = true;
  ::autofill::mojom::ButtonTitleInfoPtr result(::autofill::mojom::ButtonTitleInfo::New());
  
      if (success && !input.ReadTitle(&result->title))
        success = false;
      if (success && !input.ReadType(&result->type))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::FormData::DataView, ::autofill::mojom::FormDataPtr>::Read(
    ::autofill::mojom::FormData::DataView input,
    ::autofill::mojom::FormDataPtr* output) {
  bool success = true;
  ::autofill::mojom::FormDataPtr result(::autofill::mojom::FormData::New());
  
      if (success && !input.ReadIdAttribute(&result->id_attribute))
        success = false;
      if (success && !input.ReadNameAttribute(&result->name_attribute))
        success = false;
      if (success && !input.ReadName(&result->name))
        success = false;
      if (success && !input.ReadButtonTitles(&result->button_titles))
        success = false;
      if (success && !input.ReadUrl(&result->url))
        success = false;
      if (success && !input.ReadAction(&result->action))
        success = false;
      if (success)
        result->is_action_empty = input.is_action_empty();
      if (success && !input.ReadMainFrameOrigin(&result->main_frame_origin))
        success = false;
      if (success)
        result->is_form_tag = input.is_form_tag();
      if (success)
        result->is_formless_checkout = input.is_formless_checkout();
      if (success)
        result->unique_renderer_id = input.unique_renderer_id();
      if (success && !input.ReadSubmissionEvent(&result->submission_event))
        success = false;
      if (success && !input.ReadFields(&result->fields))
        success = false;
      if (success && !input.ReadUsernamePredictions(&result->username_predictions))
        success = false;
      if (success)
        result->is_gaia_with_skip_save_password_form = input.is_gaia_with_skip_save_password_form();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::FormFieldDataPredictions::DataView, ::autofill::mojom::FormFieldDataPredictionsPtr>::Read(
    ::autofill::mojom::FormFieldDataPredictions::DataView input,
    ::autofill::mojom::FormFieldDataPredictionsPtr* output) {
  bool success = true;
  ::autofill::mojom::FormFieldDataPredictionsPtr result(::autofill::mojom::FormFieldDataPredictions::New());
  
      if (success && !input.ReadField(&result->field))
        success = false;
      if (success && !input.ReadSignature(&result->signature))
        success = false;
      if (success && !input.ReadHeuristicType(&result->heuristic_type))
        success = false;
      if (success && !input.ReadServerType(&result->server_type))
        success = false;
      if (success && !input.ReadOverallType(&result->overall_type))
        success = false;
      if (success && !input.ReadParseableName(&result->parseable_name))
        success = false;
      if (success && !input.ReadSection(&result->section))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::FormDataPredictions::DataView, ::autofill::mojom::FormDataPredictionsPtr>::Read(
    ::autofill::mojom::FormDataPredictions::DataView input,
    ::autofill::mojom::FormDataPredictionsPtr* output) {
  bool success = true;
  ::autofill::mojom::FormDataPredictionsPtr result(::autofill::mojom::FormDataPredictions::New());
  
      if (success && !input.ReadData(&result->data))
        success = false;
      if (success && !input.ReadSignature(&result->signature))
        success = false;
      if (success && !input.ReadFields(&result->fields))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::PasswordAndMetadata::DataView, ::autofill::mojom::PasswordAndMetadataPtr>::Read(
    ::autofill::mojom::PasswordAndMetadata::DataView input,
    ::autofill::mojom::PasswordAndMetadataPtr* output) {
  bool success = true;
  ::autofill::mojom::PasswordAndMetadataPtr result(::autofill::mojom::PasswordAndMetadata::New());
  
      if (success && !input.ReadPassword(&result->password))
        success = false;
      if (success && !input.ReadRealm(&result->realm))
        success = false;
      if (success)
        result->uses_account_store = input.uses_account_store();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::PasswordFormFillData::DataView, ::autofill::mojom::PasswordFormFillDataPtr>::Read(
    ::autofill::mojom::PasswordFormFillData::DataView input,
    ::autofill::mojom::PasswordFormFillDataPtr* output) {
  bool success = true;
  ::autofill::mojom::PasswordFormFillDataPtr result(::autofill::mojom::PasswordFormFillData::New());
  
      if (success)
        result->form_renderer_id = input.form_renderer_id();
      if (success && !input.ReadOrigin(&result->origin))
        success = false;
      if (success && !input.ReadAction(&result->action))
        success = false;
      if (success && !input.ReadUsernameField(&result->username_field))
        success = false;
      if (success && !input.ReadPasswordField(&result->password_field))
        success = false;
      if (success)
        result->username_may_use_prefilled_placeholder = input.username_may_use_prefilled_placeholder();
      if (success && !input.ReadPreferredRealm(&result->preferred_realm))
        success = false;
      if (success)
        result->uses_account_store = input.uses_account_store();
      if (success && !input.ReadAdditionalLogins(&result->additional_logins))
        success = false;
      if (success)
        result->wait_for_username = input.wait_for_username();
      if (success)
        result->has_renderer_ids = input.has_renderer_ids();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::PasswordFormGenerationData::DataView, ::autofill::mojom::PasswordFormGenerationDataPtr>::Read(
    ::autofill::mojom::PasswordFormGenerationData::DataView input,
    ::autofill::mojom::PasswordFormGenerationDataPtr* output) {
  bool success = true;
  ::autofill::mojom::PasswordFormGenerationDataPtr result(::autofill::mojom::PasswordFormGenerationData::New());
  
      if (success)
        result->new_password_renderer_id = input.new_password_renderer_id();
      if (success)
        result->confirmation_password_renderer_id = input.confirmation_password_renderer_id();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::PasswordGenerationUIData::DataView, ::autofill::mojom::PasswordGenerationUIDataPtr>::Read(
    ::autofill::mojom::PasswordGenerationUIData::DataView input,
    ::autofill::mojom::PasswordGenerationUIDataPtr* output) {
  bool success = true;
  ::autofill::mojom::PasswordGenerationUIDataPtr result(::autofill::mojom::PasswordGenerationUIData::New());
  
      if (success && !input.ReadBounds(&result->bounds))
        success = false;
      if (success)
        result->max_length = input.max_length();
      if (success && !input.ReadGenerationElement(&result->generation_element))
        success = false;
      if (success)
        result->generation_element_id = input.generation_element_id();
      if (success)
        result->is_generation_element_password_type = input.is_generation_element_password_type();
      if (success && !input.ReadTextDirection(&result->text_direction))
        success = false;
      if (success && !input.ReadFormData(&result->form_data))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::ValueElementPair::DataView, ::autofill::mojom::ValueElementPairPtr>::Read(
    ::autofill::mojom::ValueElementPair::DataView input,
    ::autofill::mojom::ValueElementPairPtr* output) {
  bool success = true;
  ::autofill::mojom::ValueElementPairPtr result(::autofill::mojom::ValueElementPair::New());
  
      if (success && !input.ReadValue(&result->value))
        success = false;
      if (success && !input.ReadFieldName(&result->field_name))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::PasswordForm::DataView, ::autofill::mojom::PasswordFormPtr>::Read(
    ::autofill::mojom::PasswordForm::DataView input,
    ::autofill::mojom::PasswordFormPtr* output) {
  bool success = true;
  ::autofill::mojom::PasswordFormPtr result(::autofill::mojom::PasswordForm::New());
  
      if (success && !input.ReadScheme(&result->scheme))
        success = false;
      if (success && !input.ReadSignonRealm(&result->signon_realm))
        success = false;
      if (success && !input.ReadOriginWithPath(&result->origin_with_path))
        success = false;
      if (success && !input.ReadAction(&result->action))
        success = false;
      if (success && !input.ReadAffiliatedWebRealm(&result->affiliated_web_realm))
        success = false;
      if (success && !input.ReadSubmitElement(&result->submit_element))
        success = false;
      if (success && !input.ReadUsernameElement(&result->username_element))
        success = false;
      if (success)
        result->username_marked_by_site = input.username_marked_by_site();
      if (success && !input.ReadUsernameValue(&result->username_value))
        success = false;
      if (success && !input.ReadAllPossibleUsernames(&result->all_possible_usernames))
        success = false;
      if (success && !input.ReadAllPossiblePasswords(&result->all_possible_passwords))
        success = false;
      if (success)
        result->form_has_autofilled_value = input.form_has_autofilled_value();
      if (success && !input.ReadPasswordElement(&result->password_element))
        success = false;
      if (success && !input.ReadPasswordValue(&result->password_value))
        success = false;
      if (success && !input.ReadNewPasswordElement(&result->new_password_element))
        success = false;
      if (success && !input.ReadNewPasswordValue(&result->new_password_value))
        success = false;
      if (success)
        result->new_password_marked_by_site = input.new_password_marked_by_site();
      if (success && !input.ReadConfirmationPasswordElement(&result->confirmation_password_element))
        success = false;
      if (success && !input.ReadDateCreated(&result->date_created))
        success = false;
      if (success && !input.ReadDateSynced(&result->date_synced))
        success = false;
      if (success)
        result->blacklisted_by_user = input.blacklisted_by_user();
      if (success && !input.ReadType(&result->type))
        success = false;
      if (success)
        result->times_used = input.times_used();
      if (success && !input.ReadFormData(&result->form_data))
        success = false;
      if (success && !input.ReadGenerationUploadStatus(&result->generation_upload_status))
        success = false;
      if (success && !input.ReadDisplayName(&result->display_name))
        success = false;
      if (success && !input.ReadIconUrl(&result->icon_url))
        success = false;
      if (success && !input.ReadFederationOrigin(&result->federation_origin))
        success = false;
      if (success)
        result->skip_zero_click = input.skip_zero_click();
      if (success)
        result->was_parsed_using_autofill_predictions = input.was_parsed_using_autofill_predictions();
      if (success)
        result->is_public_suffix_match = input.is_public_suffix_match();
      if (success)
        result->is_affiliation_based_match = input.is_affiliation_based_match();
      if (success && !input.ReadSubmissionEvent(&result->submission_event))
        success = false;
      if (success)
        result->only_for_fallback = input.only_for_fallback();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::ParsingResult::DataView, ::autofill::mojom::ParsingResultPtr>::Read(
    ::autofill::mojom::ParsingResult::DataView input,
    ::autofill::mojom::ParsingResultPtr* output) {
  bool success = true;
  ::autofill::mojom::ParsingResultPtr result(::autofill::mojom::ParsingResult::New());
  
      if (success)
        result->username_renderer_id = input.username_renderer_id();
      if (success)
        result->password_renderer_id = input.password_renderer_id();
      if (success)
        result->new_password_renderer_id = input.new_password_renderer_id();
      if (success)
        result->confirm_password_renderer_id = input.confirm_password_renderer_id();
  *output = std::move(result);
  return success;
}

}  // namespace mojo

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif