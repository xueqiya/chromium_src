// components/autofill/core/common/mojom/autofill_types.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_AUTOFILL_CORE_COMMON_MOJOM_AUTOFILL_TYPES_MOJOM_H_
#define COMPONENTS_AUTOFILL_CORE_COMMON_MOJOM_AUTOFILL_TYPES_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "base/callback.h"
#include "base/macros.h"
#include "base/optional.h"

#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#if BUILDFLAG(MOJO_TRACE_ENABLED)
#include "base/trace_event/trace_event.h"
#endif
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"
#include "components/autofill/core/common/mojom/autofill_types.mojom-shared.h"
#include "components/autofill/core/common/mojom/autofill_types.mojom-forward.h"
#include "mojo/public/mojom/base/text_direction.mojom.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "mojo/public/mojom/base/string16.mojom.h"
#include "ui/gfx/geometry/mojom/geometry.mojom.h"
#include "url/mojom/origin.mojom.h"
#include "url/mojom/url.mojom.h"
#include <string>
#include <vector>




#include "components/autofill/core/common/form_data.h"
#include "components/autofill/core/common/form_data_predictions.h"
#include "components/autofill/core/common/form_field_data.h"
#include "components/autofill/core/common/form_field_data_predictions.h"
#include "components/autofill/core/common/password_form.h"
#include "components/autofill/core/common/password_form_fill_data.h"
#include "components/autofill/core/common/password_form_generation_data.h"
#include "components/autofill/core/common/password_generation_util.h"




namespace autofill {
namespace mojom {












class  PasswordFormGenerationData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PasswordFormGenerationData, T>::value>;
  using DataView = PasswordFormGenerationDataDataView;
  using Data_ = internal::PasswordFormGenerationData_Data;

  template <typename... Args>
  static PasswordFormGenerationDataPtr New(Args&&... args) {
    return PasswordFormGenerationDataPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PasswordFormGenerationDataPtr From(const U& u) {
    return mojo::TypeConverter<PasswordFormGenerationDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PasswordFormGenerationData>::Convert(*this);
  }


  PasswordFormGenerationData();

  PasswordFormGenerationData(
      uint32_t new_password_renderer_id,
      uint32_t confirmation_password_renderer_id);

  ~PasswordFormGenerationData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PasswordFormGenerationDataPtr>
  PasswordFormGenerationDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PasswordFormGenerationData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PasswordFormGenerationData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PasswordFormGenerationData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PasswordFormGenerationData_UnserializedMessageContext<
            UserType, PasswordFormGenerationData::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<PasswordFormGenerationData::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return PasswordFormGenerationData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PasswordFormGenerationData_UnserializedMessageContext<
            UserType, PasswordFormGenerationData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PasswordFormGenerationData::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  uint32_t new_password_renderer_id;
  
  uint32_t confirmation_password_renderer_id;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PasswordFormGenerationData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PasswordFormGenerationData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PasswordFormGenerationData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PasswordFormGenerationData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}








class  ParsingResult {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ParsingResult, T>::value>;
  using DataView = ParsingResultDataView;
  using Data_ = internal::ParsingResult_Data;

  template <typename... Args>
  static ParsingResultPtr New(Args&&... args) {
    return ParsingResultPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ParsingResultPtr From(const U& u) {
    return mojo::TypeConverter<ParsingResultPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ParsingResult>::Convert(*this);
  }


  ParsingResult();

  ParsingResult(
      uint32_t username_renderer_id,
      uint32_t password_renderer_id,
      uint32_t new_password_renderer_id,
      uint32_t confirm_password_renderer_id);

  ~ParsingResult();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ParsingResultPtr>
  ParsingResultPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ParsingResult::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ParsingResult::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ParsingResult::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ParsingResult_UnserializedMessageContext<
            UserType, ParsingResult::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<ParsingResult::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ParsingResult::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ParsingResult_UnserializedMessageContext<
            UserType, ParsingResult::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ParsingResult::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  uint32_t username_renderer_id;
  
  uint32_t password_renderer_id;
  
  uint32_t new_password_renderer_id;
  
  uint32_t confirm_password_renderer_id;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ParsingResult::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ParsingResult::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ParsingResult::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ParsingResult::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}







class  FormFieldData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<FormFieldData, T>::value>;
  using DataView = FormFieldDataDataView;
  using Data_ = internal::FormFieldData_Data;
  using CheckStatus = FormFieldData_CheckStatus;
  using RoleAttribute = FormFieldData_RoleAttribute;
  using LabelSource = FormFieldData_LabelSource;

  template <typename... Args>
  static FormFieldDataPtr New(Args&&... args) {
    return FormFieldDataPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static FormFieldDataPtr From(const U& u) {
    return mojo::TypeConverter<FormFieldDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, FormFieldData>::Convert(*this);
  }


  FormFieldData();

  FormFieldData(
      const ::base::string16& label,
      const ::base::string16& name,
      const ::base::string16& id_attribute,
      const ::base::string16& name_attribute,
      const ::base::string16& value,
      const std::string& form_control_type,
      const std::string& autocomplete_attribute,
      const ::base::string16& placeholder,
      const ::base::string16& css_classes,
      const ::base::string16& aria_label,
      const ::base::string16& aria_description,
      uint32_t unique_renderer_id,
      uint32_t properties_mask,
      int32_t form_control_ax_id,
      uint64_t max_length,
      bool is_autofilled,
      const std::string& section,
      FormFieldData::CheckStatus check_status,
      bool is_focusable,
      bool should_autocomplete,
      FormFieldData::RoleAttribute role,
      ::base::i18n::TextDirection text_direction,
      bool is_enabled,
      bool is_readonly,
      const ::base::string16& typed_value,
      std::vector<::base::string16> option_values,
      std::vector<::base::string16> option_contents,
      FormFieldData::LabelSource label_source);

  ~FormFieldData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = FormFieldDataPtr>
  FormFieldDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, FormFieldData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        FormFieldData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        FormFieldData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::FormFieldData_UnserializedMessageContext<
            UserType, FormFieldData::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<FormFieldData::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return FormFieldData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::FormFieldData_UnserializedMessageContext<
            UserType, FormFieldData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<FormFieldData::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::base::string16 label;
  
  ::base::string16 name;
  
  ::base::string16 id_attribute;
  
  ::base::string16 name_attribute;
  
  ::base::string16 value;
  
  std::string form_control_type;
  
  std::string autocomplete_attribute;
  
  ::base::string16 placeholder;
  
  ::base::string16 css_classes;
  
  ::base::string16 aria_label;
  
  ::base::string16 aria_description;
  
  uint32_t unique_renderer_id;
  
  uint32_t properties_mask;
  
  int32_t form_control_ax_id;
  
  uint64_t max_length;
  
  bool is_autofilled;
  
  std::string section;
  
  FormFieldData::CheckStatus check_status;
  
  bool is_focusable;
  
  bool should_autocomplete;
  
  FormFieldData::RoleAttribute role;
  
  ::base::i18n::TextDirection text_direction;
  
  bool is_enabled;
  
  bool is_readonly;
  
  ::base::string16 typed_value;
  
  std::vector<::base::string16> option_values;
  
  std::vector<::base::string16> option_contents;
  
  FormFieldData::LabelSource label_source;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FormFieldData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, FormFieldData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, FormFieldData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, FormFieldData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  ButtonTitleInfo {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ButtonTitleInfo, T>::value>;
  using DataView = ButtonTitleInfoDataView;
  using Data_ = internal::ButtonTitleInfo_Data;

  template <typename... Args>
  static ButtonTitleInfoPtr New(Args&&... args) {
    return ButtonTitleInfoPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ButtonTitleInfoPtr From(const U& u) {
    return mojo::TypeConverter<ButtonTitleInfoPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ButtonTitleInfo>::Convert(*this);
  }


  ButtonTitleInfo();

  ButtonTitleInfo(
      const ::base::string16& title,
      ButtonTitleType type);

  ~ButtonTitleInfo();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ButtonTitleInfoPtr>
  ButtonTitleInfoPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ButtonTitleInfo::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ButtonTitleInfo::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ButtonTitleInfo::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ButtonTitleInfo_UnserializedMessageContext<
            UserType, ButtonTitleInfo::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<ButtonTitleInfo::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ButtonTitleInfo::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ButtonTitleInfo_UnserializedMessageContext<
            UserType, ButtonTitleInfo::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ButtonTitleInfo::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::base::string16 title;
  
  ButtonTitleType type;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ButtonTitleInfo::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ButtonTitleInfo::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ButtonTitleInfo::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ButtonTitleInfo::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  FormData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<FormData, T>::value>;
  using DataView = FormDataDataView;
  using Data_ = internal::FormData_Data;

  template <typename... Args>
  static FormDataPtr New(Args&&... args) {
    return FormDataPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static FormDataPtr From(const U& u) {
    return mojo::TypeConverter<FormDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, FormData>::Convert(*this);
  }


  FormData();

  FormData(
      const ::base::string16& id_attribute,
      const ::base::string16& name_attribute,
      const ::base::string16& name,
      std::vector<ButtonTitleInfoPtr> button_titles,
      const ::GURL& url,
      const ::GURL& action,
      bool is_action_empty,
      const ::url::Origin& main_frame_origin,
      bool is_form_tag,
      bool is_formless_checkout,
      uint32_t unique_renderer_id,
      SubmissionIndicatorEvent submission_event,
      std::vector<::autofill::FormFieldData> fields,
      std::vector<uint32_t> username_predictions,
      bool is_gaia_with_skip_save_password_form);

  ~FormData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = FormDataPtr>
  FormDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, FormData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        FormData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        FormData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::FormData_UnserializedMessageContext<
            UserType, FormData::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<FormData::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return FormData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::FormData_UnserializedMessageContext<
            UserType, FormData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<FormData::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::base::string16 id_attribute;
  
  ::base::string16 name_attribute;
  
  ::base::string16 name;
  
  std::vector<ButtonTitleInfoPtr> button_titles;
  
  ::GURL url;
  
  ::GURL action;
  
  bool is_action_empty;
  
  ::url::Origin main_frame_origin;
  
  bool is_form_tag;
  
  bool is_formless_checkout;
  
  uint32_t unique_renderer_id;
  
  SubmissionIndicatorEvent submission_event;
  
  std::vector<::autofill::FormFieldData> fields;
  
  std::vector<uint32_t> username_predictions;
  
  bool is_gaia_with_skip_save_password_form;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(FormData);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FormData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, FormData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, FormData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, FormData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  FormFieldDataPredictions {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<FormFieldDataPredictions, T>::value>;
  using DataView = FormFieldDataPredictionsDataView;
  using Data_ = internal::FormFieldDataPredictions_Data;

  template <typename... Args>
  static FormFieldDataPredictionsPtr New(Args&&... args) {
    return FormFieldDataPredictionsPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static FormFieldDataPredictionsPtr From(const U& u) {
    return mojo::TypeConverter<FormFieldDataPredictionsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, FormFieldDataPredictions>::Convert(*this);
  }


  FormFieldDataPredictions();

  FormFieldDataPredictions(
      const ::autofill::FormFieldData& field,
      const std::string& signature,
      const std::string& heuristic_type,
      const std::string& server_type,
      const std::string& overall_type,
      const std::string& parseable_name,
      const std::string& section);

  ~FormFieldDataPredictions();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = FormFieldDataPredictionsPtr>
  FormFieldDataPredictionsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, FormFieldDataPredictions::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        FormFieldDataPredictions::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        FormFieldDataPredictions::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::FormFieldDataPredictions_UnserializedMessageContext<
            UserType, FormFieldDataPredictions::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<FormFieldDataPredictions::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return FormFieldDataPredictions::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::FormFieldDataPredictions_UnserializedMessageContext<
            UserType, FormFieldDataPredictions::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<FormFieldDataPredictions::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::autofill::FormFieldData field;
  
  std::string signature;
  
  std::string heuristic_type;
  
  std::string server_type;
  
  std::string overall_type;
  
  std::string parseable_name;
  
  std::string section;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FormFieldDataPredictions::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, FormFieldDataPredictions::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, FormFieldDataPredictions::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, FormFieldDataPredictions::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  FormDataPredictions {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<FormDataPredictions, T>::value>;
  using DataView = FormDataPredictionsDataView;
  using Data_ = internal::FormDataPredictions_Data;

  template <typename... Args>
  static FormDataPredictionsPtr New(Args&&... args) {
    return FormDataPredictionsPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static FormDataPredictionsPtr From(const U& u) {
    return mojo::TypeConverter<FormDataPredictionsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, FormDataPredictions>::Convert(*this);
  }


  FormDataPredictions();

  FormDataPredictions(
      const ::autofill::FormData& data,
      const std::string& signature,
      std::vector<::autofill::FormFieldDataPredictions> fields);

  ~FormDataPredictions();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = FormDataPredictionsPtr>
  FormDataPredictionsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, FormDataPredictions::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        FormDataPredictions::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        FormDataPredictions::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::FormDataPredictions_UnserializedMessageContext<
            UserType, FormDataPredictions::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<FormDataPredictions::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return FormDataPredictions::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::FormDataPredictions_UnserializedMessageContext<
            UserType, FormDataPredictions::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<FormDataPredictions::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::autofill::FormData data;
  
  std::string signature;
  
  std::vector<::autofill::FormFieldDataPredictions> fields;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FormDataPredictions::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, FormDataPredictions::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, FormDataPredictions::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, FormDataPredictions::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  PasswordAndMetadata {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PasswordAndMetadata, T>::value>;
  using DataView = PasswordAndMetadataDataView;
  using Data_ = internal::PasswordAndMetadata_Data;

  template <typename... Args>
  static PasswordAndMetadataPtr New(Args&&... args) {
    return PasswordAndMetadataPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PasswordAndMetadataPtr From(const U& u) {
    return mojo::TypeConverter<PasswordAndMetadataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PasswordAndMetadata>::Convert(*this);
  }


  PasswordAndMetadata();

  PasswordAndMetadata(
      const ::base::string16& password,
      const std::string& realm,
      bool uses_account_store);

  ~PasswordAndMetadata();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PasswordAndMetadataPtr>
  PasswordAndMetadataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PasswordAndMetadata::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PasswordAndMetadata::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PasswordAndMetadata::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PasswordAndMetadata_UnserializedMessageContext<
            UserType, PasswordAndMetadata::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<PasswordAndMetadata::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return PasswordAndMetadata::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PasswordAndMetadata_UnserializedMessageContext<
            UserType, PasswordAndMetadata::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PasswordAndMetadata::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::base::string16 password;
  
  std::string realm;
  
  bool uses_account_store;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PasswordAndMetadata::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PasswordAndMetadata::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PasswordAndMetadata::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PasswordAndMetadata::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  PasswordFormFillData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PasswordFormFillData, T>::value>;
  using DataView = PasswordFormFillDataDataView;
  using Data_ = internal::PasswordFormFillData_Data;

  template <typename... Args>
  static PasswordFormFillDataPtr New(Args&&... args) {
    return PasswordFormFillDataPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PasswordFormFillDataPtr From(const U& u) {
    return mojo::TypeConverter<PasswordFormFillDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PasswordFormFillData>::Convert(*this);
  }


  PasswordFormFillData();

  PasswordFormFillData(
      uint32_t form_renderer_id,
      const ::GURL& origin,
      const ::GURL& action,
      const ::autofill::FormFieldData& username_field,
      const ::autofill::FormFieldData& password_field,
      bool username_may_use_prefilled_placeholder,
      const std::string& preferred_realm,
      bool uses_account_store,
      const base::flat_map<::base::string16, ::autofill::PasswordAndMetadata>& additional_logins,
      bool wait_for_username,
      bool has_renderer_ids);

  ~PasswordFormFillData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PasswordFormFillDataPtr>
  PasswordFormFillDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PasswordFormFillData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PasswordFormFillData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PasswordFormFillData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PasswordFormFillData_UnserializedMessageContext<
            UserType, PasswordFormFillData::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<PasswordFormFillData::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return PasswordFormFillData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PasswordFormFillData_UnserializedMessageContext<
            UserType, PasswordFormFillData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PasswordFormFillData::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  uint32_t form_renderer_id;
  
  ::GURL origin;
  
  ::GURL action;
  
  ::autofill::FormFieldData username_field;
  
  ::autofill::FormFieldData password_field;
  
  bool username_may_use_prefilled_placeholder;
  
  std::string preferred_realm;
  
  bool uses_account_store;
  
  base::flat_map<::base::string16, ::autofill::PasswordAndMetadata> additional_logins;
  
  bool wait_for_username;
  
  bool has_renderer_ids;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PasswordFormFillData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PasswordFormFillData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PasswordFormFillData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PasswordFormFillData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class  PasswordGenerationUIData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PasswordGenerationUIData, T>::value>;
  using DataView = PasswordGenerationUIDataDataView;
  using Data_ = internal::PasswordGenerationUIData_Data;

  template <typename... Args>
  static PasswordGenerationUIDataPtr New(Args&&... args) {
    return PasswordGenerationUIDataPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PasswordGenerationUIDataPtr From(const U& u) {
    return mojo::TypeConverter<PasswordGenerationUIDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PasswordGenerationUIData>::Convert(*this);
  }


  PasswordGenerationUIData();

  PasswordGenerationUIData(
      const ::gfx::RectF& bounds,
      int32_t max_length,
      const ::base::string16& generation_element,
      uint32_t generation_element_id,
      bool is_generation_element_password_type,
      ::base::i18n::TextDirection text_direction,
      const ::autofill::FormData& form_data);

  ~PasswordGenerationUIData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PasswordGenerationUIDataPtr>
  PasswordGenerationUIDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PasswordGenerationUIData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PasswordGenerationUIData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PasswordGenerationUIData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PasswordGenerationUIData_UnserializedMessageContext<
            UserType, PasswordGenerationUIData::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<PasswordGenerationUIData::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return PasswordGenerationUIData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PasswordGenerationUIData_UnserializedMessageContext<
            UserType, PasswordGenerationUIData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PasswordGenerationUIData::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::gfx::RectF bounds;
  
  int32_t max_length;
  
  ::base::string16 generation_element;
  
  uint32_t generation_element_id;
  
  bool is_generation_element_password_type;
  
  ::base::i18n::TextDirection text_direction;
  
  ::autofill::FormData form_data;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PasswordGenerationUIData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PasswordGenerationUIData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PasswordGenerationUIData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PasswordGenerationUIData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  ValueElementPair {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ValueElementPair, T>::value>;
  using DataView = ValueElementPairDataView;
  using Data_ = internal::ValueElementPair_Data;

  template <typename... Args>
  static ValueElementPairPtr New(Args&&... args) {
    return ValueElementPairPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ValueElementPairPtr From(const U& u) {
    return mojo::TypeConverter<ValueElementPairPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ValueElementPair>::Convert(*this);
  }


  ValueElementPair();

  ValueElementPair(
      const ::base::string16& value,
      const ::base::string16& field_name);

  ~ValueElementPair();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ValueElementPairPtr>
  ValueElementPairPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ValueElementPair::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ValueElementPair::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ValueElementPair::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ValueElementPair_UnserializedMessageContext<
            UserType, ValueElementPair::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<ValueElementPair::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ValueElementPair::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ValueElementPair_UnserializedMessageContext<
            UserType, ValueElementPair::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ValueElementPair::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::base::string16 value;
  
  ::base::string16 field_name;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ValueElementPair::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ValueElementPair::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ValueElementPair::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ValueElementPair::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  PasswordForm {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PasswordForm, T>::value>;
  using DataView = PasswordFormDataView;
  using Data_ = internal::PasswordForm_Data;
  using Scheme = PasswordForm_Scheme;
  using Type = PasswordForm_Type;
  using GenerationUploadStatus = PasswordForm_GenerationUploadStatus;

  template <typename... Args>
  static PasswordFormPtr New(Args&&... args) {
    return PasswordFormPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PasswordFormPtr From(const U& u) {
    return mojo::TypeConverter<PasswordFormPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PasswordForm>::Convert(*this);
  }


  PasswordForm();

  PasswordForm(
      PasswordForm::Scheme scheme,
      const std::string& signon_realm,
      const ::GURL& origin_with_path,
      const ::GURL& action,
      const std::string& affiliated_web_realm,
      const ::base::string16& submit_element,
      const ::base::string16& username_element,
      bool username_marked_by_site,
      const ::base::string16& username_value,
      std::vector<::autofill::ValueElementPair> all_possible_usernames,
      std::vector<::autofill::ValueElementPair> all_possible_passwords,
      bool form_has_autofilled_value,
      const ::base::string16& password_element,
      const ::base::string16& password_value,
      const ::base::string16& new_password_element,
      const ::base::string16& new_password_value,
      bool new_password_marked_by_site,
      const ::base::string16& confirmation_password_element,
      ::base::Time date_created,
      ::base::Time date_synced,
      bool blacklisted_by_user,
      PasswordForm::Type type,
      int32_t times_used,
      const ::autofill::FormData& form_data,
      PasswordForm::GenerationUploadStatus generation_upload_status,
      const ::base::string16& display_name,
      const ::GURL& icon_url,
      const ::url::Origin& federation_origin,
      bool skip_zero_click,
      bool was_parsed_using_autofill_predictions,
      bool is_public_suffix_match,
      bool is_affiliation_based_match,
      SubmissionIndicatorEvent submission_event,
      bool only_for_fallback);

  ~PasswordForm();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PasswordFormPtr>
  PasswordFormPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PasswordForm::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PasswordForm::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PasswordForm::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PasswordForm_UnserializedMessageContext<
            UserType, PasswordForm::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<PasswordForm::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return PasswordForm::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PasswordForm_UnserializedMessageContext<
            UserType, PasswordForm::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PasswordForm::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  PasswordForm::Scheme scheme;
  
  std::string signon_realm;
  
  ::GURL origin_with_path;
  
  ::GURL action;
  
  std::string affiliated_web_realm;
  
  ::base::string16 submit_element;
  
  ::base::string16 username_element;
  
  bool username_marked_by_site;
  
  ::base::string16 username_value;
  
  std::vector<::autofill::ValueElementPair> all_possible_usernames;
  
  std::vector<::autofill::ValueElementPair> all_possible_passwords;
  
  bool form_has_autofilled_value;
  
  ::base::string16 password_element;
  
  ::base::string16 password_value;
  
  ::base::string16 new_password_element;
  
  ::base::string16 new_password_value;
  
  bool new_password_marked_by_site;
  
  ::base::string16 confirmation_password_element;
  
  ::base::Time date_created;
  
  ::base::Time date_synced;
  
  bool blacklisted_by_user;
  
  PasswordForm::Type type;
  
  int32_t times_used;
  
  ::autofill::FormData form_data;
  
  PasswordForm::GenerationUploadStatus generation_upload_status;
  
  ::base::string16 display_name;
  
  ::GURL icon_url;
  
  ::url::Origin federation_origin;
  
  bool skip_zero_click;
  
  bool was_parsed_using_autofill_predictions;
  
  bool is_public_suffix_match;
  
  bool is_affiliation_based_match;
  
  SubmissionIndicatorEvent submission_event;
  
  bool only_for_fallback;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PasswordForm::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PasswordForm::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PasswordForm::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PasswordForm::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}


template <typename StructPtrType>
FormFieldDataPtr FormFieldData::Clone() const {
  return New(
      mojo::Clone(label),
      mojo::Clone(name),
      mojo::Clone(id_attribute),
      mojo::Clone(name_attribute),
      mojo::Clone(value),
      mojo::Clone(form_control_type),
      mojo::Clone(autocomplete_attribute),
      mojo::Clone(placeholder),
      mojo::Clone(css_classes),
      mojo::Clone(aria_label),
      mojo::Clone(aria_description),
      mojo::Clone(unique_renderer_id),
      mojo::Clone(properties_mask),
      mojo::Clone(form_control_ax_id),
      mojo::Clone(max_length),
      mojo::Clone(is_autofilled),
      mojo::Clone(section),
      mojo::Clone(check_status),
      mojo::Clone(is_focusable),
      mojo::Clone(should_autocomplete),
      mojo::Clone(role),
      mojo::Clone(text_direction),
      mojo::Clone(is_enabled),
      mojo::Clone(is_readonly),
      mojo::Clone(typed_value),
      mojo::Clone(option_values),
      mojo::Clone(option_contents),
      mojo::Clone(label_source)
  );
}

template <typename T, FormFieldData::EnableIfSame<T>*>
bool FormFieldData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->label, other_struct.label))
    return false;
  if (!mojo::Equals(this->name, other_struct.name))
    return false;
  if (!mojo::Equals(this->id_attribute, other_struct.id_attribute))
    return false;
  if (!mojo::Equals(this->name_attribute, other_struct.name_attribute))
    return false;
  if (!mojo::Equals(this->value, other_struct.value))
    return false;
  if (!mojo::Equals(this->form_control_type, other_struct.form_control_type))
    return false;
  if (!mojo::Equals(this->autocomplete_attribute, other_struct.autocomplete_attribute))
    return false;
  if (!mojo::Equals(this->placeholder, other_struct.placeholder))
    return false;
  if (!mojo::Equals(this->css_classes, other_struct.css_classes))
    return false;
  if (!mojo::Equals(this->aria_label, other_struct.aria_label))
    return false;
  if (!mojo::Equals(this->aria_description, other_struct.aria_description))
    return false;
  if (!mojo::Equals(this->unique_renderer_id, other_struct.unique_renderer_id))
    return false;
  if (!mojo::Equals(this->properties_mask, other_struct.properties_mask))
    return false;
  if (!mojo::Equals(this->form_control_ax_id, other_struct.form_control_ax_id))
    return false;
  if (!mojo::Equals(this->max_length, other_struct.max_length))
    return false;
  if (!mojo::Equals(this->is_autofilled, other_struct.is_autofilled))
    return false;
  if (!mojo::Equals(this->section, other_struct.section))
    return false;
  if (!mojo::Equals(this->check_status, other_struct.check_status))
    return false;
  if (!mojo::Equals(this->is_focusable, other_struct.is_focusable))
    return false;
  if (!mojo::Equals(this->should_autocomplete, other_struct.should_autocomplete))
    return false;
  if (!mojo::Equals(this->role, other_struct.role))
    return false;
  if (!mojo::Equals(this->text_direction, other_struct.text_direction))
    return false;
  if (!mojo::Equals(this->is_enabled, other_struct.is_enabled))
    return false;
  if (!mojo::Equals(this->is_readonly, other_struct.is_readonly))
    return false;
  if (!mojo::Equals(this->typed_value, other_struct.typed_value))
    return false;
  if (!mojo::Equals(this->option_values, other_struct.option_values))
    return false;
  if (!mojo::Equals(this->option_contents, other_struct.option_contents))
    return false;
  if (!mojo::Equals(this->label_source, other_struct.label_source))
    return false;
  return true;
}

template <typename T, FormFieldData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.label < rhs.label)
    return true;
  if (rhs.label < lhs.label)
    return false;
  if (lhs.name < rhs.name)
    return true;
  if (rhs.name < lhs.name)
    return false;
  if (lhs.id_attribute < rhs.id_attribute)
    return true;
  if (rhs.id_attribute < lhs.id_attribute)
    return false;
  if (lhs.name_attribute < rhs.name_attribute)
    return true;
  if (rhs.name_attribute < lhs.name_attribute)
    return false;
  if (lhs.value < rhs.value)
    return true;
  if (rhs.value < lhs.value)
    return false;
  if (lhs.form_control_type < rhs.form_control_type)
    return true;
  if (rhs.form_control_type < lhs.form_control_type)
    return false;
  if (lhs.autocomplete_attribute < rhs.autocomplete_attribute)
    return true;
  if (rhs.autocomplete_attribute < lhs.autocomplete_attribute)
    return false;
  if (lhs.placeholder < rhs.placeholder)
    return true;
  if (rhs.placeholder < lhs.placeholder)
    return false;
  if (lhs.css_classes < rhs.css_classes)
    return true;
  if (rhs.css_classes < lhs.css_classes)
    return false;
  if (lhs.aria_label < rhs.aria_label)
    return true;
  if (rhs.aria_label < lhs.aria_label)
    return false;
  if (lhs.aria_description < rhs.aria_description)
    return true;
  if (rhs.aria_description < lhs.aria_description)
    return false;
  if (lhs.unique_renderer_id < rhs.unique_renderer_id)
    return true;
  if (rhs.unique_renderer_id < lhs.unique_renderer_id)
    return false;
  if (lhs.properties_mask < rhs.properties_mask)
    return true;
  if (rhs.properties_mask < lhs.properties_mask)
    return false;
  if (lhs.form_control_ax_id < rhs.form_control_ax_id)
    return true;
  if (rhs.form_control_ax_id < lhs.form_control_ax_id)
    return false;
  if (lhs.max_length < rhs.max_length)
    return true;
  if (rhs.max_length < lhs.max_length)
    return false;
  if (lhs.is_autofilled < rhs.is_autofilled)
    return true;
  if (rhs.is_autofilled < lhs.is_autofilled)
    return false;
  if (lhs.section < rhs.section)
    return true;
  if (rhs.section < lhs.section)
    return false;
  if (lhs.check_status < rhs.check_status)
    return true;
  if (rhs.check_status < lhs.check_status)
    return false;
  if (lhs.is_focusable < rhs.is_focusable)
    return true;
  if (rhs.is_focusable < lhs.is_focusable)
    return false;
  if (lhs.should_autocomplete < rhs.should_autocomplete)
    return true;
  if (rhs.should_autocomplete < lhs.should_autocomplete)
    return false;
  if (lhs.role < rhs.role)
    return true;
  if (rhs.role < lhs.role)
    return false;
  if (lhs.text_direction < rhs.text_direction)
    return true;
  if (rhs.text_direction < lhs.text_direction)
    return false;
  if (lhs.is_enabled < rhs.is_enabled)
    return true;
  if (rhs.is_enabled < lhs.is_enabled)
    return false;
  if (lhs.is_readonly < rhs.is_readonly)
    return true;
  if (rhs.is_readonly < lhs.is_readonly)
    return false;
  if (lhs.typed_value < rhs.typed_value)
    return true;
  if (rhs.typed_value < lhs.typed_value)
    return false;
  if (lhs.option_values < rhs.option_values)
    return true;
  if (rhs.option_values < lhs.option_values)
    return false;
  if (lhs.option_contents < rhs.option_contents)
    return true;
  if (rhs.option_contents < lhs.option_contents)
    return false;
  if (lhs.label_source < rhs.label_source)
    return true;
  if (rhs.label_source < lhs.label_source)
    return false;
  return false;
}
template <typename StructPtrType>
ButtonTitleInfoPtr ButtonTitleInfo::Clone() const {
  return New(
      mojo::Clone(title),
      mojo::Clone(type)
  );
}

template <typename T, ButtonTitleInfo::EnableIfSame<T>*>
bool ButtonTitleInfo::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->title, other_struct.title))
    return false;
  if (!mojo::Equals(this->type, other_struct.type))
    return false;
  return true;
}

template <typename T, ButtonTitleInfo::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.title < rhs.title)
    return true;
  if (rhs.title < lhs.title)
    return false;
  if (lhs.type < rhs.type)
    return true;
  if (rhs.type < lhs.type)
    return false;
  return false;
}
template <typename StructPtrType>
FormDataPtr FormData::Clone() const {
  return New(
      mojo::Clone(id_attribute),
      mojo::Clone(name_attribute),
      mojo::Clone(name),
      mojo::Clone(button_titles),
      mojo::Clone(url),
      mojo::Clone(action),
      mojo::Clone(is_action_empty),
      mojo::Clone(main_frame_origin),
      mojo::Clone(is_form_tag),
      mojo::Clone(is_formless_checkout),
      mojo::Clone(unique_renderer_id),
      mojo::Clone(submission_event),
      mojo::Clone(fields),
      mojo::Clone(username_predictions),
      mojo::Clone(is_gaia_with_skip_save_password_form)
  );
}

template <typename T, FormData::EnableIfSame<T>*>
bool FormData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->id_attribute, other_struct.id_attribute))
    return false;
  if (!mojo::Equals(this->name_attribute, other_struct.name_attribute))
    return false;
  if (!mojo::Equals(this->name, other_struct.name))
    return false;
  if (!mojo::Equals(this->button_titles, other_struct.button_titles))
    return false;
  if (!mojo::Equals(this->url, other_struct.url))
    return false;
  if (!mojo::Equals(this->action, other_struct.action))
    return false;
  if (!mojo::Equals(this->is_action_empty, other_struct.is_action_empty))
    return false;
  if (!mojo::Equals(this->main_frame_origin, other_struct.main_frame_origin))
    return false;
  if (!mojo::Equals(this->is_form_tag, other_struct.is_form_tag))
    return false;
  if (!mojo::Equals(this->is_formless_checkout, other_struct.is_formless_checkout))
    return false;
  if (!mojo::Equals(this->unique_renderer_id, other_struct.unique_renderer_id))
    return false;
  if (!mojo::Equals(this->submission_event, other_struct.submission_event))
    return false;
  if (!mojo::Equals(this->fields, other_struct.fields))
    return false;
  if (!mojo::Equals(this->username_predictions, other_struct.username_predictions))
    return false;
  if (!mojo::Equals(this->is_gaia_with_skip_save_password_form, other_struct.is_gaia_with_skip_save_password_form))
    return false;
  return true;
}

template <typename T, FormData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.id_attribute < rhs.id_attribute)
    return true;
  if (rhs.id_attribute < lhs.id_attribute)
    return false;
  if (lhs.name_attribute < rhs.name_attribute)
    return true;
  if (rhs.name_attribute < lhs.name_attribute)
    return false;
  if (lhs.name < rhs.name)
    return true;
  if (rhs.name < lhs.name)
    return false;
  if (lhs.button_titles < rhs.button_titles)
    return true;
  if (rhs.button_titles < lhs.button_titles)
    return false;
  if (lhs.url < rhs.url)
    return true;
  if (rhs.url < lhs.url)
    return false;
  if (lhs.action < rhs.action)
    return true;
  if (rhs.action < lhs.action)
    return false;
  if (lhs.is_action_empty < rhs.is_action_empty)
    return true;
  if (rhs.is_action_empty < lhs.is_action_empty)
    return false;
  if (lhs.main_frame_origin < rhs.main_frame_origin)
    return true;
  if (rhs.main_frame_origin < lhs.main_frame_origin)
    return false;
  if (lhs.is_form_tag < rhs.is_form_tag)
    return true;
  if (rhs.is_form_tag < lhs.is_form_tag)
    return false;
  if (lhs.is_formless_checkout < rhs.is_formless_checkout)
    return true;
  if (rhs.is_formless_checkout < lhs.is_formless_checkout)
    return false;
  if (lhs.unique_renderer_id < rhs.unique_renderer_id)
    return true;
  if (rhs.unique_renderer_id < lhs.unique_renderer_id)
    return false;
  if (lhs.submission_event < rhs.submission_event)
    return true;
  if (rhs.submission_event < lhs.submission_event)
    return false;
  if (lhs.fields < rhs.fields)
    return true;
  if (rhs.fields < lhs.fields)
    return false;
  if (lhs.username_predictions < rhs.username_predictions)
    return true;
  if (rhs.username_predictions < lhs.username_predictions)
    return false;
  if (lhs.is_gaia_with_skip_save_password_form < rhs.is_gaia_with_skip_save_password_form)
    return true;
  if (rhs.is_gaia_with_skip_save_password_form < lhs.is_gaia_with_skip_save_password_form)
    return false;
  return false;
}
template <typename StructPtrType>
FormFieldDataPredictionsPtr FormFieldDataPredictions::Clone() const {
  return New(
      mojo::Clone(field),
      mojo::Clone(signature),
      mojo::Clone(heuristic_type),
      mojo::Clone(server_type),
      mojo::Clone(overall_type),
      mojo::Clone(parseable_name),
      mojo::Clone(section)
  );
}

template <typename T, FormFieldDataPredictions::EnableIfSame<T>*>
bool FormFieldDataPredictions::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->field, other_struct.field))
    return false;
  if (!mojo::Equals(this->signature, other_struct.signature))
    return false;
  if (!mojo::Equals(this->heuristic_type, other_struct.heuristic_type))
    return false;
  if (!mojo::Equals(this->server_type, other_struct.server_type))
    return false;
  if (!mojo::Equals(this->overall_type, other_struct.overall_type))
    return false;
  if (!mojo::Equals(this->parseable_name, other_struct.parseable_name))
    return false;
  if (!mojo::Equals(this->section, other_struct.section))
    return false;
  return true;
}

template <typename T, FormFieldDataPredictions::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.field < rhs.field)
    return true;
  if (rhs.field < lhs.field)
    return false;
  if (lhs.signature < rhs.signature)
    return true;
  if (rhs.signature < lhs.signature)
    return false;
  if (lhs.heuristic_type < rhs.heuristic_type)
    return true;
  if (rhs.heuristic_type < lhs.heuristic_type)
    return false;
  if (lhs.server_type < rhs.server_type)
    return true;
  if (rhs.server_type < lhs.server_type)
    return false;
  if (lhs.overall_type < rhs.overall_type)
    return true;
  if (rhs.overall_type < lhs.overall_type)
    return false;
  if (lhs.parseable_name < rhs.parseable_name)
    return true;
  if (rhs.parseable_name < lhs.parseable_name)
    return false;
  if (lhs.section < rhs.section)
    return true;
  if (rhs.section < lhs.section)
    return false;
  return false;
}
template <typename StructPtrType>
FormDataPredictionsPtr FormDataPredictions::Clone() const {
  return New(
      mojo::Clone(data),
      mojo::Clone(signature),
      mojo::Clone(fields)
  );
}

template <typename T, FormDataPredictions::EnableIfSame<T>*>
bool FormDataPredictions::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->data, other_struct.data))
    return false;
  if (!mojo::Equals(this->signature, other_struct.signature))
    return false;
  if (!mojo::Equals(this->fields, other_struct.fields))
    return false;
  return true;
}

template <typename T, FormDataPredictions::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.data < rhs.data)
    return true;
  if (rhs.data < lhs.data)
    return false;
  if (lhs.signature < rhs.signature)
    return true;
  if (rhs.signature < lhs.signature)
    return false;
  if (lhs.fields < rhs.fields)
    return true;
  if (rhs.fields < lhs.fields)
    return false;
  return false;
}
template <typename StructPtrType>
PasswordAndMetadataPtr PasswordAndMetadata::Clone() const {
  return New(
      mojo::Clone(password),
      mojo::Clone(realm),
      mojo::Clone(uses_account_store)
  );
}

template <typename T, PasswordAndMetadata::EnableIfSame<T>*>
bool PasswordAndMetadata::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->password, other_struct.password))
    return false;
  if (!mojo::Equals(this->realm, other_struct.realm))
    return false;
  if (!mojo::Equals(this->uses_account_store, other_struct.uses_account_store))
    return false;
  return true;
}

template <typename T, PasswordAndMetadata::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.password < rhs.password)
    return true;
  if (rhs.password < lhs.password)
    return false;
  if (lhs.realm < rhs.realm)
    return true;
  if (rhs.realm < lhs.realm)
    return false;
  if (lhs.uses_account_store < rhs.uses_account_store)
    return true;
  if (rhs.uses_account_store < lhs.uses_account_store)
    return false;
  return false;
}
template <typename StructPtrType>
PasswordFormFillDataPtr PasswordFormFillData::Clone() const {
  return New(
      mojo::Clone(form_renderer_id),
      mojo::Clone(origin),
      mojo::Clone(action),
      mojo::Clone(username_field),
      mojo::Clone(password_field),
      mojo::Clone(username_may_use_prefilled_placeholder),
      mojo::Clone(preferred_realm),
      mojo::Clone(uses_account_store),
      mojo::Clone(additional_logins),
      mojo::Clone(wait_for_username),
      mojo::Clone(has_renderer_ids)
  );
}

template <typename T, PasswordFormFillData::EnableIfSame<T>*>
bool PasswordFormFillData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->form_renderer_id, other_struct.form_renderer_id))
    return false;
  if (!mojo::Equals(this->origin, other_struct.origin))
    return false;
  if (!mojo::Equals(this->action, other_struct.action))
    return false;
  if (!mojo::Equals(this->username_field, other_struct.username_field))
    return false;
  if (!mojo::Equals(this->password_field, other_struct.password_field))
    return false;
  if (!mojo::Equals(this->username_may_use_prefilled_placeholder, other_struct.username_may_use_prefilled_placeholder))
    return false;
  if (!mojo::Equals(this->preferred_realm, other_struct.preferred_realm))
    return false;
  if (!mojo::Equals(this->uses_account_store, other_struct.uses_account_store))
    return false;
  if (!mojo::Equals(this->additional_logins, other_struct.additional_logins))
    return false;
  if (!mojo::Equals(this->wait_for_username, other_struct.wait_for_username))
    return false;
  if (!mojo::Equals(this->has_renderer_ids, other_struct.has_renderer_ids))
    return false;
  return true;
}

template <typename T, PasswordFormFillData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.form_renderer_id < rhs.form_renderer_id)
    return true;
  if (rhs.form_renderer_id < lhs.form_renderer_id)
    return false;
  if (lhs.origin < rhs.origin)
    return true;
  if (rhs.origin < lhs.origin)
    return false;
  if (lhs.action < rhs.action)
    return true;
  if (rhs.action < lhs.action)
    return false;
  if (lhs.username_field < rhs.username_field)
    return true;
  if (rhs.username_field < lhs.username_field)
    return false;
  if (lhs.password_field < rhs.password_field)
    return true;
  if (rhs.password_field < lhs.password_field)
    return false;
  if (lhs.username_may_use_prefilled_placeholder < rhs.username_may_use_prefilled_placeholder)
    return true;
  if (rhs.username_may_use_prefilled_placeholder < lhs.username_may_use_prefilled_placeholder)
    return false;
  if (lhs.preferred_realm < rhs.preferred_realm)
    return true;
  if (rhs.preferred_realm < lhs.preferred_realm)
    return false;
  if (lhs.uses_account_store < rhs.uses_account_store)
    return true;
  if (rhs.uses_account_store < lhs.uses_account_store)
    return false;
  if (lhs.additional_logins < rhs.additional_logins)
    return true;
  if (rhs.additional_logins < lhs.additional_logins)
    return false;
  if (lhs.wait_for_username < rhs.wait_for_username)
    return true;
  if (rhs.wait_for_username < lhs.wait_for_username)
    return false;
  if (lhs.has_renderer_ids < rhs.has_renderer_ids)
    return true;
  if (rhs.has_renderer_ids < lhs.has_renderer_ids)
    return false;
  return false;
}
template <typename StructPtrType>
PasswordFormGenerationDataPtr PasswordFormGenerationData::Clone() const {
  return New(
      mojo::Clone(new_password_renderer_id),
      mojo::Clone(confirmation_password_renderer_id)
  );
}

template <typename T, PasswordFormGenerationData::EnableIfSame<T>*>
bool PasswordFormGenerationData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->new_password_renderer_id, other_struct.new_password_renderer_id))
    return false;
  if (!mojo::Equals(this->confirmation_password_renderer_id, other_struct.confirmation_password_renderer_id))
    return false;
  return true;
}

template <typename T, PasswordFormGenerationData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.new_password_renderer_id < rhs.new_password_renderer_id)
    return true;
  if (rhs.new_password_renderer_id < lhs.new_password_renderer_id)
    return false;
  if (lhs.confirmation_password_renderer_id < rhs.confirmation_password_renderer_id)
    return true;
  if (rhs.confirmation_password_renderer_id < lhs.confirmation_password_renderer_id)
    return false;
  return false;
}
template <typename StructPtrType>
PasswordGenerationUIDataPtr PasswordGenerationUIData::Clone() const {
  return New(
      mojo::Clone(bounds),
      mojo::Clone(max_length),
      mojo::Clone(generation_element),
      mojo::Clone(generation_element_id),
      mojo::Clone(is_generation_element_password_type),
      mojo::Clone(text_direction),
      mojo::Clone(form_data)
  );
}

template <typename T, PasswordGenerationUIData::EnableIfSame<T>*>
bool PasswordGenerationUIData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->bounds, other_struct.bounds))
    return false;
  if (!mojo::Equals(this->max_length, other_struct.max_length))
    return false;
  if (!mojo::Equals(this->generation_element, other_struct.generation_element))
    return false;
  if (!mojo::Equals(this->generation_element_id, other_struct.generation_element_id))
    return false;
  if (!mojo::Equals(this->is_generation_element_password_type, other_struct.is_generation_element_password_type))
    return false;
  if (!mojo::Equals(this->text_direction, other_struct.text_direction))
    return false;
  if (!mojo::Equals(this->form_data, other_struct.form_data))
    return false;
  return true;
}

template <typename T, PasswordGenerationUIData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.bounds < rhs.bounds)
    return true;
  if (rhs.bounds < lhs.bounds)
    return false;
  if (lhs.max_length < rhs.max_length)
    return true;
  if (rhs.max_length < lhs.max_length)
    return false;
  if (lhs.generation_element < rhs.generation_element)
    return true;
  if (rhs.generation_element < lhs.generation_element)
    return false;
  if (lhs.generation_element_id < rhs.generation_element_id)
    return true;
  if (rhs.generation_element_id < lhs.generation_element_id)
    return false;
  if (lhs.is_generation_element_password_type < rhs.is_generation_element_password_type)
    return true;
  if (rhs.is_generation_element_password_type < lhs.is_generation_element_password_type)
    return false;
  if (lhs.text_direction < rhs.text_direction)
    return true;
  if (rhs.text_direction < lhs.text_direction)
    return false;
  if (lhs.form_data < rhs.form_data)
    return true;
  if (rhs.form_data < lhs.form_data)
    return false;
  return false;
}
template <typename StructPtrType>
ValueElementPairPtr ValueElementPair::Clone() const {
  return New(
      mojo::Clone(value),
      mojo::Clone(field_name)
  );
}

template <typename T, ValueElementPair::EnableIfSame<T>*>
bool ValueElementPair::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->value, other_struct.value))
    return false;
  if (!mojo::Equals(this->field_name, other_struct.field_name))
    return false;
  return true;
}

template <typename T, ValueElementPair::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.value < rhs.value)
    return true;
  if (rhs.value < lhs.value)
    return false;
  if (lhs.field_name < rhs.field_name)
    return true;
  if (rhs.field_name < lhs.field_name)
    return false;
  return false;
}
template <typename StructPtrType>
PasswordFormPtr PasswordForm::Clone() const {
  return New(
      mojo::Clone(scheme),
      mojo::Clone(signon_realm),
      mojo::Clone(origin_with_path),
      mojo::Clone(action),
      mojo::Clone(affiliated_web_realm),
      mojo::Clone(submit_element),
      mojo::Clone(username_element),
      mojo::Clone(username_marked_by_site),
      mojo::Clone(username_value),
      mojo::Clone(all_possible_usernames),
      mojo::Clone(all_possible_passwords),
      mojo::Clone(form_has_autofilled_value),
      mojo::Clone(password_element),
      mojo::Clone(password_value),
      mojo::Clone(new_password_element),
      mojo::Clone(new_password_value),
      mojo::Clone(new_password_marked_by_site),
      mojo::Clone(confirmation_password_element),
      mojo::Clone(date_created),
      mojo::Clone(date_synced),
      mojo::Clone(blacklisted_by_user),
      mojo::Clone(type),
      mojo::Clone(times_used),
      mojo::Clone(form_data),
      mojo::Clone(generation_upload_status),
      mojo::Clone(display_name),
      mojo::Clone(icon_url),
      mojo::Clone(federation_origin),
      mojo::Clone(skip_zero_click),
      mojo::Clone(was_parsed_using_autofill_predictions),
      mojo::Clone(is_public_suffix_match),
      mojo::Clone(is_affiliation_based_match),
      mojo::Clone(submission_event),
      mojo::Clone(only_for_fallback)
  );
}

template <typename T, PasswordForm::EnableIfSame<T>*>
bool PasswordForm::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->scheme, other_struct.scheme))
    return false;
  if (!mojo::Equals(this->signon_realm, other_struct.signon_realm))
    return false;
  if (!mojo::Equals(this->origin_with_path, other_struct.origin_with_path))
    return false;
  if (!mojo::Equals(this->action, other_struct.action))
    return false;
  if (!mojo::Equals(this->affiliated_web_realm, other_struct.affiliated_web_realm))
    return false;
  if (!mojo::Equals(this->submit_element, other_struct.submit_element))
    return false;
  if (!mojo::Equals(this->username_element, other_struct.username_element))
    return false;
  if (!mojo::Equals(this->username_marked_by_site, other_struct.username_marked_by_site))
    return false;
  if (!mojo::Equals(this->username_value, other_struct.username_value))
    return false;
  if (!mojo::Equals(this->all_possible_usernames, other_struct.all_possible_usernames))
    return false;
  if (!mojo::Equals(this->all_possible_passwords, other_struct.all_possible_passwords))
    return false;
  if (!mojo::Equals(this->form_has_autofilled_value, other_struct.form_has_autofilled_value))
    return false;
  if (!mojo::Equals(this->password_element, other_struct.password_element))
    return false;
  if (!mojo::Equals(this->password_value, other_struct.password_value))
    return false;
  if (!mojo::Equals(this->new_password_element, other_struct.new_password_element))
    return false;
  if (!mojo::Equals(this->new_password_value, other_struct.new_password_value))
    return false;
  if (!mojo::Equals(this->new_password_marked_by_site, other_struct.new_password_marked_by_site))
    return false;
  if (!mojo::Equals(this->confirmation_password_element, other_struct.confirmation_password_element))
    return false;
  if (!mojo::Equals(this->date_created, other_struct.date_created))
    return false;
  if (!mojo::Equals(this->date_synced, other_struct.date_synced))
    return false;
  if (!mojo::Equals(this->blacklisted_by_user, other_struct.blacklisted_by_user))
    return false;
  if (!mojo::Equals(this->type, other_struct.type))
    return false;
  if (!mojo::Equals(this->times_used, other_struct.times_used))
    return false;
  if (!mojo::Equals(this->form_data, other_struct.form_data))
    return false;
  if (!mojo::Equals(this->generation_upload_status, other_struct.generation_upload_status))
    return false;
  if (!mojo::Equals(this->display_name, other_struct.display_name))
    return false;
  if (!mojo::Equals(this->icon_url, other_struct.icon_url))
    return false;
  if (!mojo::Equals(this->federation_origin, other_struct.federation_origin))
    return false;
  if (!mojo::Equals(this->skip_zero_click, other_struct.skip_zero_click))
    return false;
  if (!mojo::Equals(this->was_parsed_using_autofill_predictions, other_struct.was_parsed_using_autofill_predictions))
    return false;
  if (!mojo::Equals(this->is_public_suffix_match, other_struct.is_public_suffix_match))
    return false;
  if (!mojo::Equals(this->is_affiliation_based_match, other_struct.is_affiliation_based_match))
    return false;
  if (!mojo::Equals(this->submission_event, other_struct.submission_event))
    return false;
  if (!mojo::Equals(this->only_for_fallback, other_struct.only_for_fallback))
    return false;
  return true;
}

template <typename T, PasswordForm::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.scheme < rhs.scheme)
    return true;
  if (rhs.scheme < lhs.scheme)
    return false;
  if (lhs.signon_realm < rhs.signon_realm)
    return true;
  if (rhs.signon_realm < lhs.signon_realm)
    return false;
  if (lhs.origin_with_path < rhs.origin_with_path)
    return true;
  if (rhs.origin_with_path < lhs.origin_with_path)
    return false;
  if (lhs.action < rhs.action)
    return true;
  if (rhs.action < lhs.action)
    return false;
  if (lhs.affiliated_web_realm < rhs.affiliated_web_realm)
    return true;
  if (rhs.affiliated_web_realm < lhs.affiliated_web_realm)
    return false;
  if (lhs.submit_element < rhs.submit_element)
    return true;
  if (rhs.submit_element < lhs.submit_element)
    return false;
  if (lhs.username_element < rhs.username_element)
    return true;
  if (rhs.username_element < lhs.username_element)
    return false;
  if (lhs.username_marked_by_site < rhs.username_marked_by_site)
    return true;
  if (rhs.username_marked_by_site < lhs.username_marked_by_site)
    return false;
  if (lhs.username_value < rhs.username_value)
    return true;
  if (rhs.username_value < lhs.username_value)
    return false;
  if (lhs.all_possible_usernames < rhs.all_possible_usernames)
    return true;
  if (rhs.all_possible_usernames < lhs.all_possible_usernames)
    return false;
  if (lhs.all_possible_passwords < rhs.all_possible_passwords)
    return true;
  if (rhs.all_possible_passwords < lhs.all_possible_passwords)
    return false;
  if (lhs.form_has_autofilled_value < rhs.form_has_autofilled_value)
    return true;
  if (rhs.form_has_autofilled_value < lhs.form_has_autofilled_value)
    return false;
  if (lhs.password_element < rhs.password_element)
    return true;
  if (rhs.password_element < lhs.password_element)
    return false;
  if (lhs.password_value < rhs.password_value)
    return true;
  if (rhs.password_value < lhs.password_value)
    return false;
  if (lhs.new_password_element < rhs.new_password_element)
    return true;
  if (rhs.new_password_element < lhs.new_password_element)
    return false;
  if (lhs.new_password_value < rhs.new_password_value)
    return true;
  if (rhs.new_password_value < lhs.new_password_value)
    return false;
  if (lhs.new_password_marked_by_site < rhs.new_password_marked_by_site)
    return true;
  if (rhs.new_password_marked_by_site < lhs.new_password_marked_by_site)
    return false;
  if (lhs.confirmation_password_element < rhs.confirmation_password_element)
    return true;
  if (rhs.confirmation_password_element < lhs.confirmation_password_element)
    return false;
  if (lhs.date_created < rhs.date_created)
    return true;
  if (rhs.date_created < lhs.date_created)
    return false;
  if (lhs.date_synced < rhs.date_synced)
    return true;
  if (rhs.date_synced < lhs.date_synced)
    return false;
  if (lhs.blacklisted_by_user < rhs.blacklisted_by_user)
    return true;
  if (rhs.blacklisted_by_user < lhs.blacklisted_by_user)
    return false;
  if (lhs.type < rhs.type)
    return true;
  if (rhs.type < lhs.type)
    return false;
  if (lhs.times_used < rhs.times_used)
    return true;
  if (rhs.times_used < lhs.times_used)
    return false;
  if (lhs.form_data < rhs.form_data)
    return true;
  if (rhs.form_data < lhs.form_data)
    return false;
  if (lhs.generation_upload_status < rhs.generation_upload_status)
    return true;
  if (rhs.generation_upload_status < lhs.generation_upload_status)
    return false;
  if (lhs.display_name < rhs.display_name)
    return true;
  if (rhs.display_name < lhs.display_name)
    return false;
  if (lhs.icon_url < rhs.icon_url)
    return true;
  if (rhs.icon_url < lhs.icon_url)
    return false;
  if (lhs.federation_origin < rhs.federation_origin)
    return true;
  if (rhs.federation_origin < lhs.federation_origin)
    return false;
  if (lhs.skip_zero_click < rhs.skip_zero_click)
    return true;
  if (rhs.skip_zero_click < lhs.skip_zero_click)
    return false;
  if (lhs.was_parsed_using_autofill_predictions < rhs.was_parsed_using_autofill_predictions)
    return true;
  if (rhs.was_parsed_using_autofill_predictions < lhs.was_parsed_using_autofill_predictions)
    return false;
  if (lhs.is_public_suffix_match < rhs.is_public_suffix_match)
    return true;
  if (rhs.is_public_suffix_match < lhs.is_public_suffix_match)
    return false;
  if (lhs.is_affiliation_based_match < rhs.is_affiliation_based_match)
    return true;
  if (rhs.is_affiliation_based_match < lhs.is_affiliation_based_match)
    return false;
  if (lhs.submission_event < rhs.submission_event)
    return true;
  if (rhs.submission_event < lhs.submission_event)
    return false;
  if (lhs.only_for_fallback < rhs.only_for_fallback)
    return true;
  if (rhs.only_for_fallback < lhs.only_for_fallback)
    return false;
  return false;
}
template <typename StructPtrType>
ParsingResultPtr ParsingResult::Clone() const {
  return New(
      mojo::Clone(username_renderer_id),
      mojo::Clone(password_renderer_id),
      mojo::Clone(new_password_renderer_id),
      mojo::Clone(confirm_password_renderer_id)
  );
}

template <typename T, ParsingResult::EnableIfSame<T>*>
bool ParsingResult::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->username_renderer_id, other_struct.username_renderer_id))
    return false;
  if (!mojo::Equals(this->password_renderer_id, other_struct.password_renderer_id))
    return false;
  if (!mojo::Equals(this->new_password_renderer_id, other_struct.new_password_renderer_id))
    return false;
  if (!mojo::Equals(this->confirm_password_renderer_id, other_struct.confirm_password_renderer_id))
    return false;
  return true;
}

template <typename T, ParsingResult::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.username_renderer_id < rhs.username_renderer_id)
    return true;
  if (rhs.username_renderer_id < lhs.username_renderer_id)
    return false;
  if (lhs.password_renderer_id < rhs.password_renderer_id)
    return true;
  if (rhs.password_renderer_id < lhs.password_renderer_id)
    return false;
  if (lhs.new_password_renderer_id < rhs.new_password_renderer_id)
    return true;
  if (rhs.new_password_renderer_id < lhs.new_password_renderer_id)
    return false;
  if (lhs.confirm_password_renderer_id < rhs.confirm_password_renderer_id)
    return true;
  if (rhs.confirm_password_renderer_id < lhs.confirm_password_renderer_id)
    return false;
  return false;
}


}  // namespace mojom
}  // namespace autofill

namespace mojo {


template <>
struct  StructTraits<::autofill::mojom::FormFieldData::DataView,
                                         ::autofill::mojom::FormFieldDataPtr> {
  static bool IsNull(const ::autofill::mojom::FormFieldDataPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::FormFieldDataPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::FormFieldData::label)& label(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->label;
  }

  static const decltype(::autofill::mojom::FormFieldData::name)& name(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->name;
  }

  static const decltype(::autofill::mojom::FormFieldData::id_attribute)& id_attribute(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->id_attribute;
  }

  static const decltype(::autofill::mojom::FormFieldData::name_attribute)& name_attribute(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->name_attribute;
  }

  static const decltype(::autofill::mojom::FormFieldData::value)& value(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->value;
  }

  static const decltype(::autofill::mojom::FormFieldData::form_control_type)& form_control_type(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->form_control_type;
  }

  static const decltype(::autofill::mojom::FormFieldData::autocomplete_attribute)& autocomplete_attribute(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->autocomplete_attribute;
  }

  static const decltype(::autofill::mojom::FormFieldData::placeholder)& placeholder(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->placeholder;
  }

  static const decltype(::autofill::mojom::FormFieldData::css_classes)& css_classes(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->css_classes;
  }

  static const decltype(::autofill::mojom::FormFieldData::aria_label)& aria_label(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->aria_label;
  }

  static const decltype(::autofill::mojom::FormFieldData::aria_description)& aria_description(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->aria_description;
  }

  static decltype(::autofill::mojom::FormFieldData::unique_renderer_id) unique_renderer_id(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->unique_renderer_id;
  }

  static decltype(::autofill::mojom::FormFieldData::properties_mask) properties_mask(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->properties_mask;
  }

  static decltype(::autofill::mojom::FormFieldData::form_control_ax_id) form_control_ax_id(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->form_control_ax_id;
  }

  static decltype(::autofill::mojom::FormFieldData::max_length) max_length(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->max_length;
  }

  static decltype(::autofill::mojom::FormFieldData::is_autofilled) is_autofilled(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->is_autofilled;
  }

  static const decltype(::autofill::mojom::FormFieldData::section)& section(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->section;
  }

  static decltype(::autofill::mojom::FormFieldData::check_status) check_status(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->check_status;
  }

  static decltype(::autofill::mojom::FormFieldData::is_focusable) is_focusable(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->is_focusable;
  }

  static decltype(::autofill::mojom::FormFieldData::should_autocomplete) should_autocomplete(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->should_autocomplete;
  }

  static decltype(::autofill::mojom::FormFieldData::role) role(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->role;
  }

  static decltype(::autofill::mojom::FormFieldData::text_direction) text_direction(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->text_direction;
  }

  static decltype(::autofill::mojom::FormFieldData::is_enabled) is_enabled(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->is_enabled;
  }

  static decltype(::autofill::mojom::FormFieldData::is_readonly) is_readonly(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->is_readonly;
  }

  static const decltype(::autofill::mojom::FormFieldData::typed_value)& typed_value(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->typed_value;
  }

  static const decltype(::autofill::mojom::FormFieldData::option_values)& option_values(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->option_values;
  }

  static const decltype(::autofill::mojom::FormFieldData::option_contents)& option_contents(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->option_contents;
  }

  static decltype(::autofill::mojom::FormFieldData::label_source) label_source(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->label_source;
  }

  static bool Read(::autofill::mojom::FormFieldData::DataView input, ::autofill::mojom::FormFieldDataPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::ButtonTitleInfo::DataView,
                                         ::autofill::mojom::ButtonTitleInfoPtr> {
  static bool IsNull(const ::autofill::mojom::ButtonTitleInfoPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::ButtonTitleInfoPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::ButtonTitleInfo::title)& title(
      const ::autofill::mojom::ButtonTitleInfoPtr& input) {
    return input->title;
  }

  static decltype(::autofill::mojom::ButtonTitleInfo::type) type(
      const ::autofill::mojom::ButtonTitleInfoPtr& input) {
    return input->type;
  }

  static bool Read(::autofill::mojom::ButtonTitleInfo::DataView input, ::autofill::mojom::ButtonTitleInfoPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::FormData::DataView,
                                         ::autofill::mojom::FormDataPtr> {
  static bool IsNull(const ::autofill::mojom::FormDataPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::FormDataPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::FormData::id_attribute)& id_attribute(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->id_attribute;
  }

  static const decltype(::autofill::mojom::FormData::name_attribute)& name_attribute(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->name_attribute;
  }

  static const decltype(::autofill::mojom::FormData::name)& name(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->name;
  }

  static const decltype(::autofill::mojom::FormData::button_titles)& button_titles(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->button_titles;
  }

  static const decltype(::autofill::mojom::FormData::url)& url(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->url;
  }

  static const decltype(::autofill::mojom::FormData::action)& action(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->action;
  }

  static decltype(::autofill::mojom::FormData::is_action_empty) is_action_empty(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->is_action_empty;
  }

  static const decltype(::autofill::mojom::FormData::main_frame_origin)& main_frame_origin(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->main_frame_origin;
  }

  static decltype(::autofill::mojom::FormData::is_form_tag) is_form_tag(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->is_form_tag;
  }

  static decltype(::autofill::mojom::FormData::is_formless_checkout) is_formless_checkout(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->is_formless_checkout;
  }

  static decltype(::autofill::mojom::FormData::unique_renderer_id) unique_renderer_id(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->unique_renderer_id;
  }

  static decltype(::autofill::mojom::FormData::submission_event) submission_event(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->submission_event;
  }

  static const decltype(::autofill::mojom::FormData::fields)& fields(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->fields;
  }

  static const decltype(::autofill::mojom::FormData::username_predictions)& username_predictions(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->username_predictions;
  }

  static decltype(::autofill::mojom::FormData::is_gaia_with_skip_save_password_form) is_gaia_with_skip_save_password_form(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->is_gaia_with_skip_save_password_form;
  }

  static bool Read(::autofill::mojom::FormData::DataView input, ::autofill::mojom::FormDataPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::FormFieldDataPredictions::DataView,
                                         ::autofill::mojom::FormFieldDataPredictionsPtr> {
  static bool IsNull(const ::autofill::mojom::FormFieldDataPredictionsPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::FormFieldDataPredictionsPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::FormFieldDataPredictions::field)& field(
      const ::autofill::mojom::FormFieldDataPredictionsPtr& input) {
    return input->field;
  }

  static const decltype(::autofill::mojom::FormFieldDataPredictions::signature)& signature(
      const ::autofill::mojom::FormFieldDataPredictionsPtr& input) {
    return input->signature;
  }

  static const decltype(::autofill::mojom::FormFieldDataPredictions::heuristic_type)& heuristic_type(
      const ::autofill::mojom::FormFieldDataPredictionsPtr& input) {
    return input->heuristic_type;
  }

  static const decltype(::autofill::mojom::FormFieldDataPredictions::server_type)& server_type(
      const ::autofill::mojom::FormFieldDataPredictionsPtr& input) {
    return input->server_type;
  }

  static const decltype(::autofill::mojom::FormFieldDataPredictions::overall_type)& overall_type(
      const ::autofill::mojom::FormFieldDataPredictionsPtr& input) {
    return input->overall_type;
  }

  static const decltype(::autofill::mojom::FormFieldDataPredictions::parseable_name)& parseable_name(
      const ::autofill::mojom::FormFieldDataPredictionsPtr& input) {
    return input->parseable_name;
  }

  static const decltype(::autofill::mojom::FormFieldDataPredictions::section)& section(
      const ::autofill::mojom::FormFieldDataPredictionsPtr& input) {
    return input->section;
  }

  static bool Read(::autofill::mojom::FormFieldDataPredictions::DataView input, ::autofill::mojom::FormFieldDataPredictionsPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::FormDataPredictions::DataView,
                                         ::autofill::mojom::FormDataPredictionsPtr> {
  static bool IsNull(const ::autofill::mojom::FormDataPredictionsPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::FormDataPredictionsPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::FormDataPredictions::data)& data(
      const ::autofill::mojom::FormDataPredictionsPtr& input) {
    return input->data;
  }

  static const decltype(::autofill::mojom::FormDataPredictions::signature)& signature(
      const ::autofill::mojom::FormDataPredictionsPtr& input) {
    return input->signature;
  }

  static const decltype(::autofill::mojom::FormDataPredictions::fields)& fields(
      const ::autofill::mojom::FormDataPredictionsPtr& input) {
    return input->fields;
  }

  static bool Read(::autofill::mojom::FormDataPredictions::DataView input, ::autofill::mojom::FormDataPredictionsPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::PasswordAndMetadata::DataView,
                                         ::autofill::mojom::PasswordAndMetadataPtr> {
  static bool IsNull(const ::autofill::mojom::PasswordAndMetadataPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::PasswordAndMetadataPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::PasswordAndMetadata::password)& password(
      const ::autofill::mojom::PasswordAndMetadataPtr& input) {
    return input->password;
  }

  static const decltype(::autofill::mojom::PasswordAndMetadata::realm)& realm(
      const ::autofill::mojom::PasswordAndMetadataPtr& input) {
    return input->realm;
  }

  static decltype(::autofill::mojom::PasswordAndMetadata::uses_account_store) uses_account_store(
      const ::autofill::mojom::PasswordAndMetadataPtr& input) {
    return input->uses_account_store;
  }

  static bool Read(::autofill::mojom::PasswordAndMetadata::DataView input, ::autofill::mojom::PasswordAndMetadataPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::PasswordFormFillData::DataView,
                                         ::autofill::mojom::PasswordFormFillDataPtr> {
  static bool IsNull(const ::autofill::mojom::PasswordFormFillDataPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::PasswordFormFillDataPtr* output) { output->reset(); }

  static decltype(::autofill::mojom::PasswordFormFillData::form_renderer_id) form_renderer_id(
      const ::autofill::mojom::PasswordFormFillDataPtr& input) {
    return input->form_renderer_id;
  }

  static const decltype(::autofill::mojom::PasswordFormFillData::origin)& origin(
      const ::autofill::mojom::PasswordFormFillDataPtr& input) {
    return input->origin;
  }

  static const decltype(::autofill::mojom::PasswordFormFillData::action)& action(
      const ::autofill::mojom::PasswordFormFillDataPtr& input) {
    return input->action;
  }

  static const decltype(::autofill::mojom::PasswordFormFillData::username_field)& username_field(
      const ::autofill::mojom::PasswordFormFillDataPtr& input) {
    return input->username_field;
  }

  static const decltype(::autofill::mojom::PasswordFormFillData::password_field)& password_field(
      const ::autofill::mojom::PasswordFormFillDataPtr& input) {
    return input->password_field;
  }

  static decltype(::autofill::mojom::PasswordFormFillData::username_may_use_prefilled_placeholder) username_may_use_prefilled_placeholder(
      const ::autofill::mojom::PasswordFormFillDataPtr& input) {
    return input->username_may_use_prefilled_placeholder;
  }

  static const decltype(::autofill::mojom::PasswordFormFillData::preferred_realm)& preferred_realm(
      const ::autofill::mojom::PasswordFormFillDataPtr& input) {
    return input->preferred_realm;
  }

  static decltype(::autofill::mojom::PasswordFormFillData::uses_account_store) uses_account_store(
      const ::autofill::mojom::PasswordFormFillDataPtr& input) {
    return input->uses_account_store;
  }

  static const decltype(::autofill::mojom::PasswordFormFillData::additional_logins)& additional_logins(
      const ::autofill::mojom::PasswordFormFillDataPtr& input) {
    return input->additional_logins;
  }

  static decltype(::autofill::mojom::PasswordFormFillData::wait_for_username) wait_for_username(
      const ::autofill::mojom::PasswordFormFillDataPtr& input) {
    return input->wait_for_username;
  }

  static decltype(::autofill::mojom::PasswordFormFillData::has_renderer_ids) has_renderer_ids(
      const ::autofill::mojom::PasswordFormFillDataPtr& input) {
    return input->has_renderer_ids;
  }

  static bool Read(::autofill::mojom::PasswordFormFillData::DataView input, ::autofill::mojom::PasswordFormFillDataPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::PasswordFormGenerationData::DataView,
                                         ::autofill::mojom::PasswordFormGenerationDataPtr> {
  static bool IsNull(const ::autofill::mojom::PasswordFormGenerationDataPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::PasswordFormGenerationDataPtr* output) { output->reset(); }

  static decltype(::autofill::mojom::PasswordFormGenerationData::new_password_renderer_id) new_password_renderer_id(
      const ::autofill::mojom::PasswordFormGenerationDataPtr& input) {
    return input->new_password_renderer_id;
  }

  static decltype(::autofill::mojom::PasswordFormGenerationData::confirmation_password_renderer_id) confirmation_password_renderer_id(
      const ::autofill::mojom::PasswordFormGenerationDataPtr& input) {
    return input->confirmation_password_renderer_id;
  }

  static bool Read(::autofill::mojom::PasswordFormGenerationData::DataView input, ::autofill::mojom::PasswordFormGenerationDataPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::PasswordGenerationUIData::DataView,
                                         ::autofill::mojom::PasswordGenerationUIDataPtr> {
  static bool IsNull(const ::autofill::mojom::PasswordGenerationUIDataPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::PasswordGenerationUIDataPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::PasswordGenerationUIData::bounds)& bounds(
      const ::autofill::mojom::PasswordGenerationUIDataPtr& input) {
    return input->bounds;
  }

  static decltype(::autofill::mojom::PasswordGenerationUIData::max_length) max_length(
      const ::autofill::mojom::PasswordGenerationUIDataPtr& input) {
    return input->max_length;
  }

  static const decltype(::autofill::mojom::PasswordGenerationUIData::generation_element)& generation_element(
      const ::autofill::mojom::PasswordGenerationUIDataPtr& input) {
    return input->generation_element;
  }

  static decltype(::autofill::mojom::PasswordGenerationUIData::generation_element_id) generation_element_id(
      const ::autofill::mojom::PasswordGenerationUIDataPtr& input) {
    return input->generation_element_id;
  }

  static decltype(::autofill::mojom::PasswordGenerationUIData::is_generation_element_password_type) is_generation_element_password_type(
      const ::autofill::mojom::PasswordGenerationUIDataPtr& input) {
    return input->is_generation_element_password_type;
  }

  static decltype(::autofill::mojom::PasswordGenerationUIData::text_direction) text_direction(
      const ::autofill::mojom::PasswordGenerationUIDataPtr& input) {
    return input->text_direction;
  }

  static const decltype(::autofill::mojom::PasswordGenerationUIData::form_data)& form_data(
      const ::autofill::mojom::PasswordGenerationUIDataPtr& input) {
    return input->form_data;
  }

  static bool Read(::autofill::mojom::PasswordGenerationUIData::DataView input, ::autofill::mojom::PasswordGenerationUIDataPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::ValueElementPair::DataView,
                                         ::autofill::mojom::ValueElementPairPtr> {
  static bool IsNull(const ::autofill::mojom::ValueElementPairPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::ValueElementPairPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::ValueElementPair::value)& value(
      const ::autofill::mojom::ValueElementPairPtr& input) {
    return input->value;
  }

  static const decltype(::autofill::mojom::ValueElementPair::field_name)& field_name(
      const ::autofill::mojom::ValueElementPairPtr& input) {
    return input->field_name;
  }

  static bool Read(::autofill::mojom::ValueElementPair::DataView input, ::autofill::mojom::ValueElementPairPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::PasswordForm::DataView,
                                         ::autofill::mojom::PasswordFormPtr> {
  static bool IsNull(const ::autofill::mojom::PasswordFormPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::PasswordFormPtr* output) { output->reset(); }

  static decltype(::autofill::mojom::PasswordForm::scheme) scheme(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->scheme;
  }

  static const decltype(::autofill::mojom::PasswordForm::signon_realm)& signon_realm(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->signon_realm;
  }

  static const decltype(::autofill::mojom::PasswordForm::origin_with_path)& origin_with_path(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->origin_with_path;
  }

  static const decltype(::autofill::mojom::PasswordForm::action)& action(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->action;
  }

  static const decltype(::autofill::mojom::PasswordForm::affiliated_web_realm)& affiliated_web_realm(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->affiliated_web_realm;
  }

  static const decltype(::autofill::mojom::PasswordForm::submit_element)& submit_element(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->submit_element;
  }

  static const decltype(::autofill::mojom::PasswordForm::username_element)& username_element(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->username_element;
  }

  static decltype(::autofill::mojom::PasswordForm::username_marked_by_site) username_marked_by_site(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->username_marked_by_site;
  }

  static const decltype(::autofill::mojom::PasswordForm::username_value)& username_value(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->username_value;
  }

  static const decltype(::autofill::mojom::PasswordForm::all_possible_usernames)& all_possible_usernames(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->all_possible_usernames;
  }

  static const decltype(::autofill::mojom::PasswordForm::all_possible_passwords)& all_possible_passwords(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->all_possible_passwords;
  }

  static decltype(::autofill::mojom::PasswordForm::form_has_autofilled_value) form_has_autofilled_value(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->form_has_autofilled_value;
  }

  static const decltype(::autofill::mojom::PasswordForm::password_element)& password_element(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->password_element;
  }

  static const decltype(::autofill::mojom::PasswordForm::password_value)& password_value(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->password_value;
  }

  static const decltype(::autofill::mojom::PasswordForm::new_password_element)& new_password_element(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->new_password_element;
  }

  static const decltype(::autofill::mojom::PasswordForm::new_password_value)& new_password_value(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->new_password_value;
  }

  static decltype(::autofill::mojom::PasswordForm::new_password_marked_by_site) new_password_marked_by_site(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->new_password_marked_by_site;
  }

  static const decltype(::autofill::mojom::PasswordForm::confirmation_password_element)& confirmation_password_element(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->confirmation_password_element;
  }

  static const decltype(::autofill::mojom::PasswordForm::date_created)& date_created(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->date_created;
  }

  static const decltype(::autofill::mojom::PasswordForm::date_synced)& date_synced(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->date_synced;
  }

  static decltype(::autofill::mojom::PasswordForm::blacklisted_by_user) blacklisted_by_user(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->blacklisted_by_user;
  }

  static decltype(::autofill::mojom::PasswordForm::type) type(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->type;
  }

  static decltype(::autofill::mojom::PasswordForm::times_used) times_used(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->times_used;
  }

  static const decltype(::autofill::mojom::PasswordForm::form_data)& form_data(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->form_data;
  }

  static decltype(::autofill::mojom::PasswordForm::generation_upload_status) generation_upload_status(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->generation_upload_status;
  }

  static const decltype(::autofill::mojom::PasswordForm::display_name)& display_name(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->display_name;
  }

  static const decltype(::autofill::mojom::PasswordForm::icon_url)& icon_url(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->icon_url;
  }

  static const decltype(::autofill::mojom::PasswordForm::federation_origin)& federation_origin(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->federation_origin;
  }

  static decltype(::autofill::mojom::PasswordForm::skip_zero_click) skip_zero_click(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->skip_zero_click;
  }

  static decltype(::autofill::mojom::PasswordForm::was_parsed_using_autofill_predictions) was_parsed_using_autofill_predictions(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->was_parsed_using_autofill_predictions;
  }

  static decltype(::autofill::mojom::PasswordForm::is_public_suffix_match) is_public_suffix_match(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->is_public_suffix_match;
  }

  static decltype(::autofill::mojom::PasswordForm::is_affiliation_based_match) is_affiliation_based_match(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->is_affiliation_based_match;
  }

  static decltype(::autofill::mojom::PasswordForm::submission_event) submission_event(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->submission_event;
  }

  static decltype(::autofill::mojom::PasswordForm::only_for_fallback) only_for_fallback(
      const ::autofill::mojom::PasswordFormPtr& input) {
    return input->only_for_fallback;
  }

  static bool Read(::autofill::mojom::PasswordForm::DataView input, ::autofill::mojom::PasswordFormPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::ParsingResult::DataView,
                                         ::autofill::mojom::ParsingResultPtr> {
  static bool IsNull(const ::autofill::mojom::ParsingResultPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::ParsingResultPtr* output) { output->reset(); }

  static decltype(::autofill::mojom::ParsingResult::username_renderer_id) username_renderer_id(
      const ::autofill::mojom::ParsingResultPtr& input) {
    return input->username_renderer_id;
  }

  static decltype(::autofill::mojom::ParsingResult::password_renderer_id) password_renderer_id(
      const ::autofill::mojom::ParsingResultPtr& input) {
    return input->password_renderer_id;
  }

  static decltype(::autofill::mojom::ParsingResult::new_password_renderer_id) new_password_renderer_id(
      const ::autofill::mojom::ParsingResultPtr& input) {
    return input->new_password_renderer_id;
  }

  static decltype(::autofill::mojom::ParsingResult::confirm_password_renderer_id) confirm_password_renderer_id(
      const ::autofill::mojom::ParsingResultPtr& input) {
    return input->confirm_password_renderer_id;
  }

  static bool Read(::autofill::mojom::ParsingResult::DataView input, ::autofill::mojom::ParsingResultPtr* output);
};

}  // namespace mojo

#endif  // COMPONENTS_AUTOFILL_CORE_COMMON_MOJOM_AUTOFILL_TYPES_MOJOM_H_