// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: server.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_server_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_server_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
#include "password_requirements.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_server_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_server_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace autofill {
class AutofillQueryContents;
class AutofillQueryContentsDefaultTypeInternal;
extern AutofillQueryContentsDefaultTypeInternal _AutofillQueryContents_default_instance_;
class AutofillQueryContents_Form;
class AutofillQueryContents_FormDefaultTypeInternal;
extern AutofillQueryContents_FormDefaultTypeInternal _AutofillQueryContents_Form_default_instance_;
class AutofillQueryContents_Form_Field;
class AutofillQueryContents_Form_FieldDefaultTypeInternal;
extern AutofillQueryContents_Form_FieldDefaultTypeInternal _AutofillQueryContents_Form_Field_default_instance_;
class AutofillQueryResponseContents;
class AutofillQueryResponseContentsDefaultTypeInternal;
extern AutofillQueryResponseContentsDefaultTypeInternal _AutofillQueryResponseContents_default_instance_;
class AutofillQueryResponseContents_Field;
class AutofillQueryResponseContents_FieldDefaultTypeInternal;
extern AutofillQueryResponseContents_FieldDefaultTypeInternal _AutofillQueryResponseContents_Field_default_instance_;
class AutofillQueryResponseContents_Field_FieldPrediction;
class AutofillQueryResponseContents_Field_FieldPredictionDefaultTypeInternal;
extern AutofillQueryResponseContents_Field_FieldPredictionDefaultTypeInternal _AutofillQueryResponseContents_Field_FieldPrediction_default_instance_;
class AutofillRandomizedFieldMetadata;
class AutofillRandomizedFieldMetadataDefaultTypeInternal;
extern AutofillRandomizedFieldMetadataDefaultTypeInternal _AutofillRandomizedFieldMetadata_default_instance_;
class AutofillRandomizedFormMetadata;
class AutofillRandomizedFormMetadataDefaultTypeInternal;
extern AutofillRandomizedFormMetadataDefaultTypeInternal _AutofillRandomizedFormMetadata_default_instance_;
class AutofillRandomizedValue;
class AutofillRandomizedValueDefaultTypeInternal;
extern AutofillRandomizedValueDefaultTypeInternal _AutofillRandomizedValue_default_instance_;
class AutofillUploadContents;
class AutofillUploadContentsDefaultTypeInternal;
extern AutofillUploadContentsDefaultTypeInternal _AutofillUploadContents_default_instance_;
class AutofillUploadContents_ButtonTitle;
class AutofillUploadContents_ButtonTitleDefaultTypeInternal;
extern AutofillUploadContents_ButtonTitleDefaultTypeInternal _AutofillUploadContents_ButtonTitle_default_instance_;
class AutofillUploadContents_Field;
class AutofillUploadContents_FieldDefaultTypeInternal;
extern AutofillUploadContents_FieldDefaultTypeInternal _AutofillUploadContents_Field_default_instance_;
class AutofillUploadContents_Field_AutofillTypeValiditiesPair;
class AutofillUploadContents_Field_AutofillTypeValiditiesPairDefaultTypeInternal;
extern AutofillUploadContents_Field_AutofillTypeValiditiesPairDefaultTypeInternal _AutofillUploadContents_Field_AutofillTypeValiditiesPair_default_instance_;
class ProfileValidityMap;
class ProfileValidityMapDefaultTypeInternal;
extern ProfileValidityMapDefaultTypeInternal _ProfileValidityMap_default_instance_;
class ProfileValidityMap_FieldValidityStatesEntry_DoNotUse;
class ProfileValidityMap_FieldValidityStatesEntry_DoNotUseDefaultTypeInternal;
extern ProfileValidityMap_FieldValidityStatesEntry_DoNotUseDefaultTypeInternal _ProfileValidityMap_FieldValidityStatesEntry_DoNotUse_default_instance_;
class UserProfileValidityMap;
class UserProfileValidityMapDefaultTypeInternal;
extern UserProfileValidityMapDefaultTypeInternal _UserProfileValidityMap_default_instance_;
class UserProfileValidityMap_ProfileValidityEntry_DoNotUse;
class UserProfileValidityMap_ProfileValidityEntry_DoNotUseDefaultTypeInternal;
extern UserProfileValidityMap_ProfileValidityEntry_DoNotUseDefaultTypeInternal _UserProfileValidityMap_ProfileValidityEntry_DoNotUse_default_instance_;
}  // namespace autofill
PROTOBUF_NAMESPACE_OPEN
template<> ::autofill::AutofillQueryContents* Arena::CreateMaybeMessage<::autofill::AutofillQueryContents>(Arena*);
template<> ::autofill::AutofillQueryContents_Form* Arena::CreateMaybeMessage<::autofill::AutofillQueryContents_Form>(Arena*);
template<> ::autofill::AutofillQueryContents_Form_Field* Arena::CreateMaybeMessage<::autofill::AutofillQueryContents_Form_Field>(Arena*);
template<> ::autofill::AutofillQueryResponseContents* Arena::CreateMaybeMessage<::autofill::AutofillQueryResponseContents>(Arena*);
template<> ::autofill::AutofillQueryResponseContents_Field* Arena::CreateMaybeMessage<::autofill::AutofillQueryResponseContents_Field>(Arena*);
template<> ::autofill::AutofillQueryResponseContents_Field_FieldPrediction* Arena::CreateMaybeMessage<::autofill::AutofillQueryResponseContents_Field_FieldPrediction>(Arena*);
template<> ::autofill::AutofillRandomizedFieldMetadata* Arena::CreateMaybeMessage<::autofill::AutofillRandomizedFieldMetadata>(Arena*);
template<> ::autofill::AutofillRandomizedFormMetadata* Arena::CreateMaybeMessage<::autofill::AutofillRandomizedFormMetadata>(Arena*);
template<> ::autofill::AutofillRandomizedValue* Arena::CreateMaybeMessage<::autofill::AutofillRandomizedValue>(Arena*);
template<> ::autofill::AutofillUploadContents* Arena::CreateMaybeMessage<::autofill::AutofillUploadContents>(Arena*);
template<> ::autofill::AutofillUploadContents_ButtonTitle* Arena::CreateMaybeMessage<::autofill::AutofillUploadContents_ButtonTitle>(Arena*);
template<> ::autofill::AutofillUploadContents_Field* Arena::CreateMaybeMessage<::autofill::AutofillUploadContents_Field>(Arena*);
template<> ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair* Arena::CreateMaybeMessage<::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair>(Arena*);
template<> ::autofill::ProfileValidityMap* Arena::CreateMaybeMessage<::autofill::ProfileValidityMap>(Arena*);
template<> ::autofill::ProfileValidityMap_FieldValidityStatesEntry_DoNotUse* Arena::CreateMaybeMessage<::autofill::ProfileValidityMap_FieldValidityStatesEntry_DoNotUse>(Arena*);
template<> ::autofill::UserProfileValidityMap* Arena::CreateMaybeMessage<::autofill::UserProfileValidityMap>(Arena*);
template<> ::autofill::UserProfileValidityMap_ProfileValidityEntry_DoNotUse* Arena::CreateMaybeMessage<::autofill::UserProfileValidityMap_ProfileValidityEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace autofill {

enum AutofillRandomizedValue_EncodingType : int {
  AutofillRandomizedValue_EncodingType_UNSPECIFIED_ENCODING_TYPE = -1,
  AutofillRandomizedValue_EncodingType_BIT_0 = 0,
  AutofillRandomizedValue_EncodingType_BIT_1 = 1,
  AutofillRandomizedValue_EncodingType_BIT_2 = 2,
  AutofillRandomizedValue_EncodingType_BIT_3 = 3,
  AutofillRandomizedValue_EncodingType_BIT_4 = 4,
  AutofillRandomizedValue_EncodingType_BIT_5 = 5,
  AutofillRandomizedValue_EncodingType_BIT_6 = 6,
  AutofillRandomizedValue_EncodingType_BIT_7 = 7,
  AutofillRandomizedValue_EncodingType_EVEN_BITS = 8,
  AutofillRandomizedValue_EncodingType_ODD_BITS = 9,
  AutofillRandomizedValue_EncodingType_ALL_BITS = 10
};
bool AutofillRandomizedValue_EncodingType_IsValid(int value);
constexpr AutofillRandomizedValue_EncodingType AutofillRandomizedValue_EncodingType_EncodingType_MIN = AutofillRandomizedValue_EncodingType_UNSPECIFIED_ENCODING_TYPE;
constexpr AutofillRandomizedValue_EncodingType AutofillRandomizedValue_EncodingType_EncodingType_MAX = AutofillRandomizedValue_EncodingType_ALL_BITS;
constexpr int AutofillRandomizedValue_EncodingType_EncodingType_ARRAYSIZE = AutofillRandomizedValue_EncodingType_EncodingType_MAX + 1;

const std::string& AutofillRandomizedValue_EncodingType_Name(AutofillRandomizedValue_EncodingType value);
template<typename T>
inline const std::string& AutofillRandomizedValue_EncodingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AutofillRandomizedValue_EncodingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AutofillRandomizedValue_EncodingType_Name.");
  return AutofillRandomizedValue_EncodingType_Name(static_cast<AutofillRandomizedValue_EncodingType>(enum_t_value));
}
bool AutofillRandomizedValue_EncodingType_Parse(
    const std::string& name, AutofillRandomizedValue_EncodingType* value);
enum AutofillUploadContents_Field_PasswordGenerationType : int {
  AutofillUploadContents_Field_PasswordGenerationType_NO_GENERATION = 0,
  AutofillUploadContents_Field_PasswordGenerationType_AUTOMATICALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM = 1,
  AutofillUploadContents_Field_PasswordGenerationType_AUTOMATICALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM = 2,
  AutofillUploadContents_Field_PasswordGenerationType_MANUALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM = 3,
  AutofillUploadContents_Field_PasswordGenerationType_MANUALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM = 4,
  AutofillUploadContents_Field_PasswordGenerationType_IGNORED_GENERATION_POPUP = 5
};
bool AutofillUploadContents_Field_PasswordGenerationType_IsValid(int value);
constexpr AutofillUploadContents_Field_PasswordGenerationType AutofillUploadContents_Field_PasswordGenerationType_PasswordGenerationType_MIN = AutofillUploadContents_Field_PasswordGenerationType_NO_GENERATION;
constexpr AutofillUploadContents_Field_PasswordGenerationType AutofillUploadContents_Field_PasswordGenerationType_PasswordGenerationType_MAX = AutofillUploadContents_Field_PasswordGenerationType_IGNORED_GENERATION_POPUP;
constexpr int AutofillUploadContents_Field_PasswordGenerationType_PasswordGenerationType_ARRAYSIZE = AutofillUploadContents_Field_PasswordGenerationType_PasswordGenerationType_MAX + 1;

const std::string& AutofillUploadContents_Field_PasswordGenerationType_Name(AutofillUploadContents_Field_PasswordGenerationType value);
template<typename T>
inline const std::string& AutofillUploadContents_Field_PasswordGenerationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AutofillUploadContents_Field_PasswordGenerationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AutofillUploadContents_Field_PasswordGenerationType_Name.");
  return AutofillUploadContents_Field_PasswordGenerationType_Name(static_cast<AutofillUploadContents_Field_PasswordGenerationType>(enum_t_value));
}
bool AutofillUploadContents_Field_PasswordGenerationType_Parse(
    const std::string& name, AutofillUploadContents_Field_PasswordGenerationType* value);
enum AutofillUploadContents_Field_VoteType : int {
  AutofillUploadContents_Field_VoteType_NO_INFORMATION = 0,
  AutofillUploadContents_Field_VoteType_CREDENTIALS_REUSED = 1,
  AutofillUploadContents_Field_VoteType_USERNAME_OVERWRITTEN = 2,
  AutofillUploadContents_Field_VoteType_USERNAME_EDITED = 3,
  AutofillUploadContents_Field_VoteType_BASE_HEURISTIC = 4,
  AutofillUploadContents_Field_VoteType_HTML_CLASSIFIER = 5,
  AutofillUploadContents_Field_VoteType_FIRST_USE = 6
};
bool AutofillUploadContents_Field_VoteType_IsValid(int value);
constexpr AutofillUploadContents_Field_VoteType AutofillUploadContents_Field_VoteType_VoteType_MIN = AutofillUploadContents_Field_VoteType_NO_INFORMATION;
constexpr AutofillUploadContents_Field_VoteType AutofillUploadContents_Field_VoteType_VoteType_MAX = AutofillUploadContents_Field_VoteType_FIRST_USE;
constexpr int AutofillUploadContents_Field_VoteType_VoteType_ARRAYSIZE = AutofillUploadContents_Field_VoteType_VoteType_MAX + 1;

const std::string& AutofillUploadContents_Field_VoteType_Name(AutofillUploadContents_Field_VoteType value);
template<typename T>
inline const std::string& AutofillUploadContents_Field_VoteType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AutofillUploadContents_Field_VoteType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AutofillUploadContents_Field_VoteType_Name.");
  return AutofillUploadContents_Field_VoteType_Name(static_cast<AutofillUploadContents_Field_VoteType>(enum_t_value));
}
bool AutofillUploadContents_Field_VoteType_Parse(
    const std::string& name, AutofillUploadContents_Field_VoteType* value);
enum AutofillUploadContents_ButtonTitle_ButtonTitleType : int {
  AutofillUploadContents_ButtonTitle_ButtonTitleType_NONE = 0,
  AutofillUploadContents_ButtonTitle_ButtonTitleType_BUTTON_ELEMENT_SUBMIT_TYPE = 1,
  AutofillUploadContents_ButtonTitle_ButtonTitleType_BUTTON_ELEMENT_BUTTON_TYPE = 2,
  AutofillUploadContents_ButtonTitle_ButtonTitleType_INPUT_ELEMENT_SUBMIT_TYPE = 3,
  AutofillUploadContents_ButtonTitle_ButtonTitleType_INPUT_ELEMENT_BUTTON_TYPE = 4,
  AutofillUploadContents_ButtonTitle_ButtonTitleType_HYPERLINK = 5,
  AutofillUploadContents_ButtonTitle_ButtonTitleType_DIV = 6,
  AutofillUploadContents_ButtonTitle_ButtonTitleType_SPAN = 7
};
bool AutofillUploadContents_ButtonTitle_ButtonTitleType_IsValid(int value);
constexpr AutofillUploadContents_ButtonTitle_ButtonTitleType AutofillUploadContents_ButtonTitle_ButtonTitleType_ButtonTitleType_MIN = AutofillUploadContents_ButtonTitle_ButtonTitleType_NONE;
constexpr AutofillUploadContents_ButtonTitle_ButtonTitleType AutofillUploadContents_ButtonTitle_ButtonTitleType_ButtonTitleType_MAX = AutofillUploadContents_ButtonTitle_ButtonTitleType_SPAN;
constexpr int AutofillUploadContents_ButtonTitle_ButtonTitleType_ButtonTitleType_ARRAYSIZE = AutofillUploadContents_ButtonTitle_ButtonTitleType_ButtonTitleType_MAX + 1;

const std::string& AutofillUploadContents_ButtonTitle_ButtonTitleType_Name(AutofillUploadContents_ButtonTitle_ButtonTitleType value);
template<typename T>
inline const std::string& AutofillUploadContents_ButtonTitle_ButtonTitleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AutofillUploadContents_ButtonTitle_ButtonTitleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AutofillUploadContents_ButtonTitle_ButtonTitleType_Name.");
  return AutofillUploadContents_ButtonTitle_ButtonTitleType_Name(static_cast<AutofillUploadContents_ButtonTitle_ButtonTitleType>(enum_t_value));
}
bool AutofillUploadContents_ButtonTitle_ButtonTitleType_Parse(
    const std::string& name, AutofillUploadContents_ButtonTitle_ButtonTitleType* value);
enum AutofillUploadContents_SubmissionIndicatorEvent : int {
  AutofillUploadContents_SubmissionIndicatorEvent_NONE = 0,
  AutofillUploadContents_SubmissionIndicatorEvent_HTML_FORM_SUBMISSION = 1,
  AutofillUploadContents_SubmissionIndicatorEvent_SAME_DOCUMENT_NAVIGATION = 2,
  AutofillUploadContents_SubmissionIndicatorEvent_XHR_SUCCEEDED = 3,
  AutofillUploadContents_SubmissionIndicatorEvent_FRAME_DETACHED = 4,
  AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_MANUAL_SAVE = 5,
  AutofillUploadContents_SubmissionIndicatorEvent_DOM_MUTATION_AFTER_XHR = 6,
  AutofillUploadContents_SubmissionIndicatorEvent_PROVISIONALLY_SAVED_FORM_ON_START_PROVISIONAL_LOAD = 7,
  AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_FILLED_FORM_ON_START_PROVISIONAL_LOAD = 8,
  AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_FILLED_INPUT_ELEMENTS_ON_START_PROVISIONAL_LOAD = 9,
  AutofillUploadContents_SubmissionIndicatorEvent_PROBABLE_FORM_SUBMISSION = 10
};
bool AutofillUploadContents_SubmissionIndicatorEvent_IsValid(int value);
constexpr AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents_SubmissionIndicatorEvent_SubmissionIndicatorEvent_MIN = AutofillUploadContents_SubmissionIndicatorEvent_NONE;
constexpr AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents_SubmissionIndicatorEvent_SubmissionIndicatorEvent_MAX = AutofillUploadContents_SubmissionIndicatorEvent_PROBABLE_FORM_SUBMISSION;
constexpr int AutofillUploadContents_SubmissionIndicatorEvent_SubmissionIndicatorEvent_ARRAYSIZE = AutofillUploadContents_SubmissionIndicatorEvent_SubmissionIndicatorEvent_MAX + 1;

const std::string& AutofillUploadContents_SubmissionIndicatorEvent_Name(AutofillUploadContents_SubmissionIndicatorEvent value);
template<typename T>
inline const std::string& AutofillUploadContents_SubmissionIndicatorEvent_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AutofillUploadContents_SubmissionIndicatorEvent>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AutofillUploadContents_SubmissionIndicatorEvent_Name.");
  return AutofillUploadContents_SubmissionIndicatorEvent_Name(static_cast<AutofillUploadContents_SubmissionIndicatorEvent>(enum_t_value));
}
bool AutofillUploadContents_SubmissionIndicatorEvent_Parse(
    const std::string& name, AutofillUploadContents_SubmissionIndicatorEvent* value);
// ===================================================================

class AutofillQueryContents_Form_Field :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillQueryContents.Form.Field) */ {
 public:
  AutofillQueryContents_Form_Field();
  virtual ~AutofillQueryContents_Form_Field();

  AutofillQueryContents_Form_Field(const AutofillQueryContents_Form_Field& from);
  AutofillQueryContents_Form_Field(AutofillQueryContents_Form_Field&& from) noexcept
    : AutofillQueryContents_Form_Field() {
    *this = ::std::move(from);
  }

  inline AutofillQueryContents_Form_Field& operator=(const AutofillQueryContents_Form_Field& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillQueryContents_Form_Field& operator=(AutofillQueryContents_Form_Field&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AutofillQueryContents_Form_Field& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutofillQueryContents_Form_Field* internal_default_instance() {
    return reinterpret_cast<const AutofillQueryContents_Form_Field*>(
               &_AutofillQueryContents_Form_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AutofillQueryContents_Form_Field& a, AutofillQueryContents_Form_Field& b) {
    a.Swap(&b);
  }
  inline void Swap(AutofillQueryContents_Form_Field* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AutofillQueryContents_Form_Field* New() const final {
    return CreateMaybeMessage<AutofillQueryContents_Form_Field>(nullptr);
  }

  AutofillQueryContents_Form_Field* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AutofillQueryContents_Form_Field>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AutofillQueryContents_Form_Field& from);
  void MergeFrom(const AutofillQueryContents_Form_Field& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillQueryContents_Form_Field* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillQueryContents.Form.Field";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 8,
    kTypeFieldNumber = 9,
    kFieldMetadataFieldNumber = 13,
    kSignatureFieldNumber = 5,
  };
  // optional string name = 8;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional string type = 9;
  bool has_type() const;
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);

  // optional .autofill.AutofillRandomizedFieldMetadata field_metadata = 13;
  bool has_field_metadata() const;
  void clear_field_metadata();
  const ::autofill::AutofillRandomizedFieldMetadata& field_metadata() const;
  ::autofill::AutofillRandomizedFieldMetadata* release_field_metadata();
  ::autofill::AutofillRandomizedFieldMetadata* mutable_field_metadata();
  void set_allocated_field_metadata(::autofill::AutofillRandomizedFieldMetadata* field_metadata);

  // required fixed32 signature = 5;
  bool has_signature() const;
  void clear_signature();
  ::PROTOBUF_NAMESPACE_ID::uint32 signature() const;
  void set_signature(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:autofill.AutofillQueryContents.Form.Field)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::autofill::AutofillRandomizedFieldMetadata* field_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 signature_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillQueryContents_Form :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillQueryContents.Form) */ {
 public:
  AutofillQueryContents_Form();
  virtual ~AutofillQueryContents_Form();

  AutofillQueryContents_Form(const AutofillQueryContents_Form& from);
  AutofillQueryContents_Form(AutofillQueryContents_Form&& from) noexcept
    : AutofillQueryContents_Form() {
    *this = ::std::move(from);
  }

  inline AutofillQueryContents_Form& operator=(const AutofillQueryContents_Form& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillQueryContents_Form& operator=(AutofillQueryContents_Form&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AutofillQueryContents_Form& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutofillQueryContents_Form* internal_default_instance() {
    return reinterpret_cast<const AutofillQueryContents_Form*>(
               &_AutofillQueryContents_Form_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AutofillQueryContents_Form& a, AutofillQueryContents_Form& b) {
    a.Swap(&b);
  }
  inline void Swap(AutofillQueryContents_Form* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AutofillQueryContents_Form* New() const final {
    return CreateMaybeMessage<AutofillQueryContents_Form>(nullptr);
  }

  AutofillQueryContents_Form* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AutofillQueryContents_Form>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AutofillQueryContents_Form& from);
  void MergeFrom(const AutofillQueryContents_Form& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillQueryContents_Form* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillQueryContents.Form";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AutofillQueryContents_Form_Field Field;

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 4,
    kFormMetadataFieldNumber = 12,
    kSignatureFieldNumber = 3,
  };
  // repeated group Field = 4 { ... };
  int field_size() const;
  void clear_field();
  ::autofill::AutofillQueryContents_Form_Field* mutable_field(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryContents_Form_Field >*
      mutable_field();
  const ::autofill::AutofillQueryContents_Form_Field& field(int index) const;
  ::autofill::AutofillQueryContents_Form_Field* add_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryContents_Form_Field >&
      field() const;

  // optional .autofill.AutofillRandomizedFormMetadata form_metadata = 12;
  bool has_form_metadata() const;
  void clear_form_metadata();
  const ::autofill::AutofillRandomizedFormMetadata& form_metadata() const;
  ::autofill::AutofillRandomizedFormMetadata* release_form_metadata();
  ::autofill::AutofillRandomizedFormMetadata* mutable_form_metadata();
  void set_allocated_form_metadata(::autofill::AutofillRandomizedFormMetadata* form_metadata);

  // required fixed64 signature = 3;
  bool has_signature() const;
  void clear_signature();
  ::PROTOBUF_NAMESPACE_ID::uint64 signature() const;
  void set_signature(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:autofill.AutofillQueryContents.Form)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryContents_Form_Field > field_;
  ::autofill::AutofillRandomizedFormMetadata* form_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 signature_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillQueryContents :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillQueryContents) */ {
 public:
  AutofillQueryContents();
  virtual ~AutofillQueryContents();

  AutofillQueryContents(const AutofillQueryContents& from);
  AutofillQueryContents(AutofillQueryContents&& from) noexcept
    : AutofillQueryContents() {
    *this = ::std::move(from);
  }

  inline AutofillQueryContents& operator=(const AutofillQueryContents& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillQueryContents& operator=(AutofillQueryContents&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AutofillQueryContents& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutofillQueryContents* internal_default_instance() {
    return reinterpret_cast<const AutofillQueryContents*>(
               &_AutofillQueryContents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AutofillQueryContents& a, AutofillQueryContents& b) {
    a.Swap(&b);
  }
  inline void Swap(AutofillQueryContents* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AutofillQueryContents* New() const final {
    return CreateMaybeMessage<AutofillQueryContents>(nullptr);
  }

  AutofillQueryContents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AutofillQueryContents>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AutofillQueryContents& from);
  void MergeFrom(const AutofillQueryContents& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillQueryContents* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillQueryContents";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AutofillQueryContents_Form Form;

  // accessors -------------------------------------------------------

  enum : int {
    kFormFieldNumber = 2,
    kExperimentsFieldNumber = 14,
    kClientVersionFieldNumber = 1,
  };
  // repeated group Form = 2 { ... };
  int form_size() const;
  void clear_form();
  ::autofill::AutofillQueryContents_Form* mutable_form(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryContents_Form >*
      mutable_form();
  const ::autofill::AutofillQueryContents_Form& form(int index) const;
  ::autofill::AutofillQueryContents_Form* add_form();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryContents_Form >&
      form() const;

  // repeated int64 experiments = 14;
  int experiments_size() const;
  void clear_experiments();
  ::PROTOBUF_NAMESPACE_ID::int64 experiments(int index) const;
  void set_experiments(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_experiments(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      experiments() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_experiments();

  // required string client_version = 1;
  bool has_client_version() const;
  void clear_client_version();
  const std::string& client_version() const;
  void set_client_version(const std::string& value);
  void set_client_version(std::string&& value);
  void set_client_version(const char* value);
  void set_client_version(const char* value, size_t size);
  std::string* mutable_client_version();
  std::string* release_client_version();
  void set_allocated_client_version(std::string* client_version);

  // @@protoc_insertion_point(class_scope:autofill.AutofillQueryContents)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryContents_Form > form_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > experiments_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_version_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillQueryResponseContents_Field_FieldPrediction :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillQueryResponseContents.Field.FieldPrediction) */ {
 public:
  AutofillQueryResponseContents_Field_FieldPrediction();
  virtual ~AutofillQueryResponseContents_Field_FieldPrediction();

  AutofillQueryResponseContents_Field_FieldPrediction(const AutofillQueryResponseContents_Field_FieldPrediction& from);
  AutofillQueryResponseContents_Field_FieldPrediction(AutofillQueryResponseContents_Field_FieldPrediction&& from) noexcept
    : AutofillQueryResponseContents_Field_FieldPrediction() {
    *this = ::std::move(from);
  }

  inline AutofillQueryResponseContents_Field_FieldPrediction& operator=(const AutofillQueryResponseContents_Field_FieldPrediction& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillQueryResponseContents_Field_FieldPrediction& operator=(AutofillQueryResponseContents_Field_FieldPrediction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AutofillQueryResponseContents_Field_FieldPrediction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutofillQueryResponseContents_Field_FieldPrediction* internal_default_instance() {
    return reinterpret_cast<const AutofillQueryResponseContents_Field_FieldPrediction*>(
               &_AutofillQueryResponseContents_Field_FieldPrediction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AutofillQueryResponseContents_Field_FieldPrediction& a, AutofillQueryResponseContents_Field_FieldPrediction& b) {
    a.Swap(&b);
  }
  inline void Swap(AutofillQueryResponseContents_Field_FieldPrediction* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AutofillQueryResponseContents_Field_FieldPrediction* New() const final {
    return CreateMaybeMessage<AutofillQueryResponseContents_Field_FieldPrediction>(nullptr);
  }

  AutofillQueryResponseContents_Field_FieldPrediction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AutofillQueryResponseContents_Field_FieldPrediction>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AutofillQueryResponseContents_Field_FieldPrediction& from);
  void MergeFrom(const AutofillQueryResponseContents_Field_FieldPrediction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillQueryResponseContents_Field_FieldPrediction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillQueryResponseContents.Field.FieldPrediction";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kMayUsePrefilledPlaceholderFieldNumber = 2,
  };
  // optional fixed32 type = 1;
  bool has_type() const;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional bool may_use_prefilled_placeholder = 2;
  bool has_may_use_prefilled_placeholder() const;
  void clear_may_use_prefilled_placeholder();
  bool may_use_prefilled_placeholder() const;
  void set_may_use_prefilled_placeholder(bool value);

  // @@protoc_insertion_point(class_scope:autofill.AutofillQueryResponseContents.Field.FieldPrediction)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 type_;
  bool may_use_prefilled_placeholder_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillQueryResponseContents_Field :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillQueryResponseContents.Field) */ {
 public:
  AutofillQueryResponseContents_Field();
  virtual ~AutofillQueryResponseContents_Field();

  AutofillQueryResponseContents_Field(const AutofillQueryResponseContents_Field& from);
  AutofillQueryResponseContents_Field(AutofillQueryResponseContents_Field&& from) noexcept
    : AutofillQueryResponseContents_Field() {
    *this = ::std::move(from);
  }

  inline AutofillQueryResponseContents_Field& operator=(const AutofillQueryResponseContents_Field& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillQueryResponseContents_Field& operator=(AutofillQueryResponseContents_Field&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AutofillQueryResponseContents_Field& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutofillQueryResponseContents_Field* internal_default_instance() {
    return reinterpret_cast<const AutofillQueryResponseContents_Field*>(
               &_AutofillQueryResponseContents_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AutofillQueryResponseContents_Field& a, AutofillQueryResponseContents_Field& b) {
    a.Swap(&b);
  }
  inline void Swap(AutofillQueryResponseContents_Field* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AutofillQueryResponseContents_Field* New() const final {
    return CreateMaybeMessage<AutofillQueryResponseContents_Field>(nullptr);
  }

  AutofillQueryResponseContents_Field* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AutofillQueryResponseContents_Field>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AutofillQueryResponseContents_Field& from);
  void MergeFrom(const AutofillQueryResponseContents_Field& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillQueryResponseContents_Field* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillQueryResponseContents.Field";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AutofillQueryResponseContents_Field_FieldPrediction FieldPrediction;

  // accessors -------------------------------------------------------

  enum : int {
    kPredictionsFieldNumber = 7,
    kPasswordRequirementsFieldNumber = 9,
    kOverallTypePredictionFieldNumber = 3,
  };
  // repeated .autofill.AutofillQueryResponseContents.Field.FieldPrediction predictions = 7;
  int predictions_size() const;
  void clear_predictions();
  ::autofill::AutofillQueryResponseContents_Field_FieldPrediction* mutable_predictions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryResponseContents_Field_FieldPrediction >*
      mutable_predictions();
  const ::autofill::AutofillQueryResponseContents_Field_FieldPrediction& predictions(int index) const;
  ::autofill::AutofillQueryResponseContents_Field_FieldPrediction* add_predictions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryResponseContents_Field_FieldPrediction >&
      predictions() const;

  // optional .autofill.PasswordRequirementsSpec password_requirements = 9;
  bool has_password_requirements() const;
  void clear_password_requirements();
  const ::autofill::PasswordRequirementsSpec& password_requirements() const;
  ::autofill::PasswordRequirementsSpec* release_password_requirements();
  ::autofill::PasswordRequirementsSpec* mutable_password_requirements();
  void set_allocated_password_requirements(::autofill::PasswordRequirementsSpec* password_requirements);

  // required fixed32 overall_type_prediction = 3;
  bool has_overall_type_prediction() const;
  void clear_overall_type_prediction();
  ::PROTOBUF_NAMESPACE_ID::uint32 overall_type_prediction() const;
  void set_overall_type_prediction(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:autofill.AutofillQueryResponseContents.Field)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryResponseContents_Field_FieldPrediction > predictions_;
  ::autofill::PasswordRequirementsSpec* password_requirements_;
  ::PROTOBUF_NAMESPACE_ID::uint32 overall_type_prediction_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillQueryResponseContents :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillQueryResponseContents) */ {
 public:
  AutofillQueryResponseContents();
  virtual ~AutofillQueryResponseContents();

  AutofillQueryResponseContents(const AutofillQueryResponseContents& from);
  AutofillQueryResponseContents(AutofillQueryResponseContents&& from) noexcept
    : AutofillQueryResponseContents() {
    *this = ::std::move(from);
  }

  inline AutofillQueryResponseContents& operator=(const AutofillQueryResponseContents& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillQueryResponseContents& operator=(AutofillQueryResponseContents&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AutofillQueryResponseContents& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutofillQueryResponseContents* internal_default_instance() {
    return reinterpret_cast<const AutofillQueryResponseContents*>(
               &_AutofillQueryResponseContents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AutofillQueryResponseContents& a, AutofillQueryResponseContents& b) {
    a.Swap(&b);
  }
  inline void Swap(AutofillQueryResponseContents* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AutofillQueryResponseContents* New() const final {
    return CreateMaybeMessage<AutofillQueryResponseContents>(nullptr);
  }

  AutofillQueryResponseContents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AutofillQueryResponseContents>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AutofillQueryResponseContents& from);
  void MergeFrom(const AutofillQueryResponseContents& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillQueryResponseContents* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillQueryResponseContents";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AutofillQueryResponseContents_Field Field;

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 2,
    kUploadRequiredFieldNumber = 1,
  };
  // repeated group Field = 2 { ... };
  int field_size() const;
  void clear_field();
  ::autofill::AutofillQueryResponseContents_Field* mutable_field(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryResponseContents_Field >*
      mutable_field();
  const ::autofill::AutofillQueryResponseContents_Field& field(int index) const;
  ::autofill::AutofillQueryResponseContents_Field* add_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryResponseContents_Field >&
      field() const;

  // optional bool upload_required = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_upload_required() const;
  PROTOBUF_DEPRECATED void clear_upload_required();
  PROTOBUF_DEPRECATED bool upload_required() const;
  PROTOBUF_DEPRECATED void set_upload_required(bool value);

  // @@protoc_insertion_point(class_scope:autofill.AutofillQueryResponseContents)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryResponseContents_Field > field_;
  bool upload_required_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillRandomizedValue :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillRandomizedValue) */ {
 public:
  AutofillRandomizedValue();
  virtual ~AutofillRandomizedValue();

  AutofillRandomizedValue(const AutofillRandomizedValue& from);
  AutofillRandomizedValue(AutofillRandomizedValue&& from) noexcept
    : AutofillRandomizedValue() {
    *this = ::std::move(from);
  }

  inline AutofillRandomizedValue& operator=(const AutofillRandomizedValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillRandomizedValue& operator=(AutofillRandomizedValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AutofillRandomizedValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutofillRandomizedValue* internal_default_instance() {
    return reinterpret_cast<const AutofillRandomizedValue*>(
               &_AutofillRandomizedValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AutofillRandomizedValue& a, AutofillRandomizedValue& b) {
    a.Swap(&b);
  }
  inline void Swap(AutofillRandomizedValue* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AutofillRandomizedValue* New() const final {
    return CreateMaybeMessage<AutofillRandomizedValue>(nullptr);
  }

  AutofillRandomizedValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AutofillRandomizedValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AutofillRandomizedValue& from);
  void MergeFrom(const AutofillRandomizedValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillRandomizedValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillRandomizedValue";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AutofillRandomizedValue_EncodingType EncodingType;
  static constexpr EncodingType UNSPECIFIED_ENCODING_TYPE =
    AutofillRandomizedValue_EncodingType_UNSPECIFIED_ENCODING_TYPE;
  static constexpr EncodingType BIT_0 =
    AutofillRandomizedValue_EncodingType_BIT_0;
  static constexpr EncodingType BIT_1 =
    AutofillRandomizedValue_EncodingType_BIT_1;
  static constexpr EncodingType BIT_2 =
    AutofillRandomizedValue_EncodingType_BIT_2;
  static constexpr EncodingType BIT_3 =
    AutofillRandomizedValue_EncodingType_BIT_3;
  static constexpr EncodingType BIT_4 =
    AutofillRandomizedValue_EncodingType_BIT_4;
  static constexpr EncodingType BIT_5 =
    AutofillRandomizedValue_EncodingType_BIT_5;
  static constexpr EncodingType BIT_6 =
    AutofillRandomizedValue_EncodingType_BIT_6;
  static constexpr EncodingType BIT_7 =
    AutofillRandomizedValue_EncodingType_BIT_7;
  static constexpr EncodingType EVEN_BITS =
    AutofillRandomizedValue_EncodingType_EVEN_BITS;
  static constexpr EncodingType ODD_BITS =
    AutofillRandomizedValue_EncodingType_ODD_BITS;
  static constexpr EncodingType ALL_BITS =
    AutofillRandomizedValue_EncodingType_ALL_BITS;
  static inline bool EncodingType_IsValid(int value) {
    return AutofillRandomizedValue_EncodingType_IsValid(value);
  }
  static constexpr EncodingType EncodingType_MIN =
    AutofillRandomizedValue_EncodingType_EncodingType_MIN;
  static constexpr EncodingType EncodingType_MAX =
    AutofillRandomizedValue_EncodingType_EncodingType_MAX;
  static constexpr int EncodingType_ARRAYSIZE =
    AutofillRandomizedValue_EncodingType_EncodingType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& EncodingType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EncodingType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EncodingType_Name.");
    return AutofillRandomizedValue_EncodingType_Name(enum_t_value);
  }
  static inline bool EncodingType_Parse(const std::string& name,
      EncodingType* value) {
    return AutofillRandomizedValue_EncodingType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEncodedBitsFieldNumber = 2,
    kEncodingTypeFieldNumber = 1,
  };
  // optional bytes encoded_bits = 2;
  bool has_encoded_bits() const;
  void clear_encoded_bits();
  const std::string& encoded_bits() const;
  void set_encoded_bits(const std::string& value);
  void set_encoded_bits(std::string&& value);
  void set_encoded_bits(const char* value);
  void set_encoded_bits(const void* value, size_t size);
  std::string* mutable_encoded_bits();
  std::string* release_encoded_bits();
  void set_allocated_encoded_bits(std::string* encoded_bits);

  // optional .autofill.AutofillRandomizedValue.EncodingType encoding_type = 1 [default = UNSPECIFIED_ENCODING_TYPE];
  bool has_encoding_type() const;
  void clear_encoding_type();
  ::autofill::AutofillRandomizedValue_EncodingType encoding_type() const;
  void set_encoding_type(::autofill::AutofillRandomizedValue_EncodingType value);

  // @@protoc_insertion_point(class_scope:autofill.AutofillRandomizedValue)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoded_bits_;
  int encoding_type_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillRandomizedFormMetadata :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillRandomizedFormMetadata) */ {
 public:
  AutofillRandomizedFormMetadata();
  virtual ~AutofillRandomizedFormMetadata();

  AutofillRandomizedFormMetadata(const AutofillRandomizedFormMetadata& from);
  AutofillRandomizedFormMetadata(AutofillRandomizedFormMetadata&& from) noexcept
    : AutofillRandomizedFormMetadata() {
    *this = ::std::move(from);
  }

  inline AutofillRandomizedFormMetadata& operator=(const AutofillRandomizedFormMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillRandomizedFormMetadata& operator=(AutofillRandomizedFormMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AutofillRandomizedFormMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutofillRandomizedFormMetadata* internal_default_instance() {
    return reinterpret_cast<const AutofillRandomizedFormMetadata*>(
               &_AutofillRandomizedFormMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AutofillRandomizedFormMetadata& a, AutofillRandomizedFormMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(AutofillRandomizedFormMetadata* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AutofillRandomizedFormMetadata* New() const final {
    return CreateMaybeMessage<AutofillRandomizedFormMetadata>(nullptr);
  }

  AutofillRandomizedFormMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AutofillRandomizedFormMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AutofillRandomizedFormMetadata& from);
  void MergeFrom(const AutofillRandomizedFormMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillRandomizedFormMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillRandomizedFormMetadata";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kActionFieldNumber = 3,
  };
  // optional .autofill.AutofillRandomizedValue id = 1;
  bool has_id() const;
  void clear_id();
  const ::autofill::AutofillRandomizedValue& id() const;
  ::autofill::AutofillRandomizedValue* release_id();
  ::autofill::AutofillRandomizedValue* mutable_id();
  void set_allocated_id(::autofill::AutofillRandomizedValue* id);

  // optional .autofill.AutofillRandomizedValue name = 2;
  bool has_name() const;
  void clear_name();
  const ::autofill::AutofillRandomizedValue& name() const;
  ::autofill::AutofillRandomizedValue* release_name();
  ::autofill::AutofillRandomizedValue* mutable_name();
  void set_allocated_name(::autofill::AutofillRandomizedValue* name);

  // optional .autofill.AutofillRandomizedValue action = 3;
  bool has_action() const;
  void clear_action();
  const ::autofill::AutofillRandomizedValue& action() const;
  ::autofill::AutofillRandomizedValue* release_action();
  ::autofill::AutofillRandomizedValue* mutable_action();
  void set_allocated_action(::autofill::AutofillRandomizedValue* action);

  // @@protoc_insertion_point(class_scope:autofill.AutofillRandomizedFormMetadata)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill::AutofillRandomizedValue* id_;
  ::autofill::AutofillRandomizedValue* name_;
  ::autofill::AutofillRandomizedValue* action_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillRandomizedFieldMetadata :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillRandomizedFieldMetadata) */ {
 public:
  AutofillRandomizedFieldMetadata();
  virtual ~AutofillRandomizedFieldMetadata();

  AutofillRandomizedFieldMetadata(const AutofillRandomizedFieldMetadata& from);
  AutofillRandomizedFieldMetadata(AutofillRandomizedFieldMetadata&& from) noexcept
    : AutofillRandomizedFieldMetadata() {
    *this = ::std::move(from);
  }

  inline AutofillRandomizedFieldMetadata& operator=(const AutofillRandomizedFieldMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillRandomizedFieldMetadata& operator=(AutofillRandomizedFieldMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AutofillRandomizedFieldMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutofillRandomizedFieldMetadata* internal_default_instance() {
    return reinterpret_cast<const AutofillRandomizedFieldMetadata*>(
               &_AutofillRandomizedFieldMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AutofillRandomizedFieldMetadata& a, AutofillRandomizedFieldMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(AutofillRandomizedFieldMetadata* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AutofillRandomizedFieldMetadata* New() const final {
    return CreateMaybeMessage<AutofillRandomizedFieldMetadata>(nullptr);
  }

  AutofillRandomizedFieldMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AutofillRandomizedFieldMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AutofillRandomizedFieldMetadata& from);
  void MergeFrom(const AutofillRandomizedFieldMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillRandomizedFieldMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillRandomizedFieldMetadata";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kTypeFieldNumber = 3,
    kLabelFieldNumber = 4,
    kAriaLabelFieldNumber = 5,
    kAriaDescriptionFieldNumber = 6,
    kCssClassFieldNumber = 7,
    kPlaceholderFieldNumber = 8,
    kInitialValueHashFieldNumber = 9,
  };
  // optional .autofill.AutofillRandomizedValue id = 1;
  bool has_id() const;
  void clear_id();
  const ::autofill::AutofillRandomizedValue& id() const;
  ::autofill::AutofillRandomizedValue* release_id();
  ::autofill::AutofillRandomizedValue* mutable_id();
  void set_allocated_id(::autofill::AutofillRandomizedValue* id);

  // optional .autofill.AutofillRandomizedValue name = 2;
  bool has_name() const;
  void clear_name();
  const ::autofill::AutofillRandomizedValue& name() const;
  ::autofill::AutofillRandomizedValue* release_name();
  ::autofill::AutofillRandomizedValue* mutable_name();
  void set_allocated_name(::autofill::AutofillRandomizedValue* name);

  // optional .autofill.AutofillRandomizedValue type = 3;
  bool has_type() const;
  void clear_type();
  const ::autofill::AutofillRandomizedValue& type() const;
  ::autofill::AutofillRandomizedValue* release_type();
  ::autofill::AutofillRandomizedValue* mutable_type();
  void set_allocated_type(::autofill::AutofillRandomizedValue* type);

  // optional .autofill.AutofillRandomizedValue label = 4;
  bool has_label() const;
  void clear_label();
  const ::autofill::AutofillRandomizedValue& label() const;
  ::autofill::AutofillRandomizedValue* release_label();
  ::autofill::AutofillRandomizedValue* mutable_label();
  void set_allocated_label(::autofill::AutofillRandomizedValue* label);

  // optional .autofill.AutofillRandomizedValue aria_label = 5;
  bool has_aria_label() const;
  void clear_aria_label();
  const ::autofill::AutofillRandomizedValue& aria_label() const;
  ::autofill::AutofillRandomizedValue* release_aria_label();
  ::autofill::AutofillRandomizedValue* mutable_aria_label();
  void set_allocated_aria_label(::autofill::AutofillRandomizedValue* aria_label);

  // optional .autofill.AutofillRandomizedValue aria_description = 6;
  bool has_aria_description() const;
  void clear_aria_description();
  const ::autofill::AutofillRandomizedValue& aria_description() const;
  ::autofill::AutofillRandomizedValue* release_aria_description();
  ::autofill::AutofillRandomizedValue* mutable_aria_description();
  void set_allocated_aria_description(::autofill::AutofillRandomizedValue* aria_description);

  // optional .autofill.AutofillRandomizedValue css_class = 7;
  bool has_css_class() const;
  void clear_css_class();
  const ::autofill::AutofillRandomizedValue& css_class() const;
  ::autofill::AutofillRandomizedValue* release_css_class();
  ::autofill::AutofillRandomizedValue* mutable_css_class();
  void set_allocated_css_class(::autofill::AutofillRandomizedValue* css_class);

  // optional .autofill.AutofillRandomizedValue placeholder = 8;
  bool has_placeholder() const;
  void clear_placeholder();
  const ::autofill::AutofillRandomizedValue& placeholder() const;
  ::autofill::AutofillRandomizedValue* release_placeholder();
  ::autofill::AutofillRandomizedValue* mutable_placeholder();
  void set_allocated_placeholder(::autofill::AutofillRandomizedValue* placeholder);

  // optional .autofill.AutofillRandomizedValue initial_value_hash = 9;
  bool has_initial_value_hash() const;
  void clear_initial_value_hash();
  const ::autofill::AutofillRandomizedValue& initial_value_hash() const;
  ::autofill::AutofillRandomizedValue* release_initial_value_hash();
  ::autofill::AutofillRandomizedValue* mutable_initial_value_hash();
  void set_allocated_initial_value_hash(::autofill::AutofillRandomizedValue* initial_value_hash);

  // @@protoc_insertion_point(class_scope:autofill.AutofillRandomizedFieldMetadata)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill::AutofillRandomizedValue* id_;
  ::autofill::AutofillRandomizedValue* name_;
  ::autofill::AutofillRandomizedValue* type_;
  ::autofill::AutofillRandomizedValue* label_;
  ::autofill::AutofillRandomizedValue* aria_label_;
  ::autofill::AutofillRandomizedValue* aria_description_;
  ::autofill::AutofillRandomizedValue* css_class_;
  ::autofill::AutofillRandomizedValue* placeholder_;
  ::autofill::AutofillRandomizedValue* initial_value_hash_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillUploadContents_Field_AutofillTypeValiditiesPair :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair) */ {
 public:
  AutofillUploadContents_Field_AutofillTypeValiditiesPair();
  virtual ~AutofillUploadContents_Field_AutofillTypeValiditiesPair();

  AutofillUploadContents_Field_AutofillTypeValiditiesPair(const AutofillUploadContents_Field_AutofillTypeValiditiesPair& from);
  AutofillUploadContents_Field_AutofillTypeValiditiesPair(AutofillUploadContents_Field_AutofillTypeValiditiesPair&& from) noexcept
    : AutofillUploadContents_Field_AutofillTypeValiditiesPair() {
    *this = ::std::move(from);
  }

  inline AutofillUploadContents_Field_AutofillTypeValiditiesPair& operator=(const AutofillUploadContents_Field_AutofillTypeValiditiesPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillUploadContents_Field_AutofillTypeValiditiesPair& operator=(AutofillUploadContents_Field_AutofillTypeValiditiesPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AutofillUploadContents_Field_AutofillTypeValiditiesPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutofillUploadContents_Field_AutofillTypeValiditiesPair* internal_default_instance() {
    return reinterpret_cast<const AutofillUploadContents_Field_AutofillTypeValiditiesPair*>(
               &_AutofillUploadContents_Field_AutofillTypeValiditiesPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AutofillUploadContents_Field_AutofillTypeValiditiesPair& a, AutofillUploadContents_Field_AutofillTypeValiditiesPair& b) {
    a.Swap(&b);
  }
  inline void Swap(AutofillUploadContents_Field_AutofillTypeValiditiesPair* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AutofillUploadContents_Field_AutofillTypeValiditiesPair* New() const final {
    return CreateMaybeMessage<AutofillUploadContents_Field_AutofillTypeValiditiesPair>(nullptr);
  }

  AutofillUploadContents_Field_AutofillTypeValiditiesPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AutofillUploadContents_Field_AutofillTypeValiditiesPair>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AutofillUploadContents_Field_AutofillTypeValiditiesPair& from);
  void MergeFrom(const AutofillUploadContents_Field_AutofillTypeValiditiesPair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillUploadContents_Field_AutofillTypeValiditiesPair* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidityFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated int32 validity = 2;
  int validity_size() const;
  void clear_validity();
  ::PROTOBUF_NAMESPACE_ID::int32 validity(int index) const;
  void set_validity(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_validity(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      validity() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_validity();

  // required int32 type = 1;
  bool has_type() const;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > validity_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillUploadContents_Field :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillUploadContents.Field) */ {
 public:
  AutofillUploadContents_Field();
  virtual ~AutofillUploadContents_Field();

  AutofillUploadContents_Field(const AutofillUploadContents_Field& from);
  AutofillUploadContents_Field(AutofillUploadContents_Field&& from) noexcept
    : AutofillUploadContents_Field() {
    *this = ::std::move(from);
  }

  inline AutofillUploadContents_Field& operator=(const AutofillUploadContents_Field& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillUploadContents_Field& operator=(AutofillUploadContents_Field&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AutofillUploadContents_Field& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutofillUploadContents_Field* internal_default_instance() {
    return reinterpret_cast<const AutofillUploadContents_Field*>(
               &_AutofillUploadContents_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AutofillUploadContents_Field& a, AutofillUploadContents_Field& b) {
    a.Swap(&b);
  }
  inline void Swap(AutofillUploadContents_Field* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AutofillUploadContents_Field* New() const final {
    return CreateMaybeMessage<AutofillUploadContents_Field>(nullptr);
  }

  AutofillUploadContents_Field* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AutofillUploadContents_Field>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AutofillUploadContents_Field& from);
  void MergeFrom(const AutofillUploadContents_Field& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillUploadContents_Field* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillUploadContents.Field";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AutofillUploadContents_Field_AutofillTypeValiditiesPair AutofillTypeValiditiesPair;

  typedef AutofillUploadContents_Field_PasswordGenerationType PasswordGenerationType;
  static constexpr PasswordGenerationType NO_GENERATION =
    AutofillUploadContents_Field_PasswordGenerationType_NO_GENERATION;
  static constexpr PasswordGenerationType AUTOMATICALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM =
    AutofillUploadContents_Field_PasswordGenerationType_AUTOMATICALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM;
  static constexpr PasswordGenerationType AUTOMATICALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM =
    AutofillUploadContents_Field_PasswordGenerationType_AUTOMATICALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM;
  static constexpr PasswordGenerationType MANUALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM =
    AutofillUploadContents_Field_PasswordGenerationType_MANUALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM;
  static constexpr PasswordGenerationType MANUALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM =
    AutofillUploadContents_Field_PasswordGenerationType_MANUALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM;
  static constexpr PasswordGenerationType IGNORED_GENERATION_POPUP =
    AutofillUploadContents_Field_PasswordGenerationType_IGNORED_GENERATION_POPUP;
  static inline bool PasswordGenerationType_IsValid(int value) {
    return AutofillUploadContents_Field_PasswordGenerationType_IsValid(value);
  }
  static constexpr PasswordGenerationType PasswordGenerationType_MIN =
    AutofillUploadContents_Field_PasswordGenerationType_PasswordGenerationType_MIN;
  static constexpr PasswordGenerationType PasswordGenerationType_MAX =
    AutofillUploadContents_Field_PasswordGenerationType_PasswordGenerationType_MAX;
  static constexpr int PasswordGenerationType_ARRAYSIZE =
    AutofillUploadContents_Field_PasswordGenerationType_PasswordGenerationType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PasswordGenerationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PasswordGenerationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PasswordGenerationType_Name.");
    return AutofillUploadContents_Field_PasswordGenerationType_Name(enum_t_value);
  }
  static inline bool PasswordGenerationType_Parse(const std::string& name,
      PasswordGenerationType* value) {
    return AutofillUploadContents_Field_PasswordGenerationType_Parse(name, value);
  }

  typedef AutofillUploadContents_Field_VoteType VoteType;
  static constexpr VoteType NO_INFORMATION =
    AutofillUploadContents_Field_VoteType_NO_INFORMATION;
  static constexpr VoteType CREDENTIALS_REUSED =
    AutofillUploadContents_Field_VoteType_CREDENTIALS_REUSED;
  static constexpr VoteType USERNAME_OVERWRITTEN =
    AutofillUploadContents_Field_VoteType_USERNAME_OVERWRITTEN;
  static constexpr VoteType USERNAME_EDITED =
    AutofillUploadContents_Field_VoteType_USERNAME_EDITED;
  static constexpr VoteType BASE_HEURISTIC =
    AutofillUploadContents_Field_VoteType_BASE_HEURISTIC;
  static constexpr VoteType HTML_CLASSIFIER =
    AutofillUploadContents_Field_VoteType_HTML_CLASSIFIER;
  static constexpr VoteType FIRST_USE =
    AutofillUploadContents_Field_VoteType_FIRST_USE;
  static inline bool VoteType_IsValid(int value) {
    return AutofillUploadContents_Field_VoteType_IsValid(value);
  }
  static constexpr VoteType VoteType_MIN =
    AutofillUploadContents_Field_VoteType_VoteType_MIN;
  static constexpr VoteType VoteType_MAX =
    AutofillUploadContents_Field_VoteType_VoteType_MAX;
  static constexpr int VoteType_ARRAYSIZE =
    AutofillUploadContents_Field_VoteType_VoteType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& VoteType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VoteType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VoteType_Name.");
    return AutofillUploadContents_Field_VoteType_Name(enum_t_value);
  }
  static inline bool VoteType_Parse(const std::string& name,
      VoteType* value) {
    return AutofillUploadContents_Field_VoteType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAutofillTypeFieldNumber = 7,
    kAutofillTypeValiditiesFieldNumber = 35,
    kNameFieldNumber = 8,
    kAutocompleteFieldNumber = 9,
    kTypeFieldNumber = 10,
    kCssClassesFieldNumber = 19,
    kIdFieldNumber = 21,
    kRandomizedFieldMetadataFieldNumber = 33,
    kSignatureFieldNumber = 6,
    kGenerationTypeFieldNumber = 17,
    kPropertiesMaskFieldNumber = 20,
    kGeneratedPasswordChangedFieldNumber = 22,
    kVoteTypeFieldNumber = 23,
    kInitialValueHashFieldNumber = 40,
  };
  // repeated fixed32 autofill_type = 7;
  int autofill_type_size() const;
  void clear_autofill_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 autofill_type(int index) const;
  void set_autofill_type(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_autofill_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      autofill_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_autofill_type();

  // repeated .autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair autofill_type_validities = 35;
  int autofill_type_validities_size() const;
  void clear_autofill_type_validities();
  ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair* mutable_autofill_type_validities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair >*
      mutable_autofill_type_validities();
  const ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair& autofill_type_validities(int index) const;
  ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair* add_autofill_type_validities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair >&
      autofill_type_validities() const;

  // optional string name = 8;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional string autocomplete = 9;
  bool has_autocomplete() const;
  void clear_autocomplete();
  const std::string& autocomplete() const;
  void set_autocomplete(const std::string& value);
  void set_autocomplete(std::string&& value);
  void set_autocomplete(const char* value);
  void set_autocomplete(const char* value, size_t size);
  std::string* mutable_autocomplete();
  std::string* release_autocomplete();
  void set_allocated_autocomplete(std::string* autocomplete);

  // optional string type = 10;
  bool has_type() const;
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);

  // optional string css_classes = 19;
  bool has_css_classes() const;
  void clear_css_classes();
  const std::string& css_classes() const;
  void set_css_classes(const std::string& value);
  void set_css_classes(std::string&& value);
  void set_css_classes(const char* value);
  void set_css_classes(const char* value, size_t size);
  std::string* mutable_css_classes();
  std::string* release_css_classes();
  void set_allocated_css_classes(std::string* css_classes);

  // optional string id = 21;
  bool has_id() const;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);

  // optional .autofill.AutofillRandomizedFieldMetadata randomized_field_metadata = 33;
  bool has_randomized_field_metadata() const;
  void clear_randomized_field_metadata();
  const ::autofill::AutofillRandomizedFieldMetadata& randomized_field_metadata() const;
  ::autofill::AutofillRandomizedFieldMetadata* release_randomized_field_metadata();
  ::autofill::AutofillRandomizedFieldMetadata* mutable_randomized_field_metadata();
  void set_allocated_randomized_field_metadata(::autofill::AutofillRandomizedFieldMetadata* randomized_field_metadata);

  // required fixed32 signature = 6;
  bool has_signature() const;
  void clear_signature();
  ::PROTOBUF_NAMESPACE_ID::uint32 signature() const;
  void set_signature(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional .autofill.AutofillUploadContents.Field.PasswordGenerationType generation_type = 17;
  bool has_generation_type() const;
  void clear_generation_type();
  ::autofill::AutofillUploadContents_Field_PasswordGenerationType generation_type() const;
  void set_generation_type(::autofill::AutofillUploadContents_Field_PasswordGenerationType value);

  // optional uint32 properties_mask = 20;
  bool has_properties_mask() const;
  void clear_properties_mask();
  ::PROTOBUF_NAMESPACE_ID::uint32 properties_mask() const;
  void set_properties_mask(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional bool generated_password_changed = 22;
  bool has_generated_password_changed() const;
  void clear_generated_password_changed();
  bool generated_password_changed() const;
  void set_generated_password_changed(bool value);

  // optional .autofill.AutofillUploadContents.Field.VoteType vote_type = 23;
  bool has_vote_type() const;
  void clear_vote_type();
  ::autofill::AutofillUploadContents_Field_VoteType vote_type() const;
  void set_vote_type(::autofill::AutofillUploadContents_Field_VoteType value);

  // optional uint32 initial_value_hash = 40;
  bool has_initial_value_hash() const;
  void clear_initial_value_hash();
  ::PROTOBUF_NAMESPACE_ID::uint32 initial_value_hash() const;
  void set_initial_value_hash(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:autofill.AutofillUploadContents.Field)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > autofill_type_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair > autofill_type_validities_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr autocomplete_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr css_classes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::autofill::AutofillRandomizedFieldMetadata* randomized_field_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 signature_;
  int generation_type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 properties_mask_;
  bool generated_password_changed_;
  int vote_type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 initial_value_hash_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillUploadContents_ButtonTitle :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillUploadContents.ButtonTitle) */ {
 public:
  AutofillUploadContents_ButtonTitle();
  virtual ~AutofillUploadContents_ButtonTitle();

  AutofillUploadContents_ButtonTitle(const AutofillUploadContents_ButtonTitle& from);
  AutofillUploadContents_ButtonTitle(AutofillUploadContents_ButtonTitle&& from) noexcept
    : AutofillUploadContents_ButtonTitle() {
    *this = ::std::move(from);
  }

  inline AutofillUploadContents_ButtonTitle& operator=(const AutofillUploadContents_ButtonTitle& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillUploadContents_ButtonTitle& operator=(AutofillUploadContents_ButtonTitle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AutofillUploadContents_ButtonTitle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutofillUploadContents_ButtonTitle* internal_default_instance() {
    return reinterpret_cast<const AutofillUploadContents_ButtonTitle*>(
               &_AutofillUploadContents_ButtonTitle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AutofillUploadContents_ButtonTitle& a, AutofillUploadContents_ButtonTitle& b) {
    a.Swap(&b);
  }
  inline void Swap(AutofillUploadContents_ButtonTitle* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AutofillUploadContents_ButtonTitle* New() const final {
    return CreateMaybeMessage<AutofillUploadContents_ButtonTitle>(nullptr);
  }

  AutofillUploadContents_ButtonTitle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AutofillUploadContents_ButtonTitle>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AutofillUploadContents_ButtonTitle& from);
  void MergeFrom(const AutofillUploadContents_ButtonTitle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillUploadContents_ButtonTitle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillUploadContents.ButtonTitle";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AutofillUploadContents_ButtonTitle_ButtonTitleType ButtonTitleType;
  static constexpr ButtonTitleType NONE =
    AutofillUploadContents_ButtonTitle_ButtonTitleType_NONE;
  static constexpr ButtonTitleType BUTTON_ELEMENT_SUBMIT_TYPE =
    AutofillUploadContents_ButtonTitle_ButtonTitleType_BUTTON_ELEMENT_SUBMIT_TYPE;
  static constexpr ButtonTitleType BUTTON_ELEMENT_BUTTON_TYPE =
    AutofillUploadContents_ButtonTitle_ButtonTitleType_BUTTON_ELEMENT_BUTTON_TYPE;
  static constexpr ButtonTitleType INPUT_ELEMENT_SUBMIT_TYPE =
    AutofillUploadContents_ButtonTitle_ButtonTitleType_INPUT_ELEMENT_SUBMIT_TYPE;
  static constexpr ButtonTitleType INPUT_ELEMENT_BUTTON_TYPE =
    AutofillUploadContents_ButtonTitle_ButtonTitleType_INPUT_ELEMENT_BUTTON_TYPE;
  static constexpr ButtonTitleType HYPERLINK =
    AutofillUploadContents_ButtonTitle_ButtonTitleType_HYPERLINK;
  static constexpr ButtonTitleType DIV =
    AutofillUploadContents_ButtonTitle_ButtonTitleType_DIV;
  static constexpr ButtonTitleType SPAN =
    AutofillUploadContents_ButtonTitle_ButtonTitleType_SPAN;
  static inline bool ButtonTitleType_IsValid(int value) {
    return AutofillUploadContents_ButtonTitle_ButtonTitleType_IsValid(value);
  }
  static constexpr ButtonTitleType ButtonTitleType_MIN =
    AutofillUploadContents_ButtonTitle_ButtonTitleType_ButtonTitleType_MIN;
  static constexpr ButtonTitleType ButtonTitleType_MAX =
    AutofillUploadContents_ButtonTitle_ButtonTitleType_ButtonTitleType_MAX;
  static constexpr int ButtonTitleType_ARRAYSIZE =
    AutofillUploadContents_ButtonTitle_ButtonTitleType_ButtonTitleType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ButtonTitleType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ButtonTitleType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ButtonTitleType_Name.");
    return AutofillUploadContents_ButtonTitle_ButtonTitleType_Name(enum_t_value);
  }
  static inline bool ButtonTitleType_Parse(const std::string& name,
      ButtonTitleType* value) {
    return AutofillUploadContents_ButtonTitle_ButtonTitleType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // optional string title = 1;
  bool has_title() const;
  void clear_title();
  const std::string& title() const;
  void set_title(const std::string& value);
  void set_title(std::string&& value);
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  std::string* mutable_title();
  std::string* release_title();
  void set_allocated_title(std::string* title);

  // optional .autofill.AutofillUploadContents.ButtonTitle.ButtonTitleType type = 2;
  bool has_type() const;
  void clear_type();
  ::autofill::AutofillUploadContents_ButtonTitle_ButtonTitleType type() const;
  void set_type(::autofill::AutofillUploadContents_ButtonTitle_ButtonTitleType value);

  // @@protoc_insertion_point(class_scope:autofill.AutofillUploadContents.ButtonTitle)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  int type_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillUploadContents :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillUploadContents) */ {
 public:
  AutofillUploadContents();
  virtual ~AutofillUploadContents();

  AutofillUploadContents(const AutofillUploadContents& from);
  AutofillUploadContents(AutofillUploadContents&& from) noexcept
    : AutofillUploadContents() {
    *this = ::std::move(from);
  }

  inline AutofillUploadContents& operator=(const AutofillUploadContents& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillUploadContents& operator=(AutofillUploadContents&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AutofillUploadContents& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutofillUploadContents* internal_default_instance() {
    return reinterpret_cast<const AutofillUploadContents*>(
               &_AutofillUploadContents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AutofillUploadContents& a, AutofillUploadContents& b) {
    a.Swap(&b);
  }
  inline void Swap(AutofillUploadContents* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AutofillUploadContents* New() const final {
    return CreateMaybeMessage<AutofillUploadContents>(nullptr);
  }

  AutofillUploadContents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AutofillUploadContents>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AutofillUploadContents& from);
  void MergeFrom(const AutofillUploadContents& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillUploadContents* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillUploadContents";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AutofillUploadContents_Field Field;
  typedef AutofillUploadContents_ButtonTitle ButtonTitle;

  typedef AutofillUploadContents_SubmissionIndicatorEvent SubmissionIndicatorEvent;
  static constexpr SubmissionIndicatorEvent NONE =
    AutofillUploadContents_SubmissionIndicatorEvent_NONE;
  static constexpr SubmissionIndicatorEvent HTML_FORM_SUBMISSION =
    AutofillUploadContents_SubmissionIndicatorEvent_HTML_FORM_SUBMISSION;
  static constexpr SubmissionIndicatorEvent SAME_DOCUMENT_NAVIGATION =
    AutofillUploadContents_SubmissionIndicatorEvent_SAME_DOCUMENT_NAVIGATION;
  static constexpr SubmissionIndicatorEvent XHR_SUCCEEDED =
    AutofillUploadContents_SubmissionIndicatorEvent_XHR_SUCCEEDED;
  static constexpr SubmissionIndicatorEvent FRAME_DETACHED =
    AutofillUploadContents_SubmissionIndicatorEvent_FRAME_DETACHED;
  static constexpr SubmissionIndicatorEvent DEPRECATED_MANUAL_SAVE =
    AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_MANUAL_SAVE;
  static constexpr SubmissionIndicatorEvent DOM_MUTATION_AFTER_XHR =
    AutofillUploadContents_SubmissionIndicatorEvent_DOM_MUTATION_AFTER_XHR;
  static constexpr SubmissionIndicatorEvent PROVISIONALLY_SAVED_FORM_ON_START_PROVISIONAL_LOAD =
    AutofillUploadContents_SubmissionIndicatorEvent_PROVISIONALLY_SAVED_FORM_ON_START_PROVISIONAL_LOAD;
  static constexpr SubmissionIndicatorEvent DEPRECATED_FILLED_FORM_ON_START_PROVISIONAL_LOAD =
    AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_FILLED_FORM_ON_START_PROVISIONAL_LOAD;
  static constexpr SubmissionIndicatorEvent DEPRECATED_FILLED_INPUT_ELEMENTS_ON_START_PROVISIONAL_LOAD =
    AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_FILLED_INPUT_ELEMENTS_ON_START_PROVISIONAL_LOAD;
  static constexpr SubmissionIndicatorEvent PROBABLE_FORM_SUBMISSION =
    AutofillUploadContents_SubmissionIndicatorEvent_PROBABLE_FORM_SUBMISSION;
  static inline bool SubmissionIndicatorEvent_IsValid(int value) {
    return AutofillUploadContents_SubmissionIndicatorEvent_IsValid(value);
  }
  static constexpr SubmissionIndicatorEvent SubmissionIndicatorEvent_MIN =
    AutofillUploadContents_SubmissionIndicatorEvent_SubmissionIndicatorEvent_MIN;
  static constexpr SubmissionIndicatorEvent SubmissionIndicatorEvent_MAX =
    AutofillUploadContents_SubmissionIndicatorEvent_SubmissionIndicatorEvent_MAX;
  static constexpr int SubmissionIndicatorEvent_ARRAYSIZE =
    AutofillUploadContents_SubmissionIndicatorEvent_SubmissionIndicatorEvent_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SubmissionIndicatorEvent_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SubmissionIndicatorEvent>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SubmissionIndicatorEvent_Name.");
    return AutofillUploadContents_SubmissionIndicatorEvent_Name(enum_t_value);
  }
  static inline bool SubmissionIndicatorEvent_Parse(const std::string& name,
      SubmissionIndicatorEvent* value) {
    return AutofillUploadContents_SubmissionIndicatorEvent_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 5,
    kButtonTitleFieldNumber = 36,
    kClientVersionFieldNumber = 1,
    kDataPresentFieldNumber = 4,
    kFormNameFieldNumber = 16,
    kLanguageFieldNumber = 31,
    kRandomizedFormMetadataFieldNumber = 32,
    kFormSignatureFieldNumber = 2,
    kActionSignatureFieldNumber = 13,
    kLoginFormSignatureFieldNumber = 14,
    kAutofillUsedFieldNumber = 3,
    kSubmissionFieldNumber = 15,
    kPasswordsRevealedFieldNumber = 24,
    kPasswordHasLowercaseLetterFieldNumber = 25,
    kPasswordLengthFieldNumber = 29,
    kPasswordHasUppercaseLetterFieldNumber = 26,
    kPasswordHasNumericFieldNumber = 27,
    kPasswordHasSpecialSymbolFieldNumber = 28,
    kHasFormTagFieldNumber = 37,
    kSubmissionEventFieldNumber = 30,
    kSecondaryFormSignatureFieldNumber = 34,
    kWasThrottleableFieldNumber = 38,
    kPasswordSpecialSymbolFieldNumber = 39,
  };
  // repeated group Field = 5 { ... };
  int field_size() const;
  void clear_field();
  ::autofill::AutofillUploadContents_Field* mutable_field(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_Field >*
      mutable_field();
  const ::autofill::AutofillUploadContents_Field& field(int index) const;
  ::autofill::AutofillUploadContents_Field* add_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_Field >&
      field() const;

  // repeated .autofill.AutofillUploadContents.ButtonTitle button_title = 36;
  int button_title_size() const;
  void clear_button_title();
  ::autofill::AutofillUploadContents_ButtonTitle* mutable_button_title(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_ButtonTitle >*
      mutable_button_title();
  const ::autofill::AutofillUploadContents_ButtonTitle& button_title(int index) const;
  ::autofill::AutofillUploadContents_ButtonTitle* add_button_title();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_ButtonTitle >&
      button_title() const;

  // required string client_version = 1;
  bool has_client_version() const;
  void clear_client_version();
  const std::string& client_version() const;
  void set_client_version(const std::string& value);
  void set_client_version(std::string&& value);
  void set_client_version(const char* value);
  void set_client_version(const char* value, size_t size);
  std::string* mutable_client_version();
  std::string* release_client_version();
  void set_allocated_client_version(std::string* client_version);

  // required string data_present = 4;
  bool has_data_present() const;
  void clear_data_present();
  const std::string& data_present() const;
  void set_data_present(const std::string& value);
  void set_data_present(std::string&& value);
  void set_data_present(const char* value);
  void set_data_present(const char* value, size_t size);
  std::string* mutable_data_present();
  std::string* release_data_present();
  void set_allocated_data_present(std::string* data_present);

  // optional string form_name = 16;
  bool has_form_name() const;
  void clear_form_name();
  const std::string& form_name() const;
  void set_form_name(const std::string& value);
  void set_form_name(std::string&& value);
  void set_form_name(const char* value);
  void set_form_name(const char* value, size_t size);
  std::string* mutable_form_name();
  std::string* release_form_name();
  void set_allocated_form_name(std::string* form_name);

  // optional string language = 31;
  bool has_language() const;
  void clear_language();
  const std::string& language() const;
  void set_language(const std::string& value);
  void set_language(std::string&& value);
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  std::string* mutable_language();
  std::string* release_language();
  void set_allocated_language(std::string* language);

  // optional .autofill.AutofillRandomizedFormMetadata randomized_form_metadata = 32;
  bool has_randomized_form_metadata() const;
  void clear_randomized_form_metadata();
  const ::autofill::AutofillRandomizedFormMetadata& randomized_form_metadata() const;
  ::autofill::AutofillRandomizedFormMetadata* release_randomized_form_metadata();
  ::autofill::AutofillRandomizedFormMetadata* mutable_randomized_form_metadata();
  void set_allocated_randomized_form_metadata(::autofill::AutofillRandomizedFormMetadata* randomized_form_metadata);

  // required fixed64 form_signature = 2;
  bool has_form_signature() const;
  void clear_form_signature();
  ::PROTOBUF_NAMESPACE_ID::uint64 form_signature() const;
  void set_form_signature(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional fixed64 action_signature = 13;
  bool has_action_signature() const;
  void clear_action_signature();
  ::PROTOBUF_NAMESPACE_ID::uint64 action_signature() const;
  void set_action_signature(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional fixed64 login_form_signature = 14;
  bool has_login_form_signature() const;
  void clear_login_form_signature();
  ::PROTOBUF_NAMESPACE_ID::uint64 login_form_signature() const;
  void set_login_form_signature(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required bool autofill_used = 3;
  bool has_autofill_used() const;
  void clear_autofill_used();
  bool autofill_used() const;
  void set_autofill_used(bool value);

  // optional bool submission = 15;
  bool has_submission() const;
  void clear_submission();
  bool submission() const;
  void set_submission(bool value);

  // optional bool passwords_revealed = 24;
  bool has_passwords_revealed() const;
  void clear_passwords_revealed();
  bool passwords_revealed() const;
  void set_passwords_revealed(bool value);

  // optional bool password_has_lowercase_letter = 25;
  bool has_password_has_lowercase_letter() const;
  void clear_password_has_lowercase_letter();
  bool password_has_lowercase_letter() const;
  void set_password_has_lowercase_letter(bool value);

  // optional uint32 password_length = 29;
  bool has_password_length() const;
  void clear_password_length();
  ::PROTOBUF_NAMESPACE_ID::uint32 password_length() const;
  void set_password_length(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional bool password_has_uppercase_letter = 26 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_password_has_uppercase_letter() const;
  PROTOBUF_DEPRECATED void clear_password_has_uppercase_letter();
  PROTOBUF_DEPRECATED bool password_has_uppercase_letter() const;
  PROTOBUF_DEPRECATED void set_password_has_uppercase_letter(bool value);

  // optional bool password_has_numeric = 27 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_password_has_numeric() const;
  PROTOBUF_DEPRECATED void clear_password_has_numeric();
  PROTOBUF_DEPRECATED bool password_has_numeric() const;
  PROTOBUF_DEPRECATED void set_password_has_numeric(bool value);

  // optional bool password_has_special_symbol = 28;
  bool has_password_has_special_symbol() const;
  void clear_password_has_special_symbol();
  bool password_has_special_symbol() const;
  void set_password_has_special_symbol(bool value);

  // optional bool has_form_tag = 37;
  bool has_has_form_tag() const;
  void clear_has_form_tag();
  bool has_form_tag() const;
  void set_has_form_tag(bool value);

  // optional .autofill.AutofillUploadContents.SubmissionIndicatorEvent submission_event = 30;
  bool has_submission_event() const;
  void clear_submission_event();
  ::autofill::AutofillUploadContents_SubmissionIndicatorEvent submission_event() const;
  void set_submission_event(::autofill::AutofillUploadContents_SubmissionIndicatorEvent value);

  // optional fixed64 secondary_form_signature = 34;
  bool has_secondary_form_signature() const;
  void clear_secondary_form_signature();
  ::PROTOBUF_NAMESPACE_ID::uint64 secondary_form_signature() const;
  void set_secondary_form_signature(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional bool was_throttleable = 38;
  bool has_was_throttleable() const;
  void clear_was_throttleable();
  bool was_throttleable() const;
  void set_was_throttleable(bool value);

  // optional uint32 password_special_symbol = 39;
  bool has_password_special_symbol() const;
  void clear_password_special_symbol();
  ::PROTOBUF_NAMESPACE_ID::uint32 password_special_symbol() const;
  void set_password_special_symbol(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:autofill.AutofillUploadContents)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_Field > field_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_ButtonTitle > button_title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_present_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr form_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  ::autofill::AutofillRandomizedFormMetadata* randomized_form_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 form_signature_;
  ::PROTOBUF_NAMESPACE_ID::uint64 action_signature_;
  ::PROTOBUF_NAMESPACE_ID::uint64 login_form_signature_;
  bool autofill_used_;
  bool submission_;
  bool passwords_revealed_;
  bool password_has_lowercase_letter_;
  ::PROTOBUF_NAMESPACE_ID::uint32 password_length_;
  bool password_has_uppercase_letter_;
  bool password_has_numeric_;
  bool password_has_special_symbol_;
  bool has_form_tag_;
  int submission_event_;
  ::PROTOBUF_NAMESPACE_ID::uint64 secondary_form_signature_;
  bool was_throttleable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 password_special_symbol_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class ProfileValidityMap_FieldValidityStatesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<ProfileValidityMap_FieldValidityStatesEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<ProfileValidityMap_FieldValidityStatesEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    0 > SuperType;
  ProfileValidityMap_FieldValidityStatesEntry_DoNotUse();
  ProfileValidityMap_FieldValidityStatesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProfileValidityMap_FieldValidityStatesEntry_DoNotUse& other);
  static const ProfileValidityMap_FieldValidityStatesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProfileValidityMap_FieldValidityStatesEntry_DoNotUse*>(&_ProfileValidityMap_FieldValidityStatesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class ProfileValidityMap :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.ProfileValidityMap) */ {
 public:
  ProfileValidityMap();
  virtual ~ProfileValidityMap();

  ProfileValidityMap(const ProfileValidityMap& from);
  ProfileValidityMap(ProfileValidityMap&& from) noexcept
    : ProfileValidityMap() {
    *this = ::std::move(from);
  }

  inline ProfileValidityMap& operator=(const ProfileValidityMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProfileValidityMap& operator=(ProfileValidityMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ProfileValidityMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProfileValidityMap* internal_default_instance() {
    return reinterpret_cast<const ProfileValidityMap*>(
               &_ProfileValidityMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ProfileValidityMap& a, ProfileValidityMap& b) {
    a.Swap(&b);
  }
  inline void Swap(ProfileValidityMap* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProfileValidityMap* New() const final {
    return CreateMaybeMessage<ProfileValidityMap>(nullptr);
  }

  ProfileValidityMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProfileValidityMap>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ProfileValidityMap& from);
  void MergeFrom(const ProfileValidityMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProfileValidityMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.ProfileValidityMap";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFieldValidityStatesFieldNumber = 1,
  };
  // map<int32, int32> field_validity_states = 1;
  int field_validity_states_size() const;
  void clear_field_validity_states();
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32 >&
      field_validity_states() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_field_validity_states();

  // @@protoc_insertion_point(class_scope:autofill.ProfileValidityMap)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      ProfileValidityMap_FieldValidityStatesEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      0 > field_validity_states_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class UserProfileValidityMap_ProfileValidityEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<UserProfileValidityMap_ProfileValidityEntry_DoNotUse, 
    std::string, ::autofill::ProfileValidityMap,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<UserProfileValidityMap_ProfileValidityEntry_DoNotUse, 
    std::string, ::autofill::ProfileValidityMap,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  UserProfileValidityMap_ProfileValidityEntry_DoNotUse();
  UserProfileValidityMap_ProfileValidityEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const UserProfileValidityMap_ProfileValidityEntry_DoNotUse& other);
  static const UserProfileValidityMap_ProfileValidityEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const UserProfileValidityMap_ProfileValidityEntry_DoNotUse*>(&_UserProfileValidityMap_ProfileValidityEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class UserProfileValidityMap :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.UserProfileValidityMap) */ {
 public:
  UserProfileValidityMap();
  virtual ~UserProfileValidityMap();

  UserProfileValidityMap(const UserProfileValidityMap& from);
  UserProfileValidityMap(UserProfileValidityMap&& from) noexcept
    : UserProfileValidityMap() {
    *this = ::std::move(from);
  }

  inline UserProfileValidityMap& operator=(const UserProfileValidityMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserProfileValidityMap& operator=(UserProfileValidityMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const UserProfileValidityMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserProfileValidityMap* internal_default_instance() {
    return reinterpret_cast<const UserProfileValidityMap*>(
               &_UserProfileValidityMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UserProfileValidityMap& a, UserProfileValidityMap& b) {
    a.Swap(&b);
  }
  inline void Swap(UserProfileValidityMap* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserProfileValidityMap* New() const final {
    return CreateMaybeMessage<UserProfileValidityMap>(nullptr);
  }

  UserProfileValidityMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserProfileValidityMap>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const UserProfileValidityMap& from);
  void MergeFrom(const UserProfileValidityMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserProfileValidityMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.UserProfileValidityMap";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kProfileValidityFieldNumber = 1,
  };
  // map<string, .autofill.ProfileValidityMap> profile_validity = 1;
  int profile_validity_size() const;
  void clear_profile_validity();
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::autofill::ProfileValidityMap >&
      profile_validity() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::autofill::ProfileValidityMap >*
      mutable_profile_validity();

  // @@protoc_insertion_point(class_scope:autofill.UserProfileValidityMap)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      UserProfileValidityMap_ProfileValidityEntry_DoNotUse,
      std::string, ::autofill::ProfileValidityMap,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > profile_validity_;
  friend struct ::TableStruct_server_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AutofillQueryContents_Form_Field

// required fixed32 signature = 5;
inline bool AutofillQueryContents_Form_Field::has_signature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AutofillQueryContents_Form_Field::clear_signature() {
  signature_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AutofillQueryContents_Form_Field::signature() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryContents.Form.Field.signature)
  return signature_;
}
inline void AutofillQueryContents_Form_Field::set_signature(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  signature_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillQueryContents.Form.Field.signature)
}

// optional string name = 8;
inline bool AutofillQueryContents_Form_Field::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutofillQueryContents_Form_Field::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillQueryContents_Form_Field::name() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryContents.Form.Field.name)
  return name_.GetNoArena();
}
inline void AutofillQueryContents_Form_Field::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.AutofillQueryContents.Form.Field.name)
}
inline void AutofillQueryContents_Form_Field::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.AutofillQueryContents.Form.Field.name)
}
inline void AutofillQueryContents_Form_Field::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.AutofillQueryContents.Form.Field.name)
}
inline void AutofillQueryContents_Form_Field::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.AutofillQueryContents.Form.Field.name)
}
inline std::string* AutofillQueryContents_Form_Field::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:autofill.AutofillQueryContents.Form.Field.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AutofillQueryContents_Form_Field::release_name() {
  // @@protoc_insertion_point(field_release:autofill.AutofillQueryContents.Form.Field.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AutofillQueryContents_Form_Field::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillQueryContents.Form.Field.name)
}

// optional string type = 9;
inline bool AutofillQueryContents_Form_Field::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AutofillQueryContents_Form_Field::clear_type() {
  type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AutofillQueryContents_Form_Field::type() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryContents.Form.Field.type)
  return type_.GetNoArena();
}
inline void AutofillQueryContents_Form_Field::set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.AutofillQueryContents.Form.Field.type)
}
inline void AutofillQueryContents_Form_Field::set_type(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.AutofillQueryContents.Form.Field.type)
}
inline void AutofillQueryContents_Form_Field::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.AutofillQueryContents.Form.Field.type)
}
inline void AutofillQueryContents_Form_Field::set_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.AutofillQueryContents.Form.Field.type)
}
inline std::string* AutofillQueryContents_Form_Field::mutable_type() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:autofill.AutofillQueryContents.Form.Field.type)
  return type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AutofillQueryContents_Form_Field::release_type() {
  // @@protoc_insertion_point(field_release:autofill.AutofillQueryContents.Form.Field.type)
  if (!has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AutofillQueryContents_Form_Field::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillQueryContents.Form.Field.type)
}

// optional .autofill.AutofillRandomizedFieldMetadata field_metadata = 13;
inline bool AutofillQueryContents_Form_Field::has_field_metadata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AutofillQueryContents_Form_Field::clear_field_metadata() {
  if (field_metadata_ != nullptr) field_metadata_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill::AutofillRandomizedFieldMetadata& AutofillQueryContents_Form_Field::field_metadata() const {
  const ::autofill::AutofillRandomizedFieldMetadata* p = field_metadata_;
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryContents.Form.Field.field_metadata)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::AutofillRandomizedFieldMetadata*>(
      &::autofill::_AutofillRandomizedFieldMetadata_default_instance_);
}
inline ::autofill::AutofillRandomizedFieldMetadata* AutofillQueryContents_Form_Field::release_field_metadata() {
  // @@protoc_insertion_point(field_release:autofill.AutofillQueryContents.Form.Field.field_metadata)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill::AutofillRandomizedFieldMetadata* temp = field_metadata_;
  field_metadata_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedFieldMetadata* AutofillQueryContents_Form_Field::mutable_field_metadata() {
  _has_bits_[0] |= 0x00000004u;
  if (field_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedFieldMetadata>(GetArenaNoVirtual());
    field_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.AutofillQueryContents.Form.Field.field_metadata)
  return field_metadata_;
}
inline void AutofillQueryContents_Form_Field::set_allocated_field_metadata(::autofill::AutofillRandomizedFieldMetadata* field_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete field_metadata_;
  }
  if (field_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      field_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, field_metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  field_metadata_ = field_metadata;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillQueryContents.Form.Field.field_metadata)
}

// -------------------------------------------------------------------

// AutofillQueryContents_Form

// required fixed64 signature = 3;
inline bool AutofillQueryContents_Form::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AutofillQueryContents_Form::clear_signature() {
  signature_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AutofillQueryContents_Form::signature() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryContents.Form.signature)
  return signature_;
}
inline void AutofillQueryContents_Form::set_signature(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  signature_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillQueryContents.Form.signature)
}

// optional .autofill.AutofillRandomizedFormMetadata form_metadata = 12;
inline bool AutofillQueryContents_Form::has_form_metadata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutofillQueryContents_Form::clear_form_metadata() {
  if (form_metadata_ != nullptr) form_metadata_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill::AutofillRandomizedFormMetadata& AutofillQueryContents_Form::form_metadata() const {
  const ::autofill::AutofillRandomizedFormMetadata* p = form_metadata_;
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryContents.Form.form_metadata)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::AutofillRandomizedFormMetadata*>(
      &::autofill::_AutofillRandomizedFormMetadata_default_instance_);
}
inline ::autofill::AutofillRandomizedFormMetadata* AutofillQueryContents_Form::release_form_metadata() {
  // @@protoc_insertion_point(field_release:autofill.AutofillQueryContents.Form.form_metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::AutofillRandomizedFormMetadata* temp = form_metadata_;
  form_metadata_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedFormMetadata* AutofillQueryContents_Form::mutable_form_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (form_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedFormMetadata>(GetArenaNoVirtual());
    form_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.AutofillQueryContents.Form.form_metadata)
  return form_metadata_;
}
inline void AutofillQueryContents_Form::set_allocated_form_metadata(::autofill::AutofillRandomizedFormMetadata* form_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete form_metadata_;
  }
  if (form_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      form_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, form_metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  form_metadata_ = form_metadata;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillQueryContents.Form.form_metadata)
}

// repeated group Field = 4 { ... };
inline int AutofillQueryContents_Form::field_size() const {
  return field_.size();
}
inline void AutofillQueryContents_Form::clear_field() {
  field_.Clear();
}
inline ::autofill::AutofillQueryContents_Form_Field* AutofillQueryContents_Form::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.AutofillQueryContents.Form.field)
  return field_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryContents_Form_Field >*
AutofillQueryContents_Form::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:autofill.AutofillQueryContents.Form.field)
  return &field_;
}
inline const ::autofill::AutofillQueryContents_Form_Field& AutofillQueryContents_Form::field(int index) const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryContents.Form.field)
  return field_.Get(index);
}
inline ::autofill::AutofillQueryContents_Form_Field* AutofillQueryContents_Form::add_field() {
  // @@protoc_insertion_point(field_add:autofill.AutofillQueryContents.Form.field)
  return field_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryContents_Form_Field >&
AutofillQueryContents_Form::field() const {
  // @@protoc_insertion_point(field_list:autofill.AutofillQueryContents.Form.field)
  return field_;
}

// -------------------------------------------------------------------

// AutofillQueryContents

// required string client_version = 1;
inline bool AutofillQueryContents::has_client_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutofillQueryContents::clear_client_version() {
  client_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillQueryContents::client_version() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryContents.client_version)
  return client_version_.GetNoArena();
}
inline void AutofillQueryContents::set_client_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.AutofillQueryContents.client_version)
}
inline void AutofillQueryContents::set_client_version(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  client_version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.AutofillQueryContents.client_version)
}
inline void AutofillQueryContents::set_client_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  client_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.AutofillQueryContents.client_version)
}
inline void AutofillQueryContents::set_client_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  client_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.AutofillQueryContents.client_version)
}
inline std::string* AutofillQueryContents::mutable_client_version() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:autofill.AutofillQueryContents.client_version)
  return client_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AutofillQueryContents::release_client_version() {
  // @@protoc_insertion_point(field_release:autofill.AutofillQueryContents.client_version)
  if (!has_client_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return client_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AutofillQueryContents::set_allocated_client_version(std::string* client_version) {
  if (client_version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_version);
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillQueryContents.client_version)
}

// repeated group Form = 2 { ... };
inline int AutofillQueryContents::form_size() const {
  return form_.size();
}
inline void AutofillQueryContents::clear_form() {
  form_.Clear();
}
inline ::autofill::AutofillQueryContents_Form* AutofillQueryContents::mutable_form(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.AutofillQueryContents.form)
  return form_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryContents_Form >*
AutofillQueryContents::mutable_form() {
  // @@protoc_insertion_point(field_mutable_list:autofill.AutofillQueryContents.form)
  return &form_;
}
inline const ::autofill::AutofillQueryContents_Form& AutofillQueryContents::form(int index) const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryContents.form)
  return form_.Get(index);
}
inline ::autofill::AutofillQueryContents_Form* AutofillQueryContents::add_form() {
  // @@protoc_insertion_point(field_add:autofill.AutofillQueryContents.form)
  return form_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryContents_Form >&
AutofillQueryContents::form() const {
  // @@protoc_insertion_point(field_list:autofill.AutofillQueryContents.form)
  return form_;
}

// repeated int64 experiments = 14;
inline int AutofillQueryContents::experiments_size() const {
  return experiments_.size();
}
inline void AutofillQueryContents::clear_experiments() {
  experiments_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AutofillQueryContents::experiments(int index) const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryContents.experiments)
  return experiments_.Get(index);
}
inline void AutofillQueryContents::set_experiments(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  experiments_.Set(index, value);
  // @@protoc_insertion_point(field_set:autofill.AutofillQueryContents.experiments)
}
inline void AutofillQueryContents::add_experiments(::PROTOBUF_NAMESPACE_ID::int64 value) {
  experiments_.Add(value);
  // @@protoc_insertion_point(field_add:autofill.AutofillQueryContents.experiments)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
AutofillQueryContents::experiments() const {
  // @@protoc_insertion_point(field_list:autofill.AutofillQueryContents.experiments)
  return experiments_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
AutofillQueryContents::mutable_experiments() {
  // @@protoc_insertion_point(field_mutable_list:autofill.AutofillQueryContents.experiments)
  return &experiments_;
}

// -------------------------------------------------------------------

// AutofillQueryResponseContents_Field_FieldPrediction

// optional fixed32 type = 1;
inline bool AutofillQueryResponseContents_Field_FieldPrediction::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutofillQueryResponseContents_Field_FieldPrediction::clear_type() {
  type_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AutofillQueryResponseContents_Field_FieldPrediction::type() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryResponseContents.Field.FieldPrediction.type)
  return type_;
}
inline void AutofillQueryResponseContents_Field_FieldPrediction::set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillQueryResponseContents.Field.FieldPrediction.type)
}

// optional bool may_use_prefilled_placeholder = 2;
inline bool AutofillQueryResponseContents_Field_FieldPrediction::has_may_use_prefilled_placeholder() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AutofillQueryResponseContents_Field_FieldPrediction::clear_may_use_prefilled_placeholder() {
  may_use_prefilled_placeholder_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool AutofillQueryResponseContents_Field_FieldPrediction::may_use_prefilled_placeholder() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryResponseContents.Field.FieldPrediction.may_use_prefilled_placeholder)
  return may_use_prefilled_placeholder_;
}
inline void AutofillQueryResponseContents_Field_FieldPrediction::set_may_use_prefilled_placeholder(bool value) {
  _has_bits_[0] |= 0x00000002u;
  may_use_prefilled_placeholder_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillQueryResponseContents.Field.FieldPrediction.may_use_prefilled_placeholder)
}

// -------------------------------------------------------------------

// AutofillQueryResponseContents_Field

// required fixed32 overall_type_prediction = 3;
inline bool AutofillQueryResponseContents_Field::has_overall_type_prediction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AutofillQueryResponseContents_Field::clear_overall_type_prediction() {
  overall_type_prediction_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AutofillQueryResponseContents_Field::overall_type_prediction() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryResponseContents.Field.overall_type_prediction)
  return overall_type_prediction_;
}
inline void AutofillQueryResponseContents_Field::set_overall_type_prediction(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  overall_type_prediction_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillQueryResponseContents.Field.overall_type_prediction)
}

// repeated .autofill.AutofillQueryResponseContents.Field.FieldPrediction predictions = 7;
inline int AutofillQueryResponseContents_Field::predictions_size() const {
  return predictions_.size();
}
inline void AutofillQueryResponseContents_Field::clear_predictions() {
  predictions_.Clear();
}
inline ::autofill::AutofillQueryResponseContents_Field_FieldPrediction* AutofillQueryResponseContents_Field::mutable_predictions(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.AutofillQueryResponseContents.Field.predictions)
  return predictions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryResponseContents_Field_FieldPrediction >*
AutofillQueryResponseContents_Field::mutable_predictions() {
  // @@protoc_insertion_point(field_mutable_list:autofill.AutofillQueryResponseContents.Field.predictions)
  return &predictions_;
}
inline const ::autofill::AutofillQueryResponseContents_Field_FieldPrediction& AutofillQueryResponseContents_Field::predictions(int index) const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryResponseContents.Field.predictions)
  return predictions_.Get(index);
}
inline ::autofill::AutofillQueryResponseContents_Field_FieldPrediction* AutofillQueryResponseContents_Field::add_predictions() {
  // @@protoc_insertion_point(field_add:autofill.AutofillQueryResponseContents.Field.predictions)
  return predictions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryResponseContents_Field_FieldPrediction >&
AutofillQueryResponseContents_Field::predictions() const {
  // @@protoc_insertion_point(field_list:autofill.AutofillQueryResponseContents.Field.predictions)
  return predictions_;
}

// optional .autofill.PasswordRequirementsSpec password_requirements = 9;
inline bool AutofillQueryResponseContents_Field::has_password_requirements() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::autofill::PasswordRequirementsSpec& AutofillQueryResponseContents_Field::password_requirements() const {
  const ::autofill::PasswordRequirementsSpec* p = password_requirements_;
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryResponseContents.Field.password_requirements)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::PasswordRequirementsSpec*>(
      &::autofill::_PasswordRequirementsSpec_default_instance_);
}
inline ::autofill::PasswordRequirementsSpec* AutofillQueryResponseContents_Field::release_password_requirements() {
  // @@protoc_insertion_point(field_release:autofill.AutofillQueryResponseContents.Field.password_requirements)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::PasswordRequirementsSpec* temp = password_requirements_;
  password_requirements_ = nullptr;
  return temp;
}
inline ::autofill::PasswordRequirementsSpec* AutofillQueryResponseContents_Field::mutable_password_requirements() {
  _has_bits_[0] |= 0x00000001u;
  if (password_requirements_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::PasswordRequirementsSpec>(GetArenaNoVirtual());
    password_requirements_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.AutofillQueryResponseContents.Field.password_requirements)
  return password_requirements_;
}
inline void AutofillQueryResponseContents_Field::set_allocated_password_requirements(::autofill::PasswordRequirementsSpec* password_requirements) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(password_requirements_);
  }
  if (password_requirements) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      password_requirements = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, password_requirements, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  password_requirements_ = password_requirements;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillQueryResponseContents.Field.password_requirements)
}

// -------------------------------------------------------------------

// AutofillQueryResponseContents

// optional bool upload_required = 1 [deprecated = true];
inline bool AutofillQueryResponseContents::has_upload_required() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutofillQueryResponseContents::clear_upload_required() {
  upload_required_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool AutofillQueryResponseContents::upload_required() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryResponseContents.upload_required)
  return upload_required_;
}
inline void AutofillQueryResponseContents::set_upload_required(bool value) {
  _has_bits_[0] |= 0x00000001u;
  upload_required_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillQueryResponseContents.upload_required)
}

// repeated group Field = 2 { ... };
inline int AutofillQueryResponseContents::field_size() const {
  return field_.size();
}
inline void AutofillQueryResponseContents::clear_field() {
  field_.Clear();
}
inline ::autofill::AutofillQueryResponseContents_Field* AutofillQueryResponseContents::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.AutofillQueryResponseContents.field)
  return field_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryResponseContents_Field >*
AutofillQueryResponseContents::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:autofill.AutofillQueryResponseContents.field)
  return &field_;
}
inline const ::autofill::AutofillQueryResponseContents_Field& AutofillQueryResponseContents::field(int index) const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryResponseContents.field)
  return field_.Get(index);
}
inline ::autofill::AutofillQueryResponseContents_Field* AutofillQueryResponseContents::add_field() {
  // @@protoc_insertion_point(field_add:autofill.AutofillQueryResponseContents.field)
  return field_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryResponseContents_Field >&
AutofillQueryResponseContents::field() const {
  // @@protoc_insertion_point(field_list:autofill.AutofillQueryResponseContents.field)
  return field_;
}

// -------------------------------------------------------------------

// AutofillRandomizedValue

// optional .autofill.AutofillRandomizedValue.EncodingType encoding_type = 1 [default = UNSPECIFIED_ENCODING_TYPE];
inline bool AutofillRandomizedValue::has_encoding_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AutofillRandomizedValue::clear_encoding_type() {
  encoding_type_ = -1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::autofill::AutofillRandomizedValue_EncodingType AutofillRandomizedValue::encoding_type() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedValue.encoding_type)
  return static_cast< ::autofill::AutofillRandomizedValue_EncodingType >(encoding_type_);
}
inline void AutofillRandomizedValue::set_encoding_type(::autofill::AutofillRandomizedValue_EncodingType value) {
  assert(::autofill::AutofillRandomizedValue_EncodingType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  encoding_type_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillRandomizedValue.encoding_type)
}

// optional bytes encoded_bits = 2;
inline bool AutofillRandomizedValue::has_encoded_bits() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutofillRandomizedValue::clear_encoded_bits() {
  encoded_bits_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillRandomizedValue::encoded_bits() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedValue.encoded_bits)
  return encoded_bits_.GetNoArena();
}
inline void AutofillRandomizedValue::set_encoded_bits(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  encoded_bits_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.AutofillRandomizedValue.encoded_bits)
}
inline void AutofillRandomizedValue::set_encoded_bits(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  encoded_bits_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.AutofillRandomizedValue.encoded_bits)
}
inline void AutofillRandomizedValue::set_encoded_bits(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  encoded_bits_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.AutofillRandomizedValue.encoded_bits)
}
inline void AutofillRandomizedValue::set_encoded_bits(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  encoded_bits_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.AutofillRandomizedValue.encoded_bits)
}
inline std::string* AutofillRandomizedValue::mutable_encoded_bits() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedValue.encoded_bits)
  return encoded_bits_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AutofillRandomizedValue::release_encoded_bits() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedValue.encoded_bits)
  if (!has_encoded_bits()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return encoded_bits_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AutofillRandomizedValue::set_allocated_encoded_bits(std::string* encoded_bits) {
  if (encoded_bits != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  encoded_bits_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encoded_bits);
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedValue.encoded_bits)
}

// -------------------------------------------------------------------

// AutofillRandomizedFormMetadata

// optional .autofill.AutofillRandomizedValue id = 1;
inline bool AutofillRandomizedFormMetadata::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutofillRandomizedFormMetadata::clear_id() {
  if (id_ != nullptr) id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::id() const {
  const ::autofill::AutofillRandomizedValue* p = id_;
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFormMetadata.id)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::AutofillRandomizedValue*>(
      &::autofill::_AutofillRandomizedValue_default_instance_);
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::release_id() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFormMetadata.id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::AutofillRandomizedValue* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFormMetadata.id)
  return id_;
}
inline void AutofillRandomizedFormMetadata::set_allocated_id(::autofill::AutofillRandomizedValue* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFormMetadata.id)
}

// optional .autofill.AutofillRandomizedValue name = 2;
inline bool AutofillRandomizedFormMetadata::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AutofillRandomizedFormMetadata::clear_name() {
  if (name_ != nullptr) name_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::name() const {
  const ::autofill::AutofillRandomizedValue* p = name_;
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFormMetadata.name)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::AutofillRandomizedValue*>(
      &::autofill::_AutofillRandomizedValue_default_instance_);
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::release_name() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFormMetadata.name)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill::AutofillRandomizedValue* temp = name_;
  name_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  if (name_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaNoVirtual());
    name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFormMetadata.name)
  return name_;
}
inline void AutofillRandomizedFormMetadata::set_allocated_name(::autofill::AutofillRandomizedValue* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete name_;
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFormMetadata.name)
}

// optional .autofill.AutofillRandomizedValue action = 3;
inline bool AutofillRandomizedFormMetadata::has_action() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AutofillRandomizedFormMetadata::clear_action() {
  if (action_ != nullptr) action_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::action() const {
  const ::autofill::AutofillRandomizedValue* p = action_;
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFormMetadata.action)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::AutofillRandomizedValue*>(
      &::autofill::_AutofillRandomizedValue_default_instance_);
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::release_action() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFormMetadata.action)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill::AutofillRandomizedValue* temp = action_;
  action_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::mutable_action() {
  _has_bits_[0] |= 0x00000004u;
  if (action_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaNoVirtual());
    action_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFormMetadata.action)
  return action_;
}
inline void AutofillRandomizedFormMetadata::set_allocated_action(::autofill::AutofillRandomizedValue* action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete action_;
  }
  if (action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  action_ = action;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFormMetadata.action)
}

// -------------------------------------------------------------------

// AutofillRandomizedFieldMetadata

// optional .autofill.AutofillRandomizedValue id = 1;
inline bool AutofillRandomizedFieldMetadata::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutofillRandomizedFieldMetadata::clear_id() {
  if (id_ != nullptr) id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::id() const {
  const ::autofill::AutofillRandomizedValue* p = id_;
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.id)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::AutofillRandomizedValue*>(
      &::autofill::_AutofillRandomizedValue_default_instance_);
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_id() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::AutofillRandomizedValue* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.id)
  return id_;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_id(::autofill::AutofillRandomizedValue* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.id)
}

// optional .autofill.AutofillRandomizedValue name = 2;
inline bool AutofillRandomizedFieldMetadata::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AutofillRandomizedFieldMetadata::clear_name() {
  if (name_ != nullptr) name_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::name() const {
  const ::autofill::AutofillRandomizedValue* p = name_;
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.name)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::AutofillRandomizedValue*>(
      &::autofill::_AutofillRandomizedValue_default_instance_);
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_name() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.name)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill::AutofillRandomizedValue* temp = name_;
  name_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  if (name_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaNoVirtual());
    name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.name)
  return name_;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_name(::autofill::AutofillRandomizedValue* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete name_;
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.name)
}

// optional .autofill.AutofillRandomizedValue type = 3;
inline bool AutofillRandomizedFieldMetadata::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AutofillRandomizedFieldMetadata::clear_type() {
  if (type_ != nullptr) type_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::type() const {
  const ::autofill::AutofillRandomizedValue* p = type_;
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.type)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::AutofillRandomizedValue*>(
      &::autofill::_AutofillRandomizedValue_default_instance_);
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_type() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.type)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill::AutofillRandomizedValue* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_type() {
  _has_bits_[0] |= 0x00000004u;
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.type)
  return type_;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_type(::autofill::AutofillRandomizedValue* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete type_;
  }
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.type)
}

// optional .autofill.AutofillRandomizedValue label = 4;
inline bool AutofillRandomizedFieldMetadata::has_label() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AutofillRandomizedFieldMetadata::clear_label() {
  if (label_ != nullptr) label_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::label() const {
  const ::autofill::AutofillRandomizedValue* p = label_;
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.label)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::AutofillRandomizedValue*>(
      &::autofill::_AutofillRandomizedValue_default_instance_);
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_label() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.label)
  _has_bits_[0] &= ~0x00000008u;
  ::autofill::AutofillRandomizedValue* temp = label_;
  label_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_label() {
  _has_bits_[0] |= 0x00000008u;
  if (label_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaNoVirtual());
    label_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.label)
  return label_;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_label(::autofill::AutofillRandomizedValue* label) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete label_;
  }
  if (label) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      label = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, label, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  label_ = label;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.label)
}

// optional .autofill.AutofillRandomizedValue aria_label = 5;
inline bool AutofillRandomizedFieldMetadata::has_aria_label() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AutofillRandomizedFieldMetadata::clear_aria_label() {
  if (aria_label_ != nullptr) aria_label_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::aria_label() const {
  const ::autofill::AutofillRandomizedValue* p = aria_label_;
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.aria_label)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::AutofillRandomizedValue*>(
      &::autofill::_AutofillRandomizedValue_default_instance_);
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_aria_label() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.aria_label)
  _has_bits_[0] &= ~0x00000010u;
  ::autofill::AutofillRandomizedValue* temp = aria_label_;
  aria_label_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_aria_label() {
  _has_bits_[0] |= 0x00000010u;
  if (aria_label_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaNoVirtual());
    aria_label_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.aria_label)
  return aria_label_;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_aria_label(::autofill::AutofillRandomizedValue* aria_label) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete aria_label_;
  }
  if (aria_label) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      aria_label = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, aria_label, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  aria_label_ = aria_label;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.aria_label)
}

// optional .autofill.AutofillRandomizedValue aria_description = 6;
inline bool AutofillRandomizedFieldMetadata::has_aria_description() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AutofillRandomizedFieldMetadata::clear_aria_description() {
  if (aria_description_ != nullptr) aria_description_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::aria_description() const {
  const ::autofill::AutofillRandomizedValue* p = aria_description_;
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.aria_description)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::AutofillRandomizedValue*>(
      &::autofill::_AutofillRandomizedValue_default_instance_);
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_aria_description() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.aria_description)
  _has_bits_[0] &= ~0x00000020u;
  ::autofill::AutofillRandomizedValue* temp = aria_description_;
  aria_description_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_aria_description() {
  _has_bits_[0] |= 0x00000020u;
  if (aria_description_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaNoVirtual());
    aria_description_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.aria_description)
  return aria_description_;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_aria_description(::autofill::AutofillRandomizedValue* aria_description) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete aria_description_;
  }
  if (aria_description) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      aria_description = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, aria_description, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  aria_description_ = aria_description;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.aria_description)
}

// optional .autofill.AutofillRandomizedValue css_class = 7;
inline bool AutofillRandomizedFieldMetadata::has_css_class() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AutofillRandomizedFieldMetadata::clear_css_class() {
  if (css_class_ != nullptr) css_class_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::css_class() const {
  const ::autofill::AutofillRandomizedValue* p = css_class_;
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.css_class)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::AutofillRandomizedValue*>(
      &::autofill::_AutofillRandomizedValue_default_instance_);
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_css_class() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.css_class)
  _has_bits_[0] &= ~0x00000040u;
  ::autofill::AutofillRandomizedValue* temp = css_class_;
  css_class_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_css_class() {
  _has_bits_[0] |= 0x00000040u;
  if (css_class_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaNoVirtual());
    css_class_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.css_class)
  return css_class_;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_css_class(::autofill::AutofillRandomizedValue* css_class) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete css_class_;
  }
  if (css_class) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      css_class = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, css_class, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  css_class_ = css_class;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.css_class)
}

// optional .autofill.AutofillRandomizedValue placeholder = 8;
inline bool AutofillRandomizedFieldMetadata::has_placeholder() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AutofillRandomizedFieldMetadata::clear_placeholder() {
  if (placeholder_ != nullptr) placeholder_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::placeholder() const {
  const ::autofill::AutofillRandomizedValue* p = placeholder_;
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.placeholder)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::AutofillRandomizedValue*>(
      &::autofill::_AutofillRandomizedValue_default_instance_);
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_placeholder() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.placeholder)
  _has_bits_[0] &= ~0x00000080u;
  ::autofill::AutofillRandomizedValue* temp = placeholder_;
  placeholder_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_placeholder() {
  _has_bits_[0] |= 0x00000080u;
  if (placeholder_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaNoVirtual());
    placeholder_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.placeholder)
  return placeholder_;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_placeholder(::autofill::AutofillRandomizedValue* placeholder) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete placeholder_;
  }
  if (placeholder) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      placeholder = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, placeholder, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  placeholder_ = placeholder;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.placeholder)
}

// optional .autofill.AutofillRandomizedValue initial_value_hash = 9;
inline bool AutofillRandomizedFieldMetadata::has_initial_value_hash() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AutofillRandomizedFieldMetadata::clear_initial_value_hash() {
  if (initial_value_hash_ != nullptr) initial_value_hash_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::initial_value_hash() const {
  const ::autofill::AutofillRandomizedValue* p = initial_value_hash_;
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.initial_value_hash)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::AutofillRandomizedValue*>(
      &::autofill::_AutofillRandomizedValue_default_instance_);
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_initial_value_hash() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.initial_value_hash)
  _has_bits_[0] &= ~0x00000100u;
  ::autofill::AutofillRandomizedValue* temp = initial_value_hash_;
  initial_value_hash_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_initial_value_hash() {
  _has_bits_[0] |= 0x00000100u;
  if (initial_value_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaNoVirtual());
    initial_value_hash_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.initial_value_hash)
  return initial_value_hash_;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_initial_value_hash(::autofill::AutofillRandomizedValue* initial_value_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete initial_value_hash_;
  }
  if (initial_value_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      initial_value_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initial_value_hash, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  initial_value_hash_ = initial_value_hash;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.initial_value_hash)
}

// -------------------------------------------------------------------

// AutofillUploadContents_Field_AutofillTypeValiditiesPair

// required int32 type = 1;
inline bool AutofillUploadContents_Field_AutofillTypeValiditiesPair::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutofillUploadContents_Field_AutofillTypeValiditiesPair::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AutofillUploadContents_Field_AutofillTypeValiditiesPair::type() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair.type)
  return type_;
}
inline void AutofillUploadContents_Field_AutofillTypeValiditiesPair::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair.type)
}

// repeated int32 validity = 2;
inline int AutofillUploadContents_Field_AutofillTypeValiditiesPair::validity_size() const {
  return validity_.size();
}
inline void AutofillUploadContents_Field_AutofillTypeValiditiesPair::clear_validity() {
  validity_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AutofillUploadContents_Field_AutofillTypeValiditiesPair::validity(int index) const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair.validity)
  return validity_.Get(index);
}
inline void AutofillUploadContents_Field_AutofillTypeValiditiesPair::set_validity(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  validity_.Set(index, value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair.validity)
}
inline void AutofillUploadContents_Field_AutofillTypeValiditiesPair::add_validity(::PROTOBUF_NAMESPACE_ID::int32 value) {
  validity_.Add(value);
  // @@protoc_insertion_point(field_add:autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair.validity)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
AutofillUploadContents_Field_AutofillTypeValiditiesPair::validity() const {
  // @@protoc_insertion_point(field_list:autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair.validity)
  return validity_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
AutofillUploadContents_Field_AutofillTypeValiditiesPair::mutable_validity() {
  // @@protoc_insertion_point(field_mutable_list:autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair.validity)
  return &validity_;
}

// -------------------------------------------------------------------

// AutofillUploadContents_Field

// required fixed32 signature = 6;
inline bool AutofillUploadContents_Field::has_signature() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AutofillUploadContents_Field::clear_signature() {
  signature_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AutofillUploadContents_Field::signature() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.signature)
  return signature_;
}
inline void AutofillUploadContents_Field::set_signature(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  signature_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.signature)
}

// repeated fixed32 autofill_type = 7;
inline int AutofillUploadContents_Field::autofill_type_size() const {
  return autofill_type_.size();
}
inline void AutofillUploadContents_Field::clear_autofill_type() {
  autofill_type_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AutofillUploadContents_Field::autofill_type(int index) const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.autofill_type)
  return autofill_type_.Get(index);
}
inline void AutofillUploadContents_Field::set_autofill_type(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  autofill_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.autofill_type)
}
inline void AutofillUploadContents_Field::add_autofill_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  autofill_type_.Add(value);
  // @@protoc_insertion_point(field_add:autofill.AutofillUploadContents.Field.autofill_type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
AutofillUploadContents_Field::autofill_type() const {
  // @@protoc_insertion_point(field_list:autofill.AutofillUploadContents.Field.autofill_type)
  return autofill_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
AutofillUploadContents_Field::mutable_autofill_type() {
  // @@protoc_insertion_point(field_mutable_list:autofill.AutofillUploadContents.Field.autofill_type)
  return &autofill_type_;
}

// optional string name = 8;
inline bool AutofillUploadContents_Field::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutofillUploadContents_Field::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillUploadContents_Field::name() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.name)
  return name_.GetNoArena();
}
inline void AutofillUploadContents_Field::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.name)
}
inline void AutofillUploadContents_Field::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.AutofillUploadContents.Field.name)
}
inline void AutofillUploadContents_Field::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.AutofillUploadContents.Field.name)
}
inline void AutofillUploadContents_Field::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.AutofillUploadContents.Field.name)
}
inline std::string* AutofillUploadContents_Field::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.Field.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AutofillUploadContents_Field::release_name() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.Field.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AutofillUploadContents_Field::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.Field.name)
}

// optional string autocomplete = 9;
inline bool AutofillUploadContents_Field::has_autocomplete() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AutofillUploadContents_Field::clear_autocomplete() {
  autocomplete_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AutofillUploadContents_Field::autocomplete() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.autocomplete)
  return autocomplete_.GetNoArena();
}
inline void AutofillUploadContents_Field::set_autocomplete(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  autocomplete_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.autocomplete)
}
inline void AutofillUploadContents_Field::set_autocomplete(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  autocomplete_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.AutofillUploadContents.Field.autocomplete)
}
inline void AutofillUploadContents_Field::set_autocomplete(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  autocomplete_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.AutofillUploadContents.Field.autocomplete)
}
inline void AutofillUploadContents_Field::set_autocomplete(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  autocomplete_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.AutofillUploadContents.Field.autocomplete)
}
inline std::string* AutofillUploadContents_Field::mutable_autocomplete() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.Field.autocomplete)
  return autocomplete_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AutofillUploadContents_Field::release_autocomplete() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.Field.autocomplete)
  if (!has_autocomplete()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return autocomplete_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AutofillUploadContents_Field::set_allocated_autocomplete(std::string* autocomplete) {
  if (autocomplete != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  autocomplete_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), autocomplete);
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.Field.autocomplete)
}

// optional string type = 10;
inline bool AutofillUploadContents_Field::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AutofillUploadContents_Field::clear_type() {
  type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AutofillUploadContents_Field::type() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.type)
  return type_.GetNoArena();
}
inline void AutofillUploadContents_Field::set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.type)
}
inline void AutofillUploadContents_Field::set_type(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.AutofillUploadContents.Field.type)
}
inline void AutofillUploadContents_Field::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.AutofillUploadContents.Field.type)
}
inline void AutofillUploadContents_Field::set_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.AutofillUploadContents.Field.type)
}
inline std::string* AutofillUploadContents_Field::mutable_type() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.Field.type)
  return type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AutofillUploadContents_Field::release_type() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.Field.type)
  if (!has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AutofillUploadContents_Field::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.Field.type)
}

// optional .autofill.AutofillRandomizedFieldMetadata randomized_field_metadata = 33;
inline bool AutofillUploadContents_Field::has_randomized_field_metadata() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AutofillUploadContents_Field::clear_randomized_field_metadata() {
  if (randomized_field_metadata_ != nullptr) randomized_field_metadata_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::autofill::AutofillRandomizedFieldMetadata& AutofillUploadContents_Field::randomized_field_metadata() const {
  const ::autofill::AutofillRandomizedFieldMetadata* p = randomized_field_metadata_;
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.randomized_field_metadata)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::AutofillRandomizedFieldMetadata*>(
      &::autofill::_AutofillRandomizedFieldMetadata_default_instance_);
}
inline ::autofill::AutofillRandomizedFieldMetadata* AutofillUploadContents_Field::release_randomized_field_metadata() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.Field.randomized_field_metadata)
  _has_bits_[0] &= ~0x00000020u;
  ::autofill::AutofillRandomizedFieldMetadata* temp = randomized_field_metadata_;
  randomized_field_metadata_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedFieldMetadata* AutofillUploadContents_Field::mutable_randomized_field_metadata() {
  _has_bits_[0] |= 0x00000020u;
  if (randomized_field_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedFieldMetadata>(GetArenaNoVirtual());
    randomized_field_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.Field.randomized_field_metadata)
  return randomized_field_metadata_;
}
inline void AutofillUploadContents_Field::set_allocated_randomized_field_metadata(::autofill::AutofillRandomizedFieldMetadata* randomized_field_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete randomized_field_metadata_;
  }
  if (randomized_field_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      randomized_field_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, randomized_field_metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  randomized_field_metadata_ = randomized_field_metadata;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.Field.randomized_field_metadata)
}

// optional .autofill.AutofillUploadContents.Field.PasswordGenerationType generation_type = 17;
inline bool AutofillUploadContents_Field::has_generation_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AutofillUploadContents_Field::clear_generation_type() {
  generation_type_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::autofill::AutofillUploadContents_Field_PasswordGenerationType AutofillUploadContents_Field::generation_type() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.generation_type)
  return static_cast< ::autofill::AutofillUploadContents_Field_PasswordGenerationType >(generation_type_);
}
inline void AutofillUploadContents_Field::set_generation_type(::autofill::AutofillUploadContents_Field_PasswordGenerationType value) {
  assert(::autofill::AutofillUploadContents_Field_PasswordGenerationType_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  generation_type_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.generation_type)
}

// optional string css_classes = 19;
inline bool AutofillUploadContents_Field::has_css_classes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AutofillUploadContents_Field::clear_css_classes() {
  css_classes_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AutofillUploadContents_Field::css_classes() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.css_classes)
  return css_classes_.GetNoArena();
}
inline void AutofillUploadContents_Field::set_css_classes(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  css_classes_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.css_classes)
}
inline void AutofillUploadContents_Field::set_css_classes(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  css_classes_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.AutofillUploadContents.Field.css_classes)
}
inline void AutofillUploadContents_Field::set_css_classes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  css_classes_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.AutofillUploadContents.Field.css_classes)
}
inline void AutofillUploadContents_Field::set_css_classes(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  css_classes_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.AutofillUploadContents.Field.css_classes)
}
inline std::string* AutofillUploadContents_Field::mutable_css_classes() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.Field.css_classes)
  return css_classes_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AutofillUploadContents_Field::release_css_classes() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.Field.css_classes)
  if (!has_css_classes()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return css_classes_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AutofillUploadContents_Field::set_allocated_css_classes(std::string* css_classes) {
  if (css_classes != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  css_classes_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), css_classes);
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.Field.css_classes)
}

// optional uint32 properties_mask = 20;
inline bool AutofillUploadContents_Field::has_properties_mask() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AutofillUploadContents_Field::clear_properties_mask() {
  properties_mask_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AutofillUploadContents_Field::properties_mask() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.properties_mask)
  return properties_mask_;
}
inline void AutofillUploadContents_Field::set_properties_mask(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  properties_mask_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.properties_mask)
}

// optional string id = 21;
inline bool AutofillUploadContents_Field::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AutofillUploadContents_Field::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& AutofillUploadContents_Field::id() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.id)
  return id_.GetNoArena();
}
inline void AutofillUploadContents_Field::set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.id)
}
inline void AutofillUploadContents_Field::set_id(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.AutofillUploadContents.Field.id)
}
inline void AutofillUploadContents_Field::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.AutofillUploadContents.Field.id)
}
inline void AutofillUploadContents_Field::set_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.AutofillUploadContents.Field.id)
}
inline std::string* AutofillUploadContents_Field::mutable_id() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.Field.id)
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AutofillUploadContents_Field::release_id() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.Field.id)
  if (!has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AutofillUploadContents_Field::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.Field.id)
}

// optional bool generated_password_changed = 22;
inline bool AutofillUploadContents_Field::has_generated_password_changed() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AutofillUploadContents_Field::clear_generated_password_changed() {
  generated_password_changed_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool AutofillUploadContents_Field::generated_password_changed() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.generated_password_changed)
  return generated_password_changed_;
}
inline void AutofillUploadContents_Field::set_generated_password_changed(bool value) {
  _has_bits_[0] |= 0x00000200u;
  generated_password_changed_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.generated_password_changed)
}

// optional .autofill.AutofillUploadContents.Field.VoteType vote_type = 23;
inline bool AutofillUploadContents_Field::has_vote_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AutofillUploadContents_Field::clear_vote_type() {
  vote_type_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::autofill::AutofillUploadContents_Field_VoteType AutofillUploadContents_Field::vote_type() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.vote_type)
  return static_cast< ::autofill::AutofillUploadContents_Field_VoteType >(vote_type_);
}
inline void AutofillUploadContents_Field::set_vote_type(::autofill::AutofillUploadContents_Field_VoteType value) {
  assert(::autofill::AutofillUploadContents_Field_VoteType_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  vote_type_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.vote_type)
}

// repeated .autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair autofill_type_validities = 35;
inline int AutofillUploadContents_Field::autofill_type_validities_size() const {
  return autofill_type_validities_.size();
}
inline void AutofillUploadContents_Field::clear_autofill_type_validities() {
  autofill_type_validities_.Clear();
}
inline ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair* AutofillUploadContents_Field::mutable_autofill_type_validities(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.Field.autofill_type_validities)
  return autofill_type_validities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair >*
AutofillUploadContents_Field::mutable_autofill_type_validities() {
  // @@protoc_insertion_point(field_mutable_list:autofill.AutofillUploadContents.Field.autofill_type_validities)
  return &autofill_type_validities_;
}
inline const ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair& AutofillUploadContents_Field::autofill_type_validities(int index) const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.autofill_type_validities)
  return autofill_type_validities_.Get(index);
}
inline ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair* AutofillUploadContents_Field::add_autofill_type_validities() {
  // @@protoc_insertion_point(field_add:autofill.AutofillUploadContents.Field.autofill_type_validities)
  return autofill_type_validities_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair >&
AutofillUploadContents_Field::autofill_type_validities() const {
  // @@protoc_insertion_point(field_list:autofill.AutofillUploadContents.Field.autofill_type_validities)
  return autofill_type_validities_;
}

// optional uint32 initial_value_hash = 40;
inline bool AutofillUploadContents_Field::has_initial_value_hash() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AutofillUploadContents_Field::clear_initial_value_hash() {
  initial_value_hash_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AutofillUploadContents_Field::initial_value_hash() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.initial_value_hash)
  return initial_value_hash_;
}
inline void AutofillUploadContents_Field::set_initial_value_hash(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  initial_value_hash_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.initial_value_hash)
}

// -------------------------------------------------------------------

// AutofillUploadContents_ButtonTitle

// optional string title = 1;
inline bool AutofillUploadContents_ButtonTitle::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutofillUploadContents_ButtonTitle::clear_title() {
  title_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillUploadContents_ButtonTitle::title() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.ButtonTitle.title)
  return title_.GetNoArena();
}
inline void AutofillUploadContents_ButtonTitle::set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.ButtonTitle.title)
}
inline void AutofillUploadContents_ButtonTitle::set_title(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.AutofillUploadContents.ButtonTitle.title)
}
inline void AutofillUploadContents_ButtonTitle::set_title(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  title_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.AutofillUploadContents.ButtonTitle.title)
}
inline void AutofillUploadContents_ButtonTitle::set_title(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  title_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.AutofillUploadContents.ButtonTitle.title)
}
inline std::string* AutofillUploadContents_ButtonTitle::mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.ButtonTitle.title)
  return title_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AutofillUploadContents_ButtonTitle::release_title() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.ButtonTitle.title)
  if (!has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return title_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AutofillUploadContents_ButtonTitle::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.ButtonTitle.title)
}

// optional .autofill.AutofillUploadContents.ButtonTitle.ButtonTitleType type = 2;
inline bool AutofillUploadContents_ButtonTitle::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AutofillUploadContents_ButtonTitle::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::autofill::AutofillUploadContents_ButtonTitle_ButtonTitleType AutofillUploadContents_ButtonTitle::type() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.ButtonTitle.type)
  return static_cast< ::autofill::AutofillUploadContents_ButtonTitle_ButtonTitleType >(type_);
}
inline void AutofillUploadContents_ButtonTitle::set_type(::autofill::AutofillUploadContents_ButtonTitle_ButtonTitleType value) {
  assert(::autofill::AutofillUploadContents_ButtonTitle_ButtonTitleType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.ButtonTitle.type)
}

// -------------------------------------------------------------------

// AutofillUploadContents

// required string client_version = 1;
inline bool AutofillUploadContents::has_client_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutofillUploadContents::clear_client_version() {
  client_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillUploadContents::client_version() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.client_version)
  return client_version_.GetNoArena();
}
inline void AutofillUploadContents::set_client_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.client_version)
}
inline void AutofillUploadContents::set_client_version(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  client_version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.AutofillUploadContents.client_version)
}
inline void AutofillUploadContents::set_client_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  client_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.AutofillUploadContents.client_version)
}
inline void AutofillUploadContents::set_client_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  client_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.AutofillUploadContents.client_version)
}
inline std::string* AutofillUploadContents::mutable_client_version() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.client_version)
  return client_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AutofillUploadContents::release_client_version() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.client_version)
  if (!has_client_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return client_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AutofillUploadContents::set_allocated_client_version(std::string* client_version) {
  if (client_version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_version);
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.client_version)
}

// required fixed64 form_signature = 2;
inline bool AutofillUploadContents::has_form_signature() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AutofillUploadContents::clear_form_signature() {
  form_signature_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AutofillUploadContents::form_signature() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.form_signature)
  return form_signature_;
}
inline void AutofillUploadContents::set_form_signature(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  form_signature_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.form_signature)
}

// optional fixed64 secondary_form_signature = 34;
inline bool AutofillUploadContents::has_secondary_form_signature() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void AutofillUploadContents::clear_secondary_form_signature() {
  secondary_form_signature_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00040000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AutofillUploadContents::secondary_form_signature() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.secondary_form_signature)
  return secondary_form_signature_;
}
inline void AutofillUploadContents::set_secondary_form_signature(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00040000u;
  secondary_form_signature_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.secondary_form_signature)
}

// required bool autofill_used = 3;
inline bool AutofillUploadContents::has_autofill_used() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AutofillUploadContents::clear_autofill_used() {
  autofill_used_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool AutofillUploadContents::autofill_used() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.autofill_used)
  return autofill_used_;
}
inline void AutofillUploadContents::set_autofill_used(bool value) {
  _has_bits_[0] |= 0x00000100u;
  autofill_used_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.autofill_used)
}

// required string data_present = 4;
inline bool AutofillUploadContents::has_data_present() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AutofillUploadContents::clear_data_present() {
  data_present_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AutofillUploadContents::data_present() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.data_present)
  return data_present_.GetNoArena();
}
inline void AutofillUploadContents::set_data_present(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  data_present_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.data_present)
}
inline void AutofillUploadContents::set_data_present(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  data_present_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.AutofillUploadContents.data_present)
}
inline void AutofillUploadContents::set_data_present(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  data_present_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.AutofillUploadContents.data_present)
}
inline void AutofillUploadContents::set_data_present(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  data_present_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.AutofillUploadContents.data_present)
}
inline std::string* AutofillUploadContents::mutable_data_present() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.data_present)
  return data_present_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AutofillUploadContents::release_data_present() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.data_present)
  if (!has_data_present()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return data_present_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AutofillUploadContents::set_allocated_data_present(std::string* data_present) {
  if (data_present != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data_present_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data_present);
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.data_present)
}

// repeated group Field = 5 { ... };
inline int AutofillUploadContents::field_size() const {
  return field_.size();
}
inline void AutofillUploadContents::clear_field() {
  field_.Clear();
}
inline ::autofill::AutofillUploadContents_Field* AutofillUploadContents::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.field)
  return field_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_Field >*
AutofillUploadContents::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:autofill.AutofillUploadContents.field)
  return &field_;
}
inline const ::autofill::AutofillUploadContents_Field& AutofillUploadContents::field(int index) const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.field)
  return field_.Get(index);
}
inline ::autofill::AutofillUploadContents_Field* AutofillUploadContents::add_field() {
  // @@protoc_insertion_point(field_add:autofill.AutofillUploadContents.field)
  return field_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_Field >&
AutofillUploadContents::field() const {
  // @@protoc_insertion_point(field_list:autofill.AutofillUploadContents.field)
  return field_;
}

// optional fixed64 action_signature = 13;
inline bool AutofillUploadContents::has_action_signature() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AutofillUploadContents::clear_action_signature() {
  action_signature_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AutofillUploadContents::action_signature() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.action_signature)
  return action_signature_;
}
inline void AutofillUploadContents::set_action_signature(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  action_signature_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.action_signature)
}

// optional fixed64 login_form_signature = 14;
inline bool AutofillUploadContents::has_login_form_signature() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AutofillUploadContents::clear_login_form_signature() {
  login_form_signature_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AutofillUploadContents::login_form_signature() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.login_form_signature)
  return login_form_signature_;
}
inline void AutofillUploadContents::set_login_form_signature(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000080u;
  login_form_signature_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.login_form_signature)
}

// optional bool submission = 15;
inline bool AutofillUploadContents::has_submission() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AutofillUploadContents::clear_submission() {
  submission_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool AutofillUploadContents::submission() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.submission)
  return submission_;
}
inline void AutofillUploadContents::set_submission(bool value) {
  _has_bits_[0] |= 0x00000200u;
  submission_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.submission)
}

// optional string form_name = 16;
inline bool AutofillUploadContents::has_form_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AutofillUploadContents::clear_form_name() {
  form_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AutofillUploadContents::form_name() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.form_name)
  return form_name_.GetNoArena();
}
inline void AutofillUploadContents::set_form_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  form_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.form_name)
}
inline void AutofillUploadContents::set_form_name(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  form_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.AutofillUploadContents.form_name)
}
inline void AutofillUploadContents::set_form_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  form_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.AutofillUploadContents.form_name)
}
inline void AutofillUploadContents::set_form_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  form_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.AutofillUploadContents.form_name)
}
inline std::string* AutofillUploadContents::mutable_form_name() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.form_name)
  return form_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AutofillUploadContents::release_form_name() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.form_name)
  if (!has_form_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return form_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AutofillUploadContents::set_allocated_form_name(std::string* form_name) {
  if (form_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  form_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), form_name);
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.form_name)
}

// optional bool passwords_revealed = 24;
inline bool AutofillUploadContents::has_passwords_revealed() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AutofillUploadContents::clear_passwords_revealed() {
  passwords_revealed_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool AutofillUploadContents::passwords_revealed() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.passwords_revealed)
  return passwords_revealed_;
}
inline void AutofillUploadContents::set_passwords_revealed(bool value) {
  _has_bits_[0] |= 0x00000400u;
  passwords_revealed_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.passwords_revealed)
}

// optional bool password_has_lowercase_letter = 25;
inline bool AutofillUploadContents::has_password_has_lowercase_letter() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AutofillUploadContents::clear_password_has_lowercase_letter() {
  password_has_lowercase_letter_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool AutofillUploadContents::password_has_lowercase_letter() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.password_has_lowercase_letter)
  return password_has_lowercase_letter_;
}
inline void AutofillUploadContents::set_password_has_lowercase_letter(bool value) {
  _has_bits_[0] |= 0x00000800u;
  password_has_lowercase_letter_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.password_has_lowercase_letter)
}

// optional bool password_has_uppercase_letter = 26 [deprecated = true];
inline bool AutofillUploadContents::has_password_has_uppercase_letter() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AutofillUploadContents::clear_password_has_uppercase_letter() {
  password_has_uppercase_letter_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool AutofillUploadContents::password_has_uppercase_letter() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.password_has_uppercase_letter)
  return password_has_uppercase_letter_;
}
inline void AutofillUploadContents::set_password_has_uppercase_letter(bool value) {
  _has_bits_[0] |= 0x00002000u;
  password_has_uppercase_letter_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.password_has_uppercase_letter)
}

// optional bool password_has_numeric = 27 [deprecated = true];
inline bool AutofillUploadContents::has_password_has_numeric() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AutofillUploadContents::clear_password_has_numeric() {
  password_has_numeric_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool AutofillUploadContents::password_has_numeric() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.password_has_numeric)
  return password_has_numeric_;
}
inline void AutofillUploadContents::set_password_has_numeric(bool value) {
  _has_bits_[0] |= 0x00004000u;
  password_has_numeric_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.password_has_numeric)
}

// optional bool password_has_special_symbol = 28;
inline bool AutofillUploadContents::has_password_has_special_symbol() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void AutofillUploadContents::clear_password_has_special_symbol() {
  password_has_special_symbol_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool AutofillUploadContents::password_has_special_symbol() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.password_has_special_symbol)
  return password_has_special_symbol_;
}
inline void AutofillUploadContents::set_password_has_special_symbol(bool value) {
  _has_bits_[0] |= 0x00008000u;
  password_has_special_symbol_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.password_has_special_symbol)
}

// optional uint32 password_length = 29;
inline bool AutofillUploadContents::has_password_length() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AutofillUploadContents::clear_password_length() {
  password_length_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AutofillUploadContents::password_length() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.password_length)
  return password_length_;
}
inline void AutofillUploadContents::set_password_length(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  password_length_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.password_length)
}

// optional uint32 password_special_symbol = 39;
inline bool AutofillUploadContents::has_password_special_symbol() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void AutofillUploadContents::clear_password_special_symbol() {
  password_special_symbol_ = 0u;
  _has_bits_[0] &= ~0x00100000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AutofillUploadContents::password_special_symbol() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.password_special_symbol)
  return password_special_symbol_;
}
inline void AutofillUploadContents::set_password_special_symbol(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00100000u;
  password_special_symbol_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.password_special_symbol)
}

// optional .autofill.AutofillUploadContents.SubmissionIndicatorEvent submission_event = 30;
inline bool AutofillUploadContents::has_submission_event() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void AutofillUploadContents::clear_submission_event() {
  submission_event_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::autofill::AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents::submission_event() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.submission_event)
  return static_cast< ::autofill::AutofillUploadContents_SubmissionIndicatorEvent >(submission_event_);
}
inline void AutofillUploadContents::set_submission_event(::autofill::AutofillUploadContents_SubmissionIndicatorEvent value) {
  assert(::autofill::AutofillUploadContents_SubmissionIndicatorEvent_IsValid(value));
  _has_bits_[0] |= 0x00020000u;
  submission_event_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.submission_event)
}

// optional string language = 31;
inline bool AutofillUploadContents::has_language() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AutofillUploadContents::clear_language() {
  language_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AutofillUploadContents::language() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.language)
  return language_.GetNoArena();
}
inline void AutofillUploadContents::set_language(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.language)
}
inline void AutofillUploadContents::set_language(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  language_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.AutofillUploadContents.language)
}
inline void AutofillUploadContents::set_language(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.AutofillUploadContents.language)
}
inline void AutofillUploadContents::set_language(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.AutofillUploadContents.language)
}
inline std::string* AutofillUploadContents::mutable_language() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.language)
  return language_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AutofillUploadContents::release_language() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.language)
  if (!has_language()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return language_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AutofillUploadContents::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  language_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.language)
}

// optional .autofill.AutofillRandomizedFormMetadata randomized_form_metadata = 32;
inline bool AutofillUploadContents::has_randomized_form_metadata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AutofillUploadContents::clear_randomized_form_metadata() {
  if (randomized_form_metadata_ != nullptr) randomized_form_metadata_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::autofill::AutofillRandomizedFormMetadata& AutofillUploadContents::randomized_form_metadata() const {
  const ::autofill::AutofillRandomizedFormMetadata* p = randomized_form_metadata_;
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.randomized_form_metadata)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::AutofillRandomizedFormMetadata*>(
      &::autofill::_AutofillRandomizedFormMetadata_default_instance_);
}
inline ::autofill::AutofillRandomizedFormMetadata* AutofillUploadContents::release_randomized_form_metadata() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.randomized_form_metadata)
  _has_bits_[0] &= ~0x00000010u;
  ::autofill::AutofillRandomizedFormMetadata* temp = randomized_form_metadata_;
  randomized_form_metadata_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedFormMetadata* AutofillUploadContents::mutable_randomized_form_metadata() {
  _has_bits_[0] |= 0x00000010u;
  if (randomized_form_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedFormMetadata>(GetArenaNoVirtual());
    randomized_form_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.randomized_form_metadata)
  return randomized_form_metadata_;
}
inline void AutofillUploadContents::set_allocated_randomized_form_metadata(::autofill::AutofillRandomizedFormMetadata* randomized_form_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete randomized_form_metadata_;
  }
  if (randomized_form_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      randomized_form_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, randomized_form_metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  randomized_form_metadata_ = randomized_form_metadata;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.randomized_form_metadata)
}

// repeated .autofill.AutofillUploadContents.ButtonTitle button_title = 36;
inline int AutofillUploadContents::button_title_size() const {
  return button_title_.size();
}
inline void AutofillUploadContents::clear_button_title() {
  button_title_.Clear();
}
inline ::autofill::AutofillUploadContents_ButtonTitle* AutofillUploadContents::mutable_button_title(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.button_title)
  return button_title_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_ButtonTitle >*
AutofillUploadContents::mutable_button_title() {
  // @@protoc_insertion_point(field_mutable_list:autofill.AutofillUploadContents.button_title)
  return &button_title_;
}
inline const ::autofill::AutofillUploadContents_ButtonTitle& AutofillUploadContents::button_title(int index) const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.button_title)
  return button_title_.Get(index);
}
inline ::autofill::AutofillUploadContents_ButtonTitle* AutofillUploadContents::add_button_title() {
  // @@protoc_insertion_point(field_add:autofill.AutofillUploadContents.button_title)
  return button_title_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_ButtonTitle >&
AutofillUploadContents::button_title() const {
  // @@protoc_insertion_point(field_list:autofill.AutofillUploadContents.button_title)
  return button_title_;
}

// optional bool has_form_tag = 37;
inline bool AutofillUploadContents::has_has_form_tag() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void AutofillUploadContents::clear_has_form_tag() {
  has_form_tag_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool AutofillUploadContents::has_form_tag() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.has_form_tag)
  return has_form_tag_;
}
inline void AutofillUploadContents::set_has_form_tag(bool value) {
  _has_bits_[0] |= 0x00010000u;
  has_form_tag_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.has_form_tag)
}

// optional bool was_throttleable = 38;
inline bool AutofillUploadContents::has_was_throttleable() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void AutofillUploadContents::clear_was_throttleable() {
  was_throttleable_ = false;
  _has_bits_[0] &= ~0x00080000u;
}
inline bool AutofillUploadContents::was_throttleable() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.was_throttleable)
  return was_throttleable_;
}
inline void AutofillUploadContents::set_was_throttleable(bool value) {
  _has_bits_[0] |= 0x00080000u;
  was_throttleable_ = value;
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.was_throttleable)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ProfileValidityMap

// map<int32, int32> field_validity_states = 1;
inline int ProfileValidityMap::field_validity_states_size() const {
  return field_validity_states_.size();
}
inline void ProfileValidityMap::clear_field_validity_states() {
  field_validity_states_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32 >&
ProfileValidityMap::field_validity_states() const {
  // @@protoc_insertion_point(field_map:autofill.ProfileValidityMap.field_validity_states)
  return field_validity_states_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32 >*
ProfileValidityMap::mutable_field_validity_states() {
  // @@protoc_insertion_point(field_mutable_map:autofill.ProfileValidityMap.field_validity_states)
  return field_validity_states_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UserProfileValidityMap

// map<string, .autofill.ProfileValidityMap> profile_validity = 1;
inline int UserProfileValidityMap::profile_validity_size() const {
  return profile_validity_.size();
}
inline void UserProfileValidityMap::clear_profile_validity() {
  profile_validity_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::autofill::ProfileValidityMap >&
UserProfileValidityMap::profile_validity() const {
  // @@protoc_insertion_point(field_map:autofill.UserProfileValidityMap.profile_validity)
  return profile_validity_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::autofill::ProfileValidityMap >*
UserProfileValidityMap::mutable_profile_validity() {
  // @@protoc_insertion_point(field_mutable_map:autofill.UserProfileValidityMap.profile_validity)
  return profile_validity_.MutableMap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace autofill

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::autofill::AutofillRandomizedValue_EncodingType> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill::AutofillUploadContents_Field_PasswordGenerationType> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill::AutofillUploadContents_Field_VoteType> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill::AutofillUploadContents_ButtonTitle_ButtonTitleType> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill::AutofillUploadContents_SubmissionIndicatorEvent> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_server_2eproto
