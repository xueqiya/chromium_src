// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fingerprint.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_fingerprint_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_fingerprint_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_fingerprint_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_fingerprint_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace autofill {
namespace risk {
class Fingerprint;
class FingerprintDefaultTypeInternal;
extern FingerprintDefaultTypeInternal _Fingerprint_default_instance_;
class Fingerprint_Dimension;
class Fingerprint_DimensionDefaultTypeInternal;
extern Fingerprint_DimensionDefaultTypeInternal _Fingerprint_Dimension_default_instance_;
class Fingerprint_MachineCharacteristics;
class Fingerprint_MachineCharacteristicsDefaultTypeInternal;
extern Fingerprint_MachineCharacteristicsDefaultTypeInternal _Fingerprint_MachineCharacteristics_default_instance_;
class Fingerprint_MachineCharacteristics_Cpu;
class Fingerprint_MachineCharacteristics_CpuDefaultTypeInternal;
extern Fingerprint_MachineCharacteristics_CpuDefaultTypeInternal _Fingerprint_MachineCharacteristics_Cpu_default_instance_;
class Fingerprint_MachineCharacteristics_Graphics;
class Fingerprint_MachineCharacteristics_GraphicsDefaultTypeInternal;
extern Fingerprint_MachineCharacteristics_GraphicsDefaultTypeInternal _Fingerprint_MachineCharacteristics_Graphics_default_instance_;
class Fingerprint_MachineCharacteristics_Plugin;
class Fingerprint_MachineCharacteristics_PluginDefaultTypeInternal;
extern Fingerprint_MachineCharacteristics_PluginDefaultTypeInternal _Fingerprint_MachineCharacteristics_Plugin_default_instance_;
class Fingerprint_Metadata;
class Fingerprint_MetadataDefaultTypeInternal;
extern Fingerprint_MetadataDefaultTypeInternal _Fingerprint_Metadata_default_instance_;
class Fingerprint_Performance;
class Fingerprint_PerformanceDefaultTypeInternal;
extern Fingerprint_PerformanceDefaultTypeInternal _Fingerprint_Performance_default_instance_;
class Fingerprint_TransientState;
class Fingerprint_TransientStateDefaultTypeInternal;
extern Fingerprint_TransientStateDefaultTypeInternal _Fingerprint_TransientState_default_instance_;
class Fingerprint_UserCharacteristics;
class Fingerprint_UserCharacteristicsDefaultTypeInternal;
extern Fingerprint_UserCharacteristicsDefaultTypeInternal _Fingerprint_UserCharacteristics_default_instance_;
class Fingerprint_UserCharacteristics_Location;
class Fingerprint_UserCharacteristics_LocationDefaultTypeInternal;
extern Fingerprint_UserCharacteristics_LocationDefaultTypeInternal _Fingerprint_UserCharacteristics_Location_default_instance_;
class Fingerprint_UserCharacteristics_Vector;
class Fingerprint_UserCharacteristics_VectorDefaultTypeInternal;
extern Fingerprint_UserCharacteristics_VectorDefaultTypeInternal _Fingerprint_UserCharacteristics_Vector_default_instance_;
}  // namespace risk
}  // namespace autofill
PROTOBUF_NAMESPACE_OPEN
template<> ::autofill::risk::Fingerprint* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint>(Arena*);
template<> ::autofill::risk::Fingerprint_Dimension* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_Dimension>(Arena*);
template<> ::autofill::risk::Fingerprint_MachineCharacteristics* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics>(Arena*);
template<> ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics_Cpu>(Arena*);
template<> ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics_Graphics>(Arena*);
template<> ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics_Plugin>(Arena*);
template<> ::autofill::risk::Fingerprint_Metadata* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_Metadata>(Arena*);
template<> ::autofill::risk::Fingerprint_Performance* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_Performance>(Arena*);
template<> ::autofill::risk::Fingerprint_TransientState* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_TransientState>(Arena*);
template<> ::autofill::risk::Fingerprint_UserCharacteristics* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics>(Arena*);
template<> ::autofill::risk::Fingerprint_UserCharacteristics_Location* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics_Location>(Arena*);
template<> ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics_Vector>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace autofill {
namespace risk {

enum Fingerprint_MachineCharacteristics_BrowserFeature : int {
  Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_UNKNOWN = 0,
  Fingerprint_MachineCharacteristics_BrowserFeature_DEPRECATED_FEATURE_AUTOCHECKOUT = 1,
  Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_REQUEST_AUTOCOMPLETE = 2
};
bool Fingerprint_MachineCharacteristics_BrowserFeature_IsValid(int value);
constexpr Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_MIN = Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_UNKNOWN;
constexpr Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_MAX = Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_REQUEST_AUTOCOMPLETE;
constexpr int Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_ARRAYSIZE = Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_MAX + 1;

const std::string& Fingerprint_MachineCharacteristics_BrowserFeature_Name(Fingerprint_MachineCharacteristics_BrowserFeature value);
template<typename T>
inline const std::string& Fingerprint_MachineCharacteristics_BrowserFeature_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Fingerprint_MachineCharacteristics_BrowserFeature>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Fingerprint_MachineCharacteristics_BrowserFeature_Name.");
  return Fingerprint_MachineCharacteristics_BrowserFeature_Name(static_cast<Fingerprint_MachineCharacteristics_BrowserFeature>(enum_t_value));
}
bool Fingerprint_MachineCharacteristics_BrowserFeature_Parse(
    const std::string& name, Fingerprint_MachineCharacteristics_BrowserFeature* value);
// ===================================================================

class Fingerprint_Dimension :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.Dimension) */ {
 public:
  Fingerprint_Dimension();
  virtual ~Fingerprint_Dimension();

  Fingerprint_Dimension(const Fingerprint_Dimension& from);
  Fingerprint_Dimension(Fingerprint_Dimension&& from) noexcept
    : Fingerprint_Dimension() {
    *this = ::std::move(from);
  }

  inline Fingerprint_Dimension& operator=(const Fingerprint_Dimension& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_Dimension& operator=(Fingerprint_Dimension&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Fingerprint_Dimension& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fingerprint_Dimension* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_Dimension*>(
               &_Fingerprint_Dimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Fingerprint_Dimension& a, Fingerprint_Dimension& b) {
    a.Swap(&b);
  }
  inline void Swap(Fingerprint_Dimension* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fingerprint_Dimension* New() const final {
    return CreateMaybeMessage<Fingerprint_Dimension>(nullptr);
  }

  Fingerprint_Dimension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fingerprint_Dimension>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Fingerprint_Dimension& from);
  void MergeFrom(const Fingerprint_Dimension& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_Dimension* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.Dimension";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // optional int32 width = 1;
  bool has_width() const;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 height = 2;
  bool has_height() const;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::int32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.Dimension)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_MachineCharacteristics_Plugin :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.MachineCharacteristics.Plugin) */ {
 public:
  Fingerprint_MachineCharacteristics_Plugin();
  virtual ~Fingerprint_MachineCharacteristics_Plugin();

  Fingerprint_MachineCharacteristics_Plugin(const Fingerprint_MachineCharacteristics_Plugin& from);
  Fingerprint_MachineCharacteristics_Plugin(Fingerprint_MachineCharacteristics_Plugin&& from) noexcept
    : Fingerprint_MachineCharacteristics_Plugin() {
    *this = ::std::move(from);
  }

  inline Fingerprint_MachineCharacteristics_Plugin& operator=(const Fingerprint_MachineCharacteristics_Plugin& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_MachineCharacteristics_Plugin& operator=(Fingerprint_MachineCharacteristics_Plugin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Fingerprint_MachineCharacteristics_Plugin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fingerprint_MachineCharacteristics_Plugin* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_MachineCharacteristics_Plugin*>(
               &_Fingerprint_MachineCharacteristics_Plugin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Fingerprint_MachineCharacteristics_Plugin& a, Fingerprint_MachineCharacteristics_Plugin& b) {
    a.Swap(&b);
  }
  inline void Swap(Fingerprint_MachineCharacteristics_Plugin* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fingerprint_MachineCharacteristics_Plugin* New() const final {
    return CreateMaybeMessage<Fingerprint_MachineCharacteristics_Plugin>(nullptr);
  }

  Fingerprint_MachineCharacteristics_Plugin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fingerprint_MachineCharacteristics_Plugin>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Fingerprint_MachineCharacteristics_Plugin& from);
  void MergeFrom(const Fingerprint_MachineCharacteristics_Plugin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_MachineCharacteristics_Plugin* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.MachineCharacteristics.Plugin";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMimeTypeFieldNumber = 3,
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kVersionFieldNumber = 4,
  };
  // repeated string mime_type = 3;
  int mime_type_size() const;
  void clear_mime_type();
  const std::string& mime_type(int index) const;
  std::string* mutable_mime_type(int index);
  void set_mime_type(int index, const std::string& value);
  void set_mime_type(int index, std::string&& value);
  void set_mime_type(int index, const char* value);
  void set_mime_type(int index, const char* value, size_t size);
  std::string* add_mime_type();
  void add_mime_type(const std::string& value);
  void add_mime_type(std::string&& value);
  void add_mime_type(const char* value);
  void add_mime_type(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& mime_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_mime_type();

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional string description = 2;
  bool has_description() const;
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);

  // optional string version = 4;
  bool has_version() const;
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> mime_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_MachineCharacteristics_Cpu :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.MachineCharacteristics.Cpu) */ {
 public:
  Fingerprint_MachineCharacteristics_Cpu();
  virtual ~Fingerprint_MachineCharacteristics_Cpu();

  Fingerprint_MachineCharacteristics_Cpu(const Fingerprint_MachineCharacteristics_Cpu& from);
  Fingerprint_MachineCharacteristics_Cpu(Fingerprint_MachineCharacteristics_Cpu&& from) noexcept
    : Fingerprint_MachineCharacteristics_Cpu() {
    *this = ::std::move(from);
  }

  inline Fingerprint_MachineCharacteristics_Cpu& operator=(const Fingerprint_MachineCharacteristics_Cpu& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_MachineCharacteristics_Cpu& operator=(Fingerprint_MachineCharacteristics_Cpu&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Fingerprint_MachineCharacteristics_Cpu& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fingerprint_MachineCharacteristics_Cpu* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_MachineCharacteristics_Cpu*>(
               &_Fingerprint_MachineCharacteristics_Cpu_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Fingerprint_MachineCharacteristics_Cpu& a, Fingerprint_MachineCharacteristics_Cpu& b) {
    a.Swap(&b);
  }
  inline void Swap(Fingerprint_MachineCharacteristics_Cpu* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fingerprint_MachineCharacteristics_Cpu* New() const final {
    return CreateMaybeMessage<Fingerprint_MachineCharacteristics_Cpu>(nullptr);
  }

  Fingerprint_MachineCharacteristics_Cpu* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fingerprint_MachineCharacteristics_Cpu>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Fingerprint_MachineCharacteristics_Cpu& from);
  void MergeFrom(const Fingerprint_MachineCharacteristics_Cpu& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_MachineCharacteristics_Cpu* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.MachineCharacteristics.Cpu";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVendorNameFieldNumber = 1,
    kBrandFieldNumber = 2,
  };
  // optional string vendor_name = 1;
  bool has_vendor_name() const;
  void clear_vendor_name();
  const std::string& vendor_name() const;
  void set_vendor_name(const std::string& value);
  void set_vendor_name(std::string&& value);
  void set_vendor_name(const char* value);
  void set_vendor_name(const char* value, size_t size);
  std::string* mutable_vendor_name();
  std::string* release_vendor_name();
  void set_allocated_vendor_name(std::string* vendor_name);

  // optional string brand = 2;
  bool has_brand() const;
  void clear_brand();
  const std::string& brand() const;
  void set_brand(const std::string& value);
  void set_brand(std::string&& value);
  void set_brand(const char* value);
  void set_brand(const char* value, size_t size);
  std::string* mutable_brand();
  std::string* release_brand();
  void set_allocated_brand(std::string* brand);

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr brand_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_MachineCharacteristics_Graphics :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.MachineCharacteristics.Graphics) */ {
 public:
  Fingerprint_MachineCharacteristics_Graphics();
  virtual ~Fingerprint_MachineCharacteristics_Graphics();

  Fingerprint_MachineCharacteristics_Graphics(const Fingerprint_MachineCharacteristics_Graphics& from);
  Fingerprint_MachineCharacteristics_Graphics(Fingerprint_MachineCharacteristics_Graphics&& from) noexcept
    : Fingerprint_MachineCharacteristics_Graphics() {
    *this = ::std::move(from);
  }

  inline Fingerprint_MachineCharacteristics_Graphics& operator=(const Fingerprint_MachineCharacteristics_Graphics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_MachineCharacteristics_Graphics& operator=(Fingerprint_MachineCharacteristics_Graphics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Fingerprint_MachineCharacteristics_Graphics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fingerprint_MachineCharacteristics_Graphics* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_MachineCharacteristics_Graphics*>(
               &_Fingerprint_MachineCharacteristics_Graphics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Fingerprint_MachineCharacteristics_Graphics& a, Fingerprint_MachineCharacteristics_Graphics& b) {
    a.Swap(&b);
  }
  inline void Swap(Fingerprint_MachineCharacteristics_Graphics* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fingerprint_MachineCharacteristics_Graphics* New() const final {
    return CreateMaybeMessage<Fingerprint_MachineCharacteristics_Graphics>(nullptr);
  }

  Fingerprint_MachineCharacteristics_Graphics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fingerprint_MachineCharacteristics_Graphics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Fingerprint_MachineCharacteristics_Graphics& from);
  void MergeFrom(const Fingerprint_MachineCharacteristics_Graphics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_MachineCharacteristics_Graphics* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.MachineCharacteristics.Graphics";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDriverVersionFieldNumber = 3,
    kDriverDateFieldNumber = 4,
    kVendorIdFieldNumber = 1,
    kDeviceIdFieldNumber = 2,
  };
  // optional string driver_version = 3;
  bool has_driver_version() const;
  void clear_driver_version();
  const std::string& driver_version() const;
  void set_driver_version(const std::string& value);
  void set_driver_version(std::string&& value);
  void set_driver_version(const char* value);
  void set_driver_version(const char* value, size_t size);
  std::string* mutable_driver_version();
  std::string* release_driver_version();
  void set_allocated_driver_version(std::string* driver_version);

  // optional string driver_date = 4;
  bool has_driver_date() const;
  void clear_driver_date();
  const std::string& driver_date() const;
  void set_driver_date(const std::string& value);
  void set_driver_date(std::string&& value);
  void set_driver_date(const char* value);
  void set_driver_date(const char* value, size_t size);
  std::string* mutable_driver_date();
  std::string* release_driver_date();
  void set_allocated_driver_date(std::string* driver_date);

  // optional uint32 vendor_id = 1;
  bool has_vendor_id() const;
  void clear_vendor_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 vendor_id() const;
  void set_vendor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 device_id = 2;
  bool has_device_id() const;
  void clear_device_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 device_id() const;
  void set_device_id(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_date_;
  ::PROTOBUF_NAMESPACE_ID::uint32 vendor_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 device_id_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_MachineCharacteristics :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.MachineCharacteristics) */ {
 public:
  Fingerprint_MachineCharacteristics();
  virtual ~Fingerprint_MachineCharacteristics();

  Fingerprint_MachineCharacteristics(const Fingerprint_MachineCharacteristics& from);
  Fingerprint_MachineCharacteristics(Fingerprint_MachineCharacteristics&& from) noexcept
    : Fingerprint_MachineCharacteristics() {
    *this = ::std::move(from);
  }

  inline Fingerprint_MachineCharacteristics& operator=(const Fingerprint_MachineCharacteristics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_MachineCharacteristics& operator=(Fingerprint_MachineCharacteristics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Fingerprint_MachineCharacteristics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fingerprint_MachineCharacteristics* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_MachineCharacteristics*>(
               &_Fingerprint_MachineCharacteristics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Fingerprint_MachineCharacteristics& a, Fingerprint_MachineCharacteristics& b) {
    a.Swap(&b);
  }
  inline void Swap(Fingerprint_MachineCharacteristics* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fingerprint_MachineCharacteristics* New() const final {
    return CreateMaybeMessage<Fingerprint_MachineCharacteristics>(nullptr);
  }

  Fingerprint_MachineCharacteristics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fingerprint_MachineCharacteristics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Fingerprint_MachineCharacteristics& from);
  void MergeFrom(const Fingerprint_MachineCharacteristics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_MachineCharacteristics* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.MachineCharacteristics";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Fingerprint_MachineCharacteristics_Plugin Plugin;
  typedef Fingerprint_MachineCharacteristics_Cpu Cpu;
  typedef Fingerprint_MachineCharacteristics_Graphics Graphics;

  typedef Fingerprint_MachineCharacteristics_BrowserFeature BrowserFeature;
  static constexpr BrowserFeature FEATURE_UNKNOWN =
    Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_UNKNOWN;
  static constexpr BrowserFeature DEPRECATED_FEATURE_AUTOCHECKOUT =
    Fingerprint_MachineCharacteristics_BrowserFeature_DEPRECATED_FEATURE_AUTOCHECKOUT;
  static constexpr BrowserFeature FEATURE_REQUEST_AUTOCOMPLETE =
    Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_REQUEST_AUTOCOMPLETE;
  static inline bool BrowserFeature_IsValid(int value) {
    return Fingerprint_MachineCharacteristics_BrowserFeature_IsValid(value);
  }
  static constexpr BrowserFeature BrowserFeature_MIN =
    Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_MIN;
  static constexpr BrowserFeature BrowserFeature_MAX =
    Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_MAX;
  static constexpr int BrowserFeature_ARRAYSIZE =
    Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_ARRAYSIZE;
  template<typename T>
  static inline const std::string& BrowserFeature_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BrowserFeature>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BrowserFeature_Name.");
    return Fingerprint_MachineCharacteristics_BrowserFeature_Name(enum_t_value);
  }
  static inline bool BrowserFeature_Parse(const std::string& name,
      BrowserFeature* value) {
    return Fingerprint_MachineCharacteristics_BrowserFeature_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFontFieldNumber = 4,
    kPluginFieldNumber = 5,
    kRequestedLanguageFieldNumber = 8,
    kPartitionSizeFieldNumber = 15,
    kOperatingSystemBuildFieldNumber = 2,
    kBrowserLanguageFieldNumber = 7,
    kCharsetFieldNumber = 9,
    kUserAgentFieldNumber = 14,
    kBrowserBuildFieldNumber = 19,
    kScreenSizeFieldNumber = 11,
    kUnavailableScreenSizeFieldNumber = 13,
    kCpuFieldNumber = 16,
    kGraphicsCardFieldNumber = 18,
    kUserAndDeviceNameHashFieldNumber = 1,
    kBrowserInstallTimeHoursFieldNumber = 3,
    kUtcOffsetMsFieldNumber = 6,
    kScreenCountFieldNumber = 10,
    kScreenColorDepthFieldNumber = 12,
    kRamFieldNumber = 17,
    kBrowserFeatureFieldNumber = 20,
  };
  // repeated string font = 4;
  int font_size() const;
  void clear_font();
  const std::string& font(int index) const;
  std::string* mutable_font(int index);
  void set_font(int index, const std::string& value);
  void set_font(int index, std::string&& value);
  void set_font(int index, const char* value);
  void set_font(int index, const char* value, size_t size);
  std::string* add_font();
  void add_font(const std::string& value);
  void add_font(std::string&& value);
  void add_font(const char* value);
  void add_font(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& font() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_font();

  // repeated .autofill.risk.Fingerprint.MachineCharacteristics.Plugin plugin = 5;
  int plugin_size() const;
  void clear_plugin();
  ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* mutable_plugin(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin >*
      mutable_plugin();
  const ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin& plugin(int index) const;
  ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* add_plugin();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin >&
      plugin() const;

  // repeated string requested_language = 8;
  int requested_language_size() const;
  void clear_requested_language();
  const std::string& requested_language(int index) const;
  std::string* mutable_requested_language(int index);
  void set_requested_language(int index, const std::string& value);
  void set_requested_language(int index, std::string&& value);
  void set_requested_language(int index, const char* value);
  void set_requested_language(int index, const char* value, size_t size);
  std::string* add_requested_language();
  void add_requested_language(const std::string& value);
  void add_requested_language(std::string&& value);
  void add_requested_language(const char* value);
  void add_requested_language(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& requested_language() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_requested_language();

  // repeated int32 partition_size = 15;
  int partition_size_size() const;
  void clear_partition_size();
  ::PROTOBUF_NAMESPACE_ID::int32 partition_size(int index) const;
  void set_partition_size(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_partition_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      partition_size() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_partition_size();

  // optional string operating_system_build = 2;
  bool has_operating_system_build() const;
  void clear_operating_system_build();
  const std::string& operating_system_build() const;
  void set_operating_system_build(const std::string& value);
  void set_operating_system_build(std::string&& value);
  void set_operating_system_build(const char* value);
  void set_operating_system_build(const char* value, size_t size);
  std::string* mutable_operating_system_build();
  std::string* release_operating_system_build();
  void set_allocated_operating_system_build(std::string* operating_system_build);

  // optional string browser_language = 7;
  bool has_browser_language() const;
  void clear_browser_language();
  const std::string& browser_language() const;
  void set_browser_language(const std::string& value);
  void set_browser_language(std::string&& value);
  void set_browser_language(const char* value);
  void set_browser_language(const char* value, size_t size);
  std::string* mutable_browser_language();
  std::string* release_browser_language();
  void set_allocated_browser_language(std::string* browser_language);

  // optional string charset = 9;
  bool has_charset() const;
  void clear_charset();
  const std::string& charset() const;
  void set_charset(const std::string& value);
  void set_charset(std::string&& value);
  void set_charset(const char* value);
  void set_charset(const char* value, size_t size);
  std::string* mutable_charset();
  std::string* release_charset();
  void set_allocated_charset(std::string* charset);

  // optional string user_agent = 14;
  bool has_user_agent() const;
  void clear_user_agent();
  const std::string& user_agent() const;
  void set_user_agent(const std::string& value);
  void set_user_agent(std::string&& value);
  void set_user_agent(const char* value);
  void set_user_agent(const char* value, size_t size);
  std::string* mutable_user_agent();
  std::string* release_user_agent();
  void set_allocated_user_agent(std::string* user_agent);

  // optional string browser_build = 19;
  bool has_browser_build() const;
  void clear_browser_build();
  const std::string& browser_build() const;
  void set_browser_build(const std::string& value);
  void set_browser_build(std::string&& value);
  void set_browser_build(const char* value);
  void set_browser_build(const char* value, size_t size);
  std::string* mutable_browser_build();
  std::string* release_browser_build();
  void set_allocated_browser_build(std::string* browser_build);

  // optional .autofill.risk.Fingerprint.Dimension screen_size = 11;
  bool has_screen_size() const;
  void clear_screen_size();
  const ::autofill::risk::Fingerprint_Dimension& screen_size() const;
  ::autofill::risk::Fingerprint_Dimension* release_screen_size();
  ::autofill::risk::Fingerprint_Dimension* mutable_screen_size();
  void set_allocated_screen_size(::autofill::risk::Fingerprint_Dimension* screen_size);

  // optional .autofill.risk.Fingerprint.Dimension unavailable_screen_size = 13;
  bool has_unavailable_screen_size() const;
  void clear_unavailable_screen_size();
  const ::autofill::risk::Fingerprint_Dimension& unavailable_screen_size() const;
  ::autofill::risk::Fingerprint_Dimension* release_unavailable_screen_size();
  ::autofill::risk::Fingerprint_Dimension* mutable_unavailable_screen_size();
  void set_allocated_unavailable_screen_size(::autofill::risk::Fingerprint_Dimension* unavailable_screen_size);

  // optional .autofill.risk.Fingerprint.MachineCharacteristics.Cpu cpu = 16;
  bool has_cpu() const;
  void clear_cpu();
  const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu& cpu() const;
  ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* release_cpu();
  ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* mutable_cpu();
  void set_allocated_cpu(::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* cpu);

  // optional .autofill.risk.Fingerprint.MachineCharacteristics.Graphics graphics_card = 18;
  bool has_graphics_card() const;
  void clear_graphics_card();
  const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics& graphics_card() const;
  ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* release_graphics_card();
  ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* mutable_graphics_card();
  void set_allocated_graphics_card(::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* graphics_card);

  // optional fixed64 user_and_device_name_hash = 1;
  bool has_user_and_device_name_hash() const;
  void clear_user_and_device_name_hash();
  ::PROTOBUF_NAMESPACE_ID::uint64 user_and_device_name_hash() const;
  void set_user_and_device_name_hash(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional int64 browser_install_time_hours = 3;
  bool has_browser_install_time_hours() const;
  void clear_browser_install_time_hours();
  ::PROTOBUF_NAMESPACE_ID::int64 browser_install_time_hours() const;
  void set_browser_install_time_hours(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 utc_offset_ms = 6;
  bool has_utc_offset_ms() const;
  void clear_utc_offset_ms();
  ::PROTOBUF_NAMESPACE_ID::int64 utc_offset_ms() const;
  void set_utc_offset_ms(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int32 screen_count = 10;
  bool has_screen_count() const;
  void clear_screen_count();
  ::PROTOBUF_NAMESPACE_ID::int32 screen_count() const;
  void set_screen_count(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 screen_color_depth = 12;
  bool has_screen_color_depth() const;
  void clear_screen_color_depth();
  ::PROTOBUF_NAMESPACE_ID::int32 screen_color_depth() const;
  void set_screen_color_depth(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int64 ram = 17;
  bool has_ram() const;
  void clear_ram();
  ::PROTOBUF_NAMESPACE_ID::int64 ram() const;
  void set_ram(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional .autofill.risk.Fingerprint.MachineCharacteristics.BrowserFeature browser_feature = 20;
  bool has_browser_feature() const;
  void clear_browser_feature();
  ::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature browser_feature() const;
  void set_browser_feature(::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature value);

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.MachineCharacteristics)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> font_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin > plugin_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> requested_language_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > partition_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operating_system_build_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browser_language_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr charset_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_agent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browser_build_;
  ::autofill::risk::Fingerprint_Dimension* screen_size_;
  ::autofill::risk::Fingerprint_Dimension* unavailable_screen_size_;
  ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* cpu_;
  ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* graphics_card_;
  ::PROTOBUF_NAMESPACE_ID::uint64 user_and_device_name_hash_;
  ::PROTOBUF_NAMESPACE_ID::int64 browser_install_time_hours_;
  ::PROTOBUF_NAMESPACE_ID::int64 utc_offset_ms_;
  ::PROTOBUF_NAMESPACE_ID::int32 screen_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 screen_color_depth_;
  ::PROTOBUF_NAMESPACE_ID::int64 ram_;
  int browser_feature_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_TransientState :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.TransientState) */ {
 public:
  Fingerprint_TransientState();
  virtual ~Fingerprint_TransientState();

  Fingerprint_TransientState(const Fingerprint_TransientState& from);
  Fingerprint_TransientState(Fingerprint_TransientState&& from) noexcept
    : Fingerprint_TransientState() {
    *this = ::std::move(from);
  }

  inline Fingerprint_TransientState& operator=(const Fingerprint_TransientState& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_TransientState& operator=(Fingerprint_TransientState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Fingerprint_TransientState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fingerprint_TransientState* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_TransientState*>(
               &_Fingerprint_TransientState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Fingerprint_TransientState& a, Fingerprint_TransientState& b) {
    a.Swap(&b);
  }
  inline void Swap(Fingerprint_TransientState* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fingerprint_TransientState* New() const final {
    return CreateMaybeMessage<Fingerprint_TransientState>(nullptr);
  }

  Fingerprint_TransientState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fingerprint_TransientState>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Fingerprint_TransientState& from);
  void MergeFrom(const Fingerprint_TransientState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_TransientState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.TransientState";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInnerWindowSizeFieldNumber = 1,
    kOuterWindowSizeFieldNumber = 2,
  };
  // optional .autofill.risk.Fingerprint.Dimension inner_window_size = 1;
  bool has_inner_window_size() const;
  void clear_inner_window_size();
  const ::autofill::risk::Fingerprint_Dimension& inner_window_size() const;
  ::autofill::risk::Fingerprint_Dimension* release_inner_window_size();
  ::autofill::risk::Fingerprint_Dimension* mutable_inner_window_size();
  void set_allocated_inner_window_size(::autofill::risk::Fingerprint_Dimension* inner_window_size);

  // optional .autofill.risk.Fingerprint.Dimension outer_window_size = 2;
  bool has_outer_window_size() const;
  void clear_outer_window_size();
  const ::autofill::risk::Fingerprint_Dimension& outer_window_size() const;
  ::autofill::risk::Fingerprint_Dimension* release_outer_window_size();
  ::autofill::risk::Fingerprint_Dimension* mutable_outer_window_size();
  void set_allocated_outer_window_size(::autofill::risk::Fingerprint_Dimension* outer_window_size);

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.TransientState)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill::risk::Fingerprint_Dimension* inner_window_size_;
  ::autofill::risk::Fingerprint_Dimension* outer_window_size_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_Performance :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.Performance) */ {
 public:
  Fingerprint_Performance();
  virtual ~Fingerprint_Performance();

  Fingerprint_Performance(const Fingerprint_Performance& from);
  Fingerprint_Performance(Fingerprint_Performance&& from) noexcept
    : Fingerprint_Performance() {
    *this = ::std::move(from);
  }

  inline Fingerprint_Performance& operator=(const Fingerprint_Performance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_Performance& operator=(Fingerprint_Performance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Fingerprint_Performance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fingerprint_Performance* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_Performance*>(
               &_Fingerprint_Performance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Fingerprint_Performance& a, Fingerprint_Performance& b) {
    a.Swap(&b);
  }
  inline void Swap(Fingerprint_Performance* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fingerprint_Performance* New() const final {
    return CreateMaybeMessage<Fingerprint_Performance>(nullptr);
  }

  Fingerprint_Performance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fingerprint_Performance>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Fingerprint_Performance& from);
  void MergeFrom(const Fingerprint_Performance& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_Performance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.Performance";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkTypeFieldNumber = 3,
    kBandwidthFieldNumber = 1,
    kMeteredFieldNumber = 2,
  };
  // optional string network_type = 3;
  bool has_network_type() const;
  void clear_network_type();
  const std::string& network_type() const;
  void set_network_type(const std::string& value);
  void set_network_type(std::string&& value);
  void set_network_type(const char* value);
  void set_network_type(const char* value, size_t size);
  std::string* mutable_network_type();
  std::string* release_network_type();
  void set_allocated_network_type(std::string* network_type);

  // optional float bandwidth = 1;
  bool has_bandwidth() const;
  void clear_bandwidth();
  float bandwidth() const;
  void set_bandwidth(float value);

  // optional bool metered = 2;
  bool has_metered() const;
  void clear_metered();
  bool metered() const;
  void set_metered(bool value);

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.Performance)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_type_;
  float bandwidth_;
  bool metered_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_UserCharacteristics_Vector :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.UserCharacteristics.Vector) */ {
 public:
  Fingerprint_UserCharacteristics_Vector();
  virtual ~Fingerprint_UserCharacteristics_Vector();

  Fingerprint_UserCharacteristics_Vector(const Fingerprint_UserCharacteristics_Vector& from);
  Fingerprint_UserCharacteristics_Vector(Fingerprint_UserCharacteristics_Vector&& from) noexcept
    : Fingerprint_UserCharacteristics_Vector() {
    *this = ::std::move(from);
  }

  inline Fingerprint_UserCharacteristics_Vector& operator=(const Fingerprint_UserCharacteristics_Vector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_UserCharacteristics_Vector& operator=(Fingerprint_UserCharacteristics_Vector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Fingerprint_UserCharacteristics_Vector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fingerprint_UserCharacteristics_Vector* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_UserCharacteristics_Vector*>(
               &_Fingerprint_UserCharacteristics_Vector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Fingerprint_UserCharacteristics_Vector& a, Fingerprint_UserCharacteristics_Vector& b) {
    a.Swap(&b);
  }
  inline void Swap(Fingerprint_UserCharacteristics_Vector* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fingerprint_UserCharacteristics_Vector* New() const final {
    return CreateMaybeMessage<Fingerprint_UserCharacteristics_Vector>(nullptr);
  }

  Fingerprint_UserCharacteristics_Vector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fingerprint_UserCharacteristics_Vector>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Fingerprint_UserCharacteristics_Vector& from);
  void MergeFrom(const Fingerprint_UserCharacteristics_Vector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_UserCharacteristics_Vector* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.UserCharacteristics.Vector";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional int32 x = 1;
  bool has_x() const;
  void clear_x();
  ::PROTOBUF_NAMESPACE_ID::int32 x() const;
  void set_x(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 y = 2;
  bool has_y() const;
  void clear_y();
  ::PROTOBUF_NAMESPACE_ID::int32 y() const;
  void set_y(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 z = 3;
  bool has_z() const;
  void clear_z();
  ::PROTOBUF_NAMESPACE_ID::int32 z() const;
  void set_z(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.UserCharacteristics.Vector)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 x_;
  ::PROTOBUF_NAMESPACE_ID::int32 y_;
  ::PROTOBUF_NAMESPACE_ID::int32 z_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_UserCharacteristics_Location :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.UserCharacteristics.Location) */ {
 public:
  Fingerprint_UserCharacteristics_Location();
  virtual ~Fingerprint_UserCharacteristics_Location();

  Fingerprint_UserCharacteristics_Location(const Fingerprint_UserCharacteristics_Location& from);
  Fingerprint_UserCharacteristics_Location(Fingerprint_UserCharacteristics_Location&& from) noexcept
    : Fingerprint_UserCharacteristics_Location() {
    *this = ::std::move(from);
  }

  inline Fingerprint_UserCharacteristics_Location& operator=(const Fingerprint_UserCharacteristics_Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_UserCharacteristics_Location& operator=(Fingerprint_UserCharacteristics_Location&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Fingerprint_UserCharacteristics_Location& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fingerprint_UserCharacteristics_Location* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_UserCharacteristics_Location*>(
               &_Fingerprint_UserCharacteristics_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Fingerprint_UserCharacteristics_Location& a, Fingerprint_UserCharacteristics_Location& b) {
    a.Swap(&b);
  }
  inline void Swap(Fingerprint_UserCharacteristics_Location* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fingerprint_UserCharacteristics_Location* New() const final {
    return CreateMaybeMessage<Fingerprint_UserCharacteristics_Location>(nullptr);
  }

  Fingerprint_UserCharacteristics_Location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fingerprint_UserCharacteristics_Location>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Fingerprint_UserCharacteristics_Location& from);
  void MergeFrom(const Fingerprint_UserCharacteristics_Location& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_UserCharacteristics_Location* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.UserCharacteristics.Location";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAltitudeFieldNumber = 1,
    kLatitudeFieldNumber = 2,
    kLongitudeFieldNumber = 3,
    kAccuracyFieldNumber = 4,
    kTimeInMsFieldNumber = 5,
  };
  // optional double altitude = 1;
  bool has_altitude() const;
  void clear_altitude();
  double altitude() const;
  void set_altitude(double value);

  // optional double latitude = 2;
  bool has_latitude() const;
  void clear_latitude();
  double latitude() const;
  void set_latitude(double value);

  // optional double longitude = 3;
  bool has_longitude() const;
  void clear_longitude();
  double longitude() const;
  void set_longitude(double value);

  // optional double accuracy = 4;
  bool has_accuracy() const;
  void clear_accuracy();
  double accuracy() const;
  void set_accuracy(double value);

  // optional int64 time_in_ms = 5;
  bool has_time_in_ms() const;
  void clear_time_in_ms();
  ::PROTOBUF_NAMESPACE_ID::int64 time_in_ms() const;
  void set_time_in_ms(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.UserCharacteristics.Location)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double altitude_;
  double latitude_;
  double longitude_;
  double accuracy_;
  ::PROTOBUF_NAMESPACE_ID::int64 time_in_ms_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_UserCharacteristics :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.UserCharacteristics) */ {
 public:
  Fingerprint_UserCharacteristics();
  virtual ~Fingerprint_UserCharacteristics();

  Fingerprint_UserCharacteristics(const Fingerprint_UserCharacteristics& from);
  Fingerprint_UserCharacteristics(Fingerprint_UserCharacteristics&& from) noexcept
    : Fingerprint_UserCharacteristics() {
    *this = ::std::move(from);
  }

  inline Fingerprint_UserCharacteristics& operator=(const Fingerprint_UserCharacteristics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_UserCharacteristics& operator=(Fingerprint_UserCharacteristics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Fingerprint_UserCharacteristics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fingerprint_UserCharacteristics* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_UserCharacteristics*>(
               &_Fingerprint_UserCharacteristics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Fingerprint_UserCharacteristics& a, Fingerprint_UserCharacteristics& b) {
    a.Swap(&b);
  }
  inline void Swap(Fingerprint_UserCharacteristics* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fingerprint_UserCharacteristics* New() const final {
    return CreateMaybeMessage<Fingerprint_UserCharacteristics>(nullptr);
  }

  Fingerprint_UserCharacteristics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fingerprint_UserCharacteristics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Fingerprint_UserCharacteristics& from);
  void MergeFrom(const Fingerprint_UserCharacteristics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_UserCharacteristics* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.UserCharacteristics";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Fingerprint_UserCharacteristics_Vector Vector;
  typedef Fingerprint_UserCharacteristics_Location Location;

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceOrientationFieldNumber = 5,
    kDeviceAccelerationFieldNumber = 6,
    kLocationFieldNumber = 7,
    kForceFieldNumber = 1,
    kTouchWidthFieldNumber = 2,
    kTouchHeightFieldNumber = 3,
    kTouchRotationFieldNumber = 4,
  };
  // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_orientation = 5;
  bool has_device_orientation() const;
  void clear_device_orientation();
  const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& device_orientation() const;
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* release_device_orientation();
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* mutable_device_orientation();
  void set_allocated_device_orientation(::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_orientation);

  // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_acceleration = 6;
  bool has_device_acceleration() const;
  void clear_device_acceleration();
  const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& device_acceleration() const;
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* release_device_acceleration();
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* mutable_device_acceleration();
  void set_allocated_device_acceleration(::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_acceleration);

  // optional .autofill.risk.Fingerprint.UserCharacteristics.Location location = 7;
  bool has_location() const;
  void clear_location();
  const ::autofill::risk::Fingerprint_UserCharacteristics_Location& location() const;
  ::autofill::risk::Fingerprint_UserCharacteristics_Location* release_location();
  ::autofill::risk::Fingerprint_UserCharacteristics_Location* mutable_location();
  void set_allocated_location(::autofill::risk::Fingerprint_UserCharacteristics_Location* location);

  // optional float force = 1;
  bool has_force() const;
  void clear_force();
  float force() const;
  void set_force(float value);

  // optional float touch_width = 2;
  bool has_touch_width() const;
  void clear_touch_width();
  float touch_width() const;
  void set_touch_width(float value);

  // optional float touch_height = 3;
  bool has_touch_height() const;
  void clear_touch_height();
  float touch_height() const;
  void set_touch_height(float value);

  // optional int32 touch_rotation = 4;
  bool has_touch_rotation() const;
  void clear_touch_rotation();
  ::PROTOBUF_NAMESPACE_ID::int32 touch_rotation() const;
  void set_touch_rotation(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.UserCharacteristics)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_orientation_;
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_acceleration_;
  ::autofill::risk::Fingerprint_UserCharacteristics_Location* location_;
  float force_;
  float touch_width_;
  float touch_height_;
  ::PROTOBUF_NAMESPACE_ID::int32 touch_rotation_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_Metadata :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.Metadata) */ {
 public:
  Fingerprint_Metadata();
  virtual ~Fingerprint_Metadata();

  Fingerprint_Metadata(const Fingerprint_Metadata& from);
  Fingerprint_Metadata(Fingerprint_Metadata&& from) noexcept
    : Fingerprint_Metadata() {
    *this = ::std::move(from);
  }

  inline Fingerprint_Metadata& operator=(const Fingerprint_Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_Metadata& operator=(Fingerprint_Metadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Fingerprint_Metadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fingerprint_Metadata* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_Metadata*>(
               &_Fingerprint_Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Fingerprint_Metadata& a, Fingerprint_Metadata& b) {
    a.Swap(&b);
  }
  inline void Swap(Fingerprint_Metadata* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fingerprint_Metadata* New() const final {
    return CreateMaybeMessage<Fingerprint_Metadata>(nullptr);
  }

  Fingerprint_Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fingerprint_Metadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Fingerprint_Metadata& from);
  void MergeFrom(const Fingerprint_Metadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_Metadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.Metadata";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsFieldNumber = 1,
    kObfuscatedGaiaIdFieldNumber = 2,
    kFingerprinterVersionFieldNumber = 3,
  };
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_ms() const;
  void set_timestamp_ms(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional uint64 obfuscated_gaia_id = 2;
  bool has_obfuscated_gaia_id() const;
  void clear_obfuscated_gaia_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 obfuscated_gaia_id() const;
  void set_obfuscated_gaia_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional int32 fingerprinter_version = 3;
  bool has_fingerprinter_version() const;
  void clear_fingerprinter_version();
  ::PROTOBUF_NAMESPACE_ID::int32 fingerprinter_version() const;
  void set_fingerprinter_version(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.Metadata)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_ms_;
  ::PROTOBUF_NAMESPACE_ID::uint64 obfuscated_gaia_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 fingerprinter_version_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint) */ {
 public:
  Fingerprint();
  virtual ~Fingerprint();

  Fingerprint(const Fingerprint& from);
  Fingerprint(Fingerprint&& from) noexcept
    : Fingerprint() {
    *this = ::std::move(from);
  }

  inline Fingerprint& operator=(const Fingerprint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint& operator=(Fingerprint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Fingerprint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fingerprint* internal_default_instance() {
    return reinterpret_cast<const Fingerprint*>(
               &_Fingerprint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Fingerprint& a, Fingerprint& b) {
    a.Swap(&b);
  }
  inline void Swap(Fingerprint* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fingerprint* New() const final {
    return CreateMaybeMessage<Fingerprint>(nullptr);
  }

  Fingerprint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fingerprint>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Fingerprint& from);
  void MergeFrom(const Fingerprint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Fingerprint_Dimension Dimension;
  typedef Fingerprint_MachineCharacteristics MachineCharacteristics;
  typedef Fingerprint_TransientState TransientState;
  typedef Fingerprint_Performance Performance;
  typedef Fingerprint_UserCharacteristics UserCharacteristics;
  typedef Fingerprint_Metadata Metadata;

  // accessors -------------------------------------------------------

  enum : int {
    kMachineCharacteristicsFieldNumber = 1,
    kPerformanceFieldNumber = 2,
    kUserCharacteristicsFieldNumber = 3,
    kTransientStateFieldNumber = 4,
    kMetadataFieldNumber = 5,
  };
  // optional .autofill.risk.Fingerprint.MachineCharacteristics machine_characteristics = 1;
  bool has_machine_characteristics() const;
  void clear_machine_characteristics();
  const ::autofill::risk::Fingerprint_MachineCharacteristics& machine_characteristics() const;
  ::autofill::risk::Fingerprint_MachineCharacteristics* release_machine_characteristics();
  ::autofill::risk::Fingerprint_MachineCharacteristics* mutable_machine_characteristics();
  void set_allocated_machine_characteristics(::autofill::risk::Fingerprint_MachineCharacteristics* machine_characteristics);

  // optional .autofill.risk.Fingerprint.Performance performance = 2;
  bool has_performance() const;
  void clear_performance();
  const ::autofill::risk::Fingerprint_Performance& performance() const;
  ::autofill::risk::Fingerprint_Performance* release_performance();
  ::autofill::risk::Fingerprint_Performance* mutable_performance();
  void set_allocated_performance(::autofill::risk::Fingerprint_Performance* performance);

  // optional .autofill.risk.Fingerprint.UserCharacteristics user_characteristics = 3;
  bool has_user_characteristics() const;
  void clear_user_characteristics();
  const ::autofill::risk::Fingerprint_UserCharacteristics& user_characteristics() const;
  ::autofill::risk::Fingerprint_UserCharacteristics* release_user_characteristics();
  ::autofill::risk::Fingerprint_UserCharacteristics* mutable_user_characteristics();
  void set_allocated_user_characteristics(::autofill::risk::Fingerprint_UserCharacteristics* user_characteristics);

  // optional .autofill.risk.Fingerprint.TransientState transient_state = 4;
  bool has_transient_state() const;
  void clear_transient_state();
  const ::autofill::risk::Fingerprint_TransientState& transient_state() const;
  ::autofill::risk::Fingerprint_TransientState* release_transient_state();
  ::autofill::risk::Fingerprint_TransientState* mutable_transient_state();
  void set_allocated_transient_state(::autofill::risk::Fingerprint_TransientState* transient_state);

  // optional .autofill.risk.Fingerprint.Metadata metadata = 5;
  bool has_metadata() const;
  void clear_metadata();
  const ::autofill::risk::Fingerprint_Metadata& metadata() const;
  ::autofill::risk::Fingerprint_Metadata* release_metadata();
  ::autofill::risk::Fingerprint_Metadata* mutable_metadata();
  void set_allocated_metadata(::autofill::risk::Fingerprint_Metadata* metadata);

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill::risk::Fingerprint_MachineCharacteristics* machine_characteristics_;
  ::autofill::risk::Fingerprint_Performance* performance_;
  ::autofill::risk::Fingerprint_UserCharacteristics* user_characteristics_;
  ::autofill::risk::Fingerprint_TransientState* transient_state_;
  ::autofill::risk::Fingerprint_Metadata* metadata_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Fingerprint_Dimension

// optional int32 width = 1;
inline bool Fingerprint_Dimension::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fingerprint_Dimension::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Fingerprint_Dimension::width() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Dimension.width)
  return width_;
}
inline void Fingerprint_Dimension::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  width_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Dimension.width)
}

// optional int32 height = 2;
inline bool Fingerprint_Dimension::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fingerprint_Dimension::clear_height() {
  height_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Fingerprint_Dimension::height() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Dimension.height)
  return height_;
}
inline void Fingerprint_Dimension::set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  height_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Dimension.height)
}

// -------------------------------------------------------------------

// Fingerprint_MachineCharacteristics_Plugin

// optional string name = 1;
inline bool Fingerprint_MachineCharacteristics_Plugin::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fingerprint_MachineCharacteristics_Plugin::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Fingerprint_MachineCharacteristics_Plugin::name() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
  return name_.GetNoArena();
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::release_name() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
}

// optional string description = 2;
inline bool Fingerprint_MachineCharacteristics_Plugin::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fingerprint_MachineCharacteristics_Plugin::clear_description() {
  description_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Fingerprint_MachineCharacteristics_Plugin::description() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
  return description_.GetNoArena();
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_description(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  description_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_description(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::mutable_description() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
  return description_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::release_description() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
  if (!has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return description_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  description_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
}

// repeated string mime_type = 3;
inline int Fingerprint_MachineCharacteristics_Plugin::mime_type_size() const {
  return mime_type_.size();
}
inline void Fingerprint_MachineCharacteristics_Plugin::clear_mime_type() {
  mime_type_.Clear();
}
inline const std::string& Fingerprint_MachineCharacteristics_Plugin::mime_type(int index) const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
  return mime_type_.Get(index);
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::mutable_mime_type(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
  return mime_type_.Mutable(index);
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_mime_type(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
  mime_type_.Mutable(index)->assign(value);
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_mime_type(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
  mime_type_.Mutable(index)->assign(std::move(value));
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_mime_type(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  mime_type_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_mime_type(int index, const char* value, size_t size) {
  mime_type_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::add_mime_type() {
  // @@protoc_insertion_point(field_add_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
  return mime_type_.Add();
}
inline void Fingerprint_MachineCharacteristics_Plugin::add_mime_type(const std::string& value) {
  mime_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline void Fingerprint_MachineCharacteristics_Plugin::add_mime_type(std::string&& value) {
  mime_type_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline void Fingerprint_MachineCharacteristics_Plugin::add_mime_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  mime_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline void Fingerprint_MachineCharacteristics_Plugin::add_mime_type(const char* value, size_t size) {
  mime_type_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Fingerprint_MachineCharacteristics_Plugin::mime_type() const {
  // @@protoc_insertion_point(field_list:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
  return mime_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Fingerprint_MachineCharacteristics_Plugin::mutable_mime_type() {
  // @@protoc_insertion_point(field_mutable_list:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
  return &mime_type_;
}

// optional string version = 4;
inline bool Fingerprint_MachineCharacteristics_Plugin::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Fingerprint_MachineCharacteristics_Plugin::clear_version() {
  version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Fingerprint_MachineCharacteristics_Plugin::version() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
  return version_.GetNoArena();
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_version(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::mutable_version() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
  return version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::release_version() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
  if (!has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
}

// -------------------------------------------------------------------

// Fingerprint_MachineCharacteristics_Cpu

// optional string vendor_name = 1;
inline bool Fingerprint_MachineCharacteristics_Cpu::has_vendor_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fingerprint_MachineCharacteristics_Cpu::clear_vendor_name() {
  vendor_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Fingerprint_MachineCharacteristics_Cpu::vendor_name() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
  return vendor_name_.GetNoArena();
}
inline void Fingerprint_MachineCharacteristics_Cpu::set_vendor_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  vendor_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
}
inline void Fingerprint_MachineCharacteristics_Cpu::set_vendor_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  vendor_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
}
inline void Fingerprint_MachineCharacteristics_Cpu::set_vendor_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  vendor_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
}
inline void Fingerprint_MachineCharacteristics_Cpu::set_vendor_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  vendor_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
}
inline std::string* Fingerprint_MachineCharacteristics_Cpu::mutable_vendor_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
  return vendor_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Fingerprint_MachineCharacteristics_Cpu::release_vendor_name() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
  if (!has_vendor_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return vendor_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Fingerprint_MachineCharacteristics_Cpu::set_allocated_vendor_name(std::string* vendor_name) {
  if (vendor_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  vendor_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vendor_name);
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
}

// optional string brand = 2;
inline bool Fingerprint_MachineCharacteristics_Cpu::has_brand() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fingerprint_MachineCharacteristics_Cpu::clear_brand() {
  brand_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Fingerprint_MachineCharacteristics_Cpu::brand() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
  return brand_.GetNoArena();
}
inline void Fingerprint_MachineCharacteristics_Cpu::set_brand(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  brand_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
}
inline void Fingerprint_MachineCharacteristics_Cpu::set_brand(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  brand_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
}
inline void Fingerprint_MachineCharacteristics_Cpu::set_brand(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  brand_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
}
inline void Fingerprint_MachineCharacteristics_Cpu::set_brand(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  brand_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
}
inline std::string* Fingerprint_MachineCharacteristics_Cpu::mutable_brand() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
  return brand_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Fingerprint_MachineCharacteristics_Cpu::release_brand() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
  if (!has_brand()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return brand_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Fingerprint_MachineCharacteristics_Cpu::set_allocated_brand(std::string* brand) {
  if (brand != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  brand_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), brand);
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
}

// -------------------------------------------------------------------

// Fingerprint_MachineCharacteristics_Graphics

// optional uint32 vendor_id = 1;
inline bool Fingerprint_MachineCharacteristics_Graphics::has_vendor_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Fingerprint_MachineCharacteristics_Graphics::clear_vendor_id() {
  vendor_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Fingerprint_MachineCharacteristics_Graphics::vendor_id() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.vendor_id)
  return vendor_id_;
}
inline void Fingerprint_MachineCharacteristics_Graphics::set_vendor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  vendor_id_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.vendor_id)
}

// optional uint32 device_id = 2;
inline bool Fingerprint_MachineCharacteristics_Graphics::has_device_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Fingerprint_MachineCharacteristics_Graphics::clear_device_id() {
  device_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Fingerprint_MachineCharacteristics_Graphics::device_id() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.device_id)
  return device_id_;
}
inline void Fingerprint_MachineCharacteristics_Graphics::set_device_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  device_id_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.device_id)
}

// optional string driver_version = 3;
inline bool Fingerprint_MachineCharacteristics_Graphics::has_driver_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fingerprint_MachineCharacteristics_Graphics::clear_driver_version() {
  driver_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Fingerprint_MachineCharacteristics_Graphics::driver_version() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
  return driver_version_.GetNoArena();
}
inline void Fingerprint_MachineCharacteristics_Graphics::set_driver_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  driver_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
}
inline void Fingerprint_MachineCharacteristics_Graphics::set_driver_version(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  driver_version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
}
inline void Fingerprint_MachineCharacteristics_Graphics::set_driver_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  driver_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
}
inline void Fingerprint_MachineCharacteristics_Graphics::set_driver_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  driver_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
}
inline std::string* Fingerprint_MachineCharacteristics_Graphics::mutable_driver_version() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
  return driver_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Fingerprint_MachineCharacteristics_Graphics::release_driver_version() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
  if (!has_driver_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return driver_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Fingerprint_MachineCharacteristics_Graphics::set_allocated_driver_version(std::string* driver_version) {
  if (driver_version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  driver_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), driver_version);
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
}

// optional string driver_date = 4;
inline bool Fingerprint_MachineCharacteristics_Graphics::has_driver_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fingerprint_MachineCharacteristics_Graphics::clear_driver_date() {
  driver_date_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Fingerprint_MachineCharacteristics_Graphics::driver_date() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
  return driver_date_.GetNoArena();
}
inline void Fingerprint_MachineCharacteristics_Graphics::set_driver_date(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  driver_date_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
}
inline void Fingerprint_MachineCharacteristics_Graphics::set_driver_date(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  driver_date_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
}
inline void Fingerprint_MachineCharacteristics_Graphics::set_driver_date(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  driver_date_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
}
inline void Fingerprint_MachineCharacteristics_Graphics::set_driver_date(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  driver_date_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
}
inline std::string* Fingerprint_MachineCharacteristics_Graphics::mutable_driver_date() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
  return driver_date_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Fingerprint_MachineCharacteristics_Graphics::release_driver_date() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
  if (!has_driver_date()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return driver_date_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Fingerprint_MachineCharacteristics_Graphics::set_allocated_driver_date(std::string* driver_date) {
  if (driver_date != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  driver_date_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), driver_date);
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
}

// -------------------------------------------------------------------

// Fingerprint_MachineCharacteristics

// optional fixed64 user_and_device_name_hash = 1;
inline bool Fingerprint_MachineCharacteristics::has_user_and_device_name_hash() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Fingerprint_MachineCharacteristics::clear_user_and_device_name_hash() {
  user_and_device_name_hash_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fingerprint_MachineCharacteristics::user_and_device_name_hash() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.user_and_device_name_hash)
  return user_and_device_name_hash_;
}
inline void Fingerprint_MachineCharacteristics::set_user_and_device_name_hash(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000200u;
  user_and_device_name_hash_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.user_and_device_name_hash)
}

// optional string operating_system_build = 2;
inline bool Fingerprint_MachineCharacteristics::has_operating_system_build() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fingerprint_MachineCharacteristics::clear_operating_system_build() {
  operating_system_build_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Fingerprint_MachineCharacteristics::operating_system_build() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
  return operating_system_build_.GetNoArena();
}
inline void Fingerprint_MachineCharacteristics::set_operating_system_build(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  operating_system_build_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
}
inline void Fingerprint_MachineCharacteristics::set_operating_system_build(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  operating_system_build_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
}
inline void Fingerprint_MachineCharacteristics::set_operating_system_build(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  operating_system_build_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
}
inline void Fingerprint_MachineCharacteristics::set_operating_system_build(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  operating_system_build_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
}
inline std::string* Fingerprint_MachineCharacteristics::mutable_operating_system_build() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
  return operating_system_build_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Fingerprint_MachineCharacteristics::release_operating_system_build() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
  if (!has_operating_system_build()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return operating_system_build_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Fingerprint_MachineCharacteristics::set_allocated_operating_system_build(std::string* operating_system_build) {
  if (operating_system_build != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  operating_system_build_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), operating_system_build);
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
}

// optional int64 browser_install_time_hours = 3;
inline bool Fingerprint_MachineCharacteristics::has_browser_install_time_hours() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Fingerprint_MachineCharacteristics::clear_browser_install_time_hours() {
  browser_install_time_hours_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Fingerprint_MachineCharacteristics::browser_install_time_hours() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.browser_install_time_hours)
  return browser_install_time_hours_;
}
inline void Fingerprint_MachineCharacteristics::set_browser_install_time_hours(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000400u;
  browser_install_time_hours_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.browser_install_time_hours)
}

// repeated string font = 4;
inline int Fingerprint_MachineCharacteristics::font_size() const {
  return font_.size();
}
inline void Fingerprint_MachineCharacteristics::clear_font() {
  font_.Clear();
}
inline const std::string& Fingerprint_MachineCharacteristics::font(int index) const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.font)
  return font_.Get(index);
}
inline std::string* Fingerprint_MachineCharacteristics::mutable_font(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.font)
  return font_.Mutable(index);
}
inline void Fingerprint_MachineCharacteristics::set_font(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.font)
  font_.Mutable(index)->assign(value);
}
inline void Fingerprint_MachineCharacteristics::set_font(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.font)
  font_.Mutable(index)->assign(std::move(value));
}
inline void Fingerprint_MachineCharacteristics::set_font(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  font_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline void Fingerprint_MachineCharacteristics::set_font(int index, const char* value, size_t size) {
  font_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline std::string* Fingerprint_MachineCharacteristics::add_font() {
  // @@protoc_insertion_point(field_add_mutable:autofill.risk.Fingerprint.MachineCharacteristics.font)
  return font_.Add();
}
inline void Fingerprint_MachineCharacteristics::add_font(const std::string& value) {
  font_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline void Fingerprint_MachineCharacteristics::add_font(std::string&& value) {
  font_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline void Fingerprint_MachineCharacteristics::add_font(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  font_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline void Fingerprint_MachineCharacteristics::add_font(const char* value, size_t size) {
  font_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Fingerprint_MachineCharacteristics::font() const {
  // @@protoc_insertion_point(field_list:autofill.risk.Fingerprint.MachineCharacteristics.font)
  return font_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Fingerprint_MachineCharacteristics::mutable_font() {
  // @@protoc_insertion_point(field_mutable_list:autofill.risk.Fingerprint.MachineCharacteristics.font)
  return &font_;
}

// repeated .autofill.risk.Fingerprint.MachineCharacteristics.Plugin plugin = 5;
inline int Fingerprint_MachineCharacteristics::plugin_size() const {
  return plugin_.size();
}
inline void Fingerprint_MachineCharacteristics::clear_plugin() {
  plugin_.Clear();
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* Fingerprint_MachineCharacteristics::mutable_plugin(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.plugin)
  return plugin_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin >*
Fingerprint_MachineCharacteristics::mutable_plugin() {
  // @@protoc_insertion_point(field_mutable_list:autofill.risk.Fingerprint.MachineCharacteristics.plugin)
  return &plugin_;
}
inline const ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin& Fingerprint_MachineCharacteristics::plugin(int index) const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.plugin)
  return plugin_.Get(index);
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* Fingerprint_MachineCharacteristics::add_plugin() {
  // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.plugin)
  return plugin_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin >&
Fingerprint_MachineCharacteristics::plugin() const {
  // @@protoc_insertion_point(field_list:autofill.risk.Fingerprint.MachineCharacteristics.plugin)
  return plugin_;
}

// optional int64 utc_offset_ms = 6;
inline bool Fingerprint_MachineCharacteristics::has_utc_offset_ms() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Fingerprint_MachineCharacteristics::clear_utc_offset_ms() {
  utc_offset_ms_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Fingerprint_MachineCharacteristics::utc_offset_ms() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.utc_offset_ms)
  return utc_offset_ms_;
}
inline void Fingerprint_MachineCharacteristics::set_utc_offset_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000800u;
  utc_offset_ms_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.utc_offset_ms)
}

// optional string browser_language = 7;
inline bool Fingerprint_MachineCharacteristics::has_browser_language() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fingerprint_MachineCharacteristics::clear_browser_language() {
  browser_language_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Fingerprint_MachineCharacteristics::browser_language() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
  return browser_language_.GetNoArena();
}
inline void Fingerprint_MachineCharacteristics::set_browser_language(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  browser_language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
}
inline void Fingerprint_MachineCharacteristics::set_browser_language(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  browser_language_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
}
inline void Fingerprint_MachineCharacteristics::set_browser_language(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  browser_language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
}
inline void Fingerprint_MachineCharacteristics::set_browser_language(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  browser_language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
}
inline std::string* Fingerprint_MachineCharacteristics::mutable_browser_language() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
  return browser_language_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Fingerprint_MachineCharacteristics::release_browser_language() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
  if (!has_browser_language()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return browser_language_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Fingerprint_MachineCharacteristics::set_allocated_browser_language(std::string* browser_language) {
  if (browser_language != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  browser_language_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), browser_language);
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
}

// repeated string requested_language = 8;
inline int Fingerprint_MachineCharacteristics::requested_language_size() const {
  return requested_language_.size();
}
inline void Fingerprint_MachineCharacteristics::clear_requested_language() {
  requested_language_.Clear();
}
inline const std::string& Fingerprint_MachineCharacteristics::requested_language(int index) const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
  return requested_language_.Get(index);
}
inline std::string* Fingerprint_MachineCharacteristics::mutable_requested_language(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
  return requested_language_.Mutable(index);
}
inline void Fingerprint_MachineCharacteristics::set_requested_language(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
  requested_language_.Mutable(index)->assign(value);
}
inline void Fingerprint_MachineCharacteristics::set_requested_language(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
  requested_language_.Mutable(index)->assign(std::move(value));
}
inline void Fingerprint_MachineCharacteristics::set_requested_language(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  requested_language_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline void Fingerprint_MachineCharacteristics::set_requested_language(int index, const char* value, size_t size) {
  requested_language_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline std::string* Fingerprint_MachineCharacteristics::add_requested_language() {
  // @@protoc_insertion_point(field_add_mutable:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
  return requested_language_.Add();
}
inline void Fingerprint_MachineCharacteristics::add_requested_language(const std::string& value) {
  requested_language_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline void Fingerprint_MachineCharacteristics::add_requested_language(std::string&& value) {
  requested_language_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline void Fingerprint_MachineCharacteristics::add_requested_language(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  requested_language_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline void Fingerprint_MachineCharacteristics::add_requested_language(const char* value, size_t size) {
  requested_language_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Fingerprint_MachineCharacteristics::requested_language() const {
  // @@protoc_insertion_point(field_list:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
  return requested_language_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Fingerprint_MachineCharacteristics::mutable_requested_language() {
  // @@protoc_insertion_point(field_mutable_list:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
  return &requested_language_;
}

// optional string charset = 9;
inline bool Fingerprint_MachineCharacteristics::has_charset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Fingerprint_MachineCharacteristics::clear_charset() {
  charset_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Fingerprint_MachineCharacteristics::charset() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.charset)
  return charset_.GetNoArena();
}
inline void Fingerprint_MachineCharacteristics::set_charset(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  charset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.charset)
}
inline void Fingerprint_MachineCharacteristics::set_charset(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  charset_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.risk.Fingerprint.MachineCharacteristics.charset)
}
inline void Fingerprint_MachineCharacteristics::set_charset(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  charset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.charset)
}
inline void Fingerprint_MachineCharacteristics::set_charset(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  charset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.charset)
}
inline std::string* Fingerprint_MachineCharacteristics::mutable_charset() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.charset)
  return charset_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Fingerprint_MachineCharacteristics::release_charset() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.charset)
  if (!has_charset()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return charset_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Fingerprint_MachineCharacteristics::set_allocated_charset(std::string* charset) {
  if (charset != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  charset_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), charset);
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.charset)
}

// optional int32 screen_count = 10;
inline bool Fingerprint_MachineCharacteristics::has_screen_count() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Fingerprint_MachineCharacteristics::clear_screen_count() {
  screen_count_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Fingerprint_MachineCharacteristics::screen_count() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.screen_count)
  return screen_count_;
}
inline void Fingerprint_MachineCharacteristics::set_screen_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00001000u;
  screen_count_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.screen_count)
}

// optional .autofill.risk.Fingerprint.Dimension screen_size = 11;
inline bool Fingerprint_MachineCharacteristics::has_screen_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Fingerprint_MachineCharacteristics::clear_screen_size() {
  if (screen_size_ != nullptr) screen_size_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_MachineCharacteristics::screen_size() const {
  const ::autofill::risk::Fingerprint_Dimension* p = screen_size_;
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.screen_size)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::risk::Fingerprint_Dimension*>(
      &::autofill::risk::_Fingerprint_Dimension_default_instance_);
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::release_screen_size() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.screen_size)
  _has_bits_[0] &= ~0x00000020u;
  ::autofill::risk::Fingerprint_Dimension* temp = screen_size_;
  screen_size_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::mutable_screen_size() {
  _has_bits_[0] |= 0x00000020u;
  if (screen_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_Dimension>(GetArenaNoVirtual());
    screen_size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.screen_size)
  return screen_size_;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_screen_size(::autofill::risk::Fingerprint_Dimension* screen_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete screen_size_;
  }
  if (screen_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      screen_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, screen_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  screen_size_ = screen_size;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.screen_size)
}

// optional int32 screen_color_depth = 12;
inline bool Fingerprint_MachineCharacteristics::has_screen_color_depth() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Fingerprint_MachineCharacteristics::clear_screen_color_depth() {
  screen_color_depth_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Fingerprint_MachineCharacteristics::screen_color_depth() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.screen_color_depth)
  return screen_color_depth_;
}
inline void Fingerprint_MachineCharacteristics::set_screen_color_depth(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00002000u;
  screen_color_depth_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.screen_color_depth)
}

// optional .autofill.risk.Fingerprint.Dimension unavailable_screen_size = 13;
inline bool Fingerprint_MachineCharacteristics::has_unavailable_screen_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Fingerprint_MachineCharacteristics::clear_unavailable_screen_size() {
  if (unavailable_screen_size_ != nullptr) unavailable_screen_size_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_MachineCharacteristics::unavailable_screen_size() const {
  const ::autofill::risk::Fingerprint_Dimension* p = unavailable_screen_size_;
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.unavailable_screen_size)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::risk::Fingerprint_Dimension*>(
      &::autofill::risk::_Fingerprint_Dimension_default_instance_);
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::release_unavailable_screen_size() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.unavailable_screen_size)
  _has_bits_[0] &= ~0x00000040u;
  ::autofill::risk::Fingerprint_Dimension* temp = unavailable_screen_size_;
  unavailable_screen_size_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::mutable_unavailable_screen_size() {
  _has_bits_[0] |= 0x00000040u;
  if (unavailable_screen_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_Dimension>(GetArenaNoVirtual());
    unavailable_screen_size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.unavailable_screen_size)
  return unavailable_screen_size_;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_unavailable_screen_size(::autofill::risk::Fingerprint_Dimension* unavailable_screen_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete unavailable_screen_size_;
  }
  if (unavailable_screen_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      unavailable_screen_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unavailable_screen_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  unavailable_screen_size_ = unavailable_screen_size;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.unavailable_screen_size)
}

// optional string user_agent = 14;
inline bool Fingerprint_MachineCharacteristics::has_user_agent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Fingerprint_MachineCharacteristics::clear_user_agent() {
  user_agent_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Fingerprint_MachineCharacteristics::user_agent() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
  return user_agent_.GetNoArena();
}
inline void Fingerprint_MachineCharacteristics::set_user_agent(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  user_agent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
}
inline void Fingerprint_MachineCharacteristics::set_user_agent(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  user_agent_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
}
inline void Fingerprint_MachineCharacteristics::set_user_agent(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  user_agent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
}
inline void Fingerprint_MachineCharacteristics::set_user_agent(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  user_agent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
}
inline std::string* Fingerprint_MachineCharacteristics::mutable_user_agent() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
  return user_agent_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Fingerprint_MachineCharacteristics::release_user_agent() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
  if (!has_user_agent()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return user_agent_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Fingerprint_MachineCharacteristics::set_allocated_user_agent(std::string* user_agent) {
  if (user_agent != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  user_agent_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_agent);
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
}

// repeated int32 partition_size = 15;
inline int Fingerprint_MachineCharacteristics::partition_size_size() const {
  return partition_size_.size();
}
inline void Fingerprint_MachineCharacteristics::clear_partition_size() {
  partition_size_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Fingerprint_MachineCharacteristics::partition_size(int index) const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.partition_size)
  return partition_size_.Get(index);
}
inline void Fingerprint_MachineCharacteristics::set_partition_size(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  partition_size_.Set(index, value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.partition_size)
}
inline void Fingerprint_MachineCharacteristics::add_partition_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  partition_size_.Add(value);
  // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.partition_size)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
Fingerprint_MachineCharacteristics::partition_size() const {
  // @@protoc_insertion_point(field_list:autofill.risk.Fingerprint.MachineCharacteristics.partition_size)
  return partition_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
Fingerprint_MachineCharacteristics::mutable_partition_size() {
  // @@protoc_insertion_point(field_mutable_list:autofill.risk.Fingerprint.MachineCharacteristics.partition_size)
  return &partition_size_;
}

// optional .autofill.risk.Fingerprint.MachineCharacteristics.Cpu cpu = 16;
inline bool Fingerprint_MachineCharacteristics::has_cpu() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Fingerprint_MachineCharacteristics::clear_cpu() {
  if (cpu_ != nullptr) cpu_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu& Fingerprint_MachineCharacteristics::cpu() const {
  const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* p = cpu_;
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.cpu)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu*>(
      &::autofill::risk::_Fingerprint_MachineCharacteristics_Cpu_default_instance_);
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* Fingerprint_MachineCharacteristics::release_cpu() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.cpu)
  _has_bits_[0] &= ~0x00000080u;
  ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* temp = cpu_;
  cpu_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* Fingerprint_MachineCharacteristics::mutable_cpu() {
  _has_bits_[0] |= 0x00000080u;
  if (cpu_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics_Cpu>(GetArenaNoVirtual());
    cpu_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.cpu)
  return cpu_;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_cpu(::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* cpu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cpu_;
  }
  if (cpu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cpu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cpu, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  cpu_ = cpu;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.cpu)
}

// optional int64 ram = 17;
inline bool Fingerprint_MachineCharacteristics::has_ram() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Fingerprint_MachineCharacteristics::clear_ram() {
  ram_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Fingerprint_MachineCharacteristics::ram() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.ram)
  return ram_;
}
inline void Fingerprint_MachineCharacteristics::set_ram(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00004000u;
  ram_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.ram)
}

// optional .autofill.risk.Fingerprint.MachineCharacteristics.Graphics graphics_card = 18;
inline bool Fingerprint_MachineCharacteristics::has_graphics_card() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Fingerprint_MachineCharacteristics::clear_graphics_card() {
  if (graphics_card_ != nullptr) graphics_card_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics& Fingerprint_MachineCharacteristics::graphics_card() const {
  const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* p = graphics_card_;
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.graphics_card)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics*>(
      &::autofill::risk::_Fingerprint_MachineCharacteristics_Graphics_default_instance_);
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* Fingerprint_MachineCharacteristics::release_graphics_card() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.graphics_card)
  _has_bits_[0] &= ~0x00000100u;
  ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* temp = graphics_card_;
  graphics_card_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* Fingerprint_MachineCharacteristics::mutable_graphics_card() {
  _has_bits_[0] |= 0x00000100u;
  if (graphics_card_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics_Graphics>(GetArenaNoVirtual());
    graphics_card_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.graphics_card)
  return graphics_card_;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_graphics_card(::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* graphics_card) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete graphics_card_;
  }
  if (graphics_card) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      graphics_card = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, graphics_card, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  graphics_card_ = graphics_card;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.graphics_card)
}

// optional string browser_build = 19;
inline bool Fingerprint_MachineCharacteristics::has_browser_build() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Fingerprint_MachineCharacteristics::clear_browser_build() {
  browser_build_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Fingerprint_MachineCharacteristics::browser_build() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
  return browser_build_.GetNoArena();
}
inline void Fingerprint_MachineCharacteristics::set_browser_build(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  browser_build_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
}
inline void Fingerprint_MachineCharacteristics::set_browser_build(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  browser_build_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
}
inline void Fingerprint_MachineCharacteristics::set_browser_build(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  browser_build_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
}
inline void Fingerprint_MachineCharacteristics::set_browser_build(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  browser_build_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
}
inline std::string* Fingerprint_MachineCharacteristics::mutable_browser_build() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
  return browser_build_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Fingerprint_MachineCharacteristics::release_browser_build() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
  if (!has_browser_build()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return browser_build_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Fingerprint_MachineCharacteristics::set_allocated_browser_build(std::string* browser_build) {
  if (browser_build != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  browser_build_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), browser_build);
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
}

// optional .autofill.risk.Fingerprint.MachineCharacteristics.BrowserFeature browser_feature = 20;
inline bool Fingerprint_MachineCharacteristics::has_browser_feature() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Fingerprint_MachineCharacteristics::clear_browser_feature() {
  browser_feature_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics::browser_feature() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.browser_feature)
  return static_cast< ::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature >(browser_feature_);
}
inline void Fingerprint_MachineCharacteristics::set_browser_feature(::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature value) {
  assert(::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature_IsValid(value));
  _has_bits_[0] |= 0x00008000u;
  browser_feature_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.browser_feature)
}

// -------------------------------------------------------------------

// Fingerprint_TransientState

// optional .autofill.risk.Fingerprint.Dimension inner_window_size = 1;
inline bool Fingerprint_TransientState::has_inner_window_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fingerprint_TransientState::clear_inner_window_size() {
  if (inner_window_size_ != nullptr) inner_window_size_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_TransientState::inner_window_size() const {
  const ::autofill::risk::Fingerprint_Dimension* p = inner_window_size_;
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.TransientState.inner_window_size)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::risk::Fingerprint_Dimension*>(
      &::autofill::risk::_Fingerprint_Dimension_default_instance_);
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::release_inner_window_size() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.TransientState.inner_window_size)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::risk::Fingerprint_Dimension* temp = inner_window_size_;
  inner_window_size_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::mutable_inner_window_size() {
  _has_bits_[0] |= 0x00000001u;
  if (inner_window_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_Dimension>(GetArenaNoVirtual());
    inner_window_size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.TransientState.inner_window_size)
  return inner_window_size_;
}
inline void Fingerprint_TransientState::set_allocated_inner_window_size(::autofill::risk::Fingerprint_Dimension* inner_window_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete inner_window_size_;
  }
  if (inner_window_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      inner_window_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inner_window_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  inner_window_size_ = inner_window_size;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.TransientState.inner_window_size)
}

// optional .autofill.risk.Fingerprint.Dimension outer_window_size = 2;
inline bool Fingerprint_TransientState::has_outer_window_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fingerprint_TransientState::clear_outer_window_size() {
  if (outer_window_size_ != nullptr) outer_window_size_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_TransientState::outer_window_size() const {
  const ::autofill::risk::Fingerprint_Dimension* p = outer_window_size_;
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.TransientState.outer_window_size)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::risk::Fingerprint_Dimension*>(
      &::autofill::risk::_Fingerprint_Dimension_default_instance_);
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::release_outer_window_size() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.TransientState.outer_window_size)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill::risk::Fingerprint_Dimension* temp = outer_window_size_;
  outer_window_size_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::mutable_outer_window_size() {
  _has_bits_[0] |= 0x00000002u;
  if (outer_window_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_Dimension>(GetArenaNoVirtual());
    outer_window_size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.TransientState.outer_window_size)
  return outer_window_size_;
}
inline void Fingerprint_TransientState::set_allocated_outer_window_size(::autofill::risk::Fingerprint_Dimension* outer_window_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete outer_window_size_;
  }
  if (outer_window_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      outer_window_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outer_window_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  outer_window_size_ = outer_window_size;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.TransientState.outer_window_size)
}

// -------------------------------------------------------------------

// Fingerprint_Performance

// optional float bandwidth = 1;
inline bool Fingerprint_Performance::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fingerprint_Performance::clear_bandwidth() {
  bandwidth_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Fingerprint_Performance::bandwidth() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Performance.bandwidth)
  return bandwidth_;
}
inline void Fingerprint_Performance::set_bandwidth(float value) {
  _has_bits_[0] |= 0x00000002u;
  bandwidth_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Performance.bandwidth)
}

// optional bool metered = 2;
inline bool Fingerprint_Performance::has_metered() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Fingerprint_Performance::clear_metered() {
  metered_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Fingerprint_Performance::metered() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Performance.metered)
  return metered_;
}
inline void Fingerprint_Performance::set_metered(bool value) {
  _has_bits_[0] |= 0x00000004u;
  metered_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Performance.metered)
}

// optional string network_type = 3;
inline bool Fingerprint_Performance::has_network_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fingerprint_Performance::clear_network_type() {
  network_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Fingerprint_Performance::network_type() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Performance.network_type)
  return network_type_.GetNoArena();
}
inline void Fingerprint_Performance::set_network_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  network_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Performance.network_type)
}
inline void Fingerprint_Performance::set_network_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  network_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autofill.risk.Fingerprint.Performance.network_type)
}
inline void Fingerprint_Performance::set_network_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  network_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.Performance.network_type)
}
inline void Fingerprint_Performance::set_network_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  network_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.Performance.network_type)
}
inline std::string* Fingerprint_Performance::mutable_network_type() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.Performance.network_type)
  return network_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Fingerprint_Performance::release_network_type() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.Performance.network_type)
  if (!has_network_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return network_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Fingerprint_Performance::set_allocated_network_type(std::string* network_type) {
  if (network_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  network_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), network_type);
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.Performance.network_type)
}

// -------------------------------------------------------------------

// Fingerprint_UserCharacteristics_Vector

// optional int32 x = 1;
inline bool Fingerprint_UserCharacteristics_Vector::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fingerprint_UserCharacteristics_Vector::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Fingerprint_UserCharacteristics_Vector::x() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Vector.x)
  return x_;
}
inline void Fingerprint_UserCharacteristics_Vector::set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Vector.x)
}

// optional int32 y = 2;
inline bool Fingerprint_UserCharacteristics_Vector::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fingerprint_UserCharacteristics_Vector::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Fingerprint_UserCharacteristics_Vector::y() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Vector.y)
  return y_;
}
inline void Fingerprint_UserCharacteristics_Vector::set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Vector.y)
}

// optional int32 z = 3;
inline bool Fingerprint_UserCharacteristics_Vector::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Fingerprint_UserCharacteristics_Vector::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Fingerprint_UserCharacteristics_Vector::z() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Vector.z)
  return z_;
}
inline void Fingerprint_UserCharacteristics_Vector::set_z(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Vector.z)
}

// -------------------------------------------------------------------

// Fingerprint_UserCharacteristics_Location

// optional double altitude = 1;
inline bool Fingerprint_UserCharacteristics_Location::has_altitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fingerprint_UserCharacteristics_Location::clear_altitude() {
  altitude_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Fingerprint_UserCharacteristics_Location::altitude() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Location.altitude)
  return altitude_;
}
inline void Fingerprint_UserCharacteristics_Location::set_altitude(double value) {
  _has_bits_[0] |= 0x00000001u;
  altitude_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Location.altitude)
}

// optional double latitude = 2;
inline bool Fingerprint_UserCharacteristics_Location::has_latitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fingerprint_UserCharacteristics_Location::clear_latitude() {
  latitude_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Fingerprint_UserCharacteristics_Location::latitude() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Location.latitude)
  return latitude_;
}
inline void Fingerprint_UserCharacteristics_Location::set_latitude(double value) {
  _has_bits_[0] |= 0x00000002u;
  latitude_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Location.latitude)
}

// optional double longitude = 3;
inline bool Fingerprint_UserCharacteristics_Location::has_longitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Fingerprint_UserCharacteristics_Location::clear_longitude() {
  longitude_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Fingerprint_UserCharacteristics_Location::longitude() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Location.longitude)
  return longitude_;
}
inline void Fingerprint_UserCharacteristics_Location::set_longitude(double value) {
  _has_bits_[0] |= 0x00000004u;
  longitude_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Location.longitude)
}

// optional double accuracy = 4;
inline bool Fingerprint_UserCharacteristics_Location::has_accuracy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Fingerprint_UserCharacteristics_Location::clear_accuracy() {
  accuracy_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double Fingerprint_UserCharacteristics_Location::accuracy() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Location.accuracy)
  return accuracy_;
}
inline void Fingerprint_UserCharacteristics_Location::set_accuracy(double value) {
  _has_bits_[0] |= 0x00000008u;
  accuracy_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Location.accuracy)
}

// optional int64 time_in_ms = 5;
inline bool Fingerprint_UserCharacteristics_Location::has_time_in_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Fingerprint_UserCharacteristics_Location::clear_time_in_ms() {
  time_in_ms_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Fingerprint_UserCharacteristics_Location::time_in_ms() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Location.time_in_ms)
  return time_in_ms_;
}
inline void Fingerprint_UserCharacteristics_Location::set_time_in_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  time_in_ms_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Location.time_in_ms)
}

// -------------------------------------------------------------------

// Fingerprint_UserCharacteristics

// optional float force = 1;
inline bool Fingerprint_UserCharacteristics::has_force() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Fingerprint_UserCharacteristics::clear_force() {
  force_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float Fingerprint_UserCharacteristics::force() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.force)
  return force_;
}
inline void Fingerprint_UserCharacteristics::set_force(float value) {
  _has_bits_[0] |= 0x00000008u;
  force_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.force)
}

// optional float touch_width = 2;
inline bool Fingerprint_UserCharacteristics::has_touch_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Fingerprint_UserCharacteristics::clear_touch_width() {
  touch_width_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float Fingerprint_UserCharacteristics::touch_width() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.touch_width)
  return touch_width_;
}
inline void Fingerprint_UserCharacteristics::set_touch_width(float value) {
  _has_bits_[0] |= 0x00000010u;
  touch_width_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.touch_width)
}

// optional float touch_height = 3;
inline bool Fingerprint_UserCharacteristics::has_touch_height() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Fingerprint_UserCharacteristics::clear_touch_height() {
  touch_height_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float Fingerprint_UserCharacteristics::touch_height() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.touch_height)
  return touch_height_;
}
inline void Fingerprint_UserCharacteristics::set_touch_height(float value) {
  _has_bits_[0] |= 0x00000020u;
  touch_height_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.touch_height)
}

// optional int32 touch_rotation = 4;
inline bool Fingerprint_UserCharacteristics::has_touch_rotation() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Fingerprint_UserCharacteristics::clear_touch_rotation() {
  touch_rotation_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Fingerprint_UserCharacteristics::touch_rotation() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.touch_rotation)
  return touch_rotation_;
}
inline void Fingerprint_UserCharacteristics::set_touch_rotation(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  touch_rotation_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.touch_rotation)
}

// optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_orientation = 5;
inline bool Fingerprint_UserCharacteristics::has_device_orientation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fingerprint_UserCharacteristics::clear_device_orientation() {
  if (device_orientation_ != nullptr) device_orientation_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& Fingerprint_UserCharacteristics::device_orientation() const {
  const ::autofill::risk::Fingerprint_UserCharacteristics_Vector* p = device_orientation_;
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.device_orientation)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::risk::Fingerprint_UserCharacteristics_Vector*>(
      &::autofill::risk::_Fingerprint_UserCharacteristics_Vector_default_instance_);
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::release_device_orientation() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.UserCharacteristics.device_orientation)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* temp = device_orientation_;
  device_orientation_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::mutable_device_orientation() {
  _has_bits_[0] |= 0x00000001u;
  if (device_orientation_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics_Vector>(GetArenaNoVirtual());
    device_orientation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.UserCharacteristics.device_orientation)
  return device_orientation_;
}
inline void Fingerprint_UserCharacteristics::set_allocated_device_orientation(::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_orientation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete device_orientation_;
  }
  if (device_orientation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      device_orientation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_orientation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  device_orientation_ = device_orientation;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.UserCharacteristics.device_orientation)
}

// optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_acceleration = 6;
inline bool Fingerprint_UserCharacteristics::has_device_acceleration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fingerprint_UserCharacteristics::clear_device_acceleration() {
  if (device_acceleration_ != nullptr) device_acceleration_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& Fingerprint_UserCharacteristics::device_acceleration() const {
  const ::autofill::risk::Fingerprint_UserCharacteristics_Vector* p = device_acceleration_;
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.device_acceleration)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::risk::Fingerprint_UserCharacteristics_Vector*>(
      &::autofill::risk::_Fingerprint_UserCharacteristics_Vector_default_instance_);
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::release_device_acceleration() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.UserCharacteristics.device_acceleration)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* temp = device_acceleration_;
  device_acceleration_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::mutable_device_acceleration() {
  _has_bits_[0] |= 0x00000002u;
  if (device_acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics_Vector>(GetArenaNoVirtual());
    device_acceleration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.UserCharacteristics.device_acceleration)
  return device_acceleration_;
}
inline void Fingerprint_UserCharacteristics::set_allocated_device_acceleration(::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete device_acceleration_;
  }
  if (device_acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      device_acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_acceleration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  device_acceleration_ = device_acceleration;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.UserCharacteristics.device_acceleration)
}

// optional .autofill.risk.Fingerprint.UserCharacteristics.Location location = 7;
inline bool Fingerprint_UserCharacteristics::has_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Fingerprint_UserCharacteristics::clear_location() {
  if (location_ != nullptr) location_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill::risk::Fingerprint_UserCharacteristics_Location& Fingerprint_UserCharacteristics::location() const {
  const ::autofill::risk::Fingerprint_UserCharacteristics_Location* p = location_;
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.location)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::risk::Fingerprint_UserCharacteristics_Location*>(
      &::autofill::risk::_Fingerprint_UserCharacteristics_Location_default_instance_);
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Location* Fingerprint_UserCharacteristics::release_location() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.UserCharacteristics.location)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill::risk::Fingerprint_UserCharacteristics_Location* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Location* Fingerprint_UserCharacteristics::mutable_location() {
  _has_bits_[0] |= 0x00000004u;
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics_Location>(GetArenaNoVirtual());
    location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.UserCharacteristics.location)
  return location_;
}
inline void Fingerprint_UserCharacteristics::set_allocated_location(::autofill::risk::Fingerprint_UserCharacteristics_Location* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.UserCharacteristics.location)
}

// -------------------------------------------------------------------

// Fingerprint_Metadata

// optional int64 timestamp_ms = 1;
inline bool Fingerprint_Metadata::has_timestamp_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fingerprint_Metadata::clear_timestamp_ms() {
  timestamp_ms_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Fingerprint_Metadata::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Metadata.timestamp_ms)
  return timestamp_ms_;
}
inline void Fingerprint_Metadata::set_timestamp_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  timestamp_ms_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Metadata.timestamp_ms)
}

// optional uint64 obfuscated_gaia_id = 2;
inline bool Fingerprint_Metadata::has_obfuscated_gaia_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fingerprint_Metadata::clear_obfuscated_gaia_id() {
  obfuscated_gaia_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fingerprint_Metadata::obfuscated_gaia_id() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Metadata.obfuscated_gaia_id)
  return obfuscated_gaia_id_;
}
inline void Fingerprint_Metadata::set_obfuscated_gaia_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  obfuscated_gaia_id_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Metadata.obfuscated_gaia_id)
}

// optional int32 fingerprinter_version = 3;
inline bool Fingerprint_Metadata::has_fingerprinter_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Fingerprint_Metadata::clear_fingerprinter_version() {
  fingerprinter_version_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Fingerprint_Metadata::fingerprinter_version() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Metadata.fingerprinter_version)
  return fingerprinter_version_;
}
inline void Fingerprint_Metadata::set_fingerprinter_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  fingerprinter_version_ = value;
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Metadata.fingerprinter_version)
}

// -------------------------------------------------------------------

// Fingerprint

// optional .autofill.risk.Fingerprint.MachineCharacteristics machine_characteristics = 1;
inline bool Fingerprint::has_machine_characteristics() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fingerprint::clear_machine_characteristics() {
  if (machine_characteristics_ != nullptr) machine_characteristics_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill::risk::Fingerprint_MachineCharacteristics& Fingerprint::machine_characteristics() const {
  const ::autofill::risk::Fingerprint_MachineCharacteristics* p = machine_characteristics_;
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.machine_characteristics)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::risk::Fingerprint_MachineCharacteristics*>(
      &::autofill::risk::_Fingerprint_MachineCharacteristics_default_instance_);
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics* Fingerprint::release_machine_characteristics() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.machine_characteristics)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::risk::Fingerprint_MachineCharacteristics* temp = machine_characteristics_;
  machine_characteristics_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics* Fingerprint::mutable_machine_characteristics() {
  _has_bits_[0] |= 0x00000001u;
  if (machine_characteristics_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics>(GetArenaNoVirtual());
    machine_characteristics_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.machine_characteristics)
  return machine_characteristics_;
}
inline void Fingerprint::set_allocated_machine_characteristics(::autofill::risk::Fingerprint_MachineCharacteristics* machine_characteristics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete machine_characteristics_;
  }
  if (machine_characteristics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      machine_characteristics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, machine_characteristics, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  machine_characteristics_ = machine_characteristics;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.machine_characteristics)
}

// optional .autofill.risk.Fingerprint.Performance performance = 2;
inline bool Fingerprint::has_performance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fingerprint::clear_performance() {
  if (performance_ != nullptr) performance_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill::risk::Fingerprint_Performance& Fingerprint::performance() const {
  const ::autofill::risk::Fingerprint_Performance* p = performance_;
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.performance)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::risk::Fingerprint_Performance*>(
      &::autofill::risk::_Fingerprint_Performance_default_instance_);
}
inline ::autofill::risk::Fingerprint_Performance* Fingerprint::release_performance() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.performance)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill::risk::Fingerprint_Performance* temp = performance_;
  performance_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_Performance* Fingerprint::mutable_performance() {
  _has_bits_[0] |= 0x00000002u;
  if (performance_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_Performance>(GetArenaNoVirtual());
    performance_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.performance)
  return performance_;
}
inline void Fingerprint::set_allocated_performance(::autofill::risk::Fingerprint_Performance* performance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete performance_;
  }
  if (performance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      performance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, performance, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  performance_ = performance;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.performance)
}

// optional .autofill.risk.Fingerprint.UserCharacteristics user_characteristics = 3;
inline bool Fingerprint::has_user_characteristics() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Fingerprint::clear_user_characteristics() {
  if (user_characteristics_ != nullptr) user_characteristics_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill::risk::Fingerprint_UserCharacteristics& Fingerprint::user_characteristics() const {
  const ::autofill::risk::Fingerprint_UserCharacteristics* p = user_characteristics_;
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.user_characteristics)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::risk::Fingerprint_UserCharacteristics*>(
      &::autofill::risk::_Fingerprint_UserCharacteristics_default_instance_);
}
inline ::autofill::risk::Fingerprint_UserCharacteristics* Fingerprint::release_user_characteristics() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.user_characteristics)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill::risk::Fingerprint_UserCharacteristics* temp = user_characteristics_;
  user_characteristics_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics* Fingerprint::mutable_user_characteristics() {
  _has_bits_[0] |= 0x00000004u;
  if (user_characteristics_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics>(GetArenaNoVirtual());
    user_characteristics_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.user_characteristics)
  return user_characteristics_;
}
inline void Fingerprint::set_allocated_user_characteristics(::autofill::risk::Fingerprint_UserCharacteristics* user_characteristics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete user_characteristics_;
  }
  if (user_characteristics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      user_characteristics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_characteristics, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  user_characteristics_ = user_characteristics;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.user_characteristics)
}

// optional .autofill.risk.Fingerprint.TransientState transient_state = 4;
inline bool Fingerprint::has_transient_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Fingerprint::clear_transient_state() {
  if (transient_state_ != nullptr) transient_state_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::autofill::risk::Fingerprint_TransientState& Fingerprint::transient_state() const {
  const ::autofill::risk::Fingerprint_TransientState* p = transient_state_;
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.transient_state)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::risk::Fingerprint_TransientState*>(
      &::autofill::risk::_Fingerprint_TransientState_default_instance_);
}
inline ::autofill::risk::Fingerprint_TransientState* Fingerprint::release_transient_state() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.transient_state)
  _has_bits_[0] &= ~0x00000008u;
  ::autofill::risk::Fingerprint_TransientState* temp = transient_state_;
  transient_state_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_TransientState* Fingerprint::mutable_transient_state() {
  _has_bits_[0] |= 0x00000008u;
  if (transient_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_TransientState>(GetArenaNoVirtual());
    transient_state_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.transient_state)
  return transient_state_;
}
inline void Fingerprint::set_allocated_transient_state(::autofill::risk::Fingerprint_TransientState* transient_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete transient_state_;
  }
  if (transient_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      transient_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transient_state, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  transient_state_ = transient_state;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.transient_state)
}

// optional .autofill.risk.Fingerprint.Metadata metadata = 5;
inline bool Fingerprint::has_metadata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Fingerprint::clear_metadata() {
  if (metadata_ != nullptr) metadata_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::autofill::risk::Fingerprint_Metadata& Fingerprint::metadata() const {
  const ::autofill::risk::Fingerprint_Metadata* p = metadata_;
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.metadata)
  return p != nullptr ? *p : *reinterpret_cast<const ::autofill::risk::Fingerprint_Metadata*>(
      &::autofill::risk::_Fingerprint_Metadata_default_instance_);
}
inline ::autofill::risk::Fingerprint_Metadata* Fingerprint::release_metadata() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.metadata)
  _has_bits_[0] &= ~0x00000010u;
  ::autofill::risk::Fingerprint_Metadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_Metadata* Fingerprint::mutable_metadata() {
  _has_bits_[0] |= 0x00000010u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_Metadata>(GetArenaNoVirtual());
    metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.metadata)
  return metadata_;
}
inline void Fingerprint::set_allocated_metadata(::autofill::risk::Fingerprint_Metadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.metadata)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace risk
}  // namespace autofill

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_fingerprint_2eproto
