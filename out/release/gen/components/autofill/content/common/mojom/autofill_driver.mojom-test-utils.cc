// components/autofill/content/common/mojom/autofill_driver.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif


#include "components/autofill/content/common/mojom/autofill_driver.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"
#include "components/autofill/core/common/mojom/autofill_types.mojom.h"
#include "mojo/public/mojom/base/string16.mojom.h"
#include "mojo/public/mojom/base/text_direction.mojom.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "ui/gfx/geometry/mojom/geometry.mojom.h"
#include "url/mojom/url.mojom.h"


#ifndef COMPONENTS_AUTOFILL_CONTENT_COMMON_MOJOM_AUTOFILL_DRIVER_MOJOM_JUMBO_H_
#define COMPONENTS_AUTOFILL_CONTENT_COMMON_MOJOM_AUTOFILL_DRIVER_MOJOM_JUMBO_H_
#include "components/autofill/core/common/mojom/autofill_types_mojom_traits.h"
#include "mojo/public/cpp/base/string16_mojom_traits.h"
#include "mojo/public/cpp/base/text_direction_mojom_traits.h"
#include "mojo/public/cpp/base/time_mojom_traits.h"
#include "mojo/public/cpp/base/unguessable_token_mojom_traits.h"
#include "ui/gfx/geometry/mojom/geometry_mojom_traits.h"
#include "url/mojom/origin_mojom_traits.h"
#include "url/mojom/url_gurl_mojom_traits.h"
#endif


namespace autofill {
namespace mojom {


void AutofillDriverInterceptorForTesting::FormsSeen(const std::vector<::autofill::FormData>& forms, ::base::TimeTicks timestamp) {
  GetForwardingInterface()->FormsSeen(std::move(forms), std::move(timestamp));
}
void AutofillDriverInterceptorForTesting::FormSubmitted(const ::autofill::FormData& form, bool known_success, ::autofill::mojom::SubmissionSource source) {
  GetForwardingInterface()->FormSubmitted(std::move(form), std::move(known_success), std::move(source));
}
void AutofillDriverInterceptorForTesting::TextFieldDidChange(const ::autofill::FormData& form, const ::autofill::FormFieldData& field, const ::gfx::RectF& bounding_box, ::base::TimeTicks timestamp) {
  GetForwardingInterface()->TextFieldDidChange(std::move(form), std::move(field), std::move(bounding_box), std::move(timestamp));
}
void AutofillDriverInterceptorForTesting::TextFieldDidScroll(const ::autofill::FormData& form, const ::autofill::FormFieldData& field, const ::gfx::RectF& bounding_box) {
  GetForwardingInterface()->TextFieldDidScroll(std::move(form), std::move(field), std::move(bounding_box));
}
void AutofillDriverInterceptorForTesting::SelectControlDidChange(const ::autofill::FormData& form, const ::autofill::FormFieldData& field, const ::gfx::RectF& bounding_box) {
  GetForwardingInterface()->SelectControlDidChange(std::move(form), std::move(field), std::move(bounding_box));
}
void AutofillDriverInterceptorForTesting::SelectFieldOptionsDidChange(const ::autofill::FormData& form) {
  GetForwardingInterface()->SelectFieldOptionsDidChange(std::move(form));
}
void AutofillDriverInterceptorForTesting::QueryFormFieldAutofill(int32_t id, const ::autofill::FormData& form, const ::autofill::FormFieldData& field, const ::gfx::RectF& bounding_box, bool autoselect_first_suggestion) {
  GetForwardingInterface()->QueryFormFieldAutofill(std::move(id), std::move(form), std::move(field), std::move(bounding_box), std::move(autoselect_first_suggestion));
}
void AutofillDriverInterceptorForTesting::HidePopup() {
  GetForwardingInterface()->HidePopup();
}
void AutofillDriverInterceptorForTesting::FocusNoLongerOnForm() {
  GetForwardingInterface()->FocusNoLongerOnForm();
}
void AutofillDriverInterceptorForTesting::FocusOnFormField(const ::autofill::FormData& form, const ::autofill::FormFieldData& field, const ::gfx::RectF& bounding_box) {
  GetForwardingInterface()->FocusOnFormField(std::move(form), std::move(field), std::move(bounding_box));
}
void AutofillDriverInterceptorForTesting::DidFillAutofillFormData(const ::autofill::FormData& form, ::base::TimeTicks timestamp) {
  GetForwardingInterface()->DidFillAutofillFormData(std::move(form), std::move(timestamp));
}
void AutofillDriverInterceptorForTesting::DidPreviewAutofillFormData() {
  GetForwardingInterface()->DidPreviewAutofillFormData();
}
void AutofillDriverInterceptorForTesting::DidEndTextFieldEditing() {
  GetForwardingInterface()->DidEndTextFieldEditing();
}
void AutofillDriverInterceptorForTesting::SetDataList(const std::vector<::base::string16>& values, const std::vector<::base::string16>& labels) {
  GetForwardingInterface()->SetDataList(std::move(values), std::move(labels));
}
AutofillDriverAsyncWaiter::AutofillDriverAsyncWaiter(
    AutofillDriver* proxy) : proxy_(proxy) {}

AutofillDriverAsyncWaiter::~AutofillDriverAsyncWaiter() = default;




void PasswordManagerDriverInterceptorForTesting::PasswordFormsParsed(const std::vector<::autofill::FormData>& forms_data) {
  GetForwardingInterface()->PasswordFormsParsed(std::move(forms_data));
}
void PasswordManagerDriverInterceptorForTesting::PasswordFormsRendered(const std::vector<::autofill::FormData>& visible_forms_data, bool did_stop_loading) {
  GetForwardingInterface()->PasswordFormsRendered(std::move(visible_forms_data), std::move(did_stop_loading));
}
void PasswordManagerDriverInterceptorForTesting::PasswordFormSubmitted(const ::autofill::FormData& form_data) {
  GetForwardingInterface()->PasswordFormSubmitted(std::move(form_data));
}
void PasswordManagerDriverInterceptorForTesting::ShowManualFallbackForSaving(const ::autofill::FormData& form_data) {
  GetForwardingInterface()->ShowManualFallbackForSaving(std::move(form_data));
}
void PasswordManagerDriverInterceptorForTesting::HideManualFallbackForSaving() {
  GetForwardingInterface()->HideManualFallbackForSaving();
}
void PasswordManagerDriverInterceptorForTesting::SameDocumentNavigation(::autofill::mojom::SubmissionIndicatorEvent submission_indication_event) {
  GetForwardingInterface()->SameDocumentNavigation(std::move(submission_indication_event));
}
void PasswordManagerDriverInterceptorForTesting::RecordSavePasswordProgress(const std::string& log) {
  GetForwardingInterface()->RecordSavePasswordProgress(std::move(log));
}
void PasswordManagerDriverInterceptorForTesting::UserModifiedPasswordField() {
  GetForwardingInterface()->UserModifiedPasswordField();
}
void PasswordManagerDriverInterceptorForTesting::UserModifiedNonPasswordField(uint32_t renderer_id, const ::base::string16& value) {
  GetForwardingInterface()->UserModifiedNonPasswordField(std::move(renderer_id), std::move(value));
}
void PasswordManagerDriverInterceptorForTesting::ShowPasswordSuggestions(::base::i18n::TextDirection text_direction, const ::base::string16& typed_username, int32_t options, const ::gfx::RectF& bounds) {
  GetForwardingInterface()->ShowPasswordSuggestions(std::move(text_direction), std::move(typed_username), std::move(options), std::move(bounds));
}
void PasswordManagerDriverInterceptorForTesting::ShowTouchToFill() {
  GetForwardingInterface()->ShowTouchToFill();
}
void PasswordManagerDriverInterceptorForTesting::CheckSafeBrowsingReputation(const ::GURL& form_action, const ::GURL& frame_url) {
  GetForwardingInterface()->CheckSafeBrowsingReputation(std::move(form_action), std::move(frame_url));
}
void PasswordManagerDriverInterceptorForTesting::FocusedInputChanged(::autofill::mojom::FocusedFieldType focused_field_type) {
  GetForwardingInterface()->FocusedInputChanged(std::move(focused_field_type));
}
void PasswordManagerDriverInterceptorForTesting::LogFirstFillingResult(uint32_t form_renderer_id, int32_t result) {
  GetForwardingInterface()->LogFirstFillingResult(std::move(form_renderer_id), std::move(result));
}
PasswordManagerDriverAsyncWaiter::PasswordManagerDriverAsyncWaiter(
    PasswordManagerDriver* proxy) : proxy_(proxy) {}

PasswordManagerDriverAsyncWaiter::~PasswordManagerDriverAsyncWaiter() = default;




void PasswordGenerationDriverInterceptorForTesting::AutomaticGenerationAvailable(const ::autofill::password_generation::PasswordGenerationUIData& password_generation_ui_data) {
  GetForwardingInterface()->AutomaticGenerationAvailable(std::move(password_generation_ui_data));
}
void PasswordGenerationDriverInterceptorForTesting::ShowPasswordEditingPopup(const ::gfx::RectF& bounds, const ::autofill::FormData& form_data, uint32_t field_renderer_id, const ::base::string16& password_value) {
  GetForwardingInterface()->ShowPasswordEditingPopup(std::move(bounds), std::move(form_data), std::move(field_renderer_id), std::move(password_value));
}
void PasswordGenerationDriverInterceptorForTesting::PasswordGenerationRejectedByTyping() {
  GetForwardingInterface()->PasswordGenerationRejectedByTyping();
}
void PasswordGenerationDriverInterceptorForTesting::PresaveGeneratedPassword(const ::autofill::FormData& form_data, const ::base::string16& password_value) {
  GetForwardingInterface()->PresaveGeneratedPassword(std::move(form_data), std::move(password_value));
}
void PasswordGenerationDriverInterceptorForTesting::PasswordNoLongerGenerated(const ::autofill::FormData& form_data) {
  GetForwardingInterface()->PasswordNoLongerGenerated(std::move(form_data));
}
void PasswordGenerationDriverInterceptorForTesting::FrameWasScrolled() {
  GetForwardingInterface()->FrameWasScrolled();
}
void PasswordGenerationDriverInterceptorForTesting::GenerationElementLostFocus() {
  GetForwardingInterface()->GenerationElementLostFocus();
}
PasswordGenerationDriverAsyncWaiter::PasswordGenerationDriverAsyncWaiter(
    PasswordGenerationDriver* proxy) : proxy_(proxy) {}

PasswordGenerationDriverAsyncWaiter::~PasswordGenerationDriverAsyncWaiter() = default;






}  // namespace mojom
}  // namespace autofill

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif