// components/autofill/content/common/mojom/autofill_agent.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif


#include "components/autofill/content/common/mojom/autofill_agent.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"
#include "components/autofill/core/common/mojom/autofill_types.mojom.h"
#include "mojo/public/mojom/base/string16.mojom.h"


#ifndef COMPONENTS_AUTOFILL_CONTENT_COMMON_MOJOM_AUTOFILL_AGENT_MOJOM_JUMBO_H_
#define COMPONENTS_AUTOFILL_CONTENT_COMMON_MOJOM_AUTOFILL_AGENT_MOJOM_JUMBO_H_
#include "components/autofill/core/common/mojom/autofill_types_mojom_traits.h"
#include "mojo/public/cpp/base/string16_mojom_traits.h"
#include "mojo/public/cpp/base/text_direction_mojom_traits.h"
#include "mojo/public/cpp/base/unguessable_token_mojom_traits.h"
#include "ui/gfx/geometry/mojom/geometry_mojom_traits.h"
#include "url/mojom/origin_mojom_traits.h"
#include "url/mojom/url_gurl_mojom_traits.h"
#endif


namespace autofill {
namespace mojom {


void AutofillAgentInterceptorForTesting::FillForm(int32_t id, const ::autofill::FormData& form) {
  GetForwardingInterface()->FillForm(std::move(id), std::move(form));
}
void AutofillAgentInterceptorForTesting::PreviewForm(int32_t id, const ::autofill::FormData& form) {
  GetForwardingInterface()->PreviewForm(std::move(id), std::move(form));
}
void AutofillAgentInterceptorForTesting::FieldTypePredictionsAvailable(const std::vector<::autofill::FormDataPredictions>& forms) {
  GetForwardingInterface()->FieldTypePredictionsAvailable(std::move(forms));
}
void AutofillAgentInterceptorForTesting::ClearSection() {
  GetForwardingInterface()->ClearSection();
}
void AutofillAgentInterceptorForTesting::ClearPreviewedForm() {
  GetForwardingInterface()->ClearPreviewedForm();
}
void AutofillAgentInterceptorForTesting::FillFieldWithValue(const ::base::string16& value) {
  GetForwardingInterface()->FillFieldWithValue(std::move(value));
}
void AutofillAgentInterceptorForTesting::PreviewFieldWithValue(const ::base::string16& value) {
  GetForwardingInterface()->PreviewFieldWithValue(std::move(value));
}
void AutofillAgentInterceptorForTesting::SetSuggestionAvailability(::autofill::mojom::AutofillState type) {
  GetForwardingInterface()->SetSuggestionAvailability(std::move(type));
}
void AutofillAgentInterceptorForTesting::AcceptDataListSuggestion(const ::base::string16& value) {
  GetForwardingInterface()->AcceptDataListSuggestion(std::move(value));
}
void AutofillAgentInterceptorForTesting::FillPasswordSuggestion(const ::base::string16& username, const ::base::string16& password) {
  GetForwardingInterface()->FillPasswordSuggestion(std::move(username), std::move(password));
}
void AutofillAgentInterceptorForTesting::PreviewPasswordSuggestion(const ::base::string16& username, const ::base::string16& password) {
  GetForwardingInterface()->PreviewPasswordSuggestion(std::move(username), std::move(password));
}
void AutofillAgentInterceptorForTesting::SetUserGestureRequired(bool required) {
  GetForwardingInterface()->SetUserGestureRequired(std::move(required));
}
void AutofillAgentInterceptorForTesting::SetSecureContextRequired(bool required) {
  GetForwardingInterface()->SetSecureContextRequired(std::move(required));
}
void AutofillAgentInterceptorForTesting::SetFocusRequiresScroll(bool require) {
  GetForwardingInterface()->SetFocusRequiresScroll(std::move(require));
}
void AutofillAgentInterceptorForTesting::SetQueryPasswordSuggestion(bool query) {
  GetForwardingInterface()->SetQueryPasswordSuggestion(std::move(query));
}
void AutofillAgentInterceptorForTesting::GetElementFormAndFieldData(const std::vector<std::string>& selectors, GetElementFormAndFieldDataCallback callback) {
  GetForwardingInterface()->GetElementFormAndFieldData(std::move(selectors), std::move(callback));
}
AutofillAgentAsyncWaiter::AutofillAgentAsyncWaiter(
    AutofillAgent* proxy) : proxy_(proxy) {}

AutofillAgentAsyncWaiter::~AutofillAgentAsyncWaiter() = default;

void AutofillAgentAsyncWaiter::GetElementFormAndFieldData(
    const std::vector<std::string>& selectors, ::autofill::FormData* out_form, ::autofill::FormFieldData* out_field) {
  base::RunLoop loop;
  proxy_->GetElementFormAndFieldData(std::move(selectors),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::autofill::FormData* out_form
,
             ::autofill::FormFieldData* out_field
,
             const ::autofill::FormData& form,
             const ::autofill::FormFieldData& field) {*out_form = std::move(form);*out_field = std::move(field);
            loop->Quit();
          },
          &loop,
          out_form,
          out_field));
  loop.Run();
}



void PasswordAutofillAgentInterceptorForTesting::FillPasswordForm(const ::autofill::PasswordFormFillData& form_data) {
  GetForwardingInterface()->FillPasswordForm(std::move(form_data));
}
void PasswordAutofillAgentInterceptorForTesting::InformNoSavedCredentials() {
  GetForwardingInterface()->InformNoSavedCredentials();
}
void PasswordAutofillAgentInterceptorForTesting::FillIntoFocusedField(bool is_password, const ::base::string16& credential) {
  GetForwardingInterface()->FillIntoFocusedField(std::move(is_password), std::move(credential));
}
void PasswordAutofillAgentInterceptorForTesting::SetLoggingState(bool active) {
  GetForwardingInterface()->SetLoggingState(std::move(active));
}
void PasswordAutofillAgentInterceptorForTesting::TouchToFillClosed(bool show_virtual_keyboard) {
  GetForwardingInterface()->TouchToFillClosed(std::move(show_virtual_keyboard));
}
void PasswordAutofillAgentInterceptorForTesting::AnnotateFieldsWithParsingResult(const ::autofill::ParsingResult& parsing_result) {
  GetForwardingInterface()->AnnotateFieldsWithParsingResult(std::move(parsing_result));
}
PasswordAutofillAgentAsyncWaiter::PasswordAutofillAgentAsyncWaiter(
    PasswordAutofillAgent* proxy) : proxy_(proxy) {}

PasswordAutofillAgentAsyncWaiter::~PasswordAutofillAgentAsyncWaiter() = default;




void PasswordGenerationAgentInterceptorForTesting::GeneratedPasswordAccepted(const ::base::string16& generated_password) {
  GetForwardingInterface()->GeneratedPasswordAccepted(std::move(generated_password));
}
void PasswordGenerationAgentInterceptorForTesting::UserTriggeredGeneratePassword(UserTriggeredGeneratePasswordCallback callback) {
  GetForwardingInterface()->UserTriggeredGeneratePassword(std::move(callback));
}
void PasswordGenerationAgentInterceptorForTesting::FoundFormEligibleForGeneration(const ::autofill::PasswordFormGenerationData& form) {
  GetForwardingInterface()->FoundFormEligibleForGeneration(std::move(form));
}
PasswordGenerationAgentAsyncWaiter::PasswordGenerationAgentAsyncWaiter(
    PasswordGenerationAgent* proxy) : proxy_(proxy) {}

PasswordGenerationAgentAsyncWaiter::~PasswordGenerationAgentAsyncWaiter() = default;

void PasswordGenerationAgentAsyncWaiter::UserTriggeredGeneratePassword(
    base::Optional<::autofill::password_generation::PasswordGenerationUIData>* out_data) {
  base::RunLoop loop;
  proxy_->UserTriggeredGeneratePassword(
      base::BindOnce(
          [](base::RunLoop* loop,
             base::Optional<::autofill::password_generation::PasswordGenerationUIData>* out_data
,
             const base::Optional<::autofill::password_generation::PasswordGenerationUIData>& data) {*out_data = std::move(data);
            loop->Quit();
          },
          &loop,
          out_data));
  loop.Run();
}





}  // namespace mojom
}  // namespace autofill

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif