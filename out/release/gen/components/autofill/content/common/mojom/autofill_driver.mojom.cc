// components/autofill/content/common/mojom/autofill_driver.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif

#include "components/autofill/content/common/mojom/autofill_driver.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/hash/md5_constexpr.h"
#include "base/logging.h"
#include "base/run_loop.h"
#include "base/task/common/task_annotator.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_context.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"

#include "components/autofill/content/common/mojom/autofill_driver.mojom-params-data.h"
#include "components/autofill/content/common/mojom/autofill_driver.mojom-shared-message-ids.h"

#include "components/autofill/content/common/mojom/autofill_driver.mojom-import-headers.h"


#ifndef COMPONENTS_AUTOFILL_CONTENT_COMMON_MOJOM_AUTOFILL_DRIVER_MOJOM_JUMBO_H_
#define COMPONENTS_AUTOFILL_CONTENT_COMMON_MOJOM_AUTOFILL_DRIVER_MOJOM_JUMBO_H_
#include "components/autofill/core/common/mojom/autofill_types_mojom_traits.h"
#include "mojo/public/cpp/base/string16_mojom_traits.h"
#include "mojo/public/cpp/base/text_direction_mojom_traits.h"
#include "mojo/public/cpp/base/time_mojom_traits.h"
#include "mojo/public/cpp/base/unguessable_token_mojom_traits.h"
#include "ui/gfx/geometry/mojom/geometry_mojom_traits.h"
#include "url/mojom/origin_mojom_traits.h"
#include "url/mojom/url_gurl_mojom_traits.h"
#endif
namespace autofill {
namespace mojom {
const char AutofillDriver::Name_[] = "autofill.mojom.AutofillDriver";

AutofillDriverProxy::AutofillDriverProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void AutofillDriverProxy::FormsSeen(
    const std::vector<::autofill::FormData>& in_forms, ::base::TimeTicks in_timestamp) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::AutofillDriver::FormsSeen");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAutofillDriver_FormsSeen_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::AutofillDriver_FormsSeen_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->forms)::BaseType::BufferWriter
      forms_writer;
  const mojo::internal::ContainerValidateParams forms_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::autofill::mojom::FormDataDataView>>(
      in_forms, buffer, &forms_writer, &forms_validate_params,
      &serialization_context);
  params->forms.Set(
      forms_writer.is_null() ? nullptr : forms_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->forms.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null forms in AutofillDriver.FormsSeen request");
  typename decltype(params->timestamp)::BaseType::BufferWriter
      timestamp_writer;
  mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
      in_timestamp, buffer, &timestamp_writer, &serialization_context);
  params->timestamp.Set(
      timestamp_writer.is_null() ? nullptr : timestamp_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->timestamp.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null timestamp in AutofillDriver.FormsSeen request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("FormsSeen");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void AutofillDriverProxy::FormSubmitted(
    const ::autofill::FormData& in_form, bool in_known_success, ::autofill::mojom::SubmissionSource in_source) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::AutofillDriver::FormSubmitted");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAutofillDriver_FormSubmitted_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::AutofillDriver_FormSubmitted_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->form)::BaseType::BufferWriter
      form_writer;
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form, buffer, &form_writer, &serialization_context);
  params->form.Set(
      form_writer.is_null() ? nullptr : form_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form in AutofillDriver.FormSubmitted request");
  params->known_success = in_known_success;
  mojo::internal::Serialize<::autofill::mojom::SubmissionSource>(
      in_source, &params->source);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("FormSubmitted");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void AutofillDriverProxy::TextFieldDidChange(
    const ::autofill::FormData& in_form, const ::autofill::FormFieldData& in_field, const ::gfx::RectF& in_bounding_box, ::base::TimeTicks in_timestamp) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::AutofillDriver::TextFieldDidChange");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAutofillDriver_TextFieldDidChange_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::AutofillDriver_TextFieldDidChange_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->form)::BaseType::BufferWriter
      form_writer;
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form, buffer, &form_writer, &serialization_context);
  params->form.Set(
      form_writer.is_null() ? nullptr : form_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form in AutofillDriver.TextFieldDidChange request");
  typename decltype(params->field)::BaseType::BufferWriter
      field_writer;
  mojo::internal::Serialize<::autofill::mojom::FormFieldDataDataView>(
      in_field, buffer, &field_writer, &serialization_context);
  params->field.Set(
      field_writer.is_null() ? nullptr : field_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->field.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null field in AutofillDriver.TextFieldDidChange request");
  typename decltype(params->bounding_box)::BaseType::BufferWriter
      bounding_box_writer;
  mojo::internal::Serialize<::gfx::mojom::RectFDataView>(
      in_bounding_box, buffer, &bounding_box_writer, &serialization_context);
  params->bounding_box.Set(
      bounding_box_writer.is_null() ? nullptr : bounding_box_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bounding_box.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bounding_box in AutofillDriver.TextFieldDidChange request");
  typename decltype(params->timestamp)::BaseType::BufferWriter
      timestamp_writer;
  mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
      in_timestamp, buffer, &timestamp_writer, &serialization_context);
  params->timestamp.Set(
      timestamp_writer.is_null() ? nullptr : timestamp_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->timestamp.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null timestamp in AutofillDriver.TextFieldDidChange request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("TextFieldDidChange");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void AutofillDriverProxy::TextFieldDidScroll(
    const ::autofill::FormData& in_form, const ::autofill::FormFieldData& in_field, const ::gfx::RectF& in_bounding_box) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::AutofillDriver::TextFieldDidScroll");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAutofillDriver_TextFieldDidScroll_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::AutofillDriver_TextFieldDidScroll_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->form)::BaseType::BufferWriter
      form_writer;
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form, buffer, &form_writer, &serialization_context);
  params->form.Set(
      form_writer.is_null() ? nullptr : form_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form in AutofillDriver.TextFieldDidScroll request");
  typename decltype(params->field)::BaseType::BufferWriter
      field_writer;
  mojo::internal::Serialize<::autofill::mojom::FormFieldDataDataView>(
      in_field, buffer, &field_writer, &serialization_context);
  params->field.Set(
      field_writer.is_null() ? nullptr : field_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->field.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null field in AutofillDriver.TextFieldDidScroll request");
  typename decltype(params->bounding_box)::BaseType::BufferWriter
      bounding_box_writer;
  mojo::internal::Serialize<::gfx::mojom::RectFDataView>(
      in_bounding_box, buffer, &bounding_box_writer, &serialization_context);
  params->bounding_box.Set(
      bounding_box_writer.is_null() ? nullptr : bounding_box_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bounding_box.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bounding_box in AutofillDriver.TextFieldDidScroll request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("TextFieldDidScroll");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void AutofillDriverProxy::SelectControlDidChange(
    const ::autofill::FormData& in_form, const ::autofill::FormFieldData& in_field, const ::gfx::RectF& in_bounding_box) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::AutofillDriver::SelectControlDidChange");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAutofillDriver_SelectControlDidChange_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::AutofillDriver_SelectControlDidChange_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->form)::BaseType::BufferWriter
      form_writer;
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form, buffer, &form_writer, &serialization_context);
  params->form.Set(
      form_writer.is_null() ? nullptr : form_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form in AutofillDriver.SelectControlDidChange request");
  typename decltype(params->field)::BaseType::BufferWriter
      field_writer;
  mojo::internal::Serialize<::autofill::mojom::FormFieldDataDataView>(
      in_field, buffer, &field_writer, &serialization_context);
  params->field.Set(
      field_writer.is_null() ? nullptr : field_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->field.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null field in AutofillDriver.SelectControlDidChange request");
  typename decltype(params->bounding_box)::BaseType::BufferWriter
      bounding_box_writer;
  mojo::internal::Serialize<::gfx::mojom::RectFDataView>(
      in_bounding_box, buffer, &bounding_box_writer, &serialization_context);
  params->bounding_box.Set(
      bounding_box_writer.is_null() ? nullptr : bounding_box_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bounding_box.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bounding_box in AutofillDriver.SelectControlDidChange request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("SelectControlDidChange");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void AutofillDriverProxy::SelectFieldOptionsDidChange(
    const ::autofill::FormData& in_form) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::AutofillDriver::SelectFieldOptionsDidChange");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAutofillDriver_SelectFieldOptionsDidChange_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::AutofillDriver_SelectFieldOptionsDidChange_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->form)::BaseType::BufferWriter
      form_writer;
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form, buffer, &form_writer, &serialization_context);
  params->form.Set(
      form_writer.is_null() ? nullptr : form_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form in AutofillDriver.SelectFieldOptionsDidChange request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("SelectFieldOptionsDidChange");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void AutofillDriverProxy::QueryFormFieldAutofill(
    int32_t in_id, const ::autofill::FormData& in_form, const ::autofill::FormFieldData& in_field, const ::gfx::RectF& in_bounding_box, bool in_autoselect_first_suggestion) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::AutofillDriver::QueryFormFieldAutofill");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAutofillDriver_QueryFormFieldAutofill_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::AutofillDriver_QueryFormFieldAutofill_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->id = in_id;
  typename decltype(params->form)::BaseType::BufferWriter
      form_writer;
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form, buffer, &form_writer, &serialization_context);
  params->form.Set(
      form_writer.is_null() ? nullptr : form_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form in AutofillDriver.QueryFormFieldAutofill request");
  typename decltype(params->field)::BaseType::BufferWriter
      field_writer;
  mojo::internal::Serialize<::autofill::mojom::FormFieldDataDataView>(
      in_field, buffer, &field_writer, &serialization_context);
  params->field.Set(
      field_writer.is_null() ? nullptr : field_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->field.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null field in AutofillDriver.QueryFormFieldAutofill request");
  typename decltype(params->bounding_box)::BaseType::BufferWriter
      bounding_box_writer;
  mojo::internal::Serialize<::gfx::mojom::RectFDataView>(
      in_bounding_box, buffer, &bounding_box_writer, &serialization_context);
  params->bounding_box.Set(
      bounding_box_writer.is_null() ? nullptr : bounding_box_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bounding_box.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bounding_box in AutofillDriver.QueryFormFieldAutofill request");
  params->autoselect_first_suggestion = in_autoselect_first_suggestion;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("QueryFormFieldAutofill");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void AutofillDriverProxy::HidePopup(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::AutofillDriver::HidePopup");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAutofillDriver_HidePopup_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::AutofillDriver_HidePopup_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("HidePopup");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void AutofillDriverProxy::FocusNoLongerOnForm(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::AutofillDriver::FocusNoLongerOnForm");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAutofillDriver_FocusNoLongerOnForm_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::AutofillDriver_FocusNoLongerOnForm_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("FocusNoLongerOnForm");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void AutofillDriverProxy::FocusOnFormField(
    const ::autofill::FormData& in_form, const ::autofill::FormFieldData& in_field, const ::gfx::RectF& in_bounding_box) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::AutofillDriver::FocusOnFormField");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAutofillDriver_FocusOnFormField_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::AutofillDriver_FocusOnFormField_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->form)::BaseType::BufferWriter
      form_writer;
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form, buffer, &form_writer, &serialization_context);
  params->form.Set(
      form_writer.is_null() ? nullptr : form_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form in AutofillDriver.FocusOnFormField request");
  typename decltype(params->field)::BaseType::BufferWriter
      field_writer;
  mojo::internal::Serialize<::autofill::mojom::FormFieldDataDataView>(
      in_field, buffer, &field_writer, &serialization_context);
  params->field.Set(
      field_writer.is_null() ? nullptr : field_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->field.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null field in AutofillDriver.FocusOnFormField request");
  typename decltype(params->bounding_box)::BaseType::BufferWriter
      bounding_box_writer;
  mojo::internal::Serialize<::gfx::mojom::RectFDataView>(
      in_bounding_box, buffer, &bounding_box_writer, &serialization_context);
  params->bounding_box.Set(
      bounding_box_writer.is_null() ? nullptr : bounding_box_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bounding_box.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bounding_box in AutofillDriver.FocusOnFormField request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("FocusOnFormField");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void AutofillDriverProxy::DidFillAutofillFormData(
    const ::autofill::FormData& in_form, ::base::TimeTicks in_timestamp) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::AutofillDriver::DidFillAutofillFormData");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAutofillDriver_DidFillAutofillFormData_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::AutofillDriver_DidFillAutofillFormData_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->form)::BaseType::BufferWriter
      form_writer;
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form, buffer, &form_writer, &serialization_context);
  params->form.Set(
      form_writer.is_null() ? nullptr : form_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form in AutofillDriver.DidFillAutofillFormData request");
  typename decltype(params->timestamp)::BaseType::BufferWriter
      timestamp_writer;
  mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
      in_timestamp, buffer, &timestamp_writer, &serialization_context);
  params->timestamp.Set(
      timestamp_writer.is_null() ? nullptr : timestamp_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->timestamp.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null timestamp in AutofillDriver.DidFillAutofillFormData request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("DidFillAutofillFormData");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void AutofillDriverProxy::DidPreviewAutofillFormData(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::AutofillDriver::DidPreviewAutofillFormData");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAutofillDriver_DidPreviewAutofillFormData_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::AutofillDriver_DidPreviewAutofillFormData_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("DidPreviewAutofillFormData");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void AutofillDriverProxy::DidEndTextFieldEditing(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::AutofillDriver::DidEndTextFieldEditing");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAutofillDriver_DidEndTextFieldEditing_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::AutofillDriver_DidEndTextFieldEditing_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("DidEndTextFieldEditing");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void AutofillDriverProxy::SetDataList(
    const std::vector<::base::string16>& in_values, const std::vector<::base::string16>& in_labels) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::AutofillDriver::SetDataList");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAutofillDriver_SetDataList_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::AutofillDriver_SetDataList_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->values)::BaseType::BufferWriter
      values_writer;
  const mojo::internal::ContainerValidateParams values_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::mojo_base::mojom::String16DataView>>(
      in_values, buffer, &values_writer, &values_validate_params,
      &serialization_context);
  params->values.Set(
      values_writer.is_null() ? nullptr : values_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->values.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null values in AutofillDriver.SetDataList request");
  typename decltype(params->labels)::BaseType::BufferWriter
      labels_writer;
  const mojo::internal::ContainerValidateParams labels_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::mojo_base::mojom::String16DataView>>(
      in_labels, buffer, &labels_writer, &labels_validate_params,
      &serialization_context);
  params->labels.Set(
      labels_writer.is_null() ? nullptr : labels_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->labels.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null labels in AutofillDriver.SetDataList request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("SetDataList");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool AutofillDriverStubDispatch::Accept(
    AutofillDriver* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kAutofillDriver_FormsSeen_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::AutofillDriver::FormsSeen",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::AutofillDriver::FormsSeen");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::AutofillDriver_FormsSeen_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_FormsSeen_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      std::vector<::autofill::FormData> p_forms{};
      ::base::TimeTicks p_timestamp{};
      AutofillDriver_FormsSeen_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadForms(&p_forms))
        success = false;
      if (success && !input_data_view.ReadTimestamp(&p_timestamp))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FormsSeen(
std::move(p_forms), 
std::move(p_timestamp));
      return true;
    }
    case internal::kAutofillDriver_FormSubmitted_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::AutofillDriver::FormSubmitted",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::AutofillDriver::FormSubmitted");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::AutofillDriver_FormSubmitted_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_FormSubmitted_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::autofill::FormData p_form{};
      bool p_known_success{};
      ::autofill::mojom::SubmissionSource p_source{};
      AutofillDriver_FormSubmitted_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadForm(&p_form))
        success = false;
      if (success)
        p_known_success = input_data_view.known_success();
      if (success && !input_data_view.ReadSource(&p_source))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FormSubmitted(
std::move(p_form), 
std::move(p_known_success), 
std::move(p_source));
      return true;
    }
    case internal::kAutofillDriver_TextFieldDidChange_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::AutofillDriver::TextFieldDidChange",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::AutofillDriver::TextFieldDidChange");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::AutofillDriver_TextFieldDidChange_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_TextFieldDidChange_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::autofill::FormData p_form{};
      ::autofill::FormFieldData p_field{};
      ::gfx::RectF p_bounding_box{};
      ::base::TimeTicks p_timestamp{};
      AutofillDriver_TextFieldDidChange_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadForm(&p_form))
        success = false;
      if (success && !input_data_view.ReadField(&p_field))
        success = false;
      if (success && !input_data_view.ReadBoundingBox(&p_bounding_box))
        success = false;
      if (success && !input_data_view.ReadTimestamp(&p_timestamp))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->TextFieldDidChange(
std::move(p_form), 
std::move(p_field), 
std::move(p_bounding_box), 
std::move(p_timestamp));
      return true;
    }
    case internal::kAutofillDriver_TextFieldDidScroll_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::AutofillDriver::TextFieldDidScroll",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::AutofillDriver::TextFieldDidScroll");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::AutofillDriver_TextFieldDidScroll_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_TextFieldDidScroll_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::autofill::FormData p_form{};
      ::autofill::FormFieldData p_field{};
      ::gfx::RectF p_bounding_box{};
      AutofillDriver_TextFieldDidScroll_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadForm(&p_form))
        success = false;
      if (success && !input_data_view.ReadField(&p_field))
        success = false;
      if (success && !input_data_view.ReadBoundingBox(&p_bounding_box))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->TextFieldDidScroll(
std::move(p_form), 
std::move(p_field), 
std::move(p_bounding_box));
      return true;
    }
    case internal::kAutofillDriver_SelectControlDidChange_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::AutofillDriver::SelectControlDidChange",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::AutofillDriver::SelectControlDidChange");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::AutofillDriver_SelectControlDidChange_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_SelectControlDidChange_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::autofill::FormData p_form{};
      ::autofill::FormFieldData p_field{};
      ::gfx::RectF p_bounding_box{};
      AutofillDriver_SelectControlDidChange_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadForm(&p_form))
        success = false;
      if (success && !input_data_view.ReadField(&p_field))
        success = false;
      if (success && !input_data_view.ReadBoundingBox(&p_bounding_box))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SelectControlDidChange(
std::move(p_form), 
std::move(p_field), 
std::move(p_bounding_box));
      return true;
    }
    case internal::kAutofillDriver_SelectFieldOptionsDidChange_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::AutofillDriver::SelectFieldOptionsDidChange",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::AutofillDriver::SelectFieldOptionsDidChange");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::AutofillDriver_SelectFieldOptionsDidChange_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_SelectFieldOptionsDidChange_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::autofill::FormData p_form{};
      AutofillDriver_SelectFieldOptionsDidChange_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadForm(&p_form))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SelectFieldOptionsDidChange(
std::move(p_form));
      return true;
    }
    case internal::kAutofillDriver_QueryFormFieldAutofill_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::AutofillDriver::QueryFormFieldAutofill",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::AutofillDriver::QueryFormFieldAutofill");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::AutofillDriver_QueryFormFieldAutofill_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_QueryFormFieldAutofill_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int32_t p_id{};
      ::autofill::FormData p_form{};
      ::autofill::FormFieldData p_field{};
      ::gfx::RectF p_bounding_box{};
      bool p_autoselect_first_suggestion{};
      AutofillDriver_QueryFormFieldAutofill_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_id = input_data_view.id();
      if (success && !input_data_view.ReadForm(&p_form))
        success = false;
      if (success && !input_data_view.ReadField(&p_field))
        success = false;
      if (success && !input_data_view.ReadBoundingBox(&p_bounding_box))
        success = false;
      if (success)
        p_autoselect_first_suggestion = input_data_view.autoselect_first_suggestion();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->QueryFormFieldAutofill(
std::move(p_id), 
std::move(p_form), 
std::move(p_field), 
std::move(p_bounding_box), 
std::move(p_autoselect_first_suggestion));
      return true;
    }
    case internal::kAutofillDriver_HidePopup_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::AutofillDriver::HidePopup",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::AutofillDriver::HidePopup");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::AutofillDriver_HidePopup_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_HidePopup_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      AutofillDriver_HidePopup_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->HidePopup();
      return true;
    }
    case internal::kAutofillDriver_FocusNoLongerOnForm_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::AutofillDriver::FocusNoLongerOnForm",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::AutofillDriver::FocusNoLongerOnForm");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::AutofillDriver_FocusNoLongerOnForm_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_FocusNoLongerOnForm_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      AutofillDriver_FocusNoLongerOnForm_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FocusNoLongerOnForm();
      return true;
    }
    case internal::kAutofillDriver_FocusOnFormField_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::AutofillDriver::FocusOnFormField",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::AutofillDriver::FocusOnFormField");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::AutofillDriver_FocusOnFormField_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_FocusOnFormField_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::autofill::FormData p_form{};
      ::autofill::FormFieldData p_field{};
      ::gfx::RectF p_bounding_box{};
      AutofillDriver_FocusOnFormField_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadForm(&p_form))
        success = false;
      if (success && !input_data_view.ReadField(&p_field))
        success = false;
      if (success && !input_data_view.ReadBoundingBox(&p_bounding_box))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FocusOnFormField(
std::move(p_form), 
std::move(p_field), 
std::move(p_bounding_box));
      return true;
    }
    case internal::kAutofillDriver_DidFillAutofillFormData_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::AutofillDriver::DidFillAutofillFormData",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::AutofillDriver::DidFillAutofillFormData");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::AutofillDriver_DidFillAutofillFormData_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_DidFillAutofillFormData_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::autofill::FormData p_form{};
      ::base::TimeTicks p_timestamp{};
      AutofillDriver_DidFillAutofillFormData_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadForm(&p_form))
        success = false;
      if (success && !input_data_view.ReadTimestamp(&p_timestamp))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidFillAutofillFormData(
std::move(p_form), 
std::move(p_timestamp));
      return true;
    }
    case internal::kAutofillDriver_DidPreviewAutofillFormData_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::AutofillDriver::DidPreviewAutofillFormData",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::AutofillDriver::DidPreviewAutofillFormData");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::AutofillDriver_DidPreviewAutofillFormData_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_DidPreviewAutofillFormData_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      AutofillDriver_DidPreviewAutofillFormData_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidPreviewAutofillFormData();
      return true;
    }
    case internal::kAutofillDriver_DidEndTextFieldEditing_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::AutofillDriver::DidEndTextFieldEditing",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::AutofillDriver::DidEndTextFieldEditing");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::AutofillDriver_DidEndTextFieldEditing_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_DidEndTextFieldEditing_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      AutofillDriver_DidEndTextFieldEditing_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidEndTextFieldEditing();
      return true;
    }
    case internal::kAutofillDriver_SetDataList_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::AutofillDriver::SetDataList",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::AutofillDriver::SetDataList");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::AutofillDriver_SetDataList_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_SetDataList_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      std::vector<::base::string16> p_values{};
      std::vector<::base::string16> p_labels{};
      AutofillDriver_SetDataList_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadValues(&p_values))
        success = false;
      if (success && !input_data_view.ReadLabels(&p_labels))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetDataList(
std::move(p_values), 
std::move(p_labels));
      return true;
    }
  }
  return false;
}

// static
bool AutofillDriverStubDispatch::AcceptWithResponder(
    AutofillDriver* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kAutofillDriver_FormsSeen_Name: {
      break;
    }
    case internal::kAutofillDriver_FormSubmitted_Name: {
      break;
    }
    case internal::kAutofillDriver_TextFieldDidChange_Name: {
      break;
    }
    case internal::kAutofillDriver_TextFieldDidScroll_Name: {
      break;
    }
    case internal::kAutofillDriver_SelectControlDidChange_Name: {
      break;
    }
    case internal::kAutofillDriver_SelectFieldOptionsDidChange_Name: {
      break;
    }
    case internal::kAutofillDriver_QueryFormFieldAutofill_Name: {
      break;
    }
    case internal::kAutofillDriver_HidePopup_Name: {
      break;
    }
    case internal::kAutofillDriver_FocusNoLongerOnForm_Name: {
      break;
    }
    case internal::kAutofillDriver_FocusOnFormField_Name: {
      break;
    }
    case internal::kAutofillDriver_DidFillAutofillFormData_Name: {
      break;
    }
    case internal::kAutofillDriver_DidPreviewAutofillFormData_Name: {
      break;
    }
    case internal::kAutofillDriver_DidEndTextFieldEditing_Name: {
      break;
    }
    case internal::kAutofillDriver_SetDataList_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kAutofillDriverValidationInfo[] = {
    {&internal::AutofillDriver_FormsSeen_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_FormSubmitted_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_TextFieldDidChange_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_TextFieldDidScroll_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_SelectControlDidChange_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_SelectFieldOptionsDidChange_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_QueryFormFieldAutofill_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_HidePopup_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_FocusNoLongerOnForm_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_FocusOnFormField_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_DidFillAutofillFormData_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_DidPreviewAutofillFormData_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_DidEndTextFieldEditing_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_SetDataList_Params_Data::Validate,
     nullptr /* no response */},
};

bool AutofillDriverRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::autofill::mojom::AutofillDriver::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kAutofillDriverValidationInfo);
}

const char PasswordManagerDriver::Name_[] = "autofill.mojom.PasswordManagerDriver";

PasswordManagerDriverProxy::PasswordManagerDriverProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void PasswordManagerDriverProxy::PasswordFormsParsed(
    const std::vector<::autofill::FormData>& in_forms_data) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::PasswordManagerDriver::PasswordFormsParsed");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_PasswordFormsParsed_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::PasswordManagerDriver_PasswordFormsParsed_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->forms_data)::BaseType::BufferWriter
      forms_data_writer;
  const mojo::internal::ContainerValidateParams forms_data_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::autofill::mojom::FormDataDataView>>(
      in_forms_data, buffer, &forms_data_writer, &forms_data_validate_params,
      &serialization_context);
  params->forms_data.Set(
      forms_data_writer.is_null() ? nullptr : forms_data_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->forms_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null forms_data in PasswordManagerDriver.PasswordFormsParsed request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("PasswordFormsParsed");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PasswordManagerDriverProxy::PasswordFormsRendered(
    const std::vector<::autofill::FormData>& in_visible_forms_data, bool in_did_stop_loading) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::PasswordManagerDriver::PasswordFormsRendered");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_PasswordFormsRendered_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::PasswordManagerDriver_PasswordFormsRendered_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->visible_forms_data)::BaseType::BufferWriter
      visible_forms_data_writer;
  const mojo::internal::ContainerValidateParams visible_forms_data_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::autofill::mojom::FormDataDataView>>(
      in_visible_forms_data, buffer, &visible_forms_data_writer, &visible_forms_data_validate_params,
      &serialization_context);
  params->visible_forms_data.Set(
      visible_forms_data_writer.is_null() ? nullptr : visible_forms_data_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->visible_forms_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null visible_forms_data in PasswordManagerDriver.PasswordFormsRendered request");
  params->did_stop_loading = in_did_stop_loading;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("PasswordFormsRendered");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PasswordManagerDriverProxy::PasswordFormSubmitted(
    const ::autofill::FormData& in_form_data) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::PasswordManagerDriver::PasswordFormSubmitted");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_PasswordFormSubmitted_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::PasswordManagerDriver_PasswordFormSubmitted_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->form_data)::BaseType::BufferWriter
      form_data_writer;
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form_data, buffer, &form_data_writer, &serialization_context);
  params->form_data.Set(
      form_data_writer.is_null() ? nullptr : form_data_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form_data in PasswordManagerDriver.PasswordFormSubmitted request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("PasswordFormSubmitted");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PasswordManagerDriverProxy::ShowManualFallbackForSaving(
    const ::autofill::FormData& in_form_data) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::PasswordManagerDriver::ShowManualFallbackForSaving");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_ShowManualFallbackForSaving_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::PasswordManagerDriver_ShowManualFallbackForSaving_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->form_data)::BaseType::BufferWriter
      form_data_writer;
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form_data, buffer, &form_data_writer, &serialization_context);
  params->form_data.Set(
      form_data_writer.is_null() ? nullptr : form_data_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form_data in PasswordManagerDriver.ShowManualFallbackForSaving request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("ShowManualFallbackForSaving");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PasswordManagerDriverProxy::HideManualFallbackForSaving(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::PasswordManagerDriver::HideManualFallbackForSaving");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_HideManualFallbackForSaving_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::PasswordManagerDriver_HideManualFallbackForSaving_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("HideManualFallbackForSaving");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PasswordManagerDriverProxy::SameDocumentNavigation(
    ::autofill::mojom::SubmissionIndicatorEvent in_submission_indication_event) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::PasswordManagerDriver::SameDocumentNavigation");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_SameDocumentNavigation_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::PasswordManagerDriver_SameDocumentNavigation_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::autofill::mojom::SubmissionIndicatorEvent>(
      in_submission_indication_event, &params->submission_indication_event);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("SameDocumentNavigation");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PasswordManagerDriverProxy::RecordSavePasswordProgress(
    const std::string& in_log) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::PasswordManagerDriver::RecordSavePasswordProgress");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_RecordSavePasswordProgress_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::PasswordManagerDriver_RecordSavePasswordProgress_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->log)::BaseType::BufferWriter
      log_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_log, buffer, &log_writer, &serialization_context);
  params->log.Set(
      log_writer.is_null() ? nullptr : log_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->log.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null log in PasswordManagerDriver.RecordSavePasswordProgress request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("RecordSavePasswordProgress");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PasswordManagerDriverProxy::UserModifiedPasswordField(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::PasswordManagerDriver::UserModifiedPasswordField");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_UserModifiedPasswordField_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::PasswordManagerDriver_UserModifiedPasswordField_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("UserModifiedPasswordField");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PasswordManagerDriverProxy::UserModifiedNonPasswordField(
    uint32_t in_renderer_id, const ::base::string16& in_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::PasswordManagerDriver::UserModifiedNonPasswordField");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_UserModifiedNonPasswordField_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::PasswordManagerDriver_UserModifiedNonPasswordField_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->renderer_id = in_renderer_id;
  typename decltype(params->value)::BaseType::BufferWriter
      value_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_value, buffer, &value_writer, &serialization_context);
  params->value.Set(
      value_writer.is_null() ? nullptr : value_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null value in PasswordManagerDriver.UserModifiedNonPasswordField request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("UserModifiedNonPasswordField");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PasswordManagerDriverProxy::ShowPasswordSuggestions(
    ::base::i18n::TextDirection in_text_direction, const ::base::string16& in_typed_username, int32_t in_options, const ::gfx::RectF& in_bounds) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::PasswordManagerDriver::ShowPasswordSuggestions");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_ShowPasswordSuggestions_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::PasswordManagerDriver_ShowPasswordSuggestions_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::mojo_base::mojom::TextDirection>(
      in_text_direction, &params->text_direction);
  typename decltype(params->typed_username)::BaseType::BufferWriter
      typed_username_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_typed_username, buffer, &typed_username_writer, &serialization_context);
  params->typed_username.Set(
      typed_username_writer.is_null() ? nullptr : typed_username_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->typed_username.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null typed_username in PasswordManagerDriver.ShowPasswordSuggestions request");
  params->options = in_options;
  typename decltype(params->bounds)::BaseType::BufferWriter
      bounds_writer;
  mojo::internal::Serialize<::gfx::mojom::RectFDataView>(
      in_bounds, buffer, &bounds_writer, &serialization_context);
  params->bounds.Set(
      bounds_writer.is_null() ? nullptr : bounds_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bounds.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bounds in PasswordManagerDriver.ShowPasswordSuggestions request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("ShowPasswordSuggestions");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PasswordManagerDriverProxy::ShowTouchToFill(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::PasswordManagerDriver::ShowTouchToFill");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_ShowTouchToFill_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::PasswordManagerDriver_ShowTouchToFill_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("ShowTouchToFill");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PasswordManagerDriverProxy::CheckSafeBrowsingReputation(
    const ::GURL& in_form_action, const ::GURL& in_frame_url) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::PasswordManagerDriver::CheckSafeBrowsingReputation");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_CheckSafeBrowsingReputation_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::PasswordManagerDriver_CheckSafeBrowsingReputation_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->form_action)::BaseType::BufferWriter
      form_action_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_form_action, buffer, &form_action_writer, &serialization_context);
  params->form_action.Set(
      form_action_writer.is_null() ? nullptr : form_action_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form_action.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form_action in PasswordManagerDriver.CheckSafeBrowsingReputation request");
  typename decltype(params->frame_url)::BaseType::BufferWriter
      frame_url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_frame_url, buffer, &frame_url_writer, &serialization_context);
  params->frame_url.Set(
      frame_url_writer.is_null() ? nullptr : frame_url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->frame_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null frame_url in PasswordManagerDriver.CheckSafeBrowsingReputation request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("CheckSafeBrowsingReputation");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PasswordManagerDriverProxy::FocusedInputChanged(
    ::autofill::mojom::FocusedFieldType in_focused_field_type) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::PasswordManagerDriver::FocusedInputChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_FocusedInputChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::PasswordManagerDriver_FocusedInputChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::autofill::mojom::FocusedFieldType>(
      in_focused_field_type, &params->focused_field_type);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("FocusedInputChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PasswordManagerDriverProxy::LogFirstFillingResult(
    uint32_t in_form_renderer_id, int32_t in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::PasswordManagerDriver::LogFirstFillingResult");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_LogFirstFillingResult_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::PasswordManagerDriver_LogFirstFillingResult_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->form_renderer_id = in_form_renderer_id;
  params->result = in_result;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("LogFirstFillingResult");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool PasswordManagerDriverStubDispatch::Accept(
    PasswordManagerDriver* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kPasswordManagerDriver_PasswordFormsParsed_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::PasswordManagerDriver::PasswordFormsParsed",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::PasswordManagerDriver::PasswordFormsParsed");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_PasswordFormsParsed_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_PasswordFormsParsed_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      std::vector<::autofill::FormData> p_forms_data{};
      PasswordManagerDriver_PasswordFormsParsed_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadFormsData(&p_forms_data))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PasswordFormsParsed(
std::move(p_forms_data));
      return true;
    }
    case internal::kPasswordManagerDriver_PasswordFormsRendered_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::PasswordManagerDriver::PasswordFormsRendered",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::PasswordManagerDriver::PasswordFormsRendered");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_PasswordFormsRendered_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_PasswordFormsRendered_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      std::vector<::autofill::FormData> p_visible_forms_data{};
      bool p_did_stop_loading{};
      PasswordManagerDriver_PasswordFormsRendered_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadVisibleFormsData(&p_visible_forms_data))
        success = false;
      if (success)
        p_did_stop_loading = input_data_view.did_stop_loading();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PasswordFormsRendered(
std::move(p_visible_forms_data), 
std::move(p_did_stop_loading));
      return true;
    }
    case internal::kPasswordManagerDriver_PasswordFormSubmitted_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::PasswordManagerDriver::PasswordFormSubmitted",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::PasswordManagerDriver::PasswordFormSubmitted");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_PasswordFormSubmitted_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_PasswordFormSubmitted_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::autofill::FormData p_form_data{};
      PasswordManagerDriver_PasswordFormSubmitted_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadFormData(&p_form_data))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PasswordFormSubmitted(
std::move(p_form_data));
      return true;
    }
    case internal::kPasswordManagerDriver_ShowManualFallbackForSaving_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::PasswordManagerDriver::ShowManualFallbackForSaving",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::PasswordManagerDriver::ShowManualFallbackForSaving");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_ShowManualFallbackForSaving_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_ShowManualFallbackForSaving_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::autofill::FormData p_form_data{};
      PasswordManagerDriver_ShowManualFallbackForSaving_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadFormData(&p_form_data))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ShowManualFallbackForSaving(
std::move(p_form_data));
      return true;
    }
    case internal::kPasswordManagerDriver_HideManualFallbackForSaving_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::PasswordManagerDriver::HideManualFallbackForSaving",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::PasswordManagerDriver::HideManualFallbackForSaving");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_HideManualFallbackForSaving_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_HideManualFallbackForSaving_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      PasswordManagerDriver_HideManualFallbackForSaving_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->HideManualFallbackForSaving();
      return true;
    }
    case internal::kPasswordManagerDriver_SameDocumentNavigation_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::PasswordManagerDriver::SameDocumentNavigation",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::PasswordManagerDriver::SameDocumentNavigation");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_SameDocumentNavigation_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_SameDocumentNavigation_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::autofill::mojom::SubmissionIndicatorEvent p_submission_indication_event{};
      PasswordManagerDriver_SameDocumentNavigation_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadSubmissionIndicationEvent(&p_submission_indication_event))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SameDocumentNavigation(
std::move(p_submission_indication_event));
      return true;
    }
    case internal::kPasswordManagerDriver_RecordSavePasswordProgress_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::PasswordManagerDriver::RecordSavePasswordProgress",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::PasswordManagerDriver::RecordSavePasswordProgress");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_RecordSavePasswordProgress_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_RecordSavePasswordProgress_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      std::string p_log{};
      PasswordManagerDriver_RecordSavePasswordProgress_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadLog(&p_log))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RecordSavePasswordProgress(
std::move(p_log));
      return true;
    }
    case internal::kPasswordManagerDriver_UserModifiedPasswordField_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::PasswordManagerDriver::UserModifiedPasswordField",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::PasswordManagerDriver::UserModifiedPasswordField");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_UserModifiedPasswordField_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_UserModifiedPasswordField_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      PasswordManagerDriver_UserModifiedPasswordField_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UserModifiedPasswordField();
      return true;
    }
    case internal::kPasswordManagerDriver_UserModifiedNonPasswordField_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::PasswordManagerDriver::UserModifiedNonPasswordField",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::PasswordManagerDriver::UserModifiedNonPasswordField");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_UserModifiedNonPasswordField_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_UserModifiedNonPasswordField_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      uint32_t p_renderer_id{};
      ::base::string16 p_value{};
      PasswordManagerDriver_UserModifiedNonPasswordField_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_renderer_id = input_data_view.renderer_id();
      if (success && !input_data_view.ReadValue(&p_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UserModifiedNonPasswordField(
std::move(p_renderer_id), 
std::move(p_value));
      return true;
    }
    case internal::kPasswordManagerDriver_ShowPasswordSuggestions_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::PasswordManagerDriver::ShowPasswordSuggestions",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::PasswordManagerDriver::ShowPasswordSuggestions");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_ShowPasswordSuggestions_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_ShowPasswordSuggestions_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::base::i18n::TextDirection p_text_direction{};
      ::base::string16 p_typed_username{};
      int32_t p_options{};
      ::gfx::RectF p_bounds{};
      PasswordManagerDriver_ShowPasswordSuggestions_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadTextDirection(&p_text_direction))
        success = false;
      if (success && !input_data_view.ReadTypedUsername(&p_typed_username))
        success = false;
      if (success)
        p_options = input_data_view.options();
      if (success && !input_data_view.ReadBounds(&p_bounds))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ShowPasswordSuggestions(
std::move(p_text_direction), 
std::move(p_typed_username), 
std::move(p_options), 
std::move(p_bounds));
      return true;
    }
    case internal::kPasswordManagerDriver_ShowTouchToFill_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::PasswordManagerDriver::ShowTouchToFill",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::PasswordManagerDriver::ShowTouchToFill");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_ShowTouchToFill_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_ShowTouchToFill_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      PasswordManagerDriver_ShowTouchToFill_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ShowTouchToFill();
      return true;
    }
    case internal::kPasswordManagerDriver_CheckSafeBrowsingReputation_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::PasswordManagerDriver::CheckSafeBrowsingReputation",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::PasswordManagerDriver::CheckSafeBrowsingReputation");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_CheckSafeBrowsingReputation_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_CheckSafeBrowsingReputation_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::GURL p_form_action{};
      ::GURL p_frame_url{};
      PasswordManagerDriver_CheckSafeBrowsingReputation_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadFormAction(&p_form_action))
        success = false;
      if (success && !input_data_view.ReadFrameUrl(&p_frame_url))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CheckSafeBrowsingReputation(
std::move(p_form_action), 
std::move(p_frame_url));
      return true;
    }
    case internal::kPasswordManagerDriver_FocusedInputChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::PasswordManagerDriver::FocusedInputChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::PasswordManagerDriver::FocusedInputChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_FocusedInputChanged_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_FocusedInputChanged_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::autofill::mojom::FocusedFieldType p_focused_field_type{};
      PasswordManagerDriver_FocusedInputChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadFocusedFieldType(&p_focused_field_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FocusedInputChanged(
std::move(p_focused_field_type));
      return true;
    }
    case internal::kPasswordManagerDriver_LogFirstFillingResult_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::PasswordManagerDriver::LogFirstFillingResult",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::PasswordManagerDriver::LogFirstFillingResult");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_LogFirstFillingResult_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_LogFirstFillingResult_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      uint32_t p_form_renderer_id{};
      int32_t p_result{};
      PasswordManagerDriver_LogFirstFillingResult_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_form_renderer_id = input_data_view.form_renderer_id();
      if (success)
        p_result = input_data_view.result();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->LogFirstFillingResult(
std::move(p_form_renderer_id), 
std::move(p_result));
      return true;
    }
  }
  return false;
}

// static
bool PasswordManagerDriverStubDispatch::AcceptWithResponder(
    PasswordManagerDriver* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kPasswordManagerDriver_PasswordFormsParsed_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_PasswordFormsRendered_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_PasswordFormSubmitted_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_ShowManualFallbackForSaving_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_HideManualFallbackForSaving_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_SameDocumentNavigation_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_RecordSavePasswordProgress_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_UserModifiedPasswordField_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_UserModifiedNonPasswordField_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_ShowPasswordSuggestions_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_ShowTouchToFill_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_CheckSafeBrowsingReputation_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_FocusedInputChanged_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_LogFirstFillingResult_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kPasswordManagerDriverValidationInfo[] = {
    {&internal::PasswordManagerDriver_PasswordFormsParsed_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_PasswordFormsRendered_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_PasswordFormSubmitted_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_ShowManualFallbackForSaving_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_HideManualFallbackForSaving_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_SameDocumentNavigation_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_RecordSavePasswordProgress_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_UserModifiedPasswordField_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_UserModifiedNonPasswordField_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_ShowPasswordSuggestions_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_ShowTouchToFill_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_CheckSafeBrowsingReputation_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_FocusedInputChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_LogFirstFillingResult_Params_Data::Validate,
     nullptr /* no response */},
};

bool PasswordManagerDriverRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::autofill::mojom::PasswordManagerDriver::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kPasswordManagerDriverValidationInfo);
}

const char PasswordGenerationDriver::Name_[] = "autofill.mojom.PasswordGenerationDriver";

PasswordGenerationDriverProxy::PasswordGenerationDriverProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void PasswordGenerationDriverProxy::AutomaticGenerationAvailable(
    const ::autofill::password_generation::PasswordGenerationUIData& in_password_generation_ui_data) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::PasswordGenerationDriver::AutomaticGenerationAvailable");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPasswordGenerationDriver_AutomaticGenerationAvailable_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::PasswordGenerationDriver_AutomaticGenerationAvailable_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->password_generation_ui_data)::BaseType::BufferWriter
      password_generation_ui_data_writer;
  mojo::internal::Serialize<::autofill::mojom::PasswordGenerationUIDataDataView>(
      in_password_generation_ui_data, buffer, &password_generation_ui_data_writer, &serialization_context);
  params->password_generation_ui_data.Set(
      password_generation_ui_data_writer.is_null() ? nullptr : password_generation_ui_data_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->password_generation_ui_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null password_generation_ui_data in PasswordGenerationDriver.AutomaticGenerationAvailable request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordGenerationDriver::Name_);
  message.set_method_name("AutomaticGenerationAvailable");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PasswordGenerationDriverProxy::ShowPasswordEditingPopup(
    const ::gfx::RectF& in_bounds, const ::autofill::FormData& in_form_data, uint32_t in_field_renderer_id, const ::base::string16& in_password_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::PasswordGenerationDriver::ShowPasswordEditingPopup");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPasswordGenerationDriver_ShowPasswordEditingPopup_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::PasswordGenerationDriver_ShowPasswordEditingPopup_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->bounds)::BaseType::BufferWriter
      bounds_writer;
  mojo::internal::Serialize<::gfx::mojom::RectFDataView>(
      in_bounds, buffer, &bounds_writer, &serialization_context);
  params->bounds.Set(
      bounds_writer.is_null() ? nullptr : bounds_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bounds.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bounds in PasswordGenerationDriver.ShowPasswordEditingPopup request");
  typename decltype(params->form_data)::BaseType::BufferWriter
      form_data_writer;
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form_data, buffer, &form_data_writer, &serialization_context);
  params->form_data.Set(
      form_data_writer.is_null() ? nullptr : form_data_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form_data in PasswordGenerationDriver.ShowPasswordEditingPopup request");
  params->field_renderer_id = in_field_renderer_id;
  typename decltype(params->password_value)::BaseType::BufferWriter
      password_value_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_password_value, buffer, &password_value_writer, &serialization_context);
  params->password_value.Set(
      password_value_writer.is_null() ? nullptr : password_value_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->password_value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null password_value in PasswordGenerationDriver.ShowPasswordEditingPopup request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordGenerationDriver::Name_);
  message.set_method_name("ShowPasswordEditingPopup");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PasswordGenerationDriverProxy::PasswordGenerationRejectedByTyping(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::PasswordGenerationDriver::PasswordGenerationRejectedByTyping");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPasswordGenerationDriver_PasswordGenerationRejectedByTyping_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::PasswordGenerationDriver_PasswordGenerationRejectedByTyping_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordGenerationDriver::Name_);
  message.set_method_name("PasswordGenerationRejectedByTyping");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PasswordGenerationDriverProxy::PresaveGeneratedPassword(
    const ::autofill::FormData& in_form_data, const ::base::string16& in_password_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::PasswordGenerationDriver::PresaveGeneratedPassword");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPasswordGenerationDriver_PresaveGeneratedPassword_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::PasswordGenerationDriver_PresaveGeneratedPassword_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->form_data)::BaseType::BufferWriter
      form_data_writer;
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form_data, buffer, &form_data_writer, &serialization_context);
  params->form_data.Set(
      form_data_writer.is_null() ? nullptr : form_data_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form_data in PasswordGenerationDriver.PresaveGeneratedPassword request");
  typename decltype(params->password_value)::BaseType::BufferWriter
      password_value_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_password_value, buffer, &password_value_writer, &serialization_context);
  params->password_value.Set(
      password_value_writer.is_null() ? nullptr : password_value_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->password_value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null password_value in PasswordGenerationDriver.PresaveGeneratedPassword request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordGenerationDriver::Name_);
  message.set_method_name("PresaveGeneratedPassword");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PasswordGenerationDriverProxy::PasswordNoLongerGenerated(
    const ::autofill::FormData& in_form_data) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::PasswordGenerationDriver::PasswordNoLongerGenerated");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPasswordGenerationDriver_PasswordNoLongerGenerated_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::PasswordGenerationDriver_PasswordNoLongerGenerated_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->form_data)::BaseType::BufferWriter
      form_data_writer;
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form_data, buffer, &form_data_writer, &serialization_context);
  params->form_data.Set(
      form_data_writer.is_null() ? nullptr : form_data_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form_data in PasswordGenerationDriver.PasswordNoLongerGenerated request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordGenerationDriver::Name_);
  message.set_method_name("PasswordNoLongerGenerated");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PasswordGenerationDriverProxy::FrameWasScrolled(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::PasswordGenerationDriver::FrameWasScrolled");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPasswordGenerationDriver_FrameWasScrolled_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::PasswordGenerationDriver_FrameWasScrolled_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordGenerationDriver::Name_);
  message.set_method_name("FrameWasScrolled");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PasswordGenerationDriverProxy::GenerationElementLostFocus(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "autofill::mojom::PasswordGenerationDriver::GenerationElementLostFocus");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPasswordGenerationDriver_GenerationElementLostFocus_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::autofill::mojom::internal::PasswordGenerationDriver_GenerationElementLostFocus_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordGenerationDriver::Name_);
  message.set_method_name("GenerationElementLostFocus");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool PasswordGenerationDriverStubDispatch::Accept(
    PasswordGenerationDriver* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kPasswordGenerationDriver_AutomaticGenerationAvailable_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::PasswordGenerationDriver::AutomaticGenerationAvailable",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::PasswordGenerationDriver::AutomaticGenerationAvailable");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::PasswordGenerationDriver_AutomaticGenerationAvailable_Params_Data* params =
          reinterpret_cast<internal::PasswordGenerationDriver_AutomaticGenerationAvailable_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::autofill::password_generation::PasswordGenerationUIData p_password_generation_ui_data{};
      PasswordGenerationDriver_AutomaticGenerationAvailable_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadPasswordGenerationUiData(&p_password_generation_ui_data))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordGenerationDriver::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AutomaticGenerationAvailable(
std::move(p_password_generation_ui_data));
      return true;
    }
    case internal::kPasswordGenerationDriver_ShowPasswordEditingPopup_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::PasswordGenerationDriver::ShowPasswordEditingPopup",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::PasswordGenerationDriver::ShowPasswordEditingPopup");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::PasswordGenerationDriver_ShowPasswordEditingPopup_Params_Data* params =
          reinterpret_cast<internal::PasswordGenerationDriver_ShowPasswordEditingPopup_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::gfx::RectF p_bounds{};
      ::autofill::FormData p_form_data{};
      uint32_t p_field_renderer_id{};
      ::base::string16 p_password_value{};
      PasswordGenerationDriver_ShowPasswordEditingPopup_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadBounds(&p_bounds))
        success = false;
      if (success && !input_data_view.ReadFormData(&p_form_data))
        success = false;
      if (success)
        p_field_renderer_id = input_data_view.field_renderer_id();
      if (success && !input_data_view.ReadPasswordValue(&p_password_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordGenerationDriver::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ShowPasswordEditingPopup(
std::move(p_bounds), 
std::move(p_form_data), 
std::move(p_field_renderer_id), 
std::move(p_password_value));
      return true;
    }
    case internal::kPasswordGenerationDriver_PasswordGenerationRejectedByTyping_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::PasswordGenerationDriver::PasswordGenerationRejectedByTyping",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::PasswordGenerationDriver::PasswordGenerationRejectedByTyping");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::PasswordGenerationDriver_PasswordGenerationRejectedByTyping_Params_Data* params =
          reinterpret_cast<internal::PasswordGenerationDriver_PasswordGenerationRejectedByTyping_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      PasswordGenerationDriver_PasswordGenerationRejectedByTyping_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordGenerationDriver::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PasswordGenerationRejectedByTyping();
      return true;
    }
    case internal::kPasswordGenerationDriver_PresaveGeneratedPassword_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::PasswordGenerationDriver::PresaveGeneratedPassword",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::PasswordGenerationDriver::PresaveGeneratedPassword");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::PasswordGenerationDriver_PresaveGeneratedPassword_Params_Data* params =
          reinterpret_cast<internal::PasswordGenerationDriver_PresaveGeneratedPassword_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::autofill::FormData p_form_data{};
      ::base::string16 p_password_value{};
      PasswordGenerationDriver_PresaveGeneratedPassword_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadFormData(&p_form_data))
        success = false;
      if (success && !input_data_view.ReadPasswordValue(&p_password_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordGenerationDriver::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PresaveGeneratedPassword(
std::move(p_form_data), 
std::move(p_password_value));
      return true;
    }
    case internal::kPasswordGenerationDriver_PasswordNoLongerGenerated_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::PasswordGenerationDriver::PasswordNoLongerGenerated",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::PasswordGenerationDriver::PasswordNoLongerGenerated");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::PasswordGenerationDriver_PasswordNoLongerGenerated_Params_Data* params =
          reinterpret_cast<internal::PasswordGenerationDriver_PasswordNoLongerGenerated_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::autofill::FormData p_form_data{};
      PasswordGenerationDriver_PasswordNoLongerGenerated_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadFormData(&p_form_data))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordGenerationDriver::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PasswordNoLongerGenerated(
std::move(p_form_data));
      return true;
    }
    case internal::kPasswordGenerationDriver_FrameWasScrolled_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::PasswordGenerationDriver::FrameWasScrolled",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::PasswordGenerationDriver::FrameWasScrolled");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::PasswordGenerationDriver_FrameWasScrolled_Params_Data* params =
          reinterpret_cast<internal::PasswordGenerationDriver_FrameWasScrolled_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      PasswordGenerationDriver_FrameWasScrolled_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordGenerationDriver::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FrameWasScrolled();
      return true;
    }
    case internal::kPasswordGenerationDriver_GenerationElementLostFocus_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)autofill::mojom::PasswordGenerationDriver::GenerationElementLostFocus",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)autofill::mojom::PasswordGenerationDriver::GenerationElementLostFocus");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::PasswordGenerationDriver_GenerationElementLostFocus_Params_Data* params =
          reinterpret_cast<internal::PasswordGenerationDriver_GenerationElementLostFocus_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      PasswordGenerationDriver_GenerationElementLostFocus_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordGenerationDriver::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GenerationElementLostFocus();
      return true;
    }
  }
  return false;
}

// static
bool PasswordGenerationDriverStubDispatch::AcceptWithResponder(
    PasswordGenerationDriver* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kPasswordGenerationDriver_AutomaticGenerationAvailable_Name: {
      break;
    }
    case internal::kPasswordGenerationDriver_ShowPasswordEditingPopup_Name: {
      break;
    }
    case internal::kPasswordGenerationDriver_PasswordGenerationRejectedByTyping_Name: {
      break;
    }
    case internal::kPasswordGenerationDriver_PresaveGeneratedPassword_Name: {
      break;
    }
    case internal::kPasswordGenerationDriver_PasswordNoLongerGenerated_Name: {
      break;
    }
    case internal::kPasswordGenerationDriver_FrameWasScrolled_Name: {
      break;
    }
    case internal::kPasswordGenerationDriver_GenerationElementLostFocus_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kPasswordGenerationDriverValidationInfo[] = {
    {&internal::PasswordGenerationDriver_AutomaticGenerationAvailable_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordGenerationDriver_ShowPasswordEditingPopup_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordGenerationDriver_PasswordGenerationRejectedByTyping_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordGenerationDriver_PresaveGeneratedPassword_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordGenerationDriver_PasswordNoLongerGenerated_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordGenerationDriver_FrameWasScrolled_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordGenerationDriver_GenerationElementLostFocus_Params_Data::Validate,
     nullptr /* no response */},
};

bool PasswordGenerationDriverRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::autofill::mojom::PasswordGenerationDriver::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kPasswordGenerationDriverValidationInfo);
}

}  // namespace mojom
}  // namespace autofill

namespace mojo {

}  // namespace mojo

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif