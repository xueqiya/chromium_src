// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: download_entry.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_download_5fentry_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_download_5fentry_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "download_source.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_download_5fentry_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_download_5fentry_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace download_pb {
class DownloadDBEntry;
class DownloadDBEntryDefaultTypeInternal;
extern DownloadDBEntryDefaultTypeInternal _DownloadDBEntry_default_instance_;
class DownloadEntries;
class DownloadEntriesDefaultTypeInternal;
extern DownloadEntriesDefaultTypeInternal _DownloadEntries_default_instance_;
class DownloadEntry;
class DownloadEntryDefaultTypeInternal;
extern DownloadEntryDefaultTypeInternal _DownloadEntry_default_instance_;
class DownloadInfo;
class DownloadInfoDefaultTypeInternal;
extern DownloadInfoDefaultTypeInternal _DownloadInfo_default_instance_;
class HttpRequestHeader;
class HttpRequestHeaderDefaultTypeInternal;
extern HttpRequestHeaderDefaultTypeInternal _HttpRequestHeader_default_instance_;
class InProgressInfo;
class InProgressInfoDefaultTypeInternal;
extern InProgressInfoDefaultTypeInternal _InProgressInfo_default_instance_;
class ReceivedSlice;
class ReceivedSliceDefaultTypeInternal;
extern ReceivedSliceDefaultTypeInternal _ReceivedSlice_default_instance_;
class UkmInfo;
class UkmInfoDefaultTypeInternal;
extern UkmInfoDefaultTypeInternal _UkmInfo_default_instance_;
}  // namespace download_pb
PROTOBUF_NAMESPACE_OPEN
template<> ::download_pb::DownloadDBEntry* Arena::CreateMaybeMessage<::download_pb::DownloadDBEntry>(Arena*);
template<> ::download_pb::DownloadEntries* Arena::CreateMaybeMessage<::download_pb::DownloadEntries>(Arena*);
template<> ::download_pb::DownloadEntry* Arena::CreateMaybeMessage<::download_pb::DownloadEntry>(Arena*);
template<> ::download_pb::DownloadInfo* Arena::CreateMaybeMessage<::download_pb::DownloadInfo>(Arena*);
template<> ::download_pb::HttpRequestHeader* Arena::CreateMaybeMessage<::download_pb::HttpRequestHeader>(Arena*);
template<> ::download_pb::InProgressInfo* Arena::CreateMaybeMessage<::download_pb::InProgressInfo>(Arena*);
template<> ::download_pb::ReceivedSlice* Arena::CreateMaybeMessage<::download_pb::ReceivedSlice>(Arena*);
template<> ::download_pb::UkmInfo* Arena::CreateMaybeMessage<::download_pb::UkmInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace download_pb {

// ===================================================================

class HttpRequestHeader :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:download_pb.HttpRequestHeader) */ {
 public:
  HttpRequestHeader();
  virtual ~HttpRequestHeader();

  HttpRequestHeader(const HttpRequestHeader& from);
  HttpRequestHeader(HttpRequestHeader&& from) noexcept
    : HttpRequestHeader() {
    *this = ::std::move(from);
  }

  inline HttpRequestHeader& operator=(const HttpRequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline HttpRequestHeader& operator=(HttpRequestHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const HttpRequestHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HttpRequestHeader* internal_default_instance() {
    return reinterpret_cast<const HttpRequestHeader*>(
               &_HttpRequestHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HttpRequestHeader& a, HttpRequestHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(HttpRequestHeader* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HttpRequestHeader* New() const final {
    return CreateMaybeMessage<HttpRequestHeader>(nullptr);
  }

  HttpRequestHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HttpRequestHeader>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const HttpRequestHeader& from);
  void MergeFrom(const HttpRequestHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HttpRequestHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "download_pb.HttpRequestHeader";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);

  // optional string value = 2;
  bool has_value() const;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:download_pb.HttpRequestHeader)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_download_5fentry_2eproto;
};
// -------------------------------------------------------------------

class ReceivedSlice :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:download_pb.ReceivedSlice) */ {
 public:
  ReceivedSlice();
  virtual ~ReceivedSlice();

  ReceivedSlice(const ReceivedSlice& from);
  ReceivedSlice(ReceivedSlice&& from) noexcept
    : ReceivedSlice() {
    *this = ::std::move(from);
  }

  inline ReceivedSlice& operator=(const ReceivedSlice& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceivedSlice& operator=(ReceivedSlice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ReceivedSlice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReceivedSlice* internal_default_instance() {
    return reinterpret_cast<const ReceivedSlice*>(
               &_ReceivedSlice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ReceivedSlice& a, ReceivedSlice& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceivedSlice* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReceivedSlice* New() const final {
    return CreateMaybeMessage<ReceivedSlice>(nullptr);
  }

  ReceivedSlice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReceivedSlice>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ReceivedSlice& from);
  void MergeFrom(const ReceivedSlice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReceivedSlice* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "download_pb.ReceivedSlice";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 1,
    kReceivedBytesFieldNumber = 2,
    kFinishedFieldNumber = 3,
  };
  // optional int64 offset = 1;
  bool has_offset() const;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 received_bytes = 2;
  bool has_received_bytes() const;
  void clear_received_bytes();
  ::PROTOBUF_NAMESPACE_ID::int64 received_bytes() const;
  void set_received_bytes(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional bool finished = 3;
  bool has_finished() const;
  void clear_finished();
  bool finished() const;
  void set_finished(bool value);

  // @@protoc_insertion_point(class_scope:download_pb.ReceivedSlice)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 offset_;
  ::PROTOBUF_NAMESPACE_ID::int64 received_bytes_;
  bool finished_;
  friend struct ::TableStruct_download_5fentry_2eproto;
};
// -------------------------------------------------------------------

class DownloadEntry :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:download_pb.DownloadEntry) */ {
 public:
  DownloadEntry();
  virtual ~DownloadEntry();

  DownloadEntry(const DownloadEntry& from);
  DownloadEntry(DownloadEntry&& from) noexcept
    : DownloadEntry() {
    *this = ::std::move(from);
  }

  inline DownloadEntry& operator=(const DownloadEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadEntry& operator=(DownloadEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DownloadEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DownloadEntry* internal_default_instance() {
    return reinterpret_cast<const DownloadEntry*>(
               &_DownloadEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DownloadEntry& a, DownloadEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadEntry* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DownloadEntry* New() const final {
    return CreateMaybeMessage<DownloadEntry>(nullptr);
  }

  DownloadEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DownloadEntry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DownloadEntry& from);
  void MergeFrom(const DownloadEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DownloadEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "download_pb.DownloadEntry";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestHeadersFieldNumber = 7,
    kGuidFieldNumber = 1,
    kRequestOriginFieldNumber = 2,
    kUkmDownloadIdFieldNumber = 4,
    kDownloadSourceFieldNumber = 3,
    kFetchErrorBodyFieldNumber = 6,
    kBytesWastedFieldNumber = 5,
  };
  // repeated .download_pb.HttpRequestHeader request_headers = 7;
  int request_headers_size() const;
  void clear_request_headers();
  ::download_pb::HttpRequestHeader* mutable_request_headers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::HttpRequestHeader >*
      mutable_request_headers();
  const ::download_pb::HttpRequestHeader& request_headers(int index) const;
  ::download_pb::HttpRequestHeader* add_request_headers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::HttpRequestHeader >&
      request_headers() const;

  // optional string guid = 1;
  bool has_guid() const;
  void clear_guid();
  const std::string& guid() const;
  void set_guid(const std::string& value);
  void set_guid(std::string&& value);
  void set_guid(const char* value);
  void set_guid(const char* value, size_t size);
  std::string* mutable_guid();
  std::string* release_guid();
  void set_allocated_guid(std::string* guid);

  // optional string request_origin = 2;
  bool has_request_origin() const;
  void clear_request_origin();
  const std::string& request_origin() const;
  void set_request_origin(const std::string& value);
  void set_request_origin(std::string&& value);
  void set_request_origin(const char* value);
  void set_request_origin(const char* value, size_t size);
  std::string* mutable_request_origin();
  std::string* release_request_origin();
  void set_allocated_request_origin(std::string* request_origin);

  // optional int64 ukm_download_id = 4;
  bool has_ukm_download_id() const;
  void clear_ukm_download_id();
  ::PROTOBUF_NAMESPACE_ID::int64 ukm_download_id() const;
  void set_ukm_download_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional .download_pb.DownloadSource download_source = 3;
  bool has_download_source() const;
  void clear_download_source();
  ::download_pb::DownloadSource download_source() const;
  void set_download_source(::download_pb::DownloadSource value);

  // optional bool fetch_error_body = 6;
  bool has_fetch_error_body() const;
  void clear_fetch_error_body();
  bool fetch_error_body() const;
  void set_fetch_error_body(bool value);

  // optional int64 bytes_wasted = 5;
  bool has_bytes_wasted() const;
  void clear_bytes_wasted();
  ::PROTOBUF_NAMESPACE_ID::int64 bytes_wasted() const;
  void set_bytes_wasted(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:download_pb.DownloadEntry)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::HttpRequestHeader > request_headers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_origin_;
  ::PROTOBUF_NAMESPACE_ID::int64 ukm_download_id_;
  int download_source_;
  bool fetch_error_body_;
  ::PROTOBUF_NAMESPACE_ID::int64 bytes_wasted_;
  friend struct ::TableStruct_download_5fentry_2eproto;
};
// -------------------------------------------------------------------

class DownloadEntries :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:download_pb.DownloadEntries) */ {
 public:
  DownloadEntries();
  virtual ~DownloadEntries();

  DownloadEntries(const DownloadEntries& from);
  DownloadEntries(DownloadEntries&& from) noexcept
    : DownloadEntries() {
    *this = ::std::move(from);
  }

  inline DownloadEntries& operator=(const DownloadEntries& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadEntries& operator=(DownloadEntries&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DownloadEntries& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DownloadEntries* internal_default_instance() {
    return reinterpret_cast<const DownloadEntries*>(
               &_DownloadEntries_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DownloadEntries& a, DownloadEntries& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadEntries* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DownloadEntries* New() const final {
    return CreateMaybeMessage<DownloadEntries>(nullptr);
  }

  DownloadEntries* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DownloadEntries>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DownloadEntries& from);
  void MergeFrom(const DownloadEntries& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DownloadEntries* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "download_pb.DownloadEntries";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .download_pb.DownloadEntry entries = 1;
  int entries_size() const;
  void clear_entries();
  ::download_pb::DownloadEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::DownloadEntry >*
      mutable_entries();
  const ::download_pb::DownloadEntry& entries(int index) const;
  ::download_pb::DownloadEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::DownloadEntry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:download_pb.DownloadEntries)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::DownloadEntry > entries_;
  friend struct ::TableStruct_download_5fentry_2eproto;
};
// -------------------------------------------------------------------

class UkmInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:download_pb.UkmInfo) */ {
 public:
  UkmInfo();
  virtual ~UkmInfo();

  UkmInfo(const UkmInfo& from);
  UkmInfo(UkmInfo&& from) noexcept
    : UkmInfo() {
    *this = ::std::move(from);
  }

  inline UkmInfo& operator=(const UkmInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UkmInfo& operator=(UkmInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const UkmInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UkmInfo* internal_default_instance() {
    return reinterpret_cast<const UkmInfo*>(
               &_UkmInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UkmInfo& a, UkmInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UkmInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UkmInfo* New() const final {
    return CreateMaybeMessage<UkmInfo>(nullptr);
  }

  UkmInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UkmInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const UkmInfo& from);
  void MergeFrom(const UkmInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UkmInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "download_pb.UkmInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUkmDownloadIdFieldNumber = 2,
    kDownloadSourceFieldNumber = 1,
  };
  // optional int64 ukm_download_id = 2;
  bool has_ukm_download_id() const;
  void clear_ukm_download_id();
  ::PROTOBUF_NAMESPACE_ID::int64 ukm_download_id() const;
  void set_ukm_download_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional .download_pb.DownloadSource download_source = 1;
  bool has_download_source() const;
  void clear_download_source();
  ::download_pb::DownloadSource download_source() const;
  void set_download_source(::download_pb::DownloadSource value);

  // @@protoc_insertion_point(class_scope:download_pb.UkmInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 ukm_download_id_;
  int download_source_;
  friend struct ::TableStruct_download_5fentry_2eproto;
};
// -------------------------------------------------------------------

class InProgressInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:download_pb.InProgressInfo) */ {
 public:
  InProgressInfo();
  virtual ~InProgressInfo();

  InProgressInfo(const InProgressInfo& from);
  InProgressInfo(InProgressInfo&& from) noexcept
    : InProgressInfo() {
    *this = ::std::move(from);
  }

  inline InProgressInfo& operator=(const InProgressInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline InProgressInfo& operator=(InProgressInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const InProgressInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InProgressInfo* internal_default_instance() {
    return reinterpret_cast<const InProgressInfo*>(
               &_InProgressInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InProgressInfo& a, InProgressInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(InProgressInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InProgressInfo* New() const final {
    return CreateMaybeMessage<InProgressInfo>(nullptr);
  }

  InProgressInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InProgressInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const InProgressInfo& from);
  void MergeFrom(const InProgressInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InProgressInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "download_pb.InProgressInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlChainFieldNumber = 1,
    kRequestHeadersFieldNumber = 7,
    kReceivedSlicesFieldNumber = 18,
    kReferrerUrlFieldNumber = 2,
    kSiteUrlFieldNumber = 3,
    kTabUrlFieldNumber = 4,
    kTabReferrerUrlFieldNumber = 5,
    kEtagFieldNumber = 8,
    kLastModifiedFieldNumber = 9,
    kMimeTypeFieldNumber = 11,
    kOriginalMimeTypeFieldNumber = 12,
    kCurrentPathFieldNumber = 13,
    kTargetPathFieldNumber = 14,
    kHashFieldNumber = 19,
    kTotalBytesFieldNumber = 10,
    kReceivedBytesFieldNumber = 15,
    kStartTimeFieldNumber = 16,
    kEndTimeFieldNumber = 17,
    kFetchErrorBodyFieldNumber = 6,
    kTransientFieldNumber = 20,
    kPausedFieldNumber = 24,
    kMeteredFieldNumber = 25,
    kStateFieldNumber = 21,
    kDangerTypeFieldNumber = 22,
    kInterruptReasonFieldNumber = 23,
    kBytesWastedFieldNumber = 26,
    kAutoResumeCountFieldNumber = 27,
  };
  // repeated string url_chain = 1;
  int url_chain_size() const;
  void clear_url_chain();
  const std::string& url_chain(int index) const;
  std::string* mutable_url_chain(int index);
  void set_url_chain(int index, const std::string& value);
  void set_url_chain(int index, std::string&& value);
  void set_url_chain(int index, const char* value);
  void set_url_chain(int index, const char* value, size_t size);
  std::string* add_url_chain();
  void add_url_chain(const std::string& value);
  void add_url_chain(std::string&& value);
  void add_url_chain(const char* value);
  void add_url_chain(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& url_chain() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_url_chain();

  // repeated .download_pb.HttpRequestHeader request_headers = 7;
  int request_headers_size() const;
  void clear_request_headers();
  ::download_pb::HttpRequestHeader* mutable_request_headers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::HttpRequestHeader >*
      mutable_request_headers();
  const ::download_pb::HttpRequestHeader& request_headers(int index) const;
  ::download_pb::HttpRequestHeader* add_request_headers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::HttpRequestHeader >&
      request_headers() const;

  // repeated .download_pb.ReceivedSlice received_slices = 18;
  int received_slices_size() const;
  void clear_received_slices();
  ::download_pb::ReceivedSlice* mutable_received_slices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::ReceivedSlice >*
      mutable_received_slices();
  const ::download_pb::ReceivedSlice& received_slices(int index) const;
  ::download_pb::ReceivedSlice* add_received_slices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::ReceivedSlice >&
      received_slices() const;

  // optional string referrer_url = 2;
  bool has_referrer_url() const;
  void clear_referrer_url();
  const std::string& referrer_url() const;
  void set_referrer_url(const std::string& value);
  void set_referrer_url(std::string&& value);
  void set_referrer_url(const char* value);
  void set_referrer_url(const char* value, size_t size);
  std::string* mutable_referrer_url();
  std::string* release_referrer_url();
  void set_allocated_referrer_url(std::string* referrer_url);

  // optional string site_url = 3;
  bool has_site_url() const;
  void clear_site_url();
  const std::string& site_url() const;
  void set_site_url(const std::string& value);
  void set_site_url(std::string&& value);
  void set_site_url(const char* value);
  void set_site_url(const char* value, size_t size);
  std::string* mutable_site_url();
  std::string* release_site_url();
  void set_allocated_site_url(std::string* site_url);

  // optional string tab_url = 4;
  bool has_tab_url() const;
  void clear_tab_url();
  const std::string& tab_url() const;
  void set_tab_url(const std::string& value);
  void set_tab_url(std::string&& value);
  void set_tab_url(const char* value);
  void set_tab_url(const char* value, size_t size);
  std::string* mutable_tab_url();
  std::string* release_tab_url();
  void set_allocated_tab_url(std::string* tab_url);

  // optional string tab_referrer_url = 5;
  bool has_tab_referrer_url() const;
  void clear_tab_referrer_url();
  const std::string& tab_referrer_url() const;
  void set_tab_referrer_url(const std::string& value);
  void set_tab_referrer_url(std::string&& value);
  void set_tab_referrer_url(const char* value);
  void set_tab_referrer_url(const char* value, size_t size);
  std::string* mutable_tab_referrer_url();
  std::string* release_tab_referrer_url();
  void set_allocated_tab_referrer_url(std::string* tab_referrer_url);

  // optional string etag = 8;
  bool has_etag() const;
  void clear_etag();
  const std::string& etag() const;
  void set_etag(const std::string& value);
  void set_etag(std::string&& value);
  void set_etag(const char* value);
  void set_etag(const char* value, size_t size);
  std::string* mutable_etag();
  std::string* release_etag();
  void set_allocated_etag(std::string* etag);

  // optional string last_modified = 9;
  bool has_last_modified() const;
  void clear_last_modified();
  const std::string& last_modified() const;
  void set_last_modified(const std::string& value);
  void set_last_modified(std::string&& value);
  void set_last_modified(const char* value);
  void set_last_modified(const char* value, size_t size);
  std::string* mutable_last_modified();
  std::string* release_last_modified();
  void set_allocated_last_modified(std::string* last_modified);

  // optional string mime_type = 11;
  bool has_mime_type() const;
  void clear_mime_type();
  const std::string& mime_type() const;
  void set_mime_type(const std::string& value);
  void set_mime_type(std::string&& value);
  void set_mime_type(const char* value);
  void set_mime_type(const char* value, size_t size);
  std::string* mutable_mime_type();
  std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);

  // optional string original_mime_type = 12;
  bool has_original_mime_type() const;
  void clear_original_mime_type();
  const std::string& original_mime_type() const;
  void set_original_mime_type(const std::string& value);
  void set_original_mime_type(std::string&& value);
  void set_original_mime_type(const char* value);
  void set_original_mime_type(const char* value, size_t size);
  std::string* mutable_original_mime_type();
  std::string* release_original_mime_type();
  void set_allocated_original_mime_type(std::string* original_mime_type);

  // optional bytes current_path = 13;
  bool has_current_path() const;
  void clear_current_path();
  const std::string& current_path() const;
  void set_current_path(const std::string& value);
  void set_current_path(std::string&& value);
  void set_current_path(const char* value);
  void set_current_path(const void* value, size_t size);
  std::string* mutable_current_path();
  std::string* release_current_path();
  void set_allocated_current_path(std::string* current_path);

  // optional bytes target_path = 14;
  bool has_target_path() const;
  void clear_target_path();
  const std::string& target_path() const;
  void set_target_path(const std::string& value);
  void set_target_path(std::string&& value);
  void set_target_path(const char* value);
  void set_target_path(const void* value, size_t size);
  std::string* mutable_target_path();
  std::string* release_target_path();
  void set_allocated_target_path(std::string* target_path);

  // optional string hash = 19;
  bool has_hash() const;
  void clear_hash();
  const std::string& hash() const;
  void set_hash(const std::string& value);
  void set_hash(std::string&& value);
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  std::string* mutable_hash();
  std::string* release_hash();
  void set_allocated_hash(std::string* hash);

  // optional int64 total_bytes = 10;
  bool has_total_bytes() const;
  void clear_total_bytes();
  ::PROTOBUF_NAMESPACE_ID::int64 total_bytes() const;
  void set_total_bytes(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 received_bytes = 15;
  bool has_received_bytes() const;
  void clear_received_bytes();
  ::PROTOBUF_NAMESPACE_ID::int64 received_bytes() const;
  void set_received_bytes(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 start_time = 16;
  bool has_start_time() const;
  void clear_start_time();
  ::PROTOBUF_NAMESPACE_ID::int64 start_time() const;
  void set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 end_time = 17;
  bool has_end_time() const;
  void clear_end_time();
  ::PROTOBUF_NAMESPACE_ID::int64 end_time() const;
  void set_end_time(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional bool fetch_error_body = 6;
  bool has_fetch_error_body() const;
  void clear_fetch_error_body();
  bool fetch_error_body() const;
  void set_fetch_error_body(bool value);

  // optional bool transient = 20;
  bool has_transient() const;
  void clear_transient();
  bool transient() const;
  void set_transient(bool value);

  // optional bool paused = 24;
  bool has_paused() const;
  void clear_paused();
  bool paused() const;
  void set_paused(bool value);

  // optional bool metered = 25;
  bool has_metered() const;
  void clear_metered();
  bool metered() const;
  void set_metered(bool value);

  // optional int32 state = 21;
  bool has_state() const;
  void clear_state();
  ::PROTOBUF_NAMESPACE_ID::int32 state() const;
  void set_state(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 danger_type = 22;
  bool has_danger_type() const;
  void clear_danger_type();
  ::PROTOBUF_NAMESPACE_ID::int32 danger_type() const;
  void set_danger_type(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 interrupt_reason = 23;
  bool has_interrupt_reason() const;
  void clear_interrupt_reason();
  ::PROTOBUF_NAMESPACE_ID::int32 interrupt_reason() const;
  void set_interrupt_reason(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int64 bytes_wasted = 26;
  bool has_bytes_wasted() const;
  void clear_bytes_wasted();
  ::PROTOBUF_NAMESPACE_ID::int64 bytes_wasted() const;
  void set_bytes_wasted(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int32 auto_resume_count = 27;
  bool has_auto_resume_count() const;
  void clear_auto_resume_count();
  ::PROTOBUF_NAMESPACE_ID::int32 auto_resume_count() const;
  void set_auto_resume_count(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:download_pb.InProgressInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> url_chain_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::HttpRequestHeader > request_headers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::ReceivedSlice > received_slices_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr referrer_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr site_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tab_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tab_referrer_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr etag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_modified_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr original_mime_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::int64 total_bytes_;
  ::PROTOBUF_NAMESPACE_ID::int64 received_bytes_;
  ::PROTOBUF_NAMESPACE_ID::int64 start_time_;
  ::PROTOBUF_NAMESPACE_ID::int64 end_time_;
  bool fetch_error_body_;
  bool transient_;
  bool paused_;
  bool metered_;
  ::PROTOBUF_NAMESPACE_ID::int32 state_;
  ::PROTOBUF_NAMESPACE_ID::int32 danger_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 interrupt_reason_;
  ::PROTOBUF_NAMESPACE_ID::int64 bytes_wasted_;
  ::PROTOBUF_NAMESPACE_ID::int32 auto_resume_count_;
  friend struct ::TableStruct_download_5fentry_2eproto;
};
// -------------------------------------------------------------------

class DownloadInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:download_pb.DownloadInfo) */ {
 public:
  DownloadInfo();
  virtual ~DownloadInfo();

  DownloadInfo(const DownloadInfo& from);
  DownloadInfo(DownloadInfo&& from) noexcept
    : DownloadInfo() {
    *this = ::std::move(from);
  }

  inline DownloadInfo& operator=(const DownloadInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadInfo& operator=(DownloadInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DownloadInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DownloadInfo* internal_default_instance() {
    return reinterpret_cast<const DownloadInfo*>(
               &_DownloadInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DownloadInfo& a, DownloadInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DownloadInfo* New() const final {
    return CreateMaybeMessage<DownloadInfo>(nullptr);
  }

  DownloadInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DownloadInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DownloadInfo& from);
  void MergeFrom(const DownloadInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DownloadInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "download_pb.DownloadInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGuidFieldNumber = 1,
    kUkmInfoFieldNumber = 3,
    kInProgressInfoFieldNumber = 4,
    kIdFieldNumber = 2,
  };
  // optional string guid = 1;
  bool has_guid() const;
  void clear_guid();
  const std::string& guid() const;
  void set_guid(const std::string& value);
  void set_guid(std::string&& value);
  void set_guid(const char* value);
  void set_guid(const char* value, size_t size);
  std::string* mutable_guid();
  std::string* release_guid();
  void set_allocated_guid(std::string* guid);

  // optional .download_pb.UkmInfo ukm_info = 3;
  bool has_ukm_info() const;
  void clear_ukm_info();
  const ::download_pb::UkmInfo& ukm_info() const;
  ::download_pb::UkmInfo* release_ukm_info();
  ::download_pb::UkmInfo* mutable_ukm_info();
  void set_allocated_ukm_info(::download_pb::UkmInfo* ukm_info);

  // optional .download_pb.InProgressInfo in_progress_info = 4;
  bool has_in_progress_info() const;
  void clear_in_progress_info();
  const ::download_pb::InProgressInfo& in_progress_info() const;
  ::download_pb::InProgressInfo* release_in_progress_info();
  ::download_pb::InProgressInfo* mutable_in_progress_info();
  void set_allocated_in_progress_info(::download_pb::InProgressInfo* in_progress_info);

  // optional int32 id = 2;
  bool has_id() const;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:download_pb.DownloadInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guid_;
  ::download_pb::UkmInfo* ukm_info_;
  ::download_pb::InProgressInfo* in_progress_info_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  friend struct ::TableStruct_download_5fentry_2eproto;
};
// -------------------------------------------------------------------

class DownloadDBEntry :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:download_pb.DownloadDBEntry) */ {
 public:
  DownloadDBEntry();
  virtual ~DownloadDBEntry();

  DownloadDBEntry(const DownloadDBEntry& from);
  DownloadDBEntry(DownloadDBEntry&& from) noexcept
    : DownloadDBEntry() {
    *this = ::std::move(from);
  }

  inline DownloadDBEntry& operator=(const DownloadDBEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadDBEntry& operator=(DownloadDBEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DownloadDBEntry& default_instance();

  enum EntryCase {
    kDownloadInfo = 1,
    ENTRY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DownloadDBEntry* internal_default_instance() {
    return reinterpret_cast<const DownloadDBEntry*>(
               &_DownloadDBEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DownloadDBEntry& a, DownloadDBEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadDBEntry* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DownloadDBEntry* New() const final {
    return CreateMaybeMessage<DownloadDBEntry>(nullptr);
  }

  DownloadDBEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DownloadDBEntry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DownloadDBEntry& from);
  void MergeFrom(const DownloadDBEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DownloadDBEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "download_pb.DownloadDBEntry";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDownloadInfoFieldNumber = 1,
  };
  // optional .download_pb.DownloadInfo download_info = 1;
  bool has_download_info() const;
  void clear_download_info();
  const ::download_pb::DownloadInfo& download_info() const;
  ::download_pb::DownloadInfo* release_download_info();
  ::download_pb::DownloadInfo* mutable_download_info();
  void set_allocated_download_info(::download_pb::DownloadInfo* download_info);

  void clear_entry();
  EntryCase entry_case() const;
  // @@protoc_insertion_point(class_scope:download_pb.DownloadDBEntry)
 private:
  class _Internal;
  void set_has_download_info();

  inline bool has_entry() const;
  inline void clear_has_entry();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  union EntryUnion {
    EntryUnion() {}
    ::download_pb::DownloadInfo* download_info_;
  } entry_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_download_5fentry_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HttpRequestHeader

// optional string key = 1;
inline bool HttpRequestHeader::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HttpRequestHeader::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HttpRequestHeader::key() const {
  // @@protoc_insertion_point(field_get:download_pb.HttpRequestHeader.key)
  return key_.GetNoArena();
}
inline void HttpRequestHeader::set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:download_pb.HttpRequestHeader.key)
}
inline void HttpRequestHeader::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:download_pb.HttpRequestHeader.key)
}
inline void HttpRequestHeader::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:download_pb.HttpRequestHeader.key)
}
inline void HttpRequestHeader::set_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:download_pb.HttpRequestHeader.key)
}
inline std::string* HttpRequestHeader::mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:download_pb.HttpRequestHeader.key)
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HttpRequestHeader::release_key() {
  // @@protoc_insertion_point(field_release:download_pb.HttpRequestHeader.key)
  if (!has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HttpRequestHeader::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:download_pb.HttpRequestHeader.key)
}

// optional string value = 2;
inline bool HttpRequestHeader::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HttpRequestHeader::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HttpRequestHeader::value() const {
  // @@protoc_insertion_point(field_get:download_pb.HttpRequestHeader.value)
  return value_.GetNoArena();
}
inline void HttpRequestHeader::set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:download_pb.HttpRequestHeader.value)
}
inline void HttpRequestHeader::set_value(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:download_pb.HttpRequestHeader.value)
}
inline void HttpRequestHeader::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:download_pb.HttpRequestHeader.value)
}
inline void HttpRequestHeader::set_value(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:download_pb.HttpRequestHeader.value)
}
inline std::string* HttpRequestHeader::mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:download_pb.HttpRequestHeader.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HttpRequestHeader::release_value() {
  // @@protoc_insertion_point(field_release:download_pb.HttpRequestHeader.value)
  if (!has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return value_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HttpRequestHeader::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:download_pb.HttpRequestHeader.value)
}

// -------------------------------------------------------------------

// ReceivedSlice

// optional int64 offset = 1;
inline bool ReceivedSlice::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReceivedSlice::clear_offset() {
  offset_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReceivedSlice::offset() const {
  // @@protoc_insertion_point(field_get:download_pb.ReceivedSlice.offset)
  return offset_;
}
inline void ReceivedSlice::set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  offset_ = value;
  // @@protoc_insertion_point(field_set:download_pb.ReceivedSlice.offset)
}

// optional int64 received_bytes = 2;
inline bool ReceivedSlice::has_received_bytes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReceivedSlice::clear_received_bytes() {
  received_bytes_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReceivedSlice::received_bytes() const {
  // @@protoc_insertion_point(field_get:download_pb.ReceivedSlice.received_bytes)
  return received_bytes_;
}
inline void ReceivedSlice::set_received_bytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  received_bytes_ = value;
  // @@protoc_insertion_point(field_set:download_pb.ReceivedSlice.received_bytes)
}

// optional bool finished = 3;
inline bool ReceivedSlice::has_finished() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReceivedSlice::clear_finished() {
  finished_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ReceivedSlice::finished() const {
  // @@protoc_insertion_point(field_get:download_pb.ReceivedSlice.finished)
  return finished_;
}
inline void ReceivedSlice::set_finished(bool value) {
  _has_bits_[0] |= 0x00000004u;
  finished_ = value;
  // @@protoc_insertion_point(field_set:download_pb.ReceivedSlice.finished)
}

// -------------------------------------------------------------------

// DownloadEntry

// optional string guid = 1;
inline bool DownloadEntry::has_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DownloadEntry::clear_guid() {
  guid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DownloadEntry::guid() const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadEntry.guid)
  return guid_.GetNoArena();
}
inline void DownloadEntry::set_guid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  guid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:download_pb.DownloadEntry.guid)
}
inline void DownloadEntry::set_guid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  guid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:download_pb.DownloadEntry.guid)
}
inline void DownloadEntry::set_guid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  guid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:download_pb.DownloadEntry.guid)
}
inline void DownloadEntry::set_guid(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  guid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:download_pb.DownloadEntry.guid)
}
inline std::string* DownloadEntry::mutable_guid() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:download_pb.DownloadEntry.guid)
  return guid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DownloadEntry::release_guid() {
  // @@protoc_insertion_point(field_release:download_pb.DownloadEntry.guid)
  if (!has_guid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return guid_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DownloadEntry::set_allocated_guid(std::string* guid) {
  if (guid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  guid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), guid);
  // @@protoc_insertion_point(field_set_allocated:download_pb.DownloadEntry.guid)
}

// optional string request_origin = 2;
inline bool DownloadEntry::has_request_origin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DownloadEntry::clear_request_origin() {
  request_origin_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DownloadEntry::request_origin() const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadEntry.request_origin)
  return request_origin_.GetNoArena();
}
inline void DownloadEntry::set_request_origin(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  request_origin_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:download_pb.DownloadEntry.request_origin)
}
inline void DownloadEntry::set_request_origin(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  request_origin_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:download_pb.DownloadEntry.request_origin)
}
inline void DownloadEntry::set_request_origin(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  request_origin_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:download_pb.DownloadEntry.request_origin)
}
inline void DownloadEntry::set_request_origin(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  request_origin_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:download_pb.DownloadEntry.request_origin)
}
inline std::string* DownloadEntry::mutable_request_origin() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:download_pb.DownloadEntry.request_origin)
  return request_origin_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DownloadEntry::release_request_origin() {
  // @@protoc_insertion_point(field_release:download_pb.DownloadEntry.request_origin)
  if (!has_request_origin()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return request_origin_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DownloadEntry::set_allocated_request_origin(std::string* request_origin) {
  if (request_origin != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  request_origin_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), request_origin);
  // @@protoc_insertion_point(field_set_allocated:download_pb.DownloadEntry.request_origin)
}

// optional .download_pb.DownloadSource download_source = 3;
inline bool DownloadEntry::has_download_source() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DownloadEntry::clear_download_source() {
  download_source_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::download_pb::DownloadSource DownloadEntry::download_source() const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadEntry.download_source)
  return static_cast< ::download_pb::DownloadSource >(download_source_);
}
inline void DownloadEntry::set_download_source(::download_pb::DownloadSource value) {
  assert(::download_pb::DownloadSource_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  download_source_ = value;
  // @@protoc_insertion_point(field_set:download_pb.DownloadEntry.download_source)
}

// optional int64 ukm_download_id = 4;
inline bool DownloadEntry::has_ukm_download_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DownloadEntry::clear_ukm_download_id() {
  ukm_download_id_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DownloadEntry::ukm_download_id() const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadEntry.ukm_download_id)
  return ukm_download_id_;
}
inline void DownloadEntry::set_ukm_download_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  ukm_download_id_ = value;
  // @@protoc_insertion_point(field_set:download_pb.DownloadEntry.ukm_download_id)
}

// optional int64 bytes_wasted = 5;
inline bool DownloadEntry::has_bytes_wasted() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DownloadEntry::clear_bytes_wasted() {
  bytes_wasted_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DownloadEntry::bytes_wasted() const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadEntry.bytes_wasted)
  return bytes_wasted_;
}
inline void DownloadEntry::set_bytes_wasted(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  bytes_wasted_ = value;
  // @@protoc_insertion_point(field_set:download_pb.DownloadEntry.bytes_wasted)
}

// optional bool fetch_error_body = 6;
inline bool DownloadEntry::has_fetch_error_body() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DownloadEntry::clear_fetch_error_body() {
  fetch_error_body_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool DownloadEntry::fetch_error_body() const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadEntry.fetch_error_body)
  return fetch_error_body_;
}
inline void DownloadEntry::set_fetch_error_body(bool value) {
  _has_bits_[0] |= 0x00000010u;
  fetch_error_body_ = value;
  // @@protoc_insertion_point(field_set:download_pb.DownloadEntry.fetch_error_body)
}

// repeated .download_pb.HttpRequestHeader request_headers = 7;
inline int DownloadEntry::request_headers_size() const {
  return request_headers_.size();
}
inline void DownloadEntry::clear_request_headers() {
  request_headers_.Clear();
}
inline ::download_pb::HttpRequestHeader* DownloadEntry::mutable_request_headers(int index) {
  // @@protoc_insertion_point(field_mutable:download_pb.DownloadEntry.request_headers)
  return request_headers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::HttpRequestHeader >*
DownloadEntry::mutable_request_headers() {
  // @@protoc_insertion_point(field_mutable_list:download_pb.DownloadEntry.request_headers)
  return &request_headers_;
}
inline const ::download_pb::HttpRequestHeader& DownloadEntry::request_headers(int index) const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadEntry.request_headers)
  return request_headers_.Get(index);
}
inline ::download_pb::HttpRequestHeader* DownloadEntry::add_request_headers() {
  // @@protoc_insertion_point(field_add:download_pb.DownloadEntry.request_headers)
  return request_headers_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::HttpRequestHeader >&
DownloadEntry::request_headers() const {
  // @@protoc_insertion_point(field_list:download_pb.DownloadEntry.request_headers)
  return request_headers_;
}

// -------------------------------------------------------------------

// DownloadEntries

// repeated .download_pb.DownloadEntry entries = 1;
inline int DownloadEntries::entries_size() const {
  return entries_.size();
}
inline void DownloadEntries::clear_entries() {
  entries_.Clear();
}
inline ::download_pb::DownloadEntry* DownloadEntries::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:download_pb.DownloadEntries.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::DownloadEntry >*
DownloadEntries::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:download_pb.DownloadEntries.entries)
  return &entries_;
}
inline const ::download_pb::DownloadEntry& DownloadEntries::entries(int index) const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadEntries.entries)
  return entries_.Get(index);
}
inline ::download_pb::DownloadEntry* DownloadEntries::add_entries() {
  // @@protoc_insertion_point(field_add:download_pb.DownloadEntries.entries)
  return entries_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::DownloadEntry >&
DownloadEntries::entries() const {
  // @@protoc_insertion_point(field_list:download_pb.DownloadEntries.entries)
  return entries_;
}

// -------------------------------------------------------------------

// UkmInfo

// optional .download_pb.DownloadSource download_source = 1;
inline bool UkmInfo::has_download_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UkmInfo::clear_download_source() {
  download_source_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::download_pb::DownloadSource UkmInfo::download_source() const {
  // @@protoc_insertion_point(field_get:download_pb.UkmInfo.download_source)
  return static_cast< ::download_pb::DownloadSource >(download_source_);
}
inline void UkmInfo::set_download_source(::download_pb::DownloadSource value) {
  assert(::download_pb::DownloadSource_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  download_source_ = value;
  // @@protoc_insertion_point(field_set:download_pb.UkmInfo.download_source)
}

// optional int64 ukm_download_id = 2;
inline bool UkmInfo::has_ukm_download_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UkmInfo::clear_ukm_download_id() {
  ukm_download_id_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UkmInfo::ukm_download_id() const {
  // @@protoc_insertion_point(field_get:download_pb.UkmInfo.ukm_download_id)
  return ukm_download_id_;
}
inline void UkmInfo::set_ukm_download_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  ukm_download_id_ = value;
  // @@protoc_insertion_point(field_set:download_pb.UkmInfo.ukm_download_id)
}

// -------------------------------------------------------------------

// InProgressInfo

// repeated string url_chain = 1;
inline int InProgressInfo::url_chain_size() const {
  return url_chain_.size();
}
inline void InProgressInfo::clear_url_chain() {
  url_chain_.Clear();
}
inline const std::string& InProgressInfo::url_chain(int index) const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.url_chain)
  return url_chain_.Get(index);
}
inline std::string* InProgressInfo::mutable_url_chain(int index) {
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.url_chain)
  return url_chain_.Mutable(index);
}
inline void InProgressInfo::set_url_chain(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.url_chain)
  url_chain_.Mutable(index)->assign(value);
}
inline void InProgressInfo::set_url_chain(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.url_chain)
  url_chain_.Mutable(index)->assign(std::move(value));
}
inline void InProgressInfo::set_url_chain(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  url_chain_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:download_pb.InProgressInfo.url_chain)
}
inline void InProgressInfo::set_url_chain(int index, const char* value, size_t size) {
  url_chain_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:download_pb.InProgressInfo.url_chain)
}
inline std::string* InProgressInfo::add_url_chain() {
  // @@protoc_insertion_point(field_add_mutable:download_pb.InProgressInfo.url_chain)
  return url_chain_.Add();
}
inline void InProgressInfo::add_url_chain(const std::string& value) {
  url_chain_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:download_pb.InProgressInfo.url_chain)
}
inline void InProgressInfo::add_url_chain(std::string&& value) {
  url_chain_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:download_pb.InProgressInfo.url_chain)
}
inline void InProgressInfo::add_url_chain(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  url_chain_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:download_pb.InProgressInfo.url_chain)
}
inline void InProgressInfo::add_url_chain(const char* value, size_t size) {
  url_chain_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:download_pb.InProgressInfo.url_chain)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InProgressInfo::url_chain() const {
  // @@protoc_insertion_point(field_list:download_pb.InProgressInfo.url_chain)
  return url_chain_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InProgressInfo::mutable_url_chain() {
  // @@protoc_insertion_point(field_mutable_list:download_pb.InProgressInfo.url_chain)
  return &url_chain_;
}

// optional string referrer_url = 2;
inline bool InProgressInfo::has_referrer_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InProgressInfo::clear_referrer_url() {
  referrer_url_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InProgressInfo::referrer_url() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.referrer_url)
  return referrer_url_.GetNoArena();
}
inline void InProgressInfo::set_referrer_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  referrer_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.referrer_url)
}
inline void InProgressInfo::set_referrer_url(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  referrer_url_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:download_pb.InProgressInfo.referrer_url)
}
inline void InProgressInfo::set_referrer_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  referrer_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:download_pb.InProgressInfo.referrer_url)
}
inline void InProgressInfo::set_referrer_url(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  referrer_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:download_pb.InProgressInfo.referrer_url)
}
inline std::string* InProgressInfo::mutable_referrer_url() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.referrer_url)
  return referrer_url_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InProgressInfo::release_referrer_url() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.referrer_url)
  if (!has_referrer_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return referrer_url_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InProgressInfo::set_allocated_referrer_url(std::string* referrer_url) {
  if (referrer_url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  referrer_url_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), referrer_url);
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.referrer_url)
}

// optional string site_url = 3;
inline bool InProgressInfo::has_site_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InProgressInfo::clear_site_url() {
  site_url_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InProgressInfo::site_url() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.site_url)
  return site_url_.GetNoArena();
}
inline void InProgressInfo::set_site_url(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  site_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.site_url)
}
inline void InProgressInfo::set_site_url(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  site_url_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:download_pb.InProgressInfo.site_url)
}
inline void InProgressInfo::set_site_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  site_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:download_pb.InProgressInfo.site_url)
}
inline void InProgressInfo::set_site_url(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  site_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:download_pb.InProgressInfo.site_url)
}
inline std::string* InProgressInfo::mutable_site_url() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.site_url)
  return site_url_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InProgressInfo::release_site_url() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.site_url)
  if (!has_site_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return site_url_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InProgressInfo::set_allocated_site_url(std::string* site_url) {
  if (site_url != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  site_url_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), site_url);
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.site_url)
}

// optional string tab_url = 4;
inline bool InProgressInfo::has_tab_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InProgressInfo::clear_tab_url() {
  tab_url_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& InProgressInfo::tab_url() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.tab_url)
  return tab_url_.GetNoArena();
}
inline void InProgressInfo::set_tab_url(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  tab_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.tab_url)
}
inline void InProgressInfo::set_tab_url(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  tab_url_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:download_pb.InProgressInfo.tab_url)
}
inline void InProgressInfo::set_tab_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  tab_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:download_pb.InProgressInfo.tab_url)
}
inline void InProgressInfo::set_tab_url(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  tab_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:download_pb.InProgressInfo.tab_url)
}
inline std::string* InProgressInfo::mutable_tab_url() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.tab_url)
  return tab_url_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InProgressInfo::release_tab_url() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.tab_url)
  if (!has_tab_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return tab_url_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InProgressInfo::set_allocated_tab_url(std::string* tab_url) {
  if (tab_url != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  tab_url_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tab_url);
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.tab_url)
}

// optional string tab_referrer_url = 5;
inline bool InProgressInfo::has_tab_referrer_url() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InProgressInfo::clear_tab_referrer_url() {
  tab_referrer_url_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& InProgressInfo::tab_referrer_url() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.tab_referrer_url)
  return tab_referrer_url_.GetNoArena();
}
inline void InProgressInfo::set_tab_referrer_url(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  tab_referrer_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.tab_referrer_url)
}
inline void InProgressInfo::set_tab_referrer_url(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  tab_referrer_url_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:download_pb.InProgressInfo.tab_referrer_url)
}
inline void InProgressInfo::set_tab_referrer_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  tab_referrer_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:download_pb.InProgressInfo.tab_referrer_url)
}
inline void InProgressInfo::set_tab_referrer_url(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  tab_referrer_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:download_pb.InProgressInfo.tab_referrer_url)
}
inline std::string* InProgressInfo::mutable_tab_referrer_url() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.tab_referrer_url)
  return tab_referrer_url_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InProgressInfo::release_tab_referrer_url() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.tab_referrer_url)
  if (!has_tab_referrer_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return tab_referrer_url_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InProgressInfo::set_allocated_tab_referrer_url(std::string* tab_referrer_url) {
  if (tab_referrer_url != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  tab_referrer_url_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tab_referrer_url);
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.tab_referrer_url)
}

// optional bool fetch_error_body = 6;
inline bool InProgressInfo::has_fetch_error_body() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void InProgressInfo::clear_fetch_error_body() {
  fetch_error_body_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool InProgressInfo::fetch_error_body() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.fetch_error_body)
  return fetch_error_body_;
}
inline void InProgressInfo::set_fetch_error_body(bool value) {
  _has_bits_[0] |= 0x00008000u;
  fetch_error_body_ = value;
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.fetch_error_body)
}

// repeated .download_pb.HttpRequestHeader request_headers = 7;
inline int InProgressInfo::request_headers_size() const {
  return request_headers_.size();
}
inline void InProgressInfo::clear_request_headers() {
  request_headers_.Clear();
}
inline ::download_pb::HttpRequestHeader* InProgressInfo::mutable_request_headers(int index) {
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.request_headers)
  return request_headers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::HttpRequestHeader >*
InProgressInfo::mutable_request_headers() {
  // @@protoc_insertion_point(field_mutable_list:download_pb.InProgressInfo.request_headers)
  return &request_headers_;
}
inline const ::download_pb::HttpRequestHeader& InProgressInfo::request_headers(int index) const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.request_headers)
  return request_headers_.Get(index);
}
inline ::download_pb::HttpRequestHeader* InProgressInfo::add_request_headers() {
  // @@protoc_insertion_point(field_add:download_pb.InProgressInfo.request_headers)
  return request_headers_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::HttpRequestHeader >&
InProgressInfo::request_headers() const {
  // @@protoc_insertion_point(field_list:download_pb.InProgressInfo.request_headers)
  return request_headers_;
}

// optional string etag = 8;
inline bool InProgressInfo::has_etag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InProgressInfo::clear_etag() {
  etag_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& InProgressInfo::etag() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.etag)
  return etag_.GetNoArena();
}
inline void InProgressInfo::set_etag(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  etag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.etag)
}
inline void InProgressInfo::set_etag(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  etag_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:download_pb.InProgressInfo.etag)
}
inline void InProgressInfo::set_etag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  etag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:download_pb.InProgressInfo.etag)
}
inline void InProgressInfo::set_etag(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  etag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:download_pb.InProgressInfo.etag)
}
inline std::string* InProgressInfo::mutable_etag() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.etag)
  return etag_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InProgressInfo::release_etag() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.etag)
  if (!has_etag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return etag_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InProgressInfo::set_allocated_etag(std::string* etag) {
  if (etag != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  etag_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), etag);
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.etag)
}

// optional string last_modified = 9;
inline bool InProgressInfo::has_last_modified() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InProgressInfo::clear_last_modified() {
  last_modified_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& InProgressInfo::last_modified() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.last_modified)
  return last_modified_.GetNoArena();
}
inline void InProgressInfo::set_last_modified(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  last_modified_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.last_modified)
}
inline void InProgressInfo::set_last_modified(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  last_modified_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:download_pb.InProgressInfo.last_modified)
}
inline void InProgressInfo::set_last_modified(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  last_modified_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:download_pb.InProgressInfo.last_modified)
}
inline void InProgressInfo::set_last_modified(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  last_modified_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:download_pb.InProgressInfo.last_modified)
}
inline std::string* InProgressInfo::mutable_last_modified() {
  _has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.last_modified)
  return last_modified_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InProgressInfo::release_last_modified() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.last_modified)
  if (!has_last_modified()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return last_modified_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InProgressInfo::set_allocated_last_modified(std::string* last_modified) {
  if (last_modified != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  last_modified_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_modified);
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.last_modified)
}

// optional int64 total_bytes = 10;
inline bool InProgressInfo::has_total_bytes() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void InProgressInfo::clear_total_bytes() {
  total_bytes_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InProgressInfo::total_bytes() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.total_bytes)
  return total_bytes_;
}
inline void InProgressInfo::set_total_bytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000800u;
  total_bytes_ = value;
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.total_bytes)
}

// optional string mime_type = 11;
inline bool InProgressInfo::has_mime_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InProgressInfo::clear_mime_type() {
  mime_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& InProgressInfo::mime_type() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.mime_type)
  return mime_type_.GetNoArena();
}
inline void InProgressInfo::set_mime_type(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  mime_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.mime_type)
}
inline void InProgressInfo::set_mime_type(std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  mime_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:download_pb.InProgressInfo.mime_type)
}
inline void InProgressInfo::set_mime_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  mime_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:download_pb.InProgressInfo.mime_type)
}
inline void InProgressInfo::set_mime_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000040u;
  mime_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:download_pb.InProgressInfo.mime_type)
}
inline std::string* InProgressInfo::mutable_mime_type() {
  _has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.mime_type)
  return mime_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InProgressInfo::release_mime_type() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.mime_type)
  if (!has_mime_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return mime_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InProgressInfo::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  mime_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mime_type);
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.mime_type)
}

// optional string original_mime_type = 12;
inline bool InProgressInfo::has_original_mime_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InProgressInfo::clear_original_mime_type() {
  original_mime_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& InProgressInfo::original_mime_type() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.original_mime_type)
  return original_mime_type_.GetNoArena();
}
inline void InProgressInfo::set_original_mime_type(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  original_mime_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.original_mime_type)
}
inline void InProgressInfo::set_original_mime_type(std::string&& value) {
  _has_bits_[0] |= 0x00000080u;
  original_mime_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:download_pb.InProgressInfo.original_mime_type)
}
inline void InProgressInfo::set_original_mime_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000080u;
  original_mime_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:download_pb.InProgressInfo.original_mime_type)
}
inline void InProgressInfo::set_original_mime_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000080u;
  original_mime_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:download_pb.InProgressInfo.original_mime_type)
}
inline std::string* InProgressInfo::mutable_original_mime_type() {
  _has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.original_mime_type)
  return original_mime_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InProgressInfo::release_original_mime_type() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.original_mime_type)
  if (!has_original_mime_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return original_mime_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InProgressInfo::set_allocated_original_mime_type(std::string* original_mime_type) {
  if (original_mime_type != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  original_mime_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), original_mime_type);
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.original_mime_type)
}

// optional bytes current_path = 13;
inline bool InProgressInfo::has_current_path() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InProgressInfo::clear_current_path() {
  current_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& InProgressInfo::current_path() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.current_path)
  return current_path_.GetNoArena();
}
inline void InProgressInfo::set_current_path(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  current_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.current_path)
}
inline void InProgressInfo::set_current_path(std::string&& value) {
  _has_bits_[0] |= 0x00000100u;
  current_path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:download_pb.InProgressInfo.current_path)
}
inline void InProgressInfo::set_current_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000100u;
  current_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:download_pb.InProgressInfo.current_path)
}
inline void InProgressInfo::set_current_path(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000100u;
  current_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:download_pb.InProgressInfo.current_path)
}
inline std::string* InProgressInfo::mutable_current_path() {
  _has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.current_path)
  return current_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InProgressInfo::release_current_path() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.current_path)
  if (!has_current_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  return current_path_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InProgressInfo::set_allocated_current_path(std::string* current_path) {
  if (current_path != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  current_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), current_path);
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.current_path)
}

// optional bytes target_path = 14;
inline bool InProgressInfo::has_target_path() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void InProgressInfo::clear_target_path() {
  target_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& InProgressInfo::target_path() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.target_path)
  return target_path_.GetNoArena();
}
inline void InProgressInfo::set_target_path(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  target_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.target_path)
}
inline void InProgressInfo::set_target_path(std::string&& value) {
  _has_bits_[0] |= 0x00000200u;
  target_path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:download_pb.InProgressInfo.target_path)
}
inline void InProgressInfo::set_target_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000200u;
  target_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:download_pb.InProgressInfo.target_path)
}
inline void InProgressInfo::set_target_path(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000200u;
  target_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:download_pb.InProgressInfo.target_path)
}
inline std::string* InProgressInfo::mutable_target_path() {
  _has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.target_path)
  return target_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InProgressInfo::release_target_path() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.target_path)
  if (!has_target_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  return target_path_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InProgressInfo::set_allocated_target_path(std::string* target_path) {
  if (target_path != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  target_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), target_path);
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.target_path)
}

// optional int64 received_bytes = 15;
inline bool InProgressInfo::has_received_bytes() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void InProgressInfo::clear_received_bytes() {
  received_bytes_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InProgressInfo::received_bytes() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.received_bytes)
  return received_bytes_;
}
inline void InProgressInfo::set_received_bytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00001000u;
  received_bytes_ = value;
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.received_bytes)
}

// optional int64 start_time = 16;
inline bool InProgressInfo::has_start_time() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void InProgressInfo::clear_start_time() {
  start_time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InProgressInfo::start_time() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.start_time)
  return start_time_;
}
inline void InProgressInfo::set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00002000u;
  start_time_ = value;
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.start_time)
}

// optional int64 end_time = 17;
inline bool InProgressInfo::has_end_time() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void InProgressInfo::clear_end_time() {
  end_time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InProgressInfo::end_time() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.end_time)
  return end_time_;
}
inline void InProgressInfo::set_end_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00004000u;
  end_time_ = value;
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.end_time)
}

// repeated .download_pb.ReceivedSlice received_slices = 18;
inline int InProgressInfo::received_slices_size() const {
  return received_slices_.size();
}
inline void InProgressInfo::clear_received_slices() {
  received_slices_.Clear();
}
inline ::download_pb::ReceivedSlice* InProgressInfo::mutable_received_slices(int index) {
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.received_slices)
  return received_slices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::ReceivedSlice >*
InProgressInfo::mutable_received_slices() {
  // @@protoc_insertion_point(field_mutable_list:download_pb.InProgressInfo.received_slices)
  return &received_slices_;
}
inline const ::download_pb::ReceivedSlice& InProgressInfo::received_slices(int index) const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.received_slices)
  return received_slices_.Get(index);
}
inline ::download_pb::ReceivedSlice* InProgressInfo::add_received_slices() {
  // @@protoc_insertion_point(field_add:download_pb.InProgressInfo.received_slices)
  return received_slices_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::ReceivedSlice >&
InProgressInfo::received_slices() const {
  // @@protoc_insertion_point(field_list:download_pb.InProgressInfo.received_slices)
  return received_slices_;
}

// optional string hash = 19;
inline bool InProgressInfo::has_hash() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void InProgressInfo::clear_hash() {
  hash_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000400u;
}
inline const std::string& InProgressInfo::hash() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.hash)
  return hash_.GetNoArena();
}
inline void InProgressInfo::set_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.hash)
}
inline void InProgressInfo::set_hash(std::string&& value) {
  _has_bits_[0] |= 0x00000400u;
  hash_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:download_pb.InProgressInfo.hash)
}
inline void InProgressInfo::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000400u;
  hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:download_pb.InProgressInfo.hash)
}
inline void InProgressInfo::set_hash(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000400u;
  hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:download_pb.InProgressInfo.hash)
}
inline std::string* InProgressInfo::mutable_hash() {
  _has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.hash)
  return hash_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InProgressInfo::release_hash() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.hash)
  if (!has_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  return hash_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InProgressInfo::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  hash_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.hash)
}

// optional bool transient = 20;
inline bool InProgressInfo::has_transient() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void InProgressInfo::clear_transient() {
  transient_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool InProgressInfo::transient() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.transient)
  return transient_;
}
inline void InProgressInfo::set_transient(bool value) {
  _has_bits_[0] |= 0x00010000u;
  transient_ = value;
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.transient)
}

// optional int32 state = 21;
inline bool InProgressInfo::has_state() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void InProgressInfo::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InProgressInfo::state() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.state)
  return state_;
}
inline void InProgressInfo::set_state(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00080000u;
  state_ = value;
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.state)
}

// optional int32 danger_type = 22;
inline bool InProgressInfo::has_danger_type() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void InProgressInfo::clear_danger_type() {
  danger_type_ = 0;
  _has_bits_[0] &= ~0x00100000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InProgressInfo::danger_type() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.danger_type)
  return danger_type_;
}
inline void InProgressInfo::set_danger_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00100000u;
  danger_type_ = value;
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.danger_type)
}

// optional int32 interrupt_reason = 23;
inline bool InProgressInfo::has_interrupt_reason() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void InProgressInfo::clear_interrupt_reason() {
  interrupt_reason_ = 0;
  _has_bits_[0] &= ~0x00200000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InProgressInfo::interrupt_reason() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.interrupt_reason)
  return interrupt_reason_;
}
inline void InProgressInfo::set_interrupt_reason(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00200000u;
  interrupt_reason_ = value;
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.interrupt_reason)
}

// optional bool paused = 24;
inline bool InProgressInfo::has_paused() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void InProgressInfo::clear_paused() {
  paused_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool InProgressInfo::paused() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.paused)
  return paused_;
}
inline void InProgressInfo::set_paused(bool value) {
  _has_bits_[0] |= 0x00020000u;
  paused_ = value;
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.paused)
}

// optional bool metered = 25;
inline bool InProgressInfo::has_metered() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void InProgressInfo::clear_metered() {
  metered_ = false;
  _has_bits_[0] &= ~0x00040000u;
}
inline bool InProgressInfo::metered() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.metered)
  return metered_;
}
inline void InProgressInfo::set_metered(bool value) {
  _has_bits_[0] |= 0x00040000u;
  metered_ = value;
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.metered)
}

// optional int64 bytes_wasted = 26;
inline bool InProgressInfo::has_bytes_wasted() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void InProgressInfo::clear_bytes_wasted() {
  bytes_wasted_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00400000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InProgressInfo::bytes_wasted() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.bytes_wasted)
  return bytes_wasted_;
}
inline void InProgressInfo::set_bytes_wasted(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00400000u;
  bytes_wasted_ = value;
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.bytes_wasted)
}

// optional int32 auto_resume_count = 27;
inline bool InProgressInfo::has_auto_resume_count() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void InProgressInfo::clear_auto_resume_count() {
  auto_resume_count_ = 0;
  _has_bits_[0] &= ~0x00800000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InProgressInfo::auto_resume_count() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.auto_resume_count)
  return auto_resume_count_;
}
inline void InProgressInfo::set_auto_resume_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00800000u;
  auto_resume_count_ = value;
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.auto_resume_count)
}

// -------------------------------------------------------------------

// DownloadInfo

// optional string guid = 1;
inline bool DownloadInfo::has_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DownloadInfo::clear_guid() {
  guid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DownloadInfo::guid() const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadInfo.guid)
  return guid_.GetNoArena();
}
inline void DownloadInfo::set_guid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  guid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:download_pb.DownloadInfo.guid)
}
inline void DownloadInfo::set_guid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  guid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:download_pb.DownloadInfo.guid)
}
inline void DownloadInfo::set_guid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  guid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:download_pb.DownloadInfo.guid)
}
inline void DownloadInfo::set_guid(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  guid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:download_pb.DownloadInfo.guid)
}
inline std::string* DownloadInfo::mutable_guid() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:download_pb.DownloadInfo.guid)
  return guid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DownloadInfo::release_guid() {
  // @@protoc_insertion_point(field_release:download_pb.DownloadInfo.guid)
  if (!has_guid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return guid_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DownloadInfo::set_allocated_guid(std::string* guid) {
  if (guid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  guid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), guid);
  // @@protoc_insertion_point(field_set_allocated:download_pb.DownloadInfo.guid)
}

// optional int32 id = 2;
inline bool DownloadInfo::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DownloadInfo::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DownloadInfo::id() const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadInfo.id)
  return id_;
}
inline void DownloadInfo::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  id_ = value;
  // @@protoc_insertion_point(field_set:download_pb.DownloadInfo.id)
}

// optional .download_pb.UkmInfo ukm_info = 3;
inline bool DownloadInfo::has_ukm_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DownloadInfo::clear_ukm_info() {
  if (ukm_info_ != nullptr) ukm_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::download_pb::UkmInfo& DownloadInfo::ukm_info() const {
  const ::download_pb::UkmInfo* p = ukm_info_;
  // @@protoc_insertion_point(field_get:download_pb.DownloadInfo.ukm_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::download_pb::UkmInfo*>(
      &::download_pb::_UkmInfo_default_instance_);
}
inline ::download_pb::UkmInfo* DownloadInfo::release_ukm_info() {
  // @@protoc_insertion_point(field_release:download_pb.DownloadInfo.ukm_info)
  _has_bits_[0] &= ~0x00000002u;
  ::download_pb::UkmInfo* temp = ukm_info_;
  ukm_info_ = nullptr;
  return temp;
}
inline ::download_pb::UkmInfo* DownloadInfo::mutable_ukm_info() {
  _has_bits_[0] |= 0x00000002u;
  if (ukm_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::download_pb::UkmInfo>(GetArenaNoVirtual());
    ukm_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:download_pb.DownloadInfo.ukm_info)
  return ukm_info_;
}
inline void DownloadInfo::set_allocated_ukm_info(::download_pb::UkmInfo* ukm_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ukm_info_;
  }
  if (ukm_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ukm_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ukm_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ukm_info_ = ukm_info;
  // @@protoc_insertion_point(field_set_allocated:download_pb.DownloadInfo.ukm_info)
}

// optional .download_pb.InProgressInfo in_progress_info = 4;
inline bool DownloadInfo::has_in_progress_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DownloadInfo::clear_in_progress_info() {
  if (in_progress_info_ != nullptr) in_progress_info_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::download_pb::InProgressInfo& DownloadInfo::in_progress_info() const {
  const ::download_pb::InProgressInfo* p = in_progress_info_;
  // @@protoc_insertion_point(field_get:download_pb.DownloadInfo.in_progress_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::download_pb::InProgressInfo*>(
      &::download_pb::_InProgressInfo_default_instance_);
}
inline ::download_pb::InProgressInfo* DownloadInfo::release_in_progress_info() {
  // @@protoc_insertion_point(field_release:download_pb.DownloadInfo.in_progress_info)
  _has_bits_[0] &= ~0x00000004u;
  ::download_pb::InProgressInfo* temp = in_progress_info_;
  in_progress_info_ = nullptr;
  return temp;
}
inline ::download_pb::InProgressInfo* DownloadInfo::mutable_in_progress_info() {
  _has_bits_[0] |= 0x00000004u;
  if (in_progress_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::download_pb::InProgressInfo>(GetArenaNoVirtual());
    in_progress_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:download_pb.DownloadInfo.in_progress_info)
  return in_progress_info_;
}
inline void DownloadInfo::set_allocated_in_progress_info(::download_pb::InProgressInfo* in_progress_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete in_progress_info_;
  }
  if (in_progress_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      in_progress_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, in_progress_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  in_progress_info_ = in_progress_info;
  // @@protoc_insertion_point(field_set_allocated:download_pb.DownloadInfo.in_progress_info)
}

// -------------------------------------------------------------------

// DownloadDBEntry

// optional .download_pb.DownloadInfo download_info = 1;
inline bool DownloadDBEntry::has_download_info() const {
  return entry_case() == kDownloadInfo;
}
inline void DownloadDBEntry::set_has_download_info() {
  _oneof_case_[0] = kDownloadInfo;
}
inline void DownloadDBEntry::clear_download_info() {
  if (has_download_info()) {
    delete entry_.download_info_;
    clear_has_entry();
  }
}
inline ::download_pb::DownloadInfo* DownloadDBEntry::release_download_info() {
  // @@protoc_insertion_point(field_release:download_pb.DownloadDBEntry.download_info)
  if (has_download_info()) {
    clear_has_entry();
      ::download_pb::DownloadInfo* temp = entry_.download_info_;
    entry_.download_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::download_pb::DownloadInfo& DownloadDBEntry::download_info() const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadDBEntry.download_info)
  return has_download_info()
      ? *entry_.download_info_
      : *reinterpret_cast< ::download_pb::DownloadInfo*>(&::download_pb::_DownloadInfo_default_instance_);
}
inline ::download_pb::DownloadInfo* DownloadDBEntry::mutable_download_info() {
  if (!has_download_info()) {
    clear_entry();
    set_has_download_info();
    entry_.download_info_ = CreateMaybeMessage< ::download_pb::DownloadInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:download_pb.DownloadDBEntry.download_info)
  return entry_.download_info_;
}

inline bool DownloadDBEntry::has_entry() const {
  return entry_case() != ENTRY_NOT_SET;
}
inline void DownloadDBEntry::clear_has_entry() {
  _oneof_case_[0] = ENTRY_NOT_SET;
}
inline DownloadDBEntry::EntryCase DownloadDBEntry::entry_case() const {
  return DownloadDBEntry::EntryCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace download_pb

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_download_5fentry_2eproto
