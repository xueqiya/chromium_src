// third_party/blink/public/mojom/frame/frame.mojom-blink.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif

#include "third_party/blink/public/mojom/frame/frame.mojom-blink.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/hash/md5_constexpr.h"
#include "base/logging.h"
#include "base/run_loop.h"
#include "base/task/common/task_annotator.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_context.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"

#include "third_party/blink/public/mojom/frame/frame.mojom-params-data.h"
#include "third_party/blink/public/mojom/frame/frame.mojom-shared-message-ids.h"

#include "third_party/blink/public/mojom/frame/frame.mojom-blink-import-headers.h"
#include "mojo/public/cpp/bindings/lib/wtf_serialization.h"


#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_FRAME_FRAME_MOJOM_BLINK_JUMBO_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_FRAME_FRAME_MOJOM_BLINK_JUMBO_H_
#include "cc/ipc/cc_param_traits_macros.h"
#include "mojo/public/cpp/base/time_mojom_traits.h"
#include "mojo/public/cpp/base/unguessable_token_mojom_traits.h"
#include "skia/public/mojom/skcolor_mojom_traits.h"
#include "third_party/blink/renderer/platform/mojo/geometry_mojom_traits.h"
#include "third_party/blink/renderer/platform/mojo/kurl_mojom_traits.h"
#include "third_party/blink/renderer/platform/mojo/security_origin_mojom_traits.h"
#include "third_party/blink/renderer/platform/mojo/string16_mojom_traits.h"
#include "ui/events/ipc/ui_events_param_traits_macros.h"
#include "ui/gfx/geometry/mojom/geometry_mojom_traits.h"
#endif
namespace blink {
namespace mojom {
namespace blink {
FindInPageResultAXParams::FindInPageResultAXParams()
    : request_id(),
      match_index(),
      start_id(),
      start_offset(),
      end_id(),
      end_offset() {}

FindInPageResultAXParams::FindInPageResultAXParams(
    int32_t request_id_in,
    int32_t match_index_in,
    int32_t start_id_in,
    int32_t start_offset_in,
    int32_t end_id_in,
    int32_t end_offset_in)
    : request_id(std::move(request_id_in)),
      match_index(std::move(match_index_in)),
      start_id(std::move(start_id_in)),
      start_offset(std::move(start_offset_in)),
      end_id(std::move(end_id_in)),
      end_offset(std::move(end_offset_in)) {}

FindInPageResultAXParams::~FindInPageResultAXParams() = default;
size_t FindInPageResultAXParams::Hash(size_t seed) const {
  seed = mojo::internal::WTFHash(seed, this->request_id);
  seed = mojo::internal::WTFHash(seed, this->match_index);
  seed = mojo::internal::WTFHash(seed, this->start_id);
  seed = mojo::internal::WTFHash(seed, this->start_offset);
  seed = mojo::internal::WTFHash(seed, this->end_id);
  seed = mojo::internal::WTFHash(seed, this->end_offset);
  return seed;
}

bool FindInPageResultAXParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char LocalFrameHost::Name_[] = "blink.mojom.LocalFrameHost";
bool LocalFrameHost::RunModalAlertDialog(const ::WTF::String& alert_message) {
  NOTREACHED();
  return false;
}
bool LocalFrameHost::RunModalConfirmDialog(const ::WTF::String& alert_message, bool* out_success) {
  NOTREACHED();
  return false;
}
bool LocalFrameHost::RunModalPromptDialog(const ::WTF::String& alert_message, const ::WTF::String& default_value, bool* out_success, ::WTF::String* out_result) {
  NOTREACHED();
  return false;
}
bool LocalFrameHost::RunBeforeUnloadConfirm(bool is_reload, bool* out_success) {
  NOTREACHED();
  return false;
}
class LocalFrameHost_RunModalAlertDialog_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  LocalFrameHost_RunModalAlertDialog_HandleSyncResponse(
      bool* result)
      : result_(result) {
    DCHECK(!*result_);
  }
  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;DISALLOW_COPY_AND_ASSIGN(LocalFrameHost_RunModalAlertDialog_HandleSyncResponse);
};

class LocalFrameHost_RunModalAlertDialog_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrameHost_RunModalAlertDialog_ForwardToCallback(
      LocalFrameHost::RunModalAlertDialogCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  LocalFrameHost::RunModalAlertDialogCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(LocalFrameHost_RunModalAlertDialog_ForwardToCallback);
};
class LocalFrameHost_RunModalConfirmDialog_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  LocalFrameHost_RunModalConfirmDialog_HandleSyncResponse(
      bool* result, bool* out_success)
      : result_(result), out_success_(out_success) {
    DCHECK(!*result_);
  }
  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  bool* out_success_;DISALLOW_COPY_AND_ASSIGN(LocalFrameHost_RunModalConfirmDialog_HandleSyncResponse);
};

class LocalFrameHost_RunModalConfirmDialog_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrameHost_RunModalConfirmDialog_ForwardToCallback(
      LocalFrameHost::RunModalConfirmDialogCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  LocalFrameHost::RunModalConfirmDialogCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(LocalFrameHost_RunModalConfirmDialog_ForwardToCallback);
};
class LocalFrameHost_RunModalPromptDialog_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  LocalFrameHost_RunModalPromptDialog_HandleSyncResponse(
      bool* result, bool* out_success, ::WTF::String* out_result)
      : result_(result), out_success_(out_success), out_result_(out_result) {
    DCHECK(!*result_);
  }
  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  bool* out_success_;
  ::WTF::String* out_result_;DISALLOW_COPY_AND_ASSIGN(LocalFrameHost_RunModalPromptDialog_HandleSyncResponse);
};

class LocalFrameHost_RunModalPromptDialog_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrameHost_RunModalPromptDialog_ForwardToCallback(
      LocalFrameHost::RunModalPromptDialogCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  LocalFrameHost::RunModalPromptDialogCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(LocalFrameHost_RunModalPromptDialog_ForwardToCallback);
};
class LocalFrameHost_RunBeforeUnloadConfirm_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  LocalFrameHost_RunBeforeUnloadConfirm_HandleSyncResponse(
      bool* result, bool* out_success)
      : result_(result), out_success_(out_success) {
    DCHECK(!*result_);
  }
  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  bool* out_success_;DISALLOW_COPY_AND_ASSIGN(LocalFrameHost_RunBeforeUnloadConfirm_HandleSyncResponse);
};

class LocalFrameHost_RunBeforeUnloadConfirm_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrameHost_RunBeforeUnloadConfirm_ForwardToCallback(
      LocalFrameHost::RunBeforeUnloadConfirmCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  LocalFrameHost::RunBeforeUnloadConfirmCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(LocalFrameHost_RunBeforeUnloadConfirm_ForwardToCallback);
};

LocalFrameHostProxy::LocalFrameHostProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void LocalFrameHostProxy::EnterFullscreen(
    ::blink::mojom::blink::FullscreenOptionsPtr in_options) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::EnterFullscreen");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_EnterFullscreen_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_EnterFullscreen_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->options)::BaseType::BufferWriter
      options_writer;
  mojo::internal::Serialize<::blink::mojom::FullscreenOptionsDataView>(
      in_options, buffer, &options_writer, &serialization_context);
  params->options.Set(
      options_writer.is_null() ? nullptr : options_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->options.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null options in LocalFrameHost.EnterFullscreen request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("EnterFullscreen");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::ExitFullscreen(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::ExitFullscreen");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_ExitFullscreen_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_ExitFullscreen_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("ExitFullscreen");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::FullscreenStateChanged(
    bool in_is_fullscreen) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::FullscreenStateChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_FullscreenStateChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_FullscreenStateChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->is_fullscreen = in_is_fullscreen;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("FullscreenStateChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::RegisterProtocolHandler(
    const WTF::String& in_scheme, const ::blink::KURL& in_url, const ::WTF::String& in_title, bool in_user_gesture) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::RegisterProtocolHandler");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_RegisterProtocolHandler_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_RegisterProtocolHandler_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->scheme)::BaseType::BufferWriter
      scheme_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_scheme, buffer, &scheme_writer, &serialization_context);
  params->scheme.Set(
      scheme_writer.is_null() ? nullptr : scheme_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->scheme.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null scheme in LocalFrameHost.RegisterProtocolHandler request");
  typename decltype(params->url)::BaseType::BufferWriter
      url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, buffer, &url_writer, &serialization_context);
  params->url.Set(
      url_writer.is_null() ? nullptr : url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in LocalFrameHost.RegisterProtocolHandler request");
  typename decltype(params->title)::BaseType::BufferWriter
      title_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_title, buffer, &title_writer, &serialization_context);
  params->title.Set(
      title_writer.is_null() ? nullptr : title_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->title.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null title in LocalFrameHost.RegisterProtocolHandler request");
  params->user_gesture = in_user_gesture;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RegisterProtocolHandler");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::UnregisterProtocolHandler(
    const WTF::String& in_scheme, const ::blink::KURL& in_url, bool in_user_gesture) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::UnregisterProtocolHandler");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_UnregisterProtocolHandler_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_UnregisterProtocolHandler_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->scheme)::BaseType::BufferWriter
      scheme_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_scheme, buffer, &scheme_writer, &serialization_context);
  params->scheme.Set(
      scheme_writer.is_null() ? nullptr : scheme_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->scheme.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null scheme in LocalFrameHost.UnregisterProtocolHandler request");
  typename decltype(params->url)::BaseType::BufferWriter
      url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, buffer, &url_writer, &serialization_context);
  params->url.Set(
      url_writer.is_null() ? nullptr : url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in LocalFrameHost.UnregisterProtocolHandler request");
  params->user_gesture = in_user_gesture;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("UnregisterProtocolHandler");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::DidDisplayInsecureContent(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::DidDisplayInsecureContent");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidDisplayInsecureContent_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_DidDisplayInsecureContent_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidDisplayInsecureContent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::DidContainInsecureFormAction(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::DidContainInsecureFormAction");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidContainInsecureFormAction_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_DidContainInsecureFormAction_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidContainInsecureFormAction");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::DocumentAvailableInMainFrame(
    bool in_uses_temporary_zoom_level) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::DocumentAvailableInMainFrame");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_DocumentAvailableInMainFrame_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_DocumentAvailableInMainFrame_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->uses_temporary_zoom_level = in_uses_temporary_zoom_level;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DocumentAvailableInMainFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::SetNeedsOcclusionTracking(
    bool in_needs_tracking) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::SetNeedsOcclusionTracking");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_SetNeedsOcclusionTracking_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_SetNeedsOcclusionTracking_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->needs_tracking = in_needs_tracking;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("SetNeedsOcclusionTracking");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::LifecycleStateChanged(
    ::blink::mojom::blink::FrameLifecycleState in_state) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::LifecycleStateChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_LifecycleStateChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_LifecycleStateChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::blink::mojom::FrameLifecycleState>(
      in_state, &params->state);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("LifecycleStateChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::EvictFromBackForwardCache(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::EvictFromBackForwardCache");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_EvictFromBackForwardCache_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_EvictFromBackForwardCache_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("EvictFromBackForwardCache");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::VisibilityChanged(
    ::blink::mojom::blink::FrameVisibility in_visibility) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::VisibilityChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_VisibilityChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_VisibilityChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::blink::mojom::FrameVisibility>(
      in_visibility, &params->visibility);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("VisibilityChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::DidChangeThemeColor(
    const base::Optional<::SkColor>& in_theme_color) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::DidChangeThemeColor");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidChangeThemeColor_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_DidChangeThemeColor_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->theme_color)::BaseType::BufferWriter
      theme_color_writer;
  mojo::internal::Serialize<::skia::mojom::SkColorDataView>(
      in_theme_color, buffer, &theme_color_writer, &serialization_context);
  params->theme_color.Set(
      theme_color_writer.is_null() ? nullptr : theme_color_writer.data());
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidChangeThemeColor");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::DidFocusFrame(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::DidFocusFrame");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidFocusFrame_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_DidFocusFrame_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidFocusFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::EnforceInsecureRequestPolicy(
    uint8_t in_policy_bitmap) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::EnforceInsecureRequestPolicy");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_EnforceInsecureRequestPolicy_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_EnforceInsecureRequestPolicy_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->policy_bitmap = in_policy_bitmap;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("EnforceInsecureRequestPolicy");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::EnforceInsecureNavigationsSet(
    const WTF::Vector<uint32_t>& in_set) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::EnforceInsecureNavigationsSet");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_EnforceInsecureNavigationsSet_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_EnforceInsecureNavigationsSet_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->set)::BaseType::BufferWriter
      set_writer;
  const mojo::internal::ContainerValidateParams set_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<uint32_t>>(
      in_set, buffer, &set_writer, &set_validate_params,
      &serialization_context);
  params->set.Set(
      set_writer.is_null() ? nullptr : set_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->set.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null set in LocalFrameHost.EnforceInsecureNavigationsSet request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("EnforceInsecureNavigationsSet");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::DidChangeActiveSchedulerTrackedFeatures(
    uint64_t in_features_mask) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::DidChangeActiveSchedulerTrackedFeatures");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidChangeActiveSchedulerTrackedFeatures_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_DidChangeActiveSchedulerTrackedFeatures_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->features_mask = in_features_mask;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidChangeActiveSchedulerTrackedFeatures");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::SuddenTerminationDisablerChanged(
    bool in_present, ::blink::mojom::blink::SuddenTerminationDisablerType in_disabler_type) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::SuddenTerminationDisablerChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_SuddenTerminationDisablerChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_SuddenTerminationDisablerChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->present = in_present;
  mojo::internal::Serialize<::blink::mojom::SuddenTerminationDisablerType>(
      in_disabler_type, &params->disabler_type);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("SuddenTerminationDisablerChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::HadStickyUserActivationBeforeNavigationChanged(
    bool in_has_gesture) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::HadStickyUserActivationBeforeNavigationChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->has_gesture = in_has_gesture;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("HadStickyUserActivationBeforeNavigationChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::ScrollRectToVisibleInParentFrame(
    const ::blink::WebRect& in_rect_to_scroll, ::blink::mojom::blink::ScrollIntoViewParamsPtr in_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::ScrollRectToVisibleInParentFrame");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_ScrollRectToVisibleInParentFrame_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_ScrollRectToVisibleInParentFrame_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->rect_to_scroll)::BaseType::BufferWriter
      rect_to_scroll_writer;
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_rect_to_scroll, buffer, &rect_to_scroll_writer, &serialization_context);
  params->rect_to_scroll.Set(
      rect_to_scroll_writer.is_null() ? nullptr : rect_to_scroll_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->rect_to_scroll.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null rect_to_scroll in LocalFrameHost.ScrollRectToVisibleInParentFrame request");
  typename decltype(params->params)::BaseType::BufferWriter
      params_writer;
  mojo::internal::Serialize<::blink::mojom::ScrollIntoViewParamsDataView>(
      in_params, buffer, &params_writer, &serialization_context);
  params->params.Set(
      params_writer.is_null() ? nullptr : params_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in LocalFrameHost.ScrollRectToVisibleInParentFrame request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("ScrollRectToVisibleInParentFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::BubbleLogicalScrollInParentFrame(
    ::blink::mojom::blink::ScrollDirection in_direction, ::ui::input_types::ScrollGranularity in_granularity) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::BubbleLogicalScrollInParentFrame");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_BubbleLogicalScrollInParentFrame_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_BubbleLogicalScrollInParentFrame_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::blink::mojom::ScrollDirection>(
      in_direction, &params->direction);
  mojo::internal::Serialize<::ui::mojom::ScrollGranularity>(
      in_granularity, &params->granularity);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("BubbleLogicalScrollInParentFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::DidAccessInitialDocument(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::DidAccessInitialDocument");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidAccessInitialDocument_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_DidAccessInitialDocument_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidAccessInitialDocument");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::DidBlockNavigation(
    const ::blink::KURL& in_blocked_url, const ::blink::KURL& in_initiator_url, ::blink::mojom::blink::NavigationBlockedReason in_reason) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::DidBlockNavigation");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidBlockNavigation_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_DidBlockNavigation_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->blocked_url)::BaseType::BufferWriter
      blocked_url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_blocked_url, buffer, &blocked_url_writer, &serialization_context);
  params->blocked_url.Set(
      blocked_url_writer.is_null() ? nullptr : blocked_url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->blocked_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null blocked_url in LocalFrameHost.DidBlockNavigation request");
  typename decltype(params->initiator_url)::BaseType::BufferWriter
      initiator_url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_initiator_url, buffer, &initiator_url_writer, &serialization_context);
  params->initiator_url.Set(
      initiator_url_writer.is_null() ? nullptr : initiator_url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->initiator_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null initiator_url in LocalFrameHost.DidBlockNavigation request");
  mojo::internal::Serialize<::blink::mojom::NavigationBlockedReason>(
      in_reason, &params->reason);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidBlockNavigation");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::DidChangeLoadProgress(
    double in_load_progress) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::DidChangeLoadProgress");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidChangeLoadProgress_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_DidChangeLoadProgress_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->load_progress = in_load_progress;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidChangeLoadProgress");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::DispatchLoad(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::DispatchLoad");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_DispatchLoad_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_DispatchLoad_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DispatchLoad");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::GoToEntryAtOffset(
    int32_t in_offset, bool in_has_user_gesture) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::GoToEntryAtOffset");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_GoToEntryAtOffset_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_GoToEntryAtOffset_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->offset = in_offset;
  params->has_user_gesture = in_has_user_gesture;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("GoToEntryAtOffset");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::RenderFallbackContentInParentProcess(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::RenderFallbackContentInParentProcess");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_RenderFallbackContentInParentProcess_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_RenderFallbackContentInParentProcess_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RenderFallbackContentInParentProcess");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::HandleAccessibilityFindInPageResult(
    FindInPageResultAXParamsPtr in_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageResult");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_HandleAccessibilityFindInPageResult_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_HandleAccessibilityFindInPageResult_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->params)::BaseType::BufferWriter
      params_writer;
  mojo::internal::Serialize<::blink::mojom::FindInPageResultAXParamsDataView>(
      in_params, buffer, &params_writer, &serialization_context);
  params->params.Set(
      params_writer.is_null() ? nullptr : params_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in LocalFrameHost.HandleAccessibilityFindInPageResult request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("HandleAccessibilityFindInPageResult");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::HandleAccessibilityFindInPageTermination(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageTermination");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_HandleAccessibilityFindInPageTermination_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_HandleAccessibilityFindInPageTermination_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("HandleAccessibilityFindInPageTermination");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::DocumentOnLoadCompleted(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::DocumentOnLoadCompleted");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_DocumentOnLoadCompleted_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_DocumentOnLoadCompleted_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DocumentOnLoadCompleted");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::ForwardResourceTimingToParent(
    ::blink::mojom::blink::ResourceTimingInfoPtr in_timing) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::ForwardResourceTimingToParent");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_ForwardResourceTimingToParent_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_ForwardResourceTimingToParent_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->timing)::BaseType::BufferWriter
      timing_writer;
  mojo::internal::Serialize<::blink::mojom::ResourceTimingInfoDataView>(
      in_timing, buffer, &timing_writer, &serialization_context);
  params->timing.Set(
      timing_writer.is_null() ? nullptr : timing_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->timing.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null timing in LocalFrameHost.ForwardResourceTimingToParent request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("ForwardResourceTimingToParent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameHostProxy::DidFinishDocumentLoad(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::DidFinishDocumentLoad");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidFinishDocumentLoad_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_DidFinishDocumentLoad_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidFinishDocumentLoad");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
bool LocalFrameHostProxy::RunModalAlertDialog(
    const ::WTF::String& param_alert_message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::RunModalAlertDialog");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunModalAlertDialog_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_RunModalAlertDialog_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->alert_message)::BaseType::BufferWriter
      alert_message_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      param_alert_message, buffer, &alert_message_writer, &serialization_context);
  params->alert_message.Set(
      alert_message_writer.is_null() ? nullptr : alert_message_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->alert_message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null alert_message in LocalFrameHost.RunModalAlertDialog request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunModalAlertDialog");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrameHost_RunModalAlertDialog_HandleSyncResponse(
          &result));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
  return result;
}

void LocalFrameHostProxy::RunModalAlertDialog(
    const ::WTF::String& in_alert_message, RunModalAlertDialogCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::RunModalAlertDialog");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunModalAlertDialog_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_RunModalAlertDialog_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->alert_message)::BaseType::BufferWriter
      alert_message_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_alert_message, buffer, &alert_message_writer, &serialization_context);
  params->alert_message.Set(
      alert_message_writer.is_null() ? nullptr : alert_message_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->alert_message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null alert_message in LocalFrameHost.RunModalAlertDialog request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunModalAlertDialog");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrameHost_RunModalAlertDialog_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
bool LocalFrameHostProxy::RunModalConfirmDialog(
    const ::WTF::String& param_alert_message, bool* out_param_success) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::RunModalConfirmDialog");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunModalConfirmDialog_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_RunModalConfirmDialog_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->alert_message)::BaseType::BufferWriter
      alert_message_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      param_alert_message, buffer, &alert_message_writer, &serialization_context);
  params->alert_message.Set(
      alert_message_writer.is_null() ? nullptr : alert_message_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->alert_message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null alert_message in LocalFrameHost.RunModalConfirmDialog request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunModalConfirmDialog");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrameHost_RunModalConfirmDialog_HandleSyncResponse(
          &result, out_param_success));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
  return result;
}

void LocalFrameHostProxy::RunModalConfirmDialog(
    const ::WTF::String& in_alert_message, RunModalConfirmDialogCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::RunModalConfirmDialog");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunModalConfirmDialog_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_RunModalConfirmDialog_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->alert_message)::BaseType::BufferWriter
      alert_message_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_alert_message, buffer, &alert_message_writer, &serialization_context);
  params->alert_message.Set(
      alert_message_writer.is_null() ? nullptr : alert_message_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->alert_message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null alert_message in LocalFrameHost.RunModalConfirmDialog request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunModalConfirmDialog");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrameHost_RunModalConfirmDialog_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
bool LocalFrameHostProxy::RunModalPromptDialog(
    const ::WTF::String& param_alert_message, const ::WTF::String& param_default_value, bool* out_param_success, ::WTF::String* out_param_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::RunModalPromptDialog");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunModalPromptDialog_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_RunModalPromptDialog_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->alert_message)::BaseType::BufferWriter
      alert_message_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      param_alert_message, buffer, &alert_message_writer, &serialization_context);
  params->alert_message.Set(
      alert_message_writer.is_null() ? nullptr : alert_message_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->alert_message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null alert_message in LocalFrameHost.RunModalPromptDialog request");
  typename decltype(params->default_value)::BaseType::BufferWriter
      default_value_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      param_default_value, buffer, &default_value_writer, &serialization_context);
  params->default_value.Set(
      default_value_writer.is_null() ? nullptr : default_value_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->default_value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null default_value in LocalFrameHost.RunModalPromptDialog request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunModalPromptDialog");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrameHost_RunModalPromptDialog_HandleSyncResponse(
          &result, out_param_success, out_param_result));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
  return result;
}

void LocalFrameHostProxy::RunModalPromptDialog(
    const ::WTF::String& in_alert_message, const ::WTF::String& in_default_value, RunModalPromptDialogCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::RunModalPromptDialog");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunModalPromptDialog_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_RunModalPromptDialog_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->alert_message)::BaseType::BufferWriter
      alert_message_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_alert_message, buffer, &alert_message_writer, &serialization_context);
  params->alert_message.Set(
      alert_message_writer.is_null() ? nullptr : alert_message_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->alert_message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null alert_message in LocalFrameHost.RunModalPromptDialog request");
  typename decltype(params->default_value)::BaseType::BufferWriter
      default_value_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_default_value, buffer, &default_value_writer, &serialization_context);
  params->default_value.Set(
      default_value_writer.is_null() ? nullptr : default_value_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->default_value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null default_value in LocalFrameHost.RunModalPromptDialog request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunModalPromptDialog");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrameHost_RunModalPromptDialog_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
bool LocalFrameHostProxy::RunBeforeUnloadConfirm(
    bool param_is_reload, bool* out_param_success) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::RunBeforeUnloadConfirm");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunBeforeUnloadConfirm_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_RunBeforeUnloadConfirm_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->is_reload = param_is_reload;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunBeforeUnloadConfirm");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrameHost_RunBeforeUnloadConfirm_HandleSyncResponse(
          &result, out_param_success));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
  return result;
}

void LocalFrameHostProxy::RunBeforeUnloadConfirm(
    bool in_is_reload, RunBeforeUnloadConfirmCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrameHost::RunBeforeUnloadConfirm");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunBeforeUnloadConfirm_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_RunBeforeUnloadConfirm_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->is_reload = in_is_reload;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunBeforeUnloadConfirm");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrameHost_RunBeforeUnloadConfirm_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class LocalFrameHost_RunModalAlertDialog_ProxyToResponder {
 public:
  static LocalFrameHost::RunModalAlertDialogCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrameHost_RunModalAlertDialog_ProxyToResponder> proxy(
        new LocalFrameHost_RunModalAlertDialog_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&LocalFrameHost_RunModalAlertDialog_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrameHost_RunModalAlertDialog_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  LocalFrameHost_RunModalAlertDialog_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrameHost::RunModalAlertDialogCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(LocalFrameHost_RunModalAlertDialog_ProxyToResponder);
};

bool LocalFrameHost_RunModalAlertDialog_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "blink::mojom::LocalFrameHost::RunModalAlertDialogCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::LocalFrameHost_RunModalAlertDialog_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrameHost_RunModalAlertDialog_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  LocalFrameHost_RunModalAlertDialog_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrameHost::Name_, 32, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void LocalFrameHost_RunModalAlertDialog_ProxyToResponder::Run(
    ) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunModalAlertDialog_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_RunModalAlertDialog_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)blink::mojom::LocalFrameHost::RunModalAlertDialogCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunModalAlertDialog");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool LocalFrameHost_RunModalAlertDialog_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrameHost_RunModalAlertDialog_ResponseParams_Data* params =
      reinterpret_cast<internal::LocalFrameHost_RunModalAlertDialog_ResponseParams_Data*>(
          message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  LocalFrameHost_RunModalAlertDialog_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrameHost::Name_, 32, true);
    return false;
  }
  mojo::internal::SyncMessageResponseSetup::SetCurrentSyncResponseMessage(
      message);
  *result_ = true;
  return true;
}
class LocalFrameHost_RunModalConfirmDialog_ProxyToResponder {
 public:
  static LocalFrameHost::RunModalConfirmDialogCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrameHost_RunModalConfirmDialog_ProxyToResponder> proxy(
        new LocalFrameHost_RunModalConfirmDialog_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&LocalFrameHost_RunModalConfirmDialog_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrameHost_RunModalConfirmDialog_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  LocalFrameHost_RunModalConfirmDialog_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrameHost::RunModalConfirmDialogCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(LocalFrameHost_RunModalConfirmDialog_ProxyToResponder);
};

bool LocalFrameHost_RunModalConfirmDialog_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "blink::mojom::LocalFrameHost::RunModalConfirmDialogCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::LocalFrameHost_RunModalConfirmDialog_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrameHost_RunModalConfirmDialog_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  bool p_success{};
  LocalFrameHost_RunModalConfirmDialog_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success)
    p_success = input_data_view.success();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrameHost::Name_, 33, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success));
  return true;
}

void LocalFrameHost_RunModalConfirmDialog_ProxyToResponder::Run(
    bool in_success) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunModalConfirmDialog_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_RunModalConfirmDialog_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->success = in_success;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)blink::mojom::LocalFrameHost::RunModalConfirmDialogCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunModalConfirmDialog");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool LocalFrameHost_RunModalConfirmDialog_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrameHost_RunModalConfirmDialog_ResponseParams_Data* params =
      reinterpret_cast<internal::LocalFrameHost_RunModalConfirmDialog_ResponseParams_Data*>(
          message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  bool p_success{};
  LocalFrameHost_RunModalConfirmDialog_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success)
    p_success = input_data_view.success();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrameHost::Name_, 33, true);
    return false;
  }
  *out_success_ = std::move(p_success);
  mojo::internal::SyncMessageResponseSetup::SetCurrentSyncResponseMessage(
      message);
  *result_ = true;
  return true;
}
class LocalFrameHost_RunModalPromptDialog_ProxyToResponder {
 public:
  static LocalFrameHost::RunModalPromptDialogCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrameHost_RunModalPromptDialog_ProxyToResponder> proxy(
        new LocalFrameHost_RunModalPromptDialog_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&LocalFrameHost_RunModalPromptDialog_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrameHost_RunModalPromptDialog_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  LocalFrameHost_RunModalPromptDialog_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrameHost::RunModalPromptDialogCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success, const ::WTF::String& in_result);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(LocalFrameHost_RunModalPromptDialog_ProxyToResponder);
};

bool LocalFrameHost_RunModalPromptDialog_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "blink::mojom::LocalFrameHost::RunModalPromptDialogCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::LocalFrameHost_RunModalPromptDialog_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrameHost_RunModalPromptDialog_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  bool p_success{};
  ::WTF::String p_result{};
  LocalFrameHost_RunModalPromptDialog_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success)
    p_success = input_data_view.success();
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrameHost::Name_, 34, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success), 
std::move(p_result));
  return true;
}

void LocalFrameHost_RunModalPromptDialog_ProxyToResponder::Run(
    bool in_success, const ::WTF::String& in_result) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunModalPromptDialog_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_RunModalPromptDialog_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->success = in_success;
  typename decltype(params->result)::BaseType::BufferWriter
      result_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_result, buffer, &result_writer, &serialization_context);
  params->result.Set(
      result_writer.is_null() ? nullptr : result_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)blink::mojom::LocalFrameHost::RunModalPromptDialogCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunModalPromptDialog");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool LocalFrameHost_RunModalPromptDialog_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrameHost_RunModalPromptDialog_ResponseParams_Data* params =
      reinterpret_cast<internal::LocalFrameHost_RunModalPromptDialog_ResponseParams_Data*>(
          message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  bool p_success{};
  ::WTF::String p_result{};
  LocalFrameHost_RunModalPromptDialog_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success)
    p_success = input_data_view.success();
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrameHost::Name_, 34, true);
    return false;
  }
  *out_success_ = std::move(p_success);
  *out_result_ = std::move(p_result);
  mojo::internal::SyncMessageResponseSetup::SetCurrentSyncResponseMessage(
      message);
  *result_ = true;
  return true;
}
class LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder {
 public:
  static LocalFrameHost::RunBeforeUnloadConfirmCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder> proxy(
        new LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrameHost::RunBeforeUnloadConfirmCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder);
};

bool LocalFrameHost_RunBeforeUnloadConfirm_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "blink::mojom::LocalFrameHost::RunBeforeUnloadConfirmCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::LocalFrameHost_RunBeforeUnloadConfirm_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrameHost_RunBeforeUnloadConfirm_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  bool p_success{};
  LocalFrameHost_RunBeforeUnloadConfirm_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success)
    p_success = input_data_view.success();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrameHost::Name_, 35, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success));
  return true;
}

void LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder::Run(
    bool in_success) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunBeforeUnloadConfirm_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrameHost_RunBeforeUnloadConfirm_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->success = in_success;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)blink::mojom::LocalFrameHost::RunBeforeUnloadConfirmCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunBeforeUnloadConfirm");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool LocalFrameHost_RunBeforeUnloadConfirm_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrameHost_RunBeforeUnloadConfirm_ResponseParams_Data* params =
      reinterpret_cast<internal::LocalFrameHost_RunBeforeUnloadConfirm_ResponseParams_Data*>(
          message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  bool p_success{};
  LocalFrameHost_RunBeforeUnloadConfirm_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success)
    p_success = input_data_view.success();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrameHost::Name_, 35, true);
    return false;
  }
  *out_success_ = std::move(p_success);
  mojo::internal::SyncMessageResponseSetup::SetCurrentSyncResponseMessage(
      message);
  *result_ = true;
  return true;
}

// static
bool LocalFrameHostStubDispatch::Accept(
    LocalFrameHost* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kLocalFrameHost_EnterFullscreen_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::EnterFullscreen",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::EnterFullscreen");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_EnterFullscreen_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_EnterFullscreen_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::blink::mojom::blink::FullscreenOptionsPtr p_options{};
      LocalFrameHost_EnterFullscreen_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadOptions(&p_options))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EnterFullscreen(
std::move(p_options));
      return true;
    }
    case internal::kLocalFrameHost_ExitFullscreen_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::ExitFullscreen",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::ExitFullscreen");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_ExitFullscreen_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_ExitFullscreen_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      LocalFrameHost_ExitFullscreen_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ExitFullscreen();
      return true;
    }
    case internal::kLocalFrameHost_FullscreenStateChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::FullscreenStateChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::FullscreenStateChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_FullscreenStateChanged_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_FullscreenStateChanged_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_is_fullscreen{};
      LocalFrameHost_FullscreenStateChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_is_fullscreen = input_data_view.is_fullscreen();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FullscreenStateChanged(
std::move(p_is_fullscreen));
      return true;
    }
    case internal::kLocalFrameHost_RegisterProtocolHandler_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::RegisterProtocolHandler",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::RegisterProtocolHandler");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_RegisterProtocolHandler_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_RegisterProtocolHandler_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      WTF::String p_scheme{};
      ::blink::KURL p_url{};
      ::WTF::String p_title{};
      bool p_user_gesture{};
      LocalFrameHost_RegisterProtocolHandler_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadScheme(&p_scheme))
        success = false;
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success && !input_data_view.ReadTitle(&p_title))
        success = false;
      if (success)
        p_user_gesture = input_data_view.user_gesture();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RegisterProtocolHandler(
std::move(p_scheme), 
std::move(p_url), 
std::move(p_title), 
std::move(p_user_gesture));
      return true;
    }
    case internal::kLocalFrameHost_UnregisterProtocolHandler_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::UnregisterProtocolHandler",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::UnregisterProtocolHandler");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_UnregisterProtocolHandler_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_UnregisterProtocolHandler_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      WTF::String p_scheme{};
      ::blink::KURL p_url{};
      bool p_user_gesture{};
      LocalFrameHost_UnregisterProtocolHandler_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadScheme(&p_scheme))
        success = false;
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success)
        p_user_gesture = input_data_view.user_gesture();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UnregisterProtocolHandler(
std::move(p_scheme), 
std::move(p_url), 
std::move(p_user_gesture));
      return true;
    }
    case internal::kLocalFrameHost_DidDisplayInsecureContent_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::DidDisplayInsecureContent",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::DidDisplayInsecureContent");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidDisplayInsecureContent_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidDisplayInsecureContent_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      LocalFrameHost_DidDisplayInsecureContent_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidDisplayInsecureContent();
      return true;
    }
    case internal::kLocalFrameHost_DidContainInsecureFormAction_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::DidContainInsecureFormAction",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::DidContainInsecureFormAction");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidContainInsecureFormAction_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidContainInsecureFormAction_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      LocalFrameHost_DidContainInsecureFormAction_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidContainInsecureFormAction();
      return true;
    }
    case internal::kLocalFrameHost_DocumentAvailableInMainFrame_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::DocumentAvailableInMainFrame",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::DocumentAvailableInMainFrame");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DocumentAvailableInMainFrame_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DocumentAvailableInMainFrame_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_uses_temporary_zoom_level{};
      LocalFrameHost_DocumentAvailableInMainFrame_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_uses_temporary_zoom_level = input_data_view.uses_temporary_zoom_level();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DocumentAvailableInMainFrame(
std::move(p_uses_temporary_zoom_level));
      return true;
    }
    case internal::kLocalFrameHost_SetNeedsOcclusionTracking_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::SetNeedsOcclusionTracking",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::SetNeedsOcclusionTracking");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_SetNeedsOcclusionTracking_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_SetNeedsOcclusionTracking_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_needs_tracking{};
      LocalFrameHost_SetNeedsOcclusionTracking_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_needs_tracking = input_data_view.needs_tracking();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetNeedsOcclusionTracking(
std::move(p_needs_tracking));
      return true;
    }
    case internal::kLocalFrameHost_LifecycleStateChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::LifecycleStateChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::LifecycleStateChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_LifecycleStateChanged_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_LifecycleStateChanged_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::blink::mojom::blink::FrameLifecycleState p_state{};
      LocalFrameHost_LifecycleStateChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadState(&p_state))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->LifecycleStateChanged(
std::move(p_state));
      return true;
    }
    case internal::kLocalFrameHost_EvictFromBackForwardCache_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::EvictFromBackForwardCache",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::EvictFromBackForwardCache");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_EvictFromBackForwardCache_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_EvictFromBackForwardCache_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      LocalFrameHost_EvictFromBackForwardCache_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EvictFromBackForwardCache();
      return true;
    }
    case internal::kLocalFrameHost_VisibilityChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::VisibilityChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::VisibilityChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_VisibilityChanged_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_VisibilityChanged_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::blink::mojom::blink::FrameVisibility p_visibility{};
      LocalFrameHost_VisibilityChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadVisibility(&p_visibility))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->VisibilityChanged(
std::move(p_visibility));
      return true;
    }
    case internal::kLocalFrameHost_DidChangeThemeColor_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::DidChangeThemeColor",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::DidChangeThemeColor");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidChangeThemeColor_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidChangeThemeColor_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      base::Optional<::SkColor> p_theme_color{};
      LocalFrameHost_DidChangeThemeColor_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadThemeColor(&p_theme_color))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidChangeThemeColor(
std::move(p_theme_color));
      return true;
    }
    case internal::kLocalFrameHost_DidFocusFrame_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::DidFocusFrame",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::DidFocusFrame");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidFocusFrame_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidFocusFrame_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      LocalFrameHost_DidFocusFrame_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidFocusFrame();
      return true;
    }
    case internal::kLocalFrameHost_EnforceInsecureRequestPolicy_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::EnforceInsecureRequestPolicy",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::EnforceInsecureRequestPolicy");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_EnforceInsecureRequestPolicy_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_EnforceInsecureRequestPolicy_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      uint8_t p_policy_bitmap{};
      LocalFrameHost_EnforceInsecureRequestPolicy_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_policy_bitmap = input_data_view.policy_bitmap();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 14, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EnforceInsecureRequestPolicy(
std::move(p_policy_bitmap));
      return true;
    }
    case internal::kLocalFrameHost_EnforceInsecureNavigationsSet_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::EnforceInsecureNavigationsSet",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::EnforceInsecureNavigationsSet");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_EnforceInsecureNavigationsSet_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_EnforceInsecureNavigationsSet_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      WTF::Vector<uint32_t> p_set{};
      LocalFrameHost_EnforceInsecureNavigationsSet_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadSet(&p_set))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 15, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EnforceInsecureNavigationsSet(
std::move(p_set));
      return true;
    }
    case internal::kLocalFrameHost_DidChangeActiveSchedulerTrackedFeatures_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::DidChangeActiveSchedulerTrackedFeatures",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::DidChangeActiveSchedulerTrackedFeatures");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidChangeActiveSchedulerTrackedFeatures_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidChangeActiveSchedulerTrackedFeatures_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      uint64_t p_features_mask{};
      LocalFrameHost_DidChangeActiveSchedulerTrackedFeatures_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_features_mask = input_data_view.features_mask();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 16, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidChangeActiveSchedulerTrackedFeatures(
std::move(p_features_mask));
      return true;
    }
    case internal::kLocalFrameHost_SuddenTerminationDisablerChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::SuddenTerminationDisablerChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::SuddenTerminationDisablerChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_SuddenTerminationDisablerChanged_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_SuddenTerminationDisablerChanged_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_present{};
      ::blink::mojom::blink::SuddenTerminationDisablerType p_disabler_type{};
      LocalFrameHost_SuddenTerminationDisablerChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_present = input_data_view.present();
      if (success && !input_data_view.ReadDisablerType(&p_disabler_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 17, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SuddenTerminationDisablerChanged(
std::move(p_present), 
std::move(p_disabler_type));
      return true;
    }
    case internal::kLocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::HadStickyUserActivationBeforeNavigationChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::HadStickyUserActivationBeforeNavigationChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_has_gesture{};
      LocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_has_gesture = input_data_view.has_gesture();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 18, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->HadStickyUserActivationBeforeNavigationChanged(
std::move(p_has_gesture));
      return true;
    }
    case internal::kLocalFrameHost_ScrollRectToVisibleInParentFrame_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::ScrollRectToVisibleInParentFrame",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::ScrollRectToVisibleInParentFrame");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_ScrollRectToVisibleInParentFrame_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_ScrollRectToVisibleInParentFrame_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::blink::WebRect p_rect_to_scroll{};
      ::blink::mojom::blink::ScrollIntoViewParamsPtr p_params{};
      LocalFrameHost_ScrollRectToVisibleInParentFrame_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadRectToScroll(&p_rect_to_scroll))
        success = false;
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 19, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ScrollRectToVisibleInParentFrame(
std::move(p_rect_to_scroll), 
std::move(p_params));
      return true;
    }
    case internal::kLocalFrameHost_BubbleLogicalScrollInParentFrame_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::BubbleLogicalScrollInParentFrame",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::BubbleLogicalScrollInParentFrame");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_BubbleLogicalScrollInParentFrame_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_BubbleLogicalScrollInParentFrame_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::blink::mojom::blink::ScrollDirection p_direction{};
      ::ui::input_types::ScrollGranularity p_granularity{};
      LocalFrameHost_BubbleLogicalScrollInParentFrame_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadDirection(&p_direction))
        success = false;
      if (success && !input_data_view.ReadGranularity(&p_granularity))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 20, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BubbleLogicalScrollInParentFrame(
std::move(p_direction), 
std::move(p_granularity));
      return true;
    }
    case internal::kLocalFrameHost_DidAccessInitialDocument_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::DidAccessInitialDocument",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::DidAccessInitialDocument");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidAccessInitialDocument_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidAccessInitialDocument_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      LocalFrameHost_DidAccessInitialDocument_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 21, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidAccessInitialDocument();
      return true;
    }
    case internal::kLocalFrameHost_DidBlockNavigation_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::DidBlockNavigation",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::DidBlockNavigation");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidBlockNavigation_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidBlockNavigation_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::blink::KURL p_blocked_url{};
      ::blink::KURL p_initiator_url{};
      ::blink::mojom::blink::NavigationBlockedReason p_reason{};
      LocalFrameHost_DidBlockNavigation_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadBlockedUrl(&p_blocked_url))
        success = false;
      if (success && !input_data_view.ReadInitiatorUrl(&p_initiator_url))
        success = false;
      if (success && !input_data_view.ReadReason(&p_reason))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 22, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidBlockNavigation(
std::move(p_blocked_url), 
std::move(p_initiator_url), 
std::move(p_reason));
      return true;
    }
    case internal::kLocalFrameHost_DidChangeLoadProgress_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::DidChangeLoadProgress",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::DidChangeLoadProgress");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidChangeLoadProgress_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidChangeLoadProgress_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      double p_load_progress{};
      LocalFrameHost_DidChangeLoadProgress_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_load_progress = input_data_view.load_progress();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 23, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidChangeLoadProgress(
std::move(p_load_progress));
      return true;
    }
    case internal::kLocalFrameHost_DispatchLoad_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::DispatchLoad",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::DispatchLoad");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DispatchLoad_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DispatchLoad_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      LocalFrameHost_DispatchLoad_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 24, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DispatchLoad();
      return true;
    }
    case internal::kLocalFrameHost_GoToEntryAtOffset_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::GoToEntryAtOffset",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::GoToEntryAtOffset");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_GoToEntryAtOffset_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_GoToEntryAtOffset_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int32_t p_offset{};
      bool p_has_user_gesture{};
      LocalFrameHost_GoToEntryAtOffset_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_offset = input_data_view.offset();
      if (success)
        p_has_user_gesture = input_data_view.has_user_gesture();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 25, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GoToEntryAtOffset(
std::move(p_offset), 
std::move(p_has_user_gesture));
      return true;
    }
    case internal::kLocalFrameHost_RenderFallbackContentInParentProcess_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::RenderFallbackContentInParentProcess",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::RenderFallbackContentInParentProcess");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_RenderFallbackContentInParentProcess_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_RenderFallbackContentInParentProcess_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      LocalFrameHost_RenderFallbackContentInParentProcess_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 26, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RenderFallbackContentInParentProcess();
      return true;
    }
    case internal::kLocalFrameHost_HandleAccessibilityFindInPageResult_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageResult",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageResult");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_HandleAccessibilityFindInPageResult_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_HandleAccessibilityFindInPageResult_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      FindInPageResultAXParamsPtr p_params{};
      LocalFrameHost_HandleAccessibilityFindInPageResult_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 27, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->HandleAccessibilityFindInPageResult(
std::move(p_params));
      return true;
    }
    case internal::kLocalFrameHost_HandleAccessibilityFindInPageTermination_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageTermination",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageTermination");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_HandleAccessibilityFindInPageTermination_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_HandleAccessibilityFindInPageTermination_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      LocalFrameHost_HandleAccessibilityFindInPageTermination_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 28, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->HandleAccessibilityFindInPageTermination();
      return true;
    }
    case internal::kLocalFrameHost_DocumentOnLoadCompleted_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::DocumentOnLoadCompleted",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::DocumentOnLoadCompleted");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DocumentOnLoadCompleted_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DocumentOnLoadCompleted_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      LocalFrameHost_DocumentOnLoadCompleted_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 29, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DocumentOnLoadCompleted();
      return true;
    }
    case internal::kLocalFrameHost_ForwardResourceTimingToParent_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::ForwardResourceTimingToParent",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::ForwardResourceTimingToParent");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_ForwardResourceTimingToParent_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_ForwardResourceTimingToParent_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::blink::mojom::blink::ResourceTimingInfoPtr p_timing{};
      LocalFrameHost_ForwardResourceTimingToParent_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadTiming(&p_timing))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 30, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ForwardResourceTimingToParent(
std::move(p_timing));
      return true;
    }
    case internal::kLocalFrameHost_DidFinishDocumentLoad_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::DidFinishDocumentLoad",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::DidFinishDocumentLoad");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidFinishDocumentLoad_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidFinishDocumentLoad_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      LocalFrameHost_DidFinishDocumentLoad_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 31, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidFinishDocumentLoad();
      return true;
    }
    case internal::kLocalFrameHost_RunModalAlertDialog_Name: {
      break;
    }
    case internal::kLocalFrameHost_RunModalConfirmDialog_Name: {
      break;
    }
    case internal::kLocalFrameHost_RunModalPromptDialog_Name: {
      break;
    }
    case internal::kLocalFrameHost_RunBeforeUnloadConfirm_Name: {
      break;
    }
  }
  return false;
}

// static
bool LocalFrameHostStubDispatch::AcceptWithResponder(
    LocalFrameHost* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kLocalFrameHost_EnterFullscreen_Name: {
      break;
    }
    case internal::kLocalFrameHost_ExitFullscreen_Name: {
      break;
    }
    case internal::kLocalFrameHost_FullscreenStateChanged_Name: {
      break;
    }
    case internal::kLocalFrameHost_RegisterProtocolHandler_Name: {
      break;
    }
    case internal::kLocalFrameHost_UnregisterProtocolHandler_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidDisplayInsecureContent_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidContainInsecureFormAction_Name: {
      break;
    }
    case internal::kLocalFrameHost_DocumentAvailableInMainFrame_Name: {
      break;
    }
    case internal::kLocalFrameHost_SetNeedsOcclusionTracking_Name: {
      break;
    }
    case internal::kLocalFrameHost_LifecycleStateChanged_Name: {
      break;
    }
    case internal::kLocalFrameHost_EvictFromBackForwardCache_Name: {
      break;
    }
    case internal::kLocalFrameHost_VisibilityChanged_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidChangeThemeColor_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidFocusFrame_Name: {
      break;
    }
    case internal::kLocalFrameHost_EnforceInsecureRequestPolicy_Name: {
      break;
    }
    case internal::kLocalFrameHost_EnforceInsecureNavigationsSet_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidChangeActiveSchedulerTrackedFeatures_Name: {
      break;
    }
    case internal::kLocalFrameHost_SuddenTerminationDisablerChanged_Name: {
      break;
    }
    case internal::kLocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_Name: {
      break;
    }
    case internal::kLocalFrameHost_ScrollRectToVisibleInParentFrame_Name: {
      break;
    }
    case internal::kLocalFrameHost_BubbleLogicalScrollInParentFrame_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidAccessInitialDocument_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidBlockNavigation_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidChangeLoadProgress_Name: {
      break;
    }
    case internal::kLocalFrameHost_DispatchLoad_Name: {
      break;
    }
    case internal::kLocalFrameHost_GoToEntryAtOffset_Name: {
      break;
    }
    case internal::kLocalFrameHost_RenderFallbackContentInParentProcess_Name: {
      break;
    }
    case internal::kLocalFrameHost_HandleAccessibilityFindInPageResult_Name: {
      break;
    }
    case internal::kLocalFrameHost_HandleAccessibilityFindInPageTermination_Name: {
      break;
    }
    case internal::kLocalFrameHost_DocumentOnLoadCompleted_Name: {
      break;
    }
    case internal::kLocalFrameHost_ForwardResourceTimingToParent_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidFinishDocumentLoad_Name: {
      break;
    }
    case internal::kLocalFrameHost_RunModalAlertDialog_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::RunModalAlertDialog",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::RunModalAlertDialog");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::LocalFrameHost_RunModalAlertDialog_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrameHost_RunModalAlertDialog_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::WTF::String p_alert_message{};
      LocalFrameHost_RunModalAlertDialog_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadAlertMessage(&p_alert_message))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 32, false);
        return false;
      }
      LocalFrameHost::RunModalAlertDialogCallback callback =
          LocalFrameHost_RunModalAlertDialog_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RunModalAlertDialog(
std::move(p_alert_message), std::move(callback));
      return true;
    }
    case internal::kLocalFrameHost_RunModalConfirmDialog_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::RunModalConfirmDialog",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::RunModalConfirmDialog");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::LocalFrameHost_RunModalConfirmDialog_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrameHost_RunModalConfirmDialog_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::WTF::String p_alert_message{};
      LocalFrameHost_RunModalConfirmDialog_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadAlertMessage(&p_alert_message))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 33, false);
        return false;
      }
      LocalFrameHost::RunModalConfirmDialogCallback callback =
          LocalFrameHost_RunModalConfirmDialog_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RunModalConfirmDialog(
std::move(p_alert_message), std::move(callback));
      return true;
    }
    case internal::kLocalFrameHost_RunModalPromptDialog_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::RunModalPromptDialog",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::RunModalPromptDialog");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::LocalFrameHost_RunModalPromptDialog_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrameHost_RunModalPromptDialog_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::WTF::String p_alert_message{};
      ::WTF::String p_default_value{};
      LocalFrameHost_RunModalPromptDialog_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadAlertMessage(&p_alert_message))
        success = false;
      if (success && !input_data_view.ReadDefaultValue(&p_default_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 34, false);
        return false;
      }
      LocalFrameHost::RunModalPromptDialogCallback callback =
          LocalFrameHost_RunModalPromptDialog_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RunModalPromptDialog(
std::move(p_alert_message), 
std::move(p_default_value), std::move(callback));
      return true;
    }
    case internal::kLocalFrameHost_RunBeforeUnloadConfirm_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrameHost::RunBeforeUnloadConfirm",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrameHost::RunBeforeUnloadConfirm");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::LocalFrameHost_RunBeforeUnloadConfirm_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrameHost_RunBeforeUnloadConfirm_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_is_reload{};
      LocalFrameHost_RunBeforeUnloadConfirm_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_is_reload = input_data_view.is_reload();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 35, false);
        return false;
      }
      LocalFrameHost::RunBeforeUnloadConfirmCallback callback =
          LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RunBeforeUnloadConfirm(
std::move(p_is_reload), std::move(callback));
      return true;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kLocalFrameHostValidationInfo[] = {
    {&internal::LocalFrameHost_EnterFullscreen_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_ExitFullscreen_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_FullscreenStateChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_RegisterProtocolHandler_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_UnregisterProtocolHandler_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidDisplayInsecureContent_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidContainInsecureFormAction_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DocumentAvailableInMainFrame_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_SetNeedsOcclusionTracking_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_LifecycleStateChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_EvictFromBackForwardCache_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_VisibilityChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidChangeThemeColor_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidFocusFrame_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_EnforceInsecureRequestPolicy_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_EnforceInsecureNavigationsSet_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidChangeActiveSchedulerTrackedFeatures_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_SuddenTerminationDisablerChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_ScrollRectToVisibleInParentFrame_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_BubbleLogicalScrollInParentFrame_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidAccessInitialDocument_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidBlockNavigation_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidChangeLoadProgress_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DispatchLoad_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_GoToEntryAtOffset_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_RenderFallbackContentInParentProcess_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_HandleAccessibilityFindInPageResult_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_HandleAccessibilityFindInPageTermination_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DocumentOnLoadCompleted_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_ForwardResourceTimingToParent_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidFinishDocumentLoad_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_RunModalAlertDialog_Params_Data::Validate,
     &internal::LocalFrameHost_RunModalAlertDialog_ResponseParams_Data::Validate},
    {&internal::LocalFrameHost_RunModalConfirmDialog_Params_Data::Validate,
     &internal::LocalFrameHost_RunModalConfirmDialog_ResponseParams_Data::Validate},
    {&internal::LocalFrameHost_RunModalPromptDialog_Params_Data::Validate,
     &internal::LocalFrameHost_RunModalPromptDialog_ResponseParams_Data::Validate},
    {&internal::LocalFrameHost_RunBeforeUnloadConfirm_Params_Data::Validate,
     &internal::LocalFrameHost_RunBeforeUnloadConfirm_ResponseParams_Data::Validate},
};

bool LocalFrameHostRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::LocalFrameHost::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kLocalFrameHostValidationInfo);
}

bool LocalFrameHostResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::LocalFrameHost::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kLocalFrameHostValidationInfo);
}
const char LocalFrame::Name_[] = "blink.mojom.LocalFrame";

class LocalFrame_GetTextSurroundingSelection_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrame_GetTextSurroundingSelection_ForwardToCallback(
      LocalFrame::GetTextSurroundingSelectionCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  LocalFrame::GetTextSurroundingSelectionCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(LocalFrame_GetTextSurroundingSelection_ForwardToCallback);
};

class LocalFrame_BeforeUnload_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrame_BeforeUnload_ForwardToCallback(
      LocalFrame::BeforeUnloadCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  LocalFrame::BeforeUnloadCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(LocalFrame_BeforeUnload_ForwardToCallback);
};

LocalFrameProxy::LocalFrameProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void LocalFrameProxy::GetTextSurroundingSelection(
    uint32_t in_max_length, GetTextSurroundingSelectionCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrame::GetTextSurroundingSelection");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrame_GetTextSurroundingSelection_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrame_GetTextSurroundingSelection_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->max_length = in_max_length;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("GetTextSurroundingSelection");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrame_GetTextSurroundingSelection_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void LocalFrameProxy::SendInterventionReport(
    const WTF::String& in_id, const WTF::String& in_message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrame::SendInterventionReport");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrame_SendInterventionReport_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrame_SendInterventionReport_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->id)::BaseType::BufferWriter
      id_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_id, buffer, &id_writer, &serialization_context);
  params->id.Set(
      id_writer.is_null() ? nullptr : id_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null id in LocalFrame.SendInterventionReport request");
  typename decltype(params->message)::BaseType::BufferWriter
      message_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_message, buffer, &message_writer, &serialization_context);
  params->message.Set(
      message_writer.is_null() ? nullptr : message_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null message in LocalFrame.SendInterventionReport request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("SendInterventionReport");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameProxy::NotifyUserActivation(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrame::NotifyUserActivation");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrame_NotifyUserActivation_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrame_NotifyUserActivation_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("NotifyUserActivation");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameProxy::AddMessageToConsole(
    ::blink::mojom::blink::ConsoleMessageLevel in_level, const WTF::String& in_message, bool in_discard_duplicates) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrame::AddMessageToConsole");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrame_AddMessageToConsole_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrame_AddMessageToConsole_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::blink::mojom::ConsoleMessageLevel>(
      in_level, &params->level);
  typename decltype(params->message)::BaseType::BufferWriter
      message_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_message, buffer, &message_writer, &serialization_context);
  params->message.Set(
      message_writer.is_null() ? nullptr : message_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null message in LocalFrame.AddMessageToConsole request");
  params->discard_duplicates = in_discard_duplicates;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("AddMessageToConsole");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameProxy::CheckCompleted(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrame::CheckCompleted");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrame_CheckCompleted_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrame_CheckCompleted_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("CheckCompleted");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameProxy::Collapse(
    bool in_collapsed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrame::Collapse");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrame_Collapse_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrame_Collapse_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->collapsed = in_collapsed;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("Collapse");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameProxy::EnableViewSourceMode(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrame::EnableViewSourceMode");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrame_EnableViewSourceMode_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrame_EnableViewSourceMode_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("EnableViewSourceMode");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameProxy::Focus(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrame::Focus");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrame_Focus_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrame_Focus_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("Focus");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameProxy::ClearFocusedElement(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrame::ClearFocusedElement");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrame_ClearFocusedElement_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrame_ClearFocusedElement_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("ClearFocusedElement");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameProxy::CopyImageAt(
    const ::gfx::Point& in_window_point) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrame::CopyImageAt");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrame_CopyImageAt_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrame_CopyImageAt_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->window_point)::BaseType::BufferWriter
      window_point_writer;
  mojo::internal::Serialize<::gfx::mojom::PointDataView>(
      in_window_point, buffer, &window_point_writer, &serialization_context);
  params->window_point.Set(
      window_point_writer.is_null() ? nullptr : window_point_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->window_point.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null window_point in LocalFrame.CopyImageAt request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("CopyImageAt");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameProxy::SaveImageAt(
    const ::gfx::Point& in_window_point) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrame::SaveImageAt");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrame_SaveImageAt_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrame_SaveImageAt_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->window_point)::BaseType::BufferWriter
      window_point_writer;
  mojo::internal::Serialize<::gfx::mojom::PointDataView>(
      in_window_point, buffer, &window_point_writer, &serialization_context);
  params->window_point.Set(
      window_point_writer.is_null() ? nullptr : window_point_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->window_point.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null window_point in LocalFrame.SaveImageAt request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("SaveImageAt");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameProxy::ReportBlinkFeatureUsage(
    const WTF::Vector<::blink::mojom::blink::WebFeature>& in_features) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrame::ReportBlinkFeatureUsage");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrame_ReportBlinkFeatureUsage_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrame_ReportBlinkFeatureUsage_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->features)::BaseType::BufferWriter
      features_writer;
  const mojo::internal::ContainerValidateParams features_validate_params(
      0, ::blink::mojom::internal::WebFeature_Data::Validate);
  mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::WebFeature>>(
      in_features, buffer, &features_writer, &features_validate_params,
      &serialization_context);
  params->features.Set(
      features_writer.is_null() ? nullptr : features_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->features.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null features in LocalFrame.ReportBlinkFeatureUsage request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("ReportBlinkFeatureUsage");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameProxy::RenderFallbackContent(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrame::RenderFallbackContent");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrame_RenderFallbackContent_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrame_RenderFallbackContent_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("RenderFallbackContent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameProxy::BeforeUnload(
    bool in_is_reload, BeforeUnloadCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrame::BeforeUnload");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrame_BeforeUnload_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrame_BeforeUnload_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->is_reload = in_is_reload;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("BeforeUnload");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrame_BeforeUnload_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void LocalFrameProxy::MediaPlayerActionAt(
    const ::gfx::Point& in_location, ::blink::mojom::blink::MediaPlayerActionPtr in_action) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrame::MediaPlayerActionAt");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrame_MediaPlayerActionAt_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrame_MediaPlayerActionAt_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->location)::BaseType::BufferWriter
      location_writer;
  mojo::internal::Serialize<::gfx::mojom::PointDataView>(
      in_location, buffer, &location_writer, &serialization_context);
  params->location.Set(
      location_writer.is_null() ? nullptr : location_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->location.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null location in LocalFrame.MediaPlayerActionAt request");
  typename decltype(params->action)::BaseType::BufferWriter
      action_writer;
  mojo::internal::Serialize<::blink::mojom::MediaPlayerActionDataView>(
      in_action, buffer, &action_writer, &serialization_context);
  params->action.Set(
      action_writer.is_null() ? nullptr : action_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->action.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null action in LocalFrame.MediaPlayerActionAt request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("MediaPlayerActionAt");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void LocalFrameProxy::AdvanceFocusInForm(
    ::blink::mojom::blink::FocusType in_focus_type) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::LocalFrame::AdvanceFocusInForm");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrame_AdvanceFocusInForm_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrame_AdvanceFocusInForm_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::blink::mojom::FocusType>(
      in_focus_type, &params->focus_type);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("AdvanceFocusInForm");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
class LocalFrame_GetTextSurroundingSelection_ProxyToResponder {
 public:
  static LocalFrame::GetTextSurroundingSelectionCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrame_GetTextSurroundingSelection_ProxyToResponder> proxy(
        new LocalFrame_GetTextSurroundingSelection_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&LocalFrame_GetTextSurroundingSelection_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrame_GetTextSurroundingSelection_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  LocalFrame_GetTextSurroundingSelection_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrame::GetTextSurroundingSelectionCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const ::WTF::String& in_content, uint32_t in_start_offset, uint32_t in_end_offset);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(LocalFrame_GetTextSurroundingSelection_ProxyToResponder);
};

bool LocalFrame_GetTextSurroundingSelection_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "blink::mojom::LocalFrame::GetTextSurroundingSelectionCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::LocalFrame_GetTextSurroundingSelection_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrame_GetTextSurroundingSelection_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  ::WTF::String p_content{};
  uint32_t p_start_offset{};
  uint32_t p_end_offset{};
  LocalFrame_GetTextSurroundingSelection_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadContent(&p_content))
    success = false;
  if (success)
    p_start_offset = input_data_view.start_offset();
  if (success)
    p_end_offset = input_data_view.end_offset();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrame::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_content), 
std::move(p_start_offset), 
std::move(p_end_offset));
  return true;
}

void LocalFrame_GetTextSurroundingSelection_ProxyToResponder::Run(
    const ::WTF::String& in_content, uint32_t in_start_offset, uint32_t in_end_offset) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrame_GetTextSurroundingSelection_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrame_GetTextSurroundingSelection_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->content)::BaseType::BufferWriter
      content_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_content, buffer, &content_writer, &serialization_context);
  params->content.Set(
      content_writer.is_null() ? nullptr : content_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->content.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null content in ");
  params->start_offset = in_start_offset;
  params->end_offset = in_end_offset;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)blink::mojom::LocalFrame::GetTextSurroundingSelectionCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("GetTextSurroundingSelection");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class LocalFrame_BeforeUnload_ProxyToResponder {
 public:
  static LocalFrame::BeforeUnloadCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrame_BeforeUnload_ProxyToResponder> proxy(
        new LocalFrame_BeforeUnload_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&LocalFrame_BeforeUnload_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrame_BeforeUnload_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  LocalFrame_BeforeUnload_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrame::BeforeUnloadCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_proceed, ::base::TimeTicks in_before_unload_start_time, ::base::TimeTicks in_before_unload_end_time);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(LocalFrame_BeforeUnload_ProxyToResponder);
};

bool LocalFrame_BeforeUnload_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "blink::mojom::LocalFrame::BeforeUnloadCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::LocalFrame_BeforeUnload_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrame_BeforeUnload_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  bool p_proceed{};
  ::base::TimeTicks p_before_unload_start_time{};
  ::base::TimeTicks p_before_unload_end_time{};
  LocalFrame_BeforeUnload_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success)
    p_proceed = input_data_view.proceed();
  if (success && !input_data_view.ReadBeforeUnloadStartTime(&p_before_unload_start_time))
    success = false;
  if (success && !input_data_view.ReadBeforeUnloadEndTime(&p_before_unload_end_time))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrame::Name_, 13, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_proceed), 
std::move(p_before_unload_start_time), 
std::move(p_before_unload_end_time));
  return true;
}

void LocalFrame_BeforeUnload_ProxyToResponder::Run(
    bool in_proceed, ::base::TimeTicks in_before_unload_start_time, ::base::TimeTicks in_before_unload_end_time) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kLocalFrame_BeforeUnload_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::LocalFrame_BeforeUnload_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->proceed = in_proceed;
  typename decltype(params->before_unload_start_time)::BaseType::BufferWriter
      before_unload_start_time_writer;
  mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
      in_before_unload_start_time, buffer, &before_unload_start_time_writer, &serialization_context);
  params->before_unload_start_time.Set(
      before_unload_start_time_writer.is_null() ? nullptr : before_unload_start_time_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->before_unload_start_time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null before_unload_start_time in ");
  typename decltype(params->before_unload_end_time)::BaseType::BufferWriter
      before_unload_end_time_writer;
  mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
      in_before_unload_end_time, buffer, &before_unload_end_time_writer, &serialization_context);
  params->before_unload_end_time.Set(
      before_unload_end_time_writer.is_null() ? nullptr : before_unload_end_time_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->before_unload_end_time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null before_unload_end_time in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)blink::mojom::LocalFrame::BeforeUnloadCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("BeforeUnload");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool LocalFrameStubDispatch::Accept(
    LocalFrame* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kLocalFrame_GetTextSurroundingSelection_Name: {
      break;
    }
    case internal::kLocalFrame_SendInterventionReport_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrame::SendInterventionReport",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrame::SendInterventionReport");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrame_SendInterventionReport_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_SendInterventionReport_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      WTF::String p_id{};
      WTF::String p_message{};
      LocalFrame_SendInterventionReport_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadId(&p_id))
        success = false;
      if (success && !input_data_view.ReadMessage(&p_message))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SendInterventionReport(
std::move(p_id), 
std::move(p_message));
      return true;
    }
    case internal::kLocalFrame_NotifyUserActivation_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrame::NotifyUserActivation",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrame::NotifyUserActivation");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrame_NotifyUserActivation_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_NotifyUserActivation_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      LocalFrame_NotifyUserActivation_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->NotifyUserActivation();
      return true;
    }
    case internal::kLocalFrame_AddMessageToConsole_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrame::AddMessageToConsole",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrame::AddMessageToConsole");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrame_AddMessageToConsole_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_AddMessageToConsole_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::blink::mojom::blink::ConsoleMessageLevel p_level{};
      WTF::String p_message{};
      bool p_discard_duplicates{};
      LocalFrame_AddMessageToConsole_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadLevel(&p_level))
        success = false;
      if (success && !input_data_view.ReadMessage(&p_message))
        success = false;
      if (success)
        p_discard_duplicates = input_data_view.discard_duplicates();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddMessageToConsole(
std::move(p_level), 
std::move(p_message), 
std::move(p_discard_duplicates));
      return true;
    }
    case internal::kLocalFrame_CheckCompleted_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrame::CheckCompleted",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrame::CheckCompleted");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrame_CheckCompleted_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_CheckCompleted_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      LocalFrame_CheckCompleted_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CheckCompleted();
      return true;
    }
    case internal::kLocalFrame_Collapse_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrame::Collapse",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrame::Collapse");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrame_Collapse_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_Collapse_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_collapsed{};
      LocalFrame_Collapse_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_collapsed = input_data_view.collapsed();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Collapse(
std::move(p_collapsed));
      return true;
    }
    case internal::kLocalFrame_EnableViewSourceMode_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrame::EnableViewSourceMode",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrame::EnableViewSourceMode");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrame_EnableViewSourceMode_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_EnableViewSourceMode_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      LocalFrame_EnableViewSourceMode_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EnableViewSourceMode();
      return true;
    }
    case internal::kLocalFrame_Focus_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrame::Focus",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrame::Focus");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrame_Focus_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_Focus_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      LocalFrame_Focus_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Focus();
      return true;
    }
    case internal::kLocalFrame_ClearFocusedElement_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrame::ClearFocusedElement",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrame::ClearFocusedElement");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrame_ClearFocusedElement_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_ClearFocusedElement_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      LocalFrame_ClearFocusedElement_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearFocusedElement();
      return true;
    }
    case internal::kLocalFrame_CopyImageAt_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrame::CopyImageAt",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrame::CopyImageAt");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrame_CopyImageAt_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_CopyImageAt_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::gfx::Point p_window_point{};
      LocalFrame_CopyImageAt_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadWindowPoint(&p_window_point))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CopyImageAt(
std::move(p_window_point));
      return true;
    }
    case internal::kLocalFrame_SaveImageAt_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrame::SaveImageAt",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrame::SaveImageAt");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrame_SaveImageAt_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_SaveImageAt_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::gfx::Point p_window_point{};
      LocalFrame_SaveImageAt_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadWindowPoint(&p_window_point))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SaveImageAt(
std::move(p_window_point));
      return true;
    }
    case internal::kLocalFrame_ReportBlinkFeatureUsage_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrame::ReportBlinkFeatureUsage",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrame::ReportBlinkFeatureUsage");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrame_ReportBlinkFeatureUsage_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_ReportBlinkFeatureUsage_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      WTF::Vector<::blink::mojom::blink::WebFeature> p_features{};
      LocalFrame_ReportBlinkFeatureUsage_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadFeatures(&p_features))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ReportBlinkFeatureUsage(
std::move(p_features));
      return true;
    }
    case internal::kLocalFrame_RenderFallbackContent_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrame::RenderFallbackContent",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrame::RenderFallbackContent");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrame_RenderFallbackContent_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_RenderFallbackContent_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      LocalFrame_RenderFallbackContent_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RenderFallbackContent();
      return true;
    }
    case internal::kLocalFrame_BeforeUnload_Name: {
      break;
    }
    case internal::kLocalFrame_MediaPlayerActionAt_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrame::MediaPlayerActionAt",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrame::MediaPlayerActionAt");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrame_MediaPlayerActionAt_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_MediaPlayerActionAt_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::gfx::Point p_location{};
      ::blink::mojom::blink::MediaPlayerActionPtr p_action{};
      LocalFrame_MediaPlayerActionAt_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadLocation(&p_location))
        success = false;
      if (success && !input_data_view.ReadAction(&p_action))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 14, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->MediaPlayerActionAt(
std::move(p_location), 
std::move(p_action));
      return true;
    }
    case internal::kLocalFrame_AdvanceFocusInForm_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrame::AdvanceFocusInForm",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrame::AdvanceFocusInForm");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::LocalFrame_AdvanceFocusInForm_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_AdvanceFocusInForm_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::blink::mojom::blink::FocusType p_focus_type{};
      LocalFrame_AdvanceFocusInForm_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadFocusType(&p_focus_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 15, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AdvanceFocusInForm(
std::move(p_focus_type));
      return true;
    }
  }
  return false;
}

// static
bool LocalFrameStubDispatch::AcceptWithResponder(
    LocalFrame* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kLocalFrame_GetTextSurroundingSelection_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrame::GetTextSurroundingSelection",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrame::GetTextSurroundingSelection");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::LocalFrame_GetTextSurroundingSelection_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrame_GetTextSurroundingSelection_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      uint32_t p_max_length{};
      LocalFrame_GetTextSurroundingSelection_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_max_length = input_data_view.max_length();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 0, false);
        return false;
      }
      LocalFrame::GetTextSurroundingSelectionCallback callback =
          LocalFrame_GetTextSurroundingSelection_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetTextSurroundingSelection(
std::move(p_max_length), std::move(callback));
      return true;
    }
    case internal::kLocalFrame_SendInterventionReport_Name: {
      break;
    }
    case internal::kLocalFrame_NotifyUserActivation_Name: {
      break;
    }
    case internal::kLocalFrame_AddMessageToConsole_Name: {
      break;
    }
    case internal::kLocalFrame_CheckCompleted_Name: {
      break;
    }
    case internal::kLocalFrame_Collapse_Name: {
      break;
    }
    case internal::kLocalFrame_EnableViewSourceMode_Name: {
      break;
    }
    case internal::kLocalFrame_Focus_Name: {
      break;
    }
    case internal::kLocalFrame_ClearFocusedElement_Name: {
      break;
    }
    case internal::kLocalFrame_CopyImageAt_Name: {
      break;
    }
    case internal::kLocalFrame_SaveImageAt_Name: {
      break;
    }
    case internal::kLocalFrame_ReportBlinkFeatureUsage_Name: {
      break;
    }
    case internal::kLocalFrame_RenderFallbackContent_Name: {
      break;
    }
    case internal::kLocalFrame_BeforeUnload_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::LocalFrame::BeforeUnload",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::LocalFrame::BeforeUnload");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::LocalFrame_BeforeUnload_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrame_BeforeUnload_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_is_reload{};
      LocalFrame_BeforeUnload_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_is_reload = input_data_view.is_reload();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 13, false);
        return false;
      }
      LocalFrame::BeforeUnloadCallback callback =
          LocalFrame_BeforeUnload_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BeforeUnload(
std::move(p_is_reload), std::move(callback));
      return true;
    }
    case internal::kLocalFrame_MediaPlayerActionAt_Name: {
      break;
    }
    case internal::kLocalFrame_AdvanceFocusInForm_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kLocalFrameValidationInfo[] = {
    {&internal::LocalFrame_GetTextSurroundingSelection_Params_Data::Validate,
     &internal::LocalFrame_GetTextSurroundingSelection_ResponseParams_Data::Validate},
    {&internal::LocalFrame_SendInterventionReport_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_NotifyUserActivation_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_AddMessageToConsole_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_CheckCompleted_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_Collapse_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_EnableViewSourceMode_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_Focus_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_ClearFocusedElement_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_CopyImageAt_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_SaveImageAt_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_ReportBlinkFeatureUsage_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_RenderFallbackContent_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_BeforeUnload_Params_Data::Validate,
     &internal::LocalFrame_BeforeUnload_ResponseParams_Data::Validate},
    {&internal::LocalFrame_MediaPlayerActionAt_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_AdvanceFocusInForm_Params_Data::Validate,
     nullptr /* no response */},
};

bool LocalFrameRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::LocalFrame::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kLocalFrameValidationInfo);
}

bool LocalFrameResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::LocalFrame::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kLocalFrameValidationInfo);
}
const char RemoteFrameHost::Name_[] = "blink.mojom.RemoteFrameHost";

RemoteFrameHostProxy::RemoteFrameHostProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void RemoteFrameHostProxy::SetInheritedEffectiveTouchAction(
    ::cc::TouchAction in_touch_action) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrameHost::SetInheritedEffectiveTouchAction");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrameHost_SetInheritedEffectiveTouchAction_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrameHost_SetInheritedEffectiveTouchAction_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::cc::mojom::TouchAction>(
      in_touch_action, &params->touch_action);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrameHost::Name_);
  message.set_method_name("SetInheritedEffectiveTouchAction");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameHostProxy::VisibilityChanged(
    ::blink::mojom::blink::FrameVisibility in_visibility) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrameHost::VisibilityChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrameHost_VisibilityChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrameHost_VisibilityChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::blink::mojom::FrameVisibility>(
      in_visibility, &params->visibility);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrameHost::Name_);
  message.set_method_name("VisibilityChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameHostProxy::DidFocusFrame(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrameHost::DidFocusFrame");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrameHost_DidFocusFrame_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrameHost_DidFocusFrame_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrameHost::Name_);
  message.set_method_name("DidFocusFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameHostProxy::CheckCompleted(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrameHost::CheckCompleted");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrameHost_CheckCompleted_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrameHost_CheckCompleted_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrameHost::Name_);
  message.set_method_name("CheckCompleted");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool RemoteFrameHostStubDispatch::Accept(
    RemoteFrameHost* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kRemoteFrameHost_SetInheritedEffectiveTouchAction_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrameHost::SetInheritedEffectiveTouchAction",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrameHost::SetInheritedEffectiveTouchAction");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrameHost_SetInheritedEffectiveTouchAction_Params_Data* params =
          reinterpret_cast<internal::RemoteFrameHost_SetInheritedEffectiveTouchAction_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::cc::TouchAction p_touch_action{};
      RemoteFrameHost_SetInheritedEffectiveTouchAction_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadTouchAction(&p_touch_action))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrameHost::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetInheritedEffectiveTouchAction(
std::move(p_touch_action));
      return true;
    }
    case internal::kRemoteFrameHost_VisibilityChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrameHost::VisibilityChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrameHost::VisibilityChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrameHost_VisibilityChanged_Params_Data* params =
          reinterpret_cast<internal::RemoteFrameHost_VisibilityChanged_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::blink::mojom::blink::FrameVisibility p_visibility{};
      RemoteFrameHost_VisibilityChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadVisibility(&p_visibility))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrameHost::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->VisibilityChanged(
std::move(p_visibility));
      return true;
    }
    case internal::kRemoteFrameHost_DidFocusFrame_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrameHost::DidFocusFrame",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrameHost::DidFocusFrame");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrameHost_DidFocusFrame_Params_Data* params =
          reinterpret_cast<internal::RemoteFrameHost_DidFocusFrame_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      RemoteFrameHost_DidFocusFrame_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrameHost::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidFocusFrame();
      return true;
    }
    case internal::kRemoteFrameHost_CheckCompleted_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrameHost::CheckCompleted",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrameHost::CheckCompleted");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrameHost_CheckCompleted_Params_Data* params =
          reinterpret_cast<internal::RemoteFrameHost_CheckCompleted_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      RemoteFrameHost_CheckCompleted_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrameHost::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CheckCompleted();
      return true;
    }
  }
  return false;
}

// static
bool RemoteFrameHostStubDispatch::AcceptWithResponder(
    RemoteFrameHost* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kRemoteFrameHost_SetInheritedEffectiveTouchAction_Name: {
      break;
    }
    case internal::kRemoteFrameHost_VisibilityChanged_Name: {
      break;
    }
    case internal::kRemoteFrameHost_DidFocusFrame_Name: {
      break;
    }
    case internal::kRemoteFrameHost_CheckCompleted_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kRemoteFrameHostValidationInfo[] = {
    {&internal::RemoteFrameHost_SetInheritedEffectiveTouchAction_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrameHost_VisibilityChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrameHost_DidFocusFrame_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrameHost_CheckCompleted_Params_Data::Validate,
     nullptr /* no response */},
};

bool RemoteFrameHostRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::RemoteFrameHost::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kRemoteFrameHostValidationInfo);
}

const char RemoteFrame::Name_[] = "blink.mojom.RemoteFrame";

RemoteFrameProxy::RemoteFrameProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void RemoteFrameProxy::WillEnterFullscreen(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrame::WillEnterFullscreen");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrame_WillEnterFullscreen_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrame_WillEnterFullscreen_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("WillEnterFullscreen");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameProxy::AddReplicatedContentSecurityPolicies(
    WTF::Vector<::network::mojom::blink::ContentSecurityPolicyHeaderPtr> in_headers) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrame::AddReplicatedContentSecurityPolicies");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrame_AddReplicatedContentSecurityPolicies_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrame_AddReplicatedContentSecurityPolicies_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->headers)::BaseType::BufferWriter
      headers_writer;
  const mojo::internal::ContainerValidateParams headers_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::ContentSecurityPolicyHeaderDataView>>(
      in_headers, buffer, &headers_writer, &headers_validate_params,
      &serialization_context);
  params->headers.Set(
      headers_writer.is_null() ? nullptr : headers_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->headers.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null headers in RemoteFrame.AddReplicatedContentSecurityPolicies request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("AddReplicatedContentSecurityPolicies");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameProxy::ResetReplicatedContentSecurityPolicy(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrame::ResetReplicatedContentSecurityPolicy");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrame_ResetReplicatedContentSecurityPolicy_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrame_ResetReplicatedContentSecurityPolicy_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("ResetReplicatedContentSecurityPolicy");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameProxy::EnforceInsecureNavigationsSet(
    const WTF::Vector<uint32_t>& in_set) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrame::EnforceInsecureNavigationsSet");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrame_EnforceInsecureNavigationsSet_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrame_EnforceInsecureNavigationsSet_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->set)::BaseType::BufferWriter
      set_writer;
  const mojo::internal::ContainerValidateParams set_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<uint32_t>>(
      in_set, buffer, &set_writer, &set_validate_params,
      &serialization_context);
  params->set.Set(
      set_writer.is_null() ? nullptr : set_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->set.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null set in RemoteFrame.EnforceInsecureNavigationsSet request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("EnforceInsecureNavigationsSet");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameProxy::SetReplicatedOrigin(
    const ::scoped_refptr<const ::blink::SecurityOrigin>& in_origin, bool in_is_potentially_trustworthy_unique_origin) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrame::SetReplicatedOrigin");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrame_SetReplicatedOrigin_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrame_SetReplicatedOrigin_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->origin)::BaseType::BufferWriter
      origin_writer;
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      in_origin, buffer, &origin_writer, &serialization_context);
  params->origin.Set(
      origin_writer.is_null() ? nullptr : origin_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null origin in RemoteFrame.SetReplicatedOrigin request");
  params->is_potentially_trustworthy_unique_origin = in_is_potentially_trustworthy_unique_origin;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("SetReplicatedOrigin");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameProxy::SetReplicatedAdFrameType(
    ::blink::mojom::blink::AdFrameType in_ad_frame_type) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrame::SetReplicatedAdFrameType");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrame_SetReplicatedAdFrameType_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrame_SetReplicatedAdFrameType_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::blink::mojom::AdFrameType>(
      in_ad_frame_type, &params->ad_frame_type);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("SetReplicatedAdFrameType");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameProxy::DispatchLoadEventForFrameOwner(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrame::DispatchLoadEventForFrameOwner");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrame_DispatchLoadEventForFrameOwner_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrame_DispatchLoadEventForFrameOwner_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("DispatchLoadEventForFrameOwner");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameProxy::SetNeedsOcclusionTracking(
    bool in_needs_tracking) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrame::SetNeedsOcclusionTracking");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrame_SetNeedsOcclusionTracking_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrame_SetNeedsOcclusionTracking_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->needs_tracking = in_needs_tracking;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("SetNeedsOcclusionTracking");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameProxy::Collapse(
    bool in_collapsed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrame::Collapse");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrame_Collapse_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrame_Collapse_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->collapsed = in_collapsed;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("Collapse");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameProxy::Focus(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrame::Focus");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrame_Focus_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrame_Focus_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("Focus");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameProxy::SetHadStickyUserActivationBeforeNavigation(
    bool in_has_gesture) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrame::SetHadStickyUserActivationBeforeNavigation");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrame_SetHadStickyUserActivationBeforeNavigation_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrame_SetHadStickyUserActivationBeforeNavigation_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->has_gesture = in_has_gesture;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("SetHadStickyUserActivationBeforeNavigation");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameProxy::BubbleLogicalScroll(
    ::blink::mojom::blink::ScrollDirection in_direction, ::ui::input_types::ScrollGranularity in_granularity) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrame::BubbleLogicalScroll");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrame_BubbleLogicalScroll_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrame_BubbleLogicalScroll_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::blink::mojom::ScrollDirection>(
      in_direction, &params->direction);
  mojo::internal::Serialize<::ui::mojom::ScrollGranularity>(
      in_granularity, &params->granularity);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("BubbleLogicalScroll");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameProxy::UpdateUserActivationState(
    ::blink::mojom::blink::UserActivationUpdateType in_state_update_type) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrame::UpdateUserActivationState");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrame_UpdateUserActivationState_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrame_UpdateUserActivationState_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::blink::mojom::UserActivationUpdateType>(
      in_state_update_type, &params->state_update_type);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("UpdateUserActivationState");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameProxy::SetEmbeddingToken(
    const ::base::UnguessableToken& in_embedding_token) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrame::SetEmbeddingToken");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrame_SetEmbeddingToken_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrame_SetEmbeddingToken_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->embedding_token)::BaseType::BufferWriter
      embedding_token_writer;
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      in_embedding_token, buffer, &embedding_token_writer, &serialization_context);
  params->embedding_token.Set(
      embedding_token_writer.is_null() ? nullptr : embedding_token_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->embedding_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null embedding_token in RemoteFrame.SetEmbeddingToken request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("SetEmbeddingToken");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameProxy::SetPageFocus(
    bool in_is_focused) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrame::SetPageFocus");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrame_SetPageFocus_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrame_SetPageFocus_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->is_focused = in_is_focused;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("SetPageFocus");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameProxy::RenderFallbackContent(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrame::RenderFallbackContent");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrame_RenderFallbackContent_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrame_RenderFallbackContent_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("RenderFallbackContent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameProxy::AddResourceTimingFromChild(
    ::blink::mojom::blink::ResourceTimingInfoPtr in_timing) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrame::AddResourceTimingFromChild");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrame_AddResourceTimingFromChild_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrame_AddResourceTimingFromChild_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->timing)::BaseType::BufferWriter
      timing_writer;
  mojo::internal::Serialize<::blink::mojom::ResourceTimingInfoDataView>(
      in_timing, buffer, &timing_writer, &serialization_context);
  params->timing.Set(
      timing_writer.is_null() ? nullptr : timing_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->timing.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null timing in RemoteFrame.AddResourceTimingFromChild request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("AddResourceTimingFromChild");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameProxy::ScrollRectToVisible(
    const ::blink::WebRect& in_rect, ::blink::mojom::blink::ScrollIntoViewParamsPtr in_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrame::ScrollRectToVisible");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrame_ScrollRectToVisible_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrame_ScrollRectToVisible_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->rect)::BaseType::BufferWriter
      rect_writer;
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_rect, buffer, &rect_writer, &serialization_context);
  params->rect.Set(
      rect_writer.is_null() ? nullptr : rect_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->rect.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null rect in RemoteFrame.ScrollRectToVisible request");
  typename decltype(params->params)::BaseType::BufferWriter
      params_writer;
  mojo::internal::Serialize<::blink::mojom::ScrollIntoViewParamsDataView>(
      in_params, buffer, &params_writer, &serialization_context);
  params->params.Set(
      params_writer.is_null() ? nullptr : params_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in RemoteFrame.ScrollRectToVisible request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("ScrollRectToVisible");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameProxy::DidStartLoading(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrame::DidStartLoading");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrame_DidStartLoading_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrame_DidStartLoading_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("DidStartLoading");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameProxy::DidStopLoading(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrame::DidStopLoading");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrame_DidStopLoading_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrame_DidStopLoading_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("DidStopLoading");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void RemoteFrameProxy::IntrinsicSizingInfoOfChildChanged(
    ::blink::mojom::blink::IntrinsicSizingInfoPtr in_sizing_info) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "blink::mojom::RemoteFrame::IntrinsicSizingInfoOfChildChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kRemoteFrame_IntrinsicSizingInfoOfChildChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::blink::mojom::internal::RemoteFrame_IntrinsicSizingInfoOfChildChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->sizing_info)::BaseType::BufferWriter
      sizing_info_writer;
  mojo::internal::Serialize<::blink::mojom::IntrinsicSizingInfoDataView>(
      in_sizing_info, buffer, &sizing_info_writer, &serialization_context);
  params->sizing_info.Set(
      sizing_info_writer.is_null() ? nullptr : sizing_info_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->sizing_info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null sizing_info in RemoteFrame.IntrinsicSizingInfoOfChildChanged request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("IntrinsicSizingInfoOfChildChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool RemoteFrameStubDispatch::Accept(
    RemoteFrame* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kRemoteFrame_WillEnterFullscreen_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrame::WillEnterFullscreen",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrame::WillEnterFullscreen");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrame_WillEnterFullscreen_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_WillEnterFullscreen_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      RemoteFrame_WillEnterFullscreen_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->WillEnterFullscreen();
      return true;
    }
    case internal::kRemoteFrame_AddReplicatedContentSecurityPolicies_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrame::AddReplicatedContentSecurityPolicies",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrame::AddReplicatedContentSecurityPolicies");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrame_AddReplicatedContentSecurityPolicies_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_AddReplicatedContentSecurityPolicies_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      WTF::Vector<::network::mojom::blink::ContentSecurityPolicyHeaderPtr> p_headers{};
      RemoteFrame_AddReplicatedContentSecurityPolicies_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadHeaders(&p_headers))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddReplicatedContentSecurityPolicies(
std::move(p_headers));
      return true;
    }
    case internal::kRemoteFrame_ResetReplicatedContentSecurityPolicy_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrame::ResetReplicatedContentSecurityPolicy",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrame::ResetReplicatedContentSecurityPolicy");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrame_ResetReplicatedContentSecurityPolicy_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_ResetReplicatedContentSecurityPolicy_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      RemoteFrame_ResetReplicatedContentSecurityPolicy_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ResetReplicatedContentSecurityPolicy();
      return true;
    }
    case internal::kRemoteFrame_EnforceInsecureNavigationsSet_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrame::EnforceInsecureNavigationsSet",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrame::EnforceInsecureNavigationsSet");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrame_EnforceInsecureNavigationsSet_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_EnforceInsecureNavigationsSet_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      WTF::Vector<uint32_t> p_set{};
      RemoteFrame_EnforceInsecureNavigationsSet_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadSet(&p_set))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EnforceInsecureNavigationsSet(
std::move(p_set));
      return true;
    }
    case internal::kRemoteFrame_SetReplicatedOrigin_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrame::SetReplicatedOrigin",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrame::SetReplicatedOrigin");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrame_SetReplicatedOrigin_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_SetReplicatedOrigin_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::scoped_refptr<const ::blink::SecurityOrigin> p_origin{};
      bool p_is_potentially_trustworthy_unique_origin{};
      RemoteFrame_SetReplicatedOrigin_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadOrigin(&p_origin))
        success = false;
      if (success)
        p_is_potentially_trustworthy_unique_origin = input_data_view.is_potentially_trustworthy_unique_origin();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetReplicatedOrigin(
std::move(p_origin), 
std::move(p_is_potentially_trustworthy_unique_origin));
      return true;
    }
    case internal::kRemoteFrame_SetReplicatedAdFrameType_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrame::SetReplicatedAdFrameType",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrame::SetReplicatedAdFrameType");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrame_SetReplicatedAdFrameType_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_SetReplicatedAdFrameType_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::blink::mojom::blink::AdFrameType p_ad_frame_type{};
      RemoteFrame_SetReplicatedAdFrameType_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadAdFrameType(&p_ad_frame_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetReplicatedAdFrameType(
std::move(p_ad_frame_type));
      return true;
    }
    case internal::kRemoteFrame_DispatchLoadEventForFrameOwner_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrame::DispatchLoadEventForFrameOwner",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrame::DispatchLoadEventForFrameOwner");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrame_DispatchLoadEventForFrameOwner_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_DispatchLoadEventForFrameOwner_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      RemoteFrame_DispatchLoadEventForFrameOwner_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DispatchLoadEventForFrameOwner();
      return true;
    }
    case internal::kRemoteFrame_SetNeedsOcclusionTracking_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrame::SetNeedsOcclusionTracking",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrame::SetNeedsOcclusionTracking");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrame_SetNeedsOcclusionTracking_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_SetNeedsOcclusionTracking_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_needs_tracking{};
      RemoteFrame_SetNeedsOcclusionTracking_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_needs_tracking = input_data_view.needs_tracking();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetNeedsOcclusionTracking(
std::move(p_needs_tracking));
      return true;
    }
    case internal::kRemoteFrame_Collapse_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrame::Collapse",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrame::Collapse");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrame_Collapse_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_Collapse_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_collapsed{};
      RemoteFrame_Collapse_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_collapsed = input_data_view.collapsed();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Collapse(
std::move(p_collapsed));
      return true;
    }
    case internal::kRemoteFrame_Focus_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrame::Focus",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrame::Focus");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrame_Focus_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_Focus_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      RemoteFrame_Focus_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Focus();
      return true;
    }
    case internal::kRemoteFrame_SetHadStickyUserActivationBeforeNavigation_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrame::SetHadStickyUserActivationBeforeNavigation",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrame::SetHadStickyUserActivationBeforeNavigation");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrame_SetHadStickyUserActivationBeforeNavigation_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_SetHadStickyUserActivationBeforeNavigation_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_has_gesture{};
      RemoteFrame_SetHadStickyUserActivationBeforeNavigation_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_has_gesture = input_data_view.has_gesture();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetHadStickyUserActivationBeforeNavigation(
std::move(p_has_gesture));
      return true;
    }
    case internal::kRemoteFrame_BubbleLogicalScroll_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrame::BubbleLogicalScroll",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrame::BubbleLogicalScroll");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrame_BubbleLogicalScroll_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_BubbleLogicalScroll_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::blink::mojom::blink::ScrollDirection p_direction{};
      ::ui::input_types::ScrollGranularity p_granularity{};
      RemoteFrame_BubbleLogicalScroll_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadDirection(&p_direction))
        success = false;
      if (success && !input_data_view.ReadGranularity(&p_granularity))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BubbleLogicalScroll(
std::move(p_direction), 
std::move(p_granularity));
      return true;
    }
    case internal::kRemoteFrame_UpdateUserActivationState_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrame::UpdateUserActivationState",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrame::UpdateUserActivationState");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrame_UpdateUserActivationState_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_UpdateUserActivationState_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::blink::mojom::blink::UserActivationUpdateType p_state_update_type{};
      RemoteFrame_UpdateUserActivationState_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadStateUpdateType(&p_state_update_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateUserActivationState(
std::move(p_state_update_type));
      return true;
    }
    case internal::kRemoteFrame_SetEmbeddingToken_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrame::SetEmbeddingToken",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrame::SetEmbeddingToken");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrame_SetEmbeddingToken_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_SetEmbeddingToken_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::base::UnguessableToken p_embedding_token{};
      RemoteFrame_SetEmbeddingToken_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadEmbeddingToken(&p_embedding_token))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetEmbeddingToken(
std::move(p_embedding_token));
      return true;
    }
    case internal::kRemoteFrame_SetPageFocus_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrame::SetPageFocus",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrame::SetPageFocus");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrame_SetPageFocus_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_SetPageFocus_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_is_focused{};
      RemoteFrame_SetPageFocus_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_is_focused = input_data_view.is_focused();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 14, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetPageFocus(
std::move(p_is_focused));
      return true;
    }
    case internal::kRemoteFrame_RenderFallbackContent_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrame::RenderFallbackContent",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrame::RenderFallbackContent");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrame_RenderFallbackContent_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_RenderFallbackContent_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      RemoteFrame_RenderFallbackContent_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 15, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RenderFallbackContent();
      return true;
    }
    case internal::kRemoteFrame_AddResourceTimingFromChild_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrame::AddResourceTimingFromChild",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrame::AddResourceTimingFromChild");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrame_AddResourceTimingFromChild_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_AddResourceTimingFromChild_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::blink::mojom::blink::ResourceTimingInfoPtr p_timing{};
      RemoteFrame_AddResourceTimingFromChild_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadTiming(&p_timing))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 16, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddResourceTimingFromChild(
std::move(p_timing));
      return true;
    }
    case internal::kRemoteFrame_ScrollRectToVisible_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrame::ScrollRectToVisible",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrame::ScrollRectToVisible");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrame_ScrollRectToVisible_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_ScrollRectToVisible_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::blink::WebRect p_rect{};
      ::blink::mojom::blink::ScrollIntoViewParamsPtr p_params{};
      RemoteFrame_ScrollRectToVisible_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadRect(&p_rect))
        success = false;
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 17, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ScrollRectToVisible(
std::move(p_rect), 
std::move(p_params));
      return true;
    }
    case internal::kRemoteFrame_DidStartLoading_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrame::DidStartLoading",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrame::DidStartLoading");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrame_DidStartLoading_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_DidStartLoading_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      RemoteFrame_DidStartLoading_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 18, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidStartLoading();
      return true;
    }
    case internal::kRemoteFrame_DidStopLoading_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrame::DidStopLoading",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrame::DidStopLoading");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrame_DidStopLoading_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_DidStopLoading_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      RemoteFrame_DidStopLoading_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 19, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidStopLoading();
      return true;
    }
    case internal::kRemoteFrame_IntrinsicSizingInfoOfChildChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)blink::mojom::RemoteFrame::IntrinsicSizingInfoOfChildChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)blink::mojom::RemoteFrame::IntrinsicSizingInfoOfChildChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::RemoteFrame_IntrinsicSizingInfoOfChildChanged_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_IntrinsicSizingInfoOfChildChanged_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::blink::mojom::blink::IntrinsicSizingInfoPtr p_sizing_info{};
      RemoteFrame_IntrinsicSizingInfoOfChildChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadSizingInfo(&p_sizing_info))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 20, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->IntrinsicSizingInfoOfChildChanged(
std::move(p_sizing_info));
      return true;
    }
  }
  return false;
}

// static
bool RemoteFrameStubDispatch::AcceptWithResponder(
    RemoteFrame* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kRemoteFrame_WillEnterFullscreen_Name: {
      break;
    }
    case internal::kRemoteFrame_AddReplicatedContentSecurityPolicies_Name: {
      break;
    }
    case internal::kRemoteFrame_ResetReplicatedContentSecurityPolicy_Name: {
      break;
    }
    case internal::kRemoteFrame_EnforceInsecureNavigationsSet_Name: {
      break;
    }
    case internal::kRemoteFrame_SetReplicatedOrigin_Name: {
      break;
    }
    case internal::kRemoteFrame_SetReplicatedAdFrameType_Name: {
      break;
    }
    case internal::kRemoteFrame_DispatchLoadEventForFrameOwner_Name: {
      break;
    }
    case internal::kRemoteFrame_SetNeedsOcclusionTracking_Name: {
      break;
    }
    case internal::kRemoteFrame_Collapse_Name: {
      break;
    }
    case internal::kRemoteFrame_Focus_Name: {
      break;
    }
    case internal::kRemoteFrame_SetHadStickyUserActivationBeforeNavigation_Name: {
      break;
    }
    case internal::kRemoteFrame_BubbleLogicalScroll_Name: {
      break;
    }
    case internal::kRemoteFrame_UpdateUserActivationState_Name: {
      break;
    }
    case internal::kRemoteFrame_SetEmbeddingToken_Name: {
      break;
    }
    case internal::kRemoteFrame_SetPageFocus_Name: {
      break;
    }
    case internal::kRemoteFrame_RenderFallbackContent_Name: {
      break;
    }
    case internal::kRemoteFrame_AddResourceTimingFromChild_Name: {
      break;
    }
    case internal::kRemoteFrame_ScrollRectToVisible_Name: {
      break;
    }
    case internal::kRemoteFrame_DidStartLoading_Name: {
      break;
    }
    case internal::kRemoteFrame_DidStopLoading_Name: {
      break;
    }
    case internal::kRemoteFrame_IntrinsicSizingInfoOfChildChanged_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kRemoteFrameValidationInfo[] = {
    {&internal::RemoteFrame_WillEnterFullscreen_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_AddReplicatedContentSecurityPolicies_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_ResetReplicatedContentSecurityPolicy_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_EnforceInsecureNavigationsSet_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_SetReplicatedOrigin_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_SetReplicatedAdFrameType_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_DispatchLoadEventForFrameOwner_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_SetNeedsOcclusionTracking_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_Collapse_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_Focus_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_SetHadStickyUserActivationBeforeNavigation_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_BubbleLogicalScroll_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_UpdateUserActivationState_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_SetEmbeddingToken_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_SetPageFocus_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_RenderFallbackContent_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_AddResourceTimingFromChild_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_ScrollRectToVisible_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_DidStartLoading_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_DidStopLoading_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_IntrinsicSizingInfoOfChildChanged_Params_Data::Validate,
     nullptr /* no response */},
};

bool RemoteFrameRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::RemoteFrame::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kRemoteFrameValidationInfo);
}

}  // namespace blink
}  // namespace mojom
}  // namespace blink

namespace mojo {


// static
bool StructTraits<::blink::mojom::blink::FindInPageResultAXParams::DataView, ::blink::mojom::blink::FindInPageResultAXParamsPtr>::Read(
    ::blink::mojom::blink::FindInPageResultAXParams::DataView input,
    ::blink::mojom::blink::FindInPageResultAXParamsPtr* output) {
  bool success = true;
  ::blink::mojom::blink::FindInPageResultAXParamsPtr result(::blink::mojom::blink::FindInPageResultAXParams::New());
  
      if (success)
        result->request_id = input.request_id();
      if (success)
        result->match_index = input.match_index();
      if (success)
        result->start_id = input.start_id();
      if (success)
        result->start_offset = input.start_offset();
      if (success)
        result->end_id = input.end_id();
      if (success)
        result->end_offset = input.end_offset();
  *output = std::move(result);
  return success;
}

}  // namespace mojo

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif