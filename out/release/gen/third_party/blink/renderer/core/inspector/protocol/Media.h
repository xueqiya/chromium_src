// This file is generated by TypeBuilder_h.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef blink_protocol_Media_h
#define blink_protocol_Media_h

#include "third_party/blink/renderer/core/core_export.h"
#include "third_party/blink/renderer/core/inspector/protocol/Protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.

namespace blink {
namespace protocol {
namespace Media {

// ------------- Forward and enum declarations.
using PlayerId = String;
using Timestamp = double;
class PlayerProperty;
using PlayerEventType = String;
class PlayerEvent;
class PlayerPropertiesChangedNotification;
class PlayerEventsAddedNotification;
class PlayersCreatedNotification;

namespace PlayerEventTypeEnum {
CORE_EXPORT extern const char ErrorEvent[];
CORE_EXPORT extern const char TriggeredEvent[];
CORE_EXPORT extern const char MessageEvent[];
} // namespace PlayerEventTypeEnum

// ------------- Type and builder declarations.

class CORE_EXPORT PlayerProperty : public Serializable{
    PROTOCOL_DISALLOW_COPY(PlayerProperty);
public:
    static std::unique_ptr<PlayerProperty> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~PlayerProperty() override { }

    String getName() { return m_name; }
    void setName(const String& value) { m_name = value; }

    bool hasValue() { return m_value.isJust(); }
    String getValue(const String& defaultValue) { return m_value.isJust() ? m_value.fromJust() : defaultValue; }
    void setValue(const String& value) { m_value = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<PlayerProperty> clone() const;

    template<int STATE>
    class PlayerPropertyBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            NameSet = 1 << 1,
            AllFieldsSet = (NameSet | 0)};


        PlayerPropertyBuilder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setName(value);
            return castState<NameSet>();
        }

        PlayerPropertyBuilder<STATE>& setValue(const String& value)
        {
            m_result->setValue(value);
            return *this;
        }

        std::unique_ptr<PlayerProperty> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PlayerProperty;
        PlayerPropertyBuilder() : m_result(new PlayerProperty()) { }

        template<int STEP> PlayerPropertyBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PlayerPropertyBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Media::PlayerProperty> m_result;
    };

    static PlayerPropertyBuilder<0> create()
    {
        return PlayerPropertyBuilder<0>();
    }

private:
    PlayerProperty()
    {
    }

    String m_name;
    Maybe<String> m_value;
};


class CORE_EXPORT PlayerEvent : public Serializable{
    PROTOCOL_DISALLOW_COPY(PlayerEvent);
public:
    static std::unique_ptr<PlayerEvent> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~PlayerEvent() override { }

    String getType() { return m_type; }
    void setType(const String& value) { m_type = value; }

    double getTimestamp() { return m_timestamp; }
    void setTimestamp(double value) { m_timestamp = value; }

    String getName() { return m_name; }
    void setName(const String& value) { m_name = value; }

    String getValue() { return m_value; }
    void setValue(const String& value) { m_value = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<PlayerEvent> clone() const;

    template<int STATE>
    class PlayerEventBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            TypeSet = 1 << 1,
            TimestampSet = 1 << 2,
            NameSet = 1 << 3,
            ValueSet = 1 << 4,
            AllFieldsSet = (TypeSet | TimestampSet | NameSet | ValueSet | 0)};


        PlayerEventBuilder<STATE | TypeSet>& setType(const String& value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setType(value);
            return castState<TypeSet>();
        }

        PlayerEventBuilder<STATE | TimestampSet>& setTimestamp(double value)
        {
            static_assert(!(STATE & TimestampSet), "property timestamp should not be set yet");
            m_result->setTimestamp(value);
            return castState<TimestampSet>();
        }

        PlayerEventBuilder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setName(value);
            return castState<NameSet>();
        }

        PlayerEventBuilder<STATE | ValueSet>& setValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue(value);
            return castState<ValueSet>();
        }

        std::unique_ptr<PlayerEvent> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PlayerEvent;
        PlayerEventBuilder() : m_result(new PlayerEvent()) { }

        template<int STEP> PlayerEventBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PlayerEventBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Media::PlayerEvent> m_result;
    };

    static PlayerEventBuilder<0> create()
    {
        return PlayerEventBuilder<0>();
    }

private:
    PlayerEvent()
    {
          m_timestamp = 0;
    }

    String m_type;
    double m_timestamp;
    String m_name;
    String m_value;
};


class CORE_EXPORT PlayerPropertiesChangedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(PlayerPropertiesChangedNotification);
public:
    static std::unique_ptr<PlayerPropertiesChangedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~PlayerPropertiesChangedNotification() override { }

    String getPlayerId() { return m_playerId; }
    void setPlayerId(const String& value) { m_playerId = value; }

    protocol::Array<protocol::Media::PlayerProperty>* getProperties() { return m_properties.get(); }
    void setProperties(std::unique_ptr<protocol::Array<protocol::Media::PlayerProperty>> value) { m_properties = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<PlayerPropertiesChangedNotification> clone() const;

    template<int STATE>
    class PlayerPropertiesChangedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            PlayerIdSet = 1 << 1,
            PropertiesSet = 1 << 2,
            AllFieldsSet = (PlayerIdSet | PropertiesSet | 0)};


        PlayerPropertiesChangedNotificationBuilder<STATE | PlayerIdSet>& setPlayerId(const String& value)
        {
            static_assert(!(STATE & PlayerIdSet), "property playerId should not be set yet");
            m_result->setPlayerId(value);
            return castState<PlayerIdSet>();
        }

        PlayerPropertiesChangedNotificationBuilder<STATE | PropertiesSet>& setProperties(std::unique_ptr<protocol::Array<protocol::Media::PlayerProperty>> value)
        {
            static_assert(!(STATE & PropertiesSet), "property properties should not be set yet");
            m_result->setProperties(std::move(value));
            return castState<PropertiesSet>();
        }

        std::unique_ptr<PlayerPropertiesChangedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PlayerPropertiesChangedNotification;
        PlayerPropertiesChangedNotificationBuilder() : m_result(new PlayerPropertiesChangedNotification()) { }

        template<int STEP> PlayerPropertiesChangedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PlayerPropertiesChangedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Media::PlayerPropertiesChangedNotification> m_result;
    };

    static PlayerPropertiesChangedNotificationBuilder<0> create()
    {
        return PlayerPropertiesChangedNotificationBuilder<0>();
    }

private:
    PlayerPropertiesChangedNotification()
    {
    }

    String m_playerId;
    std::unique_ptr<protocol::Array<protocol::Media::PlayerProperty>> m_properties;
};


class CORE_EXPORT PlayerEventsAddedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(PlayerEventsAddedNotification);
public:
    static std::unique_ptr<PlayerEventsAddedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~PlayerEventsAddedNotification() override { }

    String getPlayerId() { return m_playerId; }
    void setPlayerId(const String& value) { m_playerId = value; }

    protocol::Array<protocol::Media::PlayerEvent>* getEvents() { return m_events.get(); }
    void setEvents(std::unique_ptr<protocol::Array<protocol::Media::PlayerEvent>> value) { m_events = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<PlayerEventsAddedNotification> clone() const;

    template<int STATE>
    class PlayerEventsAddedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            PlayerIdSet = 1 << 1,
            EventsSet = 1 << 2,
            AllFieldsSet = (PlayerIdSet | EventsSet | 0)};


        PlayerEventsAddedNotificationBuilder<STATE | PlayerIdSet>& setPlayerId(const String& value)
        {
            static_assert(!(STATE & PlayerIdSet), "property playerId should not be set yet");
            m_result->setPlayerId(value);
            return castState<PlayerIdSet>();
        }

        PlayerEventsAddedNotificationBuilder<STATE | EventsSet>& setEvents(std::unique_ptr<protocol::Array<protocol::Media::PlayerEvent>> value)
        {
            static_assert(!(STATE & EventsSet), "property events should not be set yet");
            m_result->setEvents(std::move(value));
            return castState<EventsSet>();
        }

        std::unique_ptr<PlayerEventsAddedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PlayerEventsAddedNotification;
        PlayerEventsAddedNotificationBuilder() : m_result(new PlayerEventsAddedNotification()) { }

        template<int STEP> PlayerEventsAddedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PlayerEventsAddedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Media::PlayerEventsAddedNotification> m_result;
    };

    static PlayerEventsAddedNotificationBuilder<0> create()
    {
        return PlayerEventsAddedNotificationBuilder<0>();
    }

private:
    PlayerEventsAddedNotification()
    {
    }

    String m_playerId;
    std::unique_ptr<protocol::Array<protocol::Media::PlayerEvent>> m_events;
};


class CORE_EXPORT PlayersCreatedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(PlayersCreatedNotification);
public:
    static std::unique_ptr<PlayersCreatedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~PlayersCreatedNotification() override { }

    protocol::Array<String>* getPlayers() { return m_players.get(); }
    void setPlayers(std::unique_ptr<protocol::Array<String>> value) { m_players = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<PlayersCreatedNotification> clone() const;

    template<int STATE>
    class PlayersCreatedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            PlayersSet = 1 << 1,
            AllFieldsSet = (PlayersSet | 0)};


        PlayersCreatedNotificationBuilder<STATE | PlayersSet>& setPlayers(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & PlayersSet), "property players should not be set yet");
            m_result->setPlayers(std::move(value));
            return castState<PlayersSet>();
        }

        std::unique_ptr<PlayersCreatedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PlayersCreatedNotification;
        PlayersCreatedNotificationBuilder() : m_result(new PlayersCreatedNotification()) { }

        template<int STEP> PlayersCreatedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PlayersCreatedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Media::PlayersCreatedNotification> m_result;
    };

    static PlayersCreatedNotificationBuilder<0> create()
    {
        return PlayersCreatedNotificationBuilder<0>();
    }

private:
    PlayersCreatedNotification()
    {
    }

    std::unique_ptr<protocol::Array<String>> m_players;
};


// ------------- Backend interface.

class CORE_EXPORT Backend {
public:
    virtual ~Backend() { }

    virtual DispatchResponse enable() = 0;
    virtual DispatchResponse disable() = 0;

};

// ------------- Frontend interface.

class CORE_EXPORT Frontend {
public:
    explicit Frontend(FrontendChannel* frontendChannel) : m_frontendChannel(frontendChannel) { }
    void playerPropertiesChanged(const String& playerId, std::unique_ptr<protocol::Array<protocol::Media::PlayerProperty>> properties);
    void playerEventsAdded(const String& playerId, std::unique_ptr<protocol::Array<protocol::Media::PlayerEvent>> events);
    void playersCreated(std::unique_ptr<protocol::Array<String>> players);

    void flush();
    void sendRawCBORNotification(std::vector<uint8_t>);
private:
    FrontendChannel* m_frontendChannel;
};

// ------------- Dispatcher.

class CORE_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher() { }
};

// ------------- Metainfo.

class CORE_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace Media
} // namespace blink
} // namespace protocol

#endif // !defined(blink_protocol_Media_h)
