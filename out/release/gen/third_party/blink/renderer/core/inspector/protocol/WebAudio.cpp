// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "third_party/blink/renderer/core/inspector/protocol/WebAudio.h"

#include "third_party/blink/renderer/core/inspector/protocol/Protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/serializer_traits.h"

namespace blink {
namespace protocol {
namespace WebAudio {

// ------------- Enum values from types.

const char Metainfo::domainName[] = "WebAudio";
const char Metainfo::commandPrefix[] = "WebAudio.";
const char Metainfo::version[] = "1.3";

namespace ContextTypeEnum {
const char Realtime[] = "realtime";
const char Offline[] = "offline";
} // namespace ContextTypeEnum

namespace ContextStateEnum {
const char Suspended[] = "suspended";
const char Running[] = "running";
const char Closed[] = "closed";
} // namespace ContextStateEnum

namespace ChannelCountModeEnum {
const char ClampedMax[] = "clamped-max";
const char Explicit[] = "explicit";
const char Max[] = "max";
} // namespace ChannelCountModeEnum

namespace ChannelInterpretationEnum {
const char Discrete[] = "discrete";
const char Speakers[] = "speakers";
} // namespace ChannelInterpretationEnum

namespace AutomationRateEnum {
const char ARate[] = "a-rate";
const char KRate[] = "k-rate";
} // namespace AutomationRateEnum

std::unique_ptr<ContextRealtimeData> ContextRealtimeData::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->addError("object expected");
        return nullptr;
    }

    std::unique_ptr<ContextRealtimeData> result(new ContextRealtimeData());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->push();
    protocol::Value* currentTimeValue = object->get("currentTime");
    errors->setName("currentTime");
    result->m_currentTime = ValueConversions<double>::fromValue(currentTimeValue, errors);
    protocol::Value* renderCapacityValue = object->get("renderCapacity");
    errors->setName("renderCapacity");
    result->m_renderCapacity = ValueConversions<double>::fromValue(renderCapacityValue, errors);
    protocol::Value* callbackIntervalMeanValue = object->get("callbackIntervalMean");
    errors->setName("callbackIntervalMean");
    result->m_callbackIntervalMean = ValueConversions<double>::fromValue(callbackIntervalMeanValue, errors);
    protocol::Value* callbackIntervalVarianceValue = object->get("callbackIntervalVariance");
    errors->setName("callbackIntervalVariance");
    result->m_callbackIntervalVariance = ValueConversions<double>::fromValue(callbackIntervalVarianceValue, errors);
    errors->pop();
    if (errors->hasErrors())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ContextRealtimeData::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("currentTime", ValueConversions<double>::toValue(m_currentTime));
    result->setValue("renderCapacity", ValueConversions<double>::toValue(m_renderCapacity));
    result->setValue("callbackIntervalMean", ValueConversions<double>::toValue(m_callbackIntervalMean));
    result->setValue("callbackIntervalVariance", ValueConversions<double>::toValue(m_callbackIntervalVariance));
    return result;
}

void ContextRealtimeData::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("currentTime"), m_currentTime, out);
      crdtp::SerializeField(crdtp::SpanFrom("renderCapacity"), m_renderCapacity, out);
      crdtp::SerializeField(crdtp::SpanFrom("callbackIntervalMean"), m_callbackIntervalMean, out);
      crdtp::SerializeField(crdtp::SpanFrom("callbackIntervalVariance"), m_callbackIntervalVariance, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ContextRealtimeData> ContextRealtimeData::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<BaseAudioContext> BaseAudioContext::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->addError("object expected");
        return nullptr;
    }

    std::unique_ptr<BaseAudioContext> result(new BaseAudioContext());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->push();
    protocol::Value* contextIdValue = object->get("contextId");
    errors->setName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    protocol::Value* contextTypeValue = object->get("contextType");
    errors->setName("contextType");
    result->m_contextType = ValueConversions<String>::fromValue(contextTypeValue, errors);
    protocol::Value* contextStateValue = object->get("contextState");
    errors->setName("contextState");
    result->m_contextState = ValueConversions<String>::fromValue(contextStateValue, errors);
    protocol::Value* realtimeDataValue = object->get("realtimeData");
    if (realtimeDataValue) {
        errors->setName("realtimeData");
        result->m_realtimeData = ValueConversions<protocol::WebAudio::ContextRealtimeData>::fromValue(realtimeDataValue, errors);
    }
    protocol::Value* callbackBufferSizeValue = object->get("callbackBufferSize");
    errors->setName("callbackBufferSize");
    result->m_callbackBufferSize = ValueConversions<double>::fromValue(callbackBufferSizeValue, errors);
    protocol::Value* maxOutputChannelCountValue = object->get("maxOutputChannelCount");
    errors->setName("maxOutputChannelCount");
    result->m_maxOutputChannelCount = ValueConversions<double>::fromValue(maxOutputChannelCountValue, errors);
    protocol::Value* sampleRateValue = object->get("sampleRate");
    errors->setName("sampleRate");
    result->m_sampleRate = ValueConversions<double>::fromValue(sampleRateValue, errors);
    errors->pop();
    if (errors->hasErrors())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> BaseAudioContext::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    result->setValue("contextType", ValueConversions<String>::toValue(m_contextType));
    result->setValue("contextState", ValueConversions<String>::toValue(m_contextState));
    if (m_realtimeData.isJust())
        result->setValue("realtimeData", ValueConversions<protocol::WebAudio::ContextRealtimeData>::toValue(m_realtimeData.fromJust()));
    result->setValue("callbackBufferSize", ValueConversions<double>::toValue(m_callbackBufferSize));
    result->setValue("maxOutputChannelCount", ValueConversions<double>::toValue(m_maxOutputChannelCount));
    result->setValue("sampleRate", ValueConversions<double>::toValue(m_sampleRate));
    return result;
}

void BaseAudioContext::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
      crdtp::SerializeField(crdtp::SpanFrom("contextType"), m_contextType, out);
      crdtp::SerializeField(crdtp::SpanFrom("contextState"), m_contextState, out);
      crdtp::SerializeField(crdtp::SpanFrom("realtimeData"), m_realtimeData, out);
      crdtp::SerializeField(crdtp::SpanFrom("callbackBufferSize"), m_callbackBufferSize, out);
      crdtp::SerializeField(crdtp::SpanFrom("maxOutputChannelCount"), m_maxOutputChannelCount, out);
      crdtp::SerializeField(crdtp::SpanFrom("sampleRate"), m_sampleRate, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<BaseAudioContext> BaseAudioContext::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AudioListener> AudioListener::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->addError("object expected");
        return nullptr;
    }

    std::unique_ptr<AudioListener> result(new AudioListener());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->push();
    protocol::Value* listenerIdValue = object->get("listenerId");
    errors->setName("listenerId");
    result->m_listenerId = ValueConversions<String>::fromValue(listenerIdValue, errors);
    protocol::Value* contextIdValue = object->get("contextId");
    errors->setName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    errors->pop();
    if (errors->hasErrors())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AudioListener::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("listenerId", ValueConversions<String>::toValue(m_listenerId));
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    return result;
}

void AudioListener::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("listenerId"), m_listenerId, out);
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AudioListener> AudioListener::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AudioNode> AudioNode::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->addError("object expected");
        return nullptr;
    }

    std::unique_ptr<AudioNode> result(new AudioNode());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->push();
    protocol::Value* nodeIdValue = object->get("nodeId");
    errors->setName("nodeId");
    result->m_nodeId = ValueConversions<String>::fromValue(nodeIdValue, errors);
    protocol::Value* contextIdValue = object->get("contextId");
    errors->setName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    protocol::Value* nodeTypeValue = object->get("nodeType");
    errors->setName("nodeType");
    result->m_nodeType = ValueConversions<String>::fromValue(nodeTypeValue, errors);
    protocol::Value* numberOfInputsValue = object->get("numberOfInputs");
    errors->setName("numberOfInputs");
    result->m_numberOfInputs = ValueConversions<double>::fromValue(numberOfInputsValue, errors);
    protocol::Value* numberOfOutputsValue = object->get("numberOfOutputs");
    errors->setName("numberOfOutputs");
    result->m_numberOfOutputs = ValueConversions<double>::fromValue(numberOfOutputsValue, errors);
    protocol::Value* channelCountValue = object->get("channelCount");
    errors->setName("channelCount");
    result->m_channelCount = ValueConversions<double>::fromValue(channelCountValue, errors);
    protocol::Value* channelCountModeValue = object->get("channelCountMode");
    errors->setName("channelCountMode");
    result->m_channelCountMode = ValueConversions<String>::fromValue(channelCountModeValue, errors);
    protocol::Value* channelInterpretationValue = object->get("channelInterpretation");
    errors->setName("channelInterpretation");
    result->m_channelInterpretation = ValueConversions<String>::fromValue(channelInterpretationValue, errors);
    errors->pop();
    if (errors->hasErrors())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AudioNode::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("nodeId", ValueConversions<String>::toValue(m_nodeId));
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    result->setValue("nodeType", ValueConversions<String>::toValue(m_nodeType));
    result->setValue("numberOfInputs", ValueConversions<double>::toValue(m_numberOfInputs));
    result->setValue("numberOfOutputs", ValueConversions<double>::toValue(m_numberOfOutputs));
    result->setValue("channelCount", ValueConversions<double>::toValue(m_channelCount));
    result->setValue("channelCountMode", ValueConversions<String>::toValue(m_channelCountMode));
    result->setValue("channelInterpretation", ValueConversions<String>::toValue(m_channelInterpretation));
    return result;
}

void AudioNode::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("nodeId"), m_nodeId, out);
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
      crdtp::SerializeField(crdtp::SpanFrom("nodeType"), m_nodeType, out);
      crdtp::SerializeField(crdtp::SpanFrom("numberOfInputs"), m_numberOfInputs, out);
      crdtp::SerializeField(crdtp::SpanFrom("numberOfOutputs"), m_numberOfOutputs, out);
      crdtp::SerializeField(crdtp::SpanFrom("channelCount"), m_channelCount, out);
      crdtp::SerializeField(crdtp::SpanFrom("channelCountMode"), m_channelCountMode, out);
      crdtp::SerializeField(crdtp::SpanFrom("channelInterpretation"), m_channelInterpretation, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AudioNode> AudioNode::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AudioParam> AudioParam::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->addError("object expected");
        return nullptr;
    }

    std::unique_ptr<AudioParam> result(new AudioParam());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->push();
    protocol::Value* paramIdValue = object->get("paramId");
    errors->setName("paramId");
    result->m_paramId = ValueConversions<String>::fromValue(paramIdValue, errors);
    protocol::Value* nodeIdValue = object->get("nodeId");
    errors->setName("nodeId");
    result->m_nodeId = ValueConversions<String>::fromValue(nodeIdValue, errors);
    protocol::Value* contextIdValue = object->get("contextId");
    errors->setName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    protocol::Value* paramTypeValue = object->get("paramType");
    errors->setName("paramType");
    result->m_paramType = ValueConversions<String>::fromValue(paramTypeValue, errors);
    protocol::Value* rateValue = object->get("rate");
    errors->setName("rate");
    result->m_rate = ValueConversions<String>::fromValue(rateValue, errors);
    protocol::Value* defaultValueValue = object->get("defaultValue");
    errors->setName("defaultValue");
    result->m_defaultValue = ValueConversions<double>::fromValue(defaultValueValue, errors);
    protocol::Value* minValueValue = object->get("minValue");
    errors->setName("minValue");
    result->m_minValue = ValueConversions<double>::fromValue(minValueValue, errors);
    protocol::Value* maxValueValue = object->get("maxValue");
    errors->setName("maxValue");
    result->m_maxValue = ValueConversions<double>::fromValue(maxValueValue, errors);
    errors->pop();
    if (errors->hasErrors())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AudioParam::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("paramId", ValueConversions<String>::toValue(m_paramId));
    result->setValue("nodeId", ValueConversions<String>::toValue(m_nodeId));
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    result->setValue("paramType", ValueConversions<String>::toValue(m_paramType));
    result->setValue("rate", ValueConversions<String>::toValue(m_rate));
    result->setValue("defaultValue", ValueConversions<double>::toValue(m_defaultValue));
    result->setValue("minValue", ValueConversions<double>::toValue(m_minValue));
    result->setValue("maxValue", ValueConversions<double>::toValue(m_maxValue));
    return result;
}

void AudioParam::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("paramId"), m_paramId, out);
      crdtp::SerializeField(crdtp::SpanFrom("nodeId"), m_nodeId, out);
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
      crdtp::SerializeField(crdtp::SpanFrom("paramType"), m_paramType, out);
      crdtp::SerializeField(crdtp::SpanFrom("rate"), m_rate, out);
      crdtp::SerializeField(crdtp::SpanFrom("defaultValue"), m_defaultValue, out);
      crdtp::SerializeField(crdtp::SpanFrom("minValue"), m_minValue, out);
      crdtp::SerializeField(crdtp::SpanFrom("maxValue"), m_maxValue, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AudioParam> AudioParam::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ContextCreatedNotification> ContextCreatedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->addError("object expected");
        return nullptr;
    }

    std::unique_ptr<ContextCreatedNotification> result(new ContextCreatedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->push();
    protocol::Value* contextValue = object->get("context");
    errors->setName("context");
    result->m_context = ValueConversions<protocol::WebAudio::BaseAudioContext>::fromValue(contextValue, errors);
    errors->pop();
    if (errors->hasErrors())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ContextCreatedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("context", ValueConversions<protocol::WebAudio::BaseAudioContext>::toValue(m_context.get()));
    return result;
}

void ContextCreatedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("context"), m_context, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ContextCreatedNotification> ContextCreatedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ContextWillBeDestroyedNotification> ContextWillBeDestroyedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->addError("object expected");
        return nullptr;
    }

    std::unique_ptr<ContextWillBeDestroyedNotification> result(new ContextWillBeDestroyedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->push();
    protocol::Value* contextIdValue = object->get("contextId");
    errors->setName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    errors->pop();
    if (errors->hasErrors())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ContextWillBeDestroyedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    return result;
}

void ContextWillBeDestroyedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ContextWillBeDestroyedNotification> ContextWillBeDestroyedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ContextChangedNotification> ContextChangedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->addError("object expected");
        return nullptr;
    }

    std::unique_ptr<ContextChangedNotification> result(new ContextChangedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->push();
    protocol::Value* contextValue = object->get("context");
    errors->setName("context");
    result->m_context = ValueConversions<protocol::WebAudio::BaseAudioContext>::fromValue(contextValue, errors);
    errors->pop();
    if (errors->hasErrors())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ContextChangedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("context", ValueConversions<protocol::WebAudio::BaseAudioContext>::toValue(m_context.get()));
    return result;
}

void ContextChangedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("context"), m_context, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ContextChangedNotification> ContextChangedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AudioListenerCreatedNotification> AudioListenerCreatedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->addError("object expected");
        return nullptr;
    }

    std::unique_ptr<AudioListenerCreatedNotification> result(new AudioListenerCreatedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->push();
    protocol::Value* listenerValue = object->get("listener");
    errors->setName("listener");
    result->m_listener = ValueConversions<protocol::WebAudio::AudioListener>::fromValue(listenerValue, errors);
    errors->pop();
    if (errors->hasErrors())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AudioListenerCreatedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("listener", ValueConversions<protocol::WebAudio::AudioListener>::toValue(m_listener.get()));
    return result;
}

void AudioListenerCreatedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("listener"), m_listener, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AudioListenerCreatedNotification> AudioListenerCreatedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AudioListenerWillBeDestroyedNotification> AudioListenerWillBeDestroyedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->addError("object expected");
        return nullptr;
    }

    std::unique_ptr<AudioListenerWillBeDestroyedNotification> result(new AudioListenerWillBeDestroyedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->push();
    protocol::Value* contextIdValue = object->get("contextId");
    errors->setName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    protocol::Value* listenerIdValue = object->get("listenerId");
    errors->setName("listenerId");
    result->m_listenerId = ValueConversions<String>::fromValue(listenerIdValue, errors);
    errors->pop();
    if (errors->hasErrors())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AudioListenerWillBeDestroyedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    result->setValue("listenerId", ValueConversions<String>::toValue(m_listenerId));
    return result;
}

void AudioListenerWillBeDestroyedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
      crdtp::SerializeField(crdtp::SpanFrom("listenerId"), m_listenerId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AudioListenerWillBeDestroyedNotification> AudioListenerWillBeDestroyedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AudioNodeCreatedNotification> AudioNodeCreatedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->addError("object expected");
        return nullptr;
    }

    std::unique_ptr<AudioNodeCreatedNotification> result(new AudioNodeCreatedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->push();
    protocol::Value* nodeValue = object->get("node");
    errors->setName("node");
    result->m_node = ValueConversions<protocol::WebAudio::AudioNode>::fromValue(nodeValue, errors);
    errors->pop();
    if (errors->hasErrors())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AudioNodeCreatedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("node", ValueConversions<protocol::WebAudio::AudioNode>::toValue(m_node.get()));
    return result;
}

void AudioNodeCreatedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("node"), m_node, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AudioNodeCreatedNotification> AudioNodeCreatedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AudioNodeWillBeDestroyedNotification> AudioNodeWillBeDestroyedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->addError("object expected");
        return nullptr;
    }

    std::unique_ptr<AudioNodeWillBeDestroyedNotification> result(new AudioNodeWillBeDestroyedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->push();
    protocol::Value* contextIdValue = object->get("contextId");
    errors->setName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    protocol::Value* nodeIdValue = object->get("nodeId");
    errors->setName("nodeId");
    result->m_nodeId = ValueConversions<String>::fromValue(nodeIdValue, errors);
    errors->pop();
    if (errors->hasErrors())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AudioNodeWillBeDestroyedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    result->setValue("nodeId", ValueConversions<String>::toValue(m_nodeId));
    return result;
}

void AudioNodeWillBeDestroyedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
      crdtp::SerializeField(crdtp::SpanFrom("nodeId"), m_nodeId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AudioNodeWillBeDestroyedNotification> AudioNodeWillBeDestroyedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AudioParamCreatedNotification> AudioParamCreatedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->addError("object expected");
        return nullptr;
    }

    std::unique_ptr<AudioParamCreatedNotification> result(new AudioParamCreatedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->push();
    protocol::Value* paramValue = object->get("param");
    errors->setName("param");
    result->m_param = ValueConversions<protocol::WebAudio::AudioParam>::fromValue(paramValue, errors);
    errors->pop();
    if (errors->hasErrors())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AudioParamCreatedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("param", ValueConversions<protocol::WebAudio::AudioParam>::toValue(m_param.get()));
    return result;
}

void AudioParamCreatedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("param"), m_param, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AudioParamCreatedNotification> AudioParamCreatedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AudioParamWillBeDestroyedNotification> AudioParamWillBeDestroyedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->addError("object expected");
        return nullptr;
    }

    std::unique_ptr<AudioParamWillBeDestroyedNotification> result(new AudioParamWillBeDestroyedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->push();
    protocol::Value* contextIdValue = object->get("contextId");
    errors->setName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    protocol::Value* nodeIdValue = object->get("nodeId");
    errors->setName("nodeId");
    result->m_nodeId = ValueConversions<String>::fromValue(nodeIdValue, errors);
    protocol::Value* paramIdValue = object->get("paramId");
    errors->setName("paramId");
    result->m_paramId = ValueConversions<String>::fromValue(paramIdValue, errors);
    errors->pop();
    if (errors->hasErrors())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AudioParamWillBeDestroyedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    result->setValue("nodeId", ValueConversions<String>::toValue(m_nodeId));
    result->setValue("paramId", ValueConversions<String>::toValue(m_paramId));
    return result;
}

void AudioParamWillBeDestroyedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
      crdtp::SerializeField(crdtp::SpanFrom("nodeId"), m_nodeId, out);
      crdtp::SerializeField(crdtp::SpanFrom("paramId"), m_paramId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AudioParamWillBeDestroyedNotification> AudioParamWillBeDestroyedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<NodesConnectedNotification> NodesConnectedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->addError("object expected");
        return nullptr;
    }

    std::unique_ptr<NodesConnectedNotification> result(new NodesConnectedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->push();
    protocol::Value* contextIdValue = object->get("contextId");
    errors->setName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    protocol::Value* sourceIdValue = object->get("sourceId");
    errors->setName("sourceId");
    result->m_sourceId = ValueConversions<String>::fromValue(sourceIdValue, errors);
    protocol::Value* destinationIdValue = object->get("destinationId");
    errors->setName("destinationId");
    result->m_destinationId = ValueConversions<String>::fromValue(destinationIdValue, errors);
    protocol::Value* sourceOutputIndexValue = object->get("sourceOutputIndex");
    if (sourceOutputIndexValue) {
        errors->setName("sourceOutputIndex");
        result->m_sourceOutputIndex = ValueConversions<double>::fromValue(sourceOutputIndexValue, errors);
    }
    protocol::Value* destinationInputIndexValue = object->get("destinationInputIndex");
    if (destinationInputIndexValue) {
        errors->setName("destinationInputIndex");
        result->m_destinationInputIndex = ValueConversions<double>::fromValue(destinationInputIndexValue, errors);
    }
    errors->pop();
    if (errors->hasErrors())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> NodesConnectedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    result->setValue("sourceId", ValueConversions<String>::toValue(m_sourceId));
    result->setValue("destinationId", ValueConversions<String>::toValue(m_destinationId));
    if (m_sourceOutputIndex.isJust())
        result->setValue("sourceOutputIndex", ValueConversions<double>::toValue(m_sourceOutputIndex.fromJust()));
    if (m_destinationInputIndex.isJust())
        result->setValue("destinationInputIndex", ValueConversions<double>::toValue(m_destinationInputIndex.fromJust()));
    return result;
}

void NodesConnectedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
      crdtp::SerializeField(crdtp::SpanFrom("sourceId"), m_sourceId, out);
      crdtp::SerializeField(crdtp::SpanFrom("destinationId"), m_destinationId, out);
      crdtp::SerializeField(crdtp::SpanFrom("sourceOutputIndex"), m_sourceOutputIndex, out);
      crdtp::SerializeField(crdtp::SpanFrom("destinationInputIndex"), m_destinationInputIndex, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<NodesConnectedNotification> NodesConnectedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<NodesDisconnectedNotification> NodesDisconnectedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->addError("object expected");
        return nullptr;
    }

    std::unique_ptr<NodesDisconnectedNotification> result(new NodesDisconnectedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->push();
    protocol::Value* contextIdValue = object->get("contextId");
    errors->setName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    protocol::Value* sourceIdValue = object->get("sourceId");
    errors->setName("sourceId");
    result->m_sourceId = ValueConversions<String>::fromValue(sourceIdValue, errors);
    protocol::Value* destinationIdValue = object->get("destinationId");
    errors->setName("destinationId");
    result->m_destinationId = ValueConversions<String>::fromValue(destinationIdValue, errors);
    protocol::Value* sourceOutputIndexValue = object->get("sourceOutputIndex");
    if (sourceOutputIndexValue) {
        errors->setName("sourceOutputIndex");
        result->m_sourceOutputIndex = ValueConversions<double>::fromValue(sourceOutputIndexValue, errors);
    }
    protocol::Value* destinationInputIndexValue = object->get("destinationInputIndex");
    if (destinationInputIndexValue) {
        errors->setName("destinationInputIndex");
        result->m_destinationInputIndex = ValueConversions<double>::fromValue(destinationInputIndexValue, errors);
    }
    errors->pop();
    if (errors->hasErrors())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> NodesDisconnectedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    result->setValue("sourceId", ValueConversions<String>::toValue(m_sourceId));
    result->setValue("destinationId", ValueConversions<String>::toValue(m_destinationId));
    if (m_sourceOutputIndex.isJust())
        result->setValue("sourceOutputIndex", ValueConversions<double>::toValue(m_sourceOutputIndex.fromJust()));
    if (m_destinationInputIndex.isJust())
        result->setValue("destinationInputIndex", ValueConversions<double>::toValue(m_destinationInputIndex.fromJust()));
    return result;
}

void NodesDisconnectedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
      crdtp::SerializeField(crdtp::SpanFrom("sourceId"), m_sourceId, out);
      crdtp::SerializeField(crdtp::SpanFrom("destinationId"), m_destinationId, out);
      crdtp::SerializeField(crdtp::SpanFrom("sourceOutputIndex"), m_sourceOutputIndex, out);
      crdtp::SerializeField(crdtp::SpanFrom("destinationInputIndex"), m_destinationInputIndex, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<NodesDisconnectedNotification> NodesDisconnectedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<NodeParamConnectedNotification> NodeParamConnectedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->addError("object expected");
        return nullptr;
    }

    std::unique_ptr<NodeParamConnectedNotification> result(new NodeParamConnectedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->push();
    protocol::Value* contextIdValue = object->get("contextId");
    errors->setName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    protocol::Value* sourceIdValue = object->get("sourceId");
    errors->setName("sourceId");
    result->m_sourceId = ValueConversions<String>::fromValue(sourceIdValue, errors);
    protocol::Value* destinationIdValue = object->get("destinationId");
    errors->setName("destinationId");
    result->m_destinationId = ValueConversions<String>::fromValue(destinationIdValue, errors);
    protocol::Value* sourceOutputIndexValue = object->get("sourceOutputIndex");
    if (sourceOutputIndexValue) {
        errors->setName("sourceOutputIndex");
        result->m_sourceOutputIndex = ValueConversions<double>::fromValue(sourceOutputIndexValue, errors);
    }
    errors->pop();
    if (errors->hasErrors())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> NodeParamConnectedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    result->setValue("sourceId", ValueConversions<String>::toValue(m_sourceId));
    result->setValue("destinationId", ValueConversions<String>::toValue(m_destinationId));
    if (m_sourceOutputIndex.isJust())
        result->setValue("sourceOutputIndex", ValueConversions<double>::toValue(m_sourceOutputIndex.fromJust()));
    return result;
}

void NodeParamConnectedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
      crdtp::SerializeField(crdtp::SpanFrom("sourceId"), m_sourceId, out);
      crdtp::SerializeField(crdtp::SpanFrom("destinationId"), m_destinationId, out);
      crdtp::SerializeField(crdtp::SpanFrom("sourceOutputIndex"), m_sourceOutputIndex, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<NodeParamConnectedNotification> NodeParamConnectedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<NodeParamDisconnectedNotification> NodeParamDisconnectedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->addError("object expected");
        return nullptr;
    }

    std::unique_ptr<NodeParamDisconnectedNotification> result(new NodeParamDisconnectedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->push();
    protocol::Value* contextIdValue = object->get("contextId");
    errors->setName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    protocol::Value* sourceIdValue = object->get("sourceId");
    errors->setName("sourceId");
    result->m_sourceId = ValueConversions<String>::fromValue(sourceIdValue, errors);
    protocol::Value* destinationIdValue = object->get("destinationId");
    errors->setName("destinationId");
    result->m_destinationId = ValueConversions<String>::fromValue(destinationIdValue, errors);
    protocol::Value* sourceOutputIndexValue = object->get("sourceOutputIndex");
    if (sourceOutputIndexValue) {
        errors->setName("sourceOutputIndex");
        result->m_sourceOutputIndex = ValueConversions<double>::fromValue(sourceOutputIndexValue, errors);
    }
    errors->pop();
    if (errors->hasErrors())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> NodeParamDisconnectedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    result->setValue("sourceId", ValueConversions<String>::toValue(m_sourceId));
    result->setValue("destinationId", ValueConversions<String>::toValue(m_destinationId));
    if (m_sourceOutputIndex.isJust())
        result->setValue("sourceOutputIndex", ValueConversions<double>::toValue(m_sourceOutputIndex.fromJust()));
    return result;
}

void NodeParamDisconnectedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
      crdtp::SerializeField(crdtp::SpanFrom("sourceId"), m_sourceId, out);
      crdtp::SerializeField(crdtp::SpanFrom("destinationId"), m_destinationId, out);
      crdtp::SerializeField(crdtp::SpanFrom("sourceOutputIndex"), m_sourceOutputIndex, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<NodeParamDisconnectedNotification> NodeParamDisconnectedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

// ------------- Enum values from params.


// ------------- Frontend notifications.

void Frontend::contextCreated(std::unique_ptr<protocol::WebAudio::BaseAudioContext> context)
{
    if (!m_frontendChannel)
        return;
    std::unique_ptr<ContextCreatedNotification> messageData = ContextCreatedNotification::create()
        .setContext(std::move(context))
        .build();
    m_frontendChannel->sendProtocolNotification(InternalResponse::createNotification("WebAudio.contextCreated", std::move(messageData)));
}

void Frontend::contextWillBeDestroyed(const String& contextId)
{
    if (!m_frontendChannel)
        return;
    std::unique_ptr<ContextWillBeDestroyedNotification> messageData = ContextWillBeDestroyedNotification::create()
        .setContextId(contextId)
        .build();
    m_frontendChannel->sendProtocolNotification(InternalResponse::createNotification("WebAudio.contextWillBeDestroyed", std::move(messageData)));
}

void Frontend::contextChanged(std::unique_ptr<protocol::WebAudio::BaseAudioContext> context)
{
    if (!m_frontendChannel)
        return;
    std::unique_ptr<ContextChangedNotification> messageData = ContextChangedNotification::create()
        .setContext(std::move(context))
        .build();
    m_frontendChannel->sendProtocolNotification(InternalResponse::createNotification("WebAudio.contextChanged", std::move(messageData)));
}

void Frontend::audioListenerCreated(std::unique_ptr<protocol::WebAudio::AudioListener> listener)
{
    if (!m_frontendChannel)
        return;
    std::unique_ptr<AudioListenerCreatedNotification> messageData = AudioListenerCreatedNotification::create()
        .setListener(std::move(listener))
        .build();
    m_frontendChannel->sendProtocolNotification(InternalResponse::createNotification("WebAudio.audioListenerCreated", std::move(messageData)));
}

void Frontend::audioListenerWillBeDestroyed(const String& contextId, const String& listenerId)
{
    if (!m_frontendChannel)
        return;
    std::unique_ptr<AudioListenerWillBeDestroyedNotification> messageData = AudioListenerWillBeDestroyedNotification::create()
        .setContextId(contextId)
        .setListenerId(listenerId)
        .build();
    m_frontendChannel->sendProtocolNotification(InternalResponse::createNotification("WebAudio.audioListenerWillBeDestroyed", std::move(messageData)));
}

void Frontend::audioNodeCreated(std::unique_ptr<protocol::WebAudio::AudioNode> node)
{
    if (!m_frontendChannel)
        return;
    std::unique_ptr<AudioNodeCreatedNotification> messageData = AudioNodeCreatedNotification::create()
        .setNode(std::move(node))
        .build();
    m_frontendChannel->sendProtocolNotification(InternalResponse::createNotification("WebAudio.audioNodeCreated", std::move(messageData)));
}

void Frontend::audioNodeWillBeDestroyed(const String& contextId, const String& nodeId)
{
    if (!m_frontendChannel)
        return;
    std::unique_ptr<AudioNodeWillBeDestroyedNotification> messageData = AudioNodeWillBeDestroyedNotification::create()
        .setContextId(contextId)
        .setNodeId(nodeId)
        .build();
    m_frontendChannel->sendProtocolNotification(InternalResponse::createNotification("WebAudio.audioNodeWillBeDestroyed", std::move(messageData)));
}

void Frontend::audioParamCreated(std::unique_ptr<protocol::WebAudio::AudioParam> param)
{
    if (!m_frontendChannel)
        return;
    std::unique_ptr<AudioParamCreatedNotification> messageData = AudioParamCreatedNotification::create()
        .setParam(std::move(param))
        .build();
    m_frontendChannel->sendProtocolNotification(InternalResponse::createNotification("WebAudio.audioParamCreated", std::move(messageData)));
}

void Frontend::audioParamWillBeDestroyed(const String& contextId, const String& nodeId, const String& paramId)
{
    if (!m_frontendChannel)
        return;
    std::unique_ptr<AudioParamWillBeDestroyedNotification> messageData = AudioParamWillBeDestroyedNotification::create()
        .setContextId(contextId)
        .setNodeId(nodeId)
        .setParamId(paramId)
        .build();
    m_frontendChannel->sendProtocolNotification(InternalResponse::createNotification("WebAudio.audioParamWillBeDestroyed", std::move(messageData)));
}

void Frontend::nodesConnected(const String& contextId, const String& sourceId, const String& destinationId, Maybe<double> sourceOutputIndex, Maybe<double> destinationInputIndex)
{
    if (!m_frontendChannel)
        return;
    std::unique_ptr<NodesConnectedNotification> messageData = NodesConnectedNotification::create()
        .setContextId(contextId)
        .setSourceId(sourceId)
        .setDestinationId(destinationId)
        .build();
    if (sourceOutputIndex.isJust())
        messageData->setSourceOutputIndex(std::move(sourceOutputIndex).takeJust());
    if (destinationInputIndex.isJust())
        messageData->setDestinationInputIndex(std::move(destinationInputIndex).takeJust());
    m_frontendChannel->sendProtocolNotification(InternalResponse::createNotification("WebAudio.nodesConnected", std::move(messageData)));
}

void Frontend::nodesDisconnected(const String& contextId, const String& sourceId, const String& destinationId, Maybe<double> sourceOutputIndex, Maybe<double> destinationInputIndex)
{
    if (!m_frontendChannel)
        return;
    std::unique_ptr<NodesDisconnectedNotification> messageData = NodesDisconnectedNotification::create()
        .setContextId(contextId)
        .setSourceId(sourceId)
        .setDestinationId(destinationId)
        .build();
    if (sourceOutputIndex.isJust())
        messageData->setSourceOutputIndex(std::move(sourceOutputIndex).takeJust());
    if (destinationInputIndex.isJust())
        messageData->setDestinationInputIndex(std::move(destinationInputIndex).takeJust());
    m_frontendChannel->sendProtocolNotification(InternalResponse::createNotification("WebAudio.nodesDisconnected", std::move(messageData)));
}

void Frontend::nodeParamConnected(const String& contextId, const String& sourceId, const String& destinationId, Maybe<double> sourceOutputIndex)
{
    if (!m_frontendChannel)
        return;
    std::unique_ptr<NodeParamConnectedNotification> messageData = NodeParamConnectedNotification::create()
        .setContextId(contextId)
        .setSourceId(sourceId)
        .setDestinationId(destinationId)
        .build();
    if (sourceOutputIndex.isJust())
        messageData->setSourceOutputIndex(std::move(sourceOutputIndex).takeJust());
    m_frontendChannel->sendProtocolNotification(InternalResponse::createNotification("WebAudio.nodeParamConnected", std::move(messageData)));
}

void Frontend::nodeParamDisconnected(const String& contextId, const String& sourceId, const String& destinationId, Maybe<double> sourceOutputIndex)
{
    if (!m_frontendChannel)
        return;
    std::unique_ptr<NodeParamDisconnectedNotification> messageData = NodeParamDisconnectedNotification::create()
        .setContextId(contextId)
        .setSourceId(sourceId)
        .setDestinationId(destinationId)
        .build();
    if (sourceOutputIndex.isJust())
        messageData->setSourceOutputIndex(std::move(sourceOutputIndex).takeJust());
    m_frontendChannel->sendProtocolNotification(InternalResponse::createNotification("WebAudio.nodeParamDisconnected", std::move(messageData)));
}

void Frontend::flush()
{
    m_frontendChannel->flushProtocolNotifications();
}

void Frontend::sendRawCBORNotification(std::vector<uint8_t> notification)
{
    m_frontendChannel->sendProtocolNotification(InternalRawNotification::fromBinary(std::move(notification)));
}

// --------------------- Dispatcher.

class DispatcherImpl : public protocol::DispatcherBase {
public:
    DispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DispatcherBase(frontendChannel)
        , m_backend(backend) {
        m_dispatchMap["WebAudio.enable"] = &DispatcherImpl::enable;
        m_dispatchMap["WebAudio.disable"] = &DispatcherImpl::disable;
        m_dispatchMap["WebAudio.getRealtimeData"] = &DispatcherImpl::getRealtimeData;
    }
    ~DispatcherImpl() override { }
    bool canDispatch(const String& method) override;
    void dispatch(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<protocol::DictionaryValue> messageObject) override;
    std::unordered_map<String, String>& redirects() { return m_redirects; }

protected:
    using CallHandler = void (DispatcherImpl::*)(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> messageObject, ErrorSupport* errors);
    using DispatchMap = std::unordered_map<String, CallHandler>;
    DispatchMap m_dispatchMap;
    std::unordered_map<String, String> m_redirects;

    void enable(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport*);
    void disable(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport*);
    void getRealtimeData(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport*);

    Backend* m_backend;
};

bool DispatcherImpl::canDispatch(const String& method) {
    return m_dispatchMap.find(method) != m_dispatchMap.end();
}

void DispatcherImpl::dispatch(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<protocol::DictionaryValue> messageObject)
{
    std::unordered_map<String, CallHandler>::iterator it = m_dispatchMap.find(method);
    DCHECK(it != m_dispatchMap.end());
    protocol::ErrorSupport errors;
    (this->*(it->second))(callId, method, message, std::move(messageObject), &errors);
}


void DispatcherImpl::enable(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport* errors)
{

    std::unique_ptr<DispatcherBase::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->enable();
    if (response.status() == DispatchResponse::kFallThrough) {
        channel()->fallThrough(callId, method, message);
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(callId, response);
    return;
}

void DispatcherImpl::disable(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport* errors)
{

    std::unique_ptr<DispatcherBase::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->disable();
    if (response.status() == DispatchResponse::kFallThrough) {
        channel()->fallThrough(callId, method, message);
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(callId, response);
    return;
}

void DispatcherImpl::getRealtimeData(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::DictionaryValue* object = DictionaryValue::cast(requestMessageObject->get("params"));
    errors->push();
    protocol::Value* contextIdValue = object ? object->get("contextId") : nullptr;
    errors->setName("contextId");
    String in_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    errors->pop();
    if (errors->hasErrors()) {
        reportProtocolError(callId, DispatchResponse::kInvalidParams, kInvalidParamsString, errors);
        return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::WebAudio::ContextRealtimeData> out_realtimeData;

    std::unique_ptr<DispatcherBase::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getRealtimeData(in_contextId, &out_realtimeData);
    if (response.status() == DispatchResponse::kFallThrough) {
        channel()->fallThrough(callId, method, message);
        return;
    }
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (response.status() == DispatchResponse::kSuccess) {
        result->setValue("realtimeData", ValueConversions<protocol::WebAudio::ContextRealtimeData>::toValue(out_realtimeData.get()));
    }
    if (weak->get())
        weak->get()->sendResponse(callId, response, std::move(result));
    return;
}

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    std::unique_ptr<DispatcherImpl> dispatcher(new DispatcherImpl(uber->channel(), backend));
    uber->setupRedirects(dispatcher->redirects());
    uber->registerBackend("WebAudio", std::move(dispatcher));
}

} // WebAudio
} // namespace blink
} // namespace protocol
