// This file is generated by TypeBuilder_h.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef blink_protocol_WebAudio_h
#define blink_protocol_WebAudio_h

#include "third_party/blink/renderer/core/core_export.h"
#include "third_party/blink/renderer/core/inspector/protocol/Protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.

namespace blink {
namespace protocol {
namespace WebAudio {

// ------------- Forward and enum declarations.
using GraphObjectId = String;
using ContextType = String;
using ContextState = String;
using NodeType = String;
using ChannelCountMode = String;
using ChannelInterpretation = String;
using ParamType = String;
using AutomationRate = String;
class ContextRealtimeData;
class BaseAudioContext;
class AudioListener;
class AudioNode;
class AudioParam;
class ContextCreatedNotification;
class ContextWillBeDestroyedNotification;
class ContextChangedNotification;
class AudioListenerCreatedNotification;
class AudioListenerWillBeDestroyedNotification;
class AudioNodeCreatedNotification;
class AudioNodeWillBeDestroyedNotification;
class AudioParamCreatedNotification;
class AudioParamWillBeDestroyedNotification;
class NodesConnectedNotification;
class NodesDisconnectedNotification;
class NodeParamConnectedNotification;
class NodeParamDisconnectedNotification;

namespace ContextTypeEnum {
CORE_EXPORT extern const char Realtime[];
CORE_EXPORT extern const char Offline[];
} // namespace ContextTypeEnum

namespace ContextStateEnum {
CORE_EXPORT extern const char Suspended[];
CORE_EXPORT extern const char Running[];
CORE_EXPORT extern const char Closed[];
} // namespace ContextStateEnum

namespace ChannelCountModeEnum {
CORE_EXPORT extern const char ClampedMax[];
CORE_EXPORT extern const char Explicit[];
CORE_EXPORT extern const char Max[];
} // namespace ChannelCountModeEnum

namespace ChannelInterpretationEnum {
CORE_EXPORT extern const char Discrete[];
CORE_EXPORT extern const char Speakers[];
} // namespace ChannelInterpretationEnum

namespace AutomationRateEnum {
CORE_EXPORT extern const char ARate[];
CORE_EXPORT extern const char KRate[];
} // namespace AutomationRateEnum

// ------------- Type and builder declarations.

class CORE_EXPORT ContextRealtimeData : public Serializable{
    PROTOCOL_DISALLOW_COPY(ContextRealtimeData);
public:
    static std::unique_ptr<ContextRealtimeData> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~ContextRealtimeData() override { }

    double getCurrentTime() { return m_currentTime; }
    void setCurrentTime(double value) { m_currentTime = value; }

    double getRenderCapacity() { return m_renderCapacity; }
    void setRenderCapacity(double value) { m_renderCapacity = value; }

    double getCallbackIntervalMean() { return m_callbackIntervalMean; }
    void setCallbackIntervalMean(double value) { m_callbackIntervalMean = value; }

    double getCallbackIntervalVariance() { return m_callbackIntervalVariance; }
    void setCallbackIntervalVariance(double value) { m_callbackIntervalVariance = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<ContextRealtimeData> clone() const;

    template<int STATE>
    class ContextRealtimeDataBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            CurrentTimeSet = 1 << 1,
            RenderCapacitySet = 1 << 2,
            CallbackIntervalMeanSet = 1 << 3,
            CallbackIntervalVarianceSet = 1 << 4,
            AllFieldsSet = (CurrentTimeSet | RenderCapacitySet | CallbackIntervalMeanSet | CallbackIntervalVarianceSet | 0)};


        ContextRealtimeDataBuilder<STATE | CurrentTimeSet>& setCurrentTime(double value)
        {
            static_assert(!(STATE & CurrentTimeSet), "property currentTime should not be set yet");
            m_result->setCurrentTime(value);
            return castState<CurrentTimeSet>();
        }

        ContextRealtimeDataBuilder<STATE | RenderCapacitySet>& setRenderCapacity(double value)
        {
            static_assert(!(STATE & RenderCapacitySet), "property renderCapacity should not be set yet");
            m_result->setRenderCapacity(value);
            return castState<RenderCapacitySet>();
        }

        ContextRealtimeDataBuilder<STATE | CallbackIntervalMeanSet>& setCallbackIntervalMean(double value)
        {
            static_assert(!(STATE & CallbackIntervalMeanSet), "property callbackIntervalMean should not be set yet");
            m_result->setCallbackIntervalMean(value);
            return castState<CallbackIntervalMeanSet>();
        }

        ContextRealtimeDataBuilder<STATE | CallbackIntervalVarianceSet>& setCallbackIntervalVariance(double value)
        {
            static_assert(!(STATE & CallbackIntervalVarianceSet), "property callbackIntervalVariance should not be set yet");
            m_result->setCallbackIntervalVariance(value);
            return castState<CallbackIntervalVarianceSet>();
        }

        std::unique_ptr<ContextRealtimeData> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ContextRealtimeData;
        ContextRealtimeDataBuilder() : m_result(new ContextRealtimeData()) { }

        template<int STEP> ContextRealtimeDataBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ContextRealtimeDataBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::WebAudio::ContextRealtimeData> m_result;
    };

    static ContextRealtimeDataBuilder<0> create()
    {
        return ContextRealtimeDataBuilder<0>();
    }

private:
    ContextRealtimeData()
    {
          m_currentTime = 0;
          m_renderCapacity = 0;
          m_callbackIntervalMean = 0;
          m_callbackIntervalVariance = 0;
    }

    double m_currentTime;
    double m_renderCapacity;
    double m_callbackIntervalMean;
    double m_callbackIntervalVariance;
};


class CORE_EXPORT BaseAudioContext : public Serializable{
    PROTOCOL_DISALLOW_COPY(BaseAudioContext);
public:
    static std::unique_ptr<BaseAudioContext> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~BaseAudioContext() override { }

    String getContextId() { return m_contextId; }
    void setContextId(const String& value) { m_contextId = value; }

    String getContextType() { return m_contextType; }
    void setContextType(const String& value) { m_contextType = value; }

    String getContextState() { return m_contextState; }
    void setContextState(const String& value) { m_contextState = value; }

    bool hasRealtimeData() { return m_realtimeData.isJust(); }
    protocol::WebAudio::ContextRealtimeData* getRealtimeData(protocol::WebAudio::ContextRealtimeData* defaultValue) { return m_realtimeData.isJust() ? m_realtimeData.fromJust() : defaultValue; }
    void setRealtimeData(std::unique_ptr<protocol::WebAudio::ContextRealtimeData> value) { m_realtimeData = std::move(value); }

    double getCallbackBufferSize() { return m_callbackBufferSize; }
    void setCallbackBufferSize(double value) { m_callbackBufferSize = value; }

    double getMaxOutputChannelCount() { return m_maxOutputChannelCount; }
    void setMaxOutputChannelCount(double value) { m_maxOutputChannelCount = value; }

    double getSampleRate() { return m_sampleRate; }
    void setSampleRate(double value) { m_sampleRate = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<BaseAudioContext> clone() const;

    template<int STATE>
    class BaseAudioContextBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ContextIdSet = 1 << 1,
            ContextTypeSet = 1 << 2,
            ContextStateSet = 1 << 3,
            CallbackBufferSizeSet = 1 << 4,
            MaxOutputChannelCountSet = 1 << 5,
            SampleRateSet = 1 << 6,
            AllFieldsSet = (ContextIdSet | ContextTypeSet | ContextStateSet | CallbackBufferSizeSet | MaxOutputChannelCountSet | SampleRateSet | 0)};


        BaseAudioContextBuilder<STATE | ContextIdSet>& setContextId(const String& value)
        {
            static_assert(!(STATE & ContextIdSet), "property contextId should not be set yet");
            m_result->setContextId(value);
            return castState<ContextIdSet>();
        }

        BaseAudioContextBuilder<STATE | ContextTypeSet>& setContextType(const String& value)
        {
            static_assert(!(STATE & ContextTypeSet), "property contextType should not be set yet");
            m_result->setContextType(value);
            return castState<ContextTypeSet>();
        }

        BaseAudioContextBuilder<STATE | ContextStateSet>& setContextState(const String& value)
        {
            static_assert(!(STATE & ContextStateSet), "property contextState should not be set yet");
            m_result->setContextState(value);
            return castState<ContextStateSet>();
        }

        BaseAudioContextBuilder<STATE>& setRealtimeData(std::unique_ptr<protocol::WebAudio::ContextRealtimeData> value)
        {
            m_result->setRealtimeData(std::move(value));
            return *this;
        }

        BaseAudioContextBuilder<STATE | CallbackBufferSizeSet>& setCallbackBufferSize(double value)
        {
            static_assert(!(STATE & CallbackBufferSizeSet), "property callbackBufferSize should not be set yet");
            m_result->setCallbackBufferSize(value);
            return castState<CallbackBufferSizeSet>();
        }

        BaseAudioContextBuilder<STATE | MaxOutputChannelCountSet>& setMaxOutputChannelCount(double value)
        {
            static_assert(!(STATE & MaxOutputChannelCountSet), "property maxOutputChannelCount should not be set yet");
            m_result->setMaxOutputChannelCount(value);
            return castState<MaxOutputChannelCountSet>();
        }

        BaseAudioContextBuilder<STATE | SampleRateSet>& setSampleRate(double value)
        {
            static_assert(!(STATE & SampleRateSet), "property sampleRate should not be set yet");
            m_result->setSampleRate(value);
            return castState<SampleRateSet>();
        }

        std::unique_ptr<BaseAudioContext> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class BaseAudioContext;
        BaseAudioContextBuilder() : m_result(new BaseAudioContext()) { }

        template<int STEP> BaseAudioContextBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<BaseAudioContextBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::WebAudio::BaseAudioContext> m_result;
    };

    static BaseAudioContextBuilder<0> create()
    {
        return BaseAudioContextBuilder<0>();
    }

private:
    BaseAudioContext()
    {
          m_callbackBufferSize = 0;
          m_maxOutputChannelCount = 0;
          m_sampleRate = 0;
    }

    String m_contextId;
    String m_contextType;
    String m_contextState;
    Maybe<protocol::WebAudio::ContextRealtimeData> m_realtimeData;
    double m_callbackBufferSize;
    double m_maxOutputChannelCount;
    double m_sampleRate;
};


class CORE_EXPORT AudioListener : public Serializable{
    PROTOCOL_DISALLOW_COPY(AudioListener);
public:
    static std::unique_ptr<AudioListener> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~AudioListener() override { }

    String getListenerId() { return m_listenerId; }
    void setListenerId(const String& value) { m_listenerId = value; }

    String getContextId() { return m_contextId; }
    void setContextId(const String& value) { m_contextId = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<AudioListener> clone() const;

    template<int STATE>
    class AudioListenerBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ListenerIdSet = 1 << 1,
            ContextIdSet = 1 << 2,
            AllFieldsSet = (ListenerIdSet | ContextIdSet | 0)};


        AudioListenerBuilder<STATE | ListenerIdSet>& setListenerId(const String& value)
        {
            static_assert(!(STATE & ListenerIdSet), "property listenerId should not be set yet");
            m_result->setListenerId(value);
            return castState<ListenerIdSet>();
        }

        AudioListenerBuilder<STATE | ContextIdSet>& setContextId(const String& value)
        {
            static_assert(!(STATE & ContextIdSet), "property contextId should not be set yet");
            m_result->setContextId(value);
            return castState<ContextIdSet>();
        }

        std::unique_ptr<AudioListener> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AudioListener;
        AudioListenerBuilder() : m_result(new AudioListener()) { }

        template<int STEP> AudioListenerBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AudioListenerBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::WebAudio::AudioListener> m_result;
    };

    static AudioListenerBuilder<0> create()
    {
        return AudioListenerBuilder<0>();
    }

private:
    AudioListener()
    {
    }

    String m_listenerId;
    String m_contextId;
};


class CORE_EXPORT AudioNode : public Serializable{
    PROTOCOL_DISALLOW_COPY(AudioNode);
public:
    static std::unique_ptr<AudioNode> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~AudioNode() override { }

    String getNodeId() { return m_nodeId; }
    void setNodeId(const String& value) { m_nodeId = value; }

    String getContextId() { return m_contextId; }
    void setContextId(const String& value) { m_contextId = value; }

    String getNodeType() { return m_nodeType; }
    void setNodeType(const String& value) { m_nodeType = value; }

    double getNumberOfInputs() { return m_numberOfInputs; }
    void setNumberOfInputs(double value) { m_numberOfInputs = value; }

    double getNumberOfOutputs() { return m_numberOfOutputs; }
    void setNumberOfOutputs(double value) { m_numberOfOutputs = value; }

    double getChannelCount() { return m_channelCount; }
    void setChannelCount(double value) { m_channelCount = value; }

    String getChannelCountMode() { return m_channelCountMode; }
    void setChannelCountMode(const String& value) { m_channelCountMode = value; }

    String getChannelInterpretation() { return m_channelInterpretation; }
    void setChannelInterpretation(const String& value) { m_channelInterpretation = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<AudioNode> clone() const;

    template<int STATE>
    class AudioNodeBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            NodeIdSet = 1 << 1,
            ContextIdSet = 1 << 2,
            NodeTypeSet = 1 << 3,
            NumberOfInputsSet = 1 << 4,
            NumberOfOutputsSet = 1 << 5,
            ChannelCountSet = 1 << 6,
            ChannelCountModeSet = 1 << 7,
            ChannelInterpretationSet = 1 << 8,
            AllFieldsSet = (NodeIdSet | ContextIdSet | NodeTypeSet | NumberOfInputsSet | NumberOfOutputsSet | ChannelCountSet | ChannelCountModeSet | ChannelInterpretationSet | 0)};


        AudioNodeBuilder<STATE | NodeIdSet>& setNodeId(const String& value)
        {
            static_assert(!(STATE & NodeIdSet), "property nodeId should not be set yet");
            m_result->setNodeId(value);
            return castState<NodeIdSet>();
        }

        AudioNodeBuilder<STATE | ContextIdSet>& setContextId(const String& value)
        {
            static_assert(!(STATE & ContextIdSet), "property contextId should not be set yet");
            m_result->setContextId(value);
            return castState<ContextIdSet>();
        }

        AudioNodeBuilder<STATE | NodeTypeSet>& setNodeType(const String& value)
        {
            static_assert(!(STATE & NodeTypeSet), "property nodeType should not be set yet");
            m_result->setNodeType(value);
            return castState<NodeTypeSet>();
        }

        AudioNodeBuilder<STATE | NumberOfInputsSet>& setNumberOfInputs(double value)
        {
            static_assert(!(STATE & NumberOfInputsSet), "property numberOfInputs should not be set yet");
            m_result->setNumberOfInputs(value);
            return castState<NumberOfInputsSet>();
        }

        AudioNodeBuilder<STATE | NumberOfOutputsSet>& setNumberOfOutputs(double value)
        {
            static_assert(!(STATE & NumberOfOutputsSet), "property numberOfOutputs should not be set yet");
            m_result->setNumberOfOutputs(value);
            return castState<NumberOfOutputsSet>();
        }

        AudioNodeBuilder<STATE | ChannelCountSet>& setChannelCount(double value)
        {
            static_assert(!(STATE & ChannelCountSet), "property channelCount should not be set yet");
            m_result->setChannelCount(value);
            return castState<ChannelCountSet>();
        }

        AudioNodeBuilder<STATE | ChannelCountModeSet>& setChannelCountMode(const String& value)
        {
            static_assert(!(STATE & ChannelCountModeSet), "property channelCountMode should not be set yet");
            m_result->setChannelCountMode(value);
            return castState<ChannelCountModeSet>();
        }

        AudioNodeBuilder<STATE | ChannelInterpretationSet>& setChannelInterpretation(const String& value)
        {
            static_assert(!(STATE & ChannelInterpretationSet), "property channelInterpretation should not be set yet");
            m_result->setChannelInterpretation(value);
            return castState<ChannelInterpretationSet>();
        }

        std::unique_ptr<AudioNode> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AudioNode;
        AudioNodeBuilder() : m_result(new AudioNode()) { }

        template<int STEP> AudioNodeBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AudioNodeBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::WebAudio::AudioNode> m_result;
    };

    static AudioNodeBuilder<0> create()
    {
        return AudioNodeBuilder<0>();
    }

private:
    AudioNode()
    {
          m_numberOfInputs = 0;
          m_numberOfOutputs = 0;
          m_channelCount = 0;
    }

    String m_nodeId;
    String m_contextId;
    String m_nodeType;
    double m_numberOfInputs;
    double m_numberOfOutputs;
    double m_channelCount;
    String m_channelCountMode;
    String m_channelInterpretation;
};


class CORE_EXPORT AudioParam : public Serializable{
    PROTOCOL_DISALLOW_COPY(AudioParam);
public:
    static std::unique_ptr<AudioParam> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~AudioParam() override { }

    String getParamId() { return m_paramId; }
    void setParamId(const String& value) { m_paramId = value; }

    String getNodeId() { return m_nodeId; }
    void setNodeId(const String& value) { m_nodeId = value; }

    String getContextId() { return m_contextId; }
    void setContextId(const String& value) { m_contextId = value; }

    String getParamType() { return m_paramType; }
    void setParamType(const String& value) { m_paramType = value; }

    String getRate() { return m_rate; }
    void setRate(const String& value) { m_rate = value; }

    double getDefaultValue() { return m_defaultValue; }
    void setDefaultValue(double value) { m_defaultValue = value; }

    double getMinValue() { return m_minValue; }
    void setMinValue(double value) { m_minValue = value; }

    double getMaxValue() { return m_maxValue; }
    void setMaxValue(double value) { m_maxValue = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<AudioParam> clone() const;

    template<int STATE>
    class AudioParamBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ParamIdSet = 1 << 1,
            NodeIdSet = 1 << 2,
            ContextIdSet = 1 << 3,
            ParamTypeSet = 1 << 4,
            RateSet = 1 << 5,
            DefaultValueSet = 1 << 6,
            MinValueSet = 1 << 7,
            MaxValueSet = 1 << 8,
            AllFieldsSet = (ParamIdSet | NodeIdSet | ContextIdSet | ParamTypeSet | RateSet | DefaultValueSet | MinValueSet | MaxValueSet | 0)};


        AudioParamBuilder<STATE | ParamIdSet>& setParamId(const String& value)
        {
            static_assert(!(STATE & ParamIdSet), "property paramId should not be set yet");
            m_result->setParamId(value);
            return castState<ParamIdSet>();
        }

        AudioParamBuilder<STATE | NodeIdSet>& setNodeId(const String& value)
        {
            static_assert(!(STATE & NodeIdSet), "property nodeId should not be set yet");
            m_result->setNodeId(value);
            return castState<NodeIdSet>();
        }

        AudioParamBuilder<STATE | ContextIdSet>& setContextId(const String& value)
        {
            static_assert(!(STATE & ContextIdSet), "property contextId should not be set yet");
            m_result->setContextId(value);
            return castState<ContextIdSet>();
        }

        AudioParamBuilder<STATE | ParamTypeSet>& setParamType(const String& value)
        {
            static_assert(!(STATE & ParamTypeSet), "property paramType should not be set yet");
            m_result->setParamType(value);
            return castState<ParamTypeSet>();
        }

        AudioParamBuilder<STATE | RateSet>& setRate(const String& value)
        {
            static_assert(!(STATE & RateSet), "property rate should not be set yet");
            m_result->setRate(value);
            return castState<RateSet>();
        }

        AudioParamBuilder<STATE | DefaultValueSet>& setDefaultValue(double value)
        {
            static_assert(!(STATE & DefaultValueSet), "property defaultValue should not be set yet");
            m_result->setDefaultValue(value);
            return castState<DefaultValueSet>();
        }

        AudioParamBuilder<STATE | MinValueSet>& setMinValue(double value)
        {
            static_assert(!(STATE & MinValueSet), "property minValue should not be set yet");
            m_result->setMinValue(value);
            return castState<MinValueSet>();
        }

        AudioParamBuilder<STATE | MaxValueSet>& setMaxValue(double value)
        {
            static_assert(!(STATE & MaxValueSet), "property maxValue should not be set yet");
            m_result->setMaxValue(value);
            return castState<MaxValueSet>();
        }

        std::unique_ptr<AudioParam> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AudioParam;
        AudioParamBuilder() : m_result(new AudioParam()) { }

        template<int STEP> AudioParamBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AudioParamBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::WebAudio::AudioParam> m_result;
    };

    static AudioParamBuilder<0> create()
    {
        return AudioParamBuilder<0>();
    }

private:
    AudioParam()
    {
          m_defaultValue = 0;
          m_minValue = 0;
          m_maxValue = 0;
    }

    String m_paramId;
    String m_nodeId;
    String m_contextId;
    String m_paramType;
    String m_rate;
    double m_defaultValue;
    double m_minValue;
    double m_maxValue;
};


class CORE_EXPORT ContextCreatedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(ContextCreatedNotification);
public:
    static std::unique_ptr<ContextCreatedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~ContextCreatedNotification() override { }

    protocol::WebAudio::BaseAudioContext* getContext() { return m_context.get(); }
    void setContext(std::unique_ptr<protocol::WebAudio::BaseAudioContext> value) { m_context = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<ContextCreatedNotification> clone() const;

    template<int STATE>
    class ContextCreatedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ContextSet = 1 << 1,
            AllFieldsSet = (ContextSet | 0)};


        ContextCreatedNotificationBuilder<STATE | ContextSet>& setContext(std::unique_ptr<protocol::WebAudio::BaseAudioContext> value)
        {
            static_assert(!(STATE & ContextSet), "property context should not be set yet");
            m_result->setContext(std::move(value));
            return castState<ContextSet>();
        }

        std::unique_ptr<ContextCreatedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ContextCreatedNotification;
        ContextCreatedNotificationBuilder() : m_result(new ContextCreatedNotification()) { }

        template<int STEP> ContextCreatedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ContextCreatedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::WebAudio::ContextCreatedNotification> m_result;
    };

    static ContextCreatedNotificationBuilder<0> create()
    {
        return ContextCreatedNotificationBuilder<0>();
    }

private:
    ContextCreatedNotification()
    {
    }

    std::unique_ptr<protocol::WebAudio::BaseAudioContext> m_context;
};


class CORE_EXPORT ContextWillBeDestroyedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(ContextWillBeDestroyedNotification);
public:
    static std::unique_ptr<ContextWillBeDestroyedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~ContextWillBeDestroyedNotification() override { }

    String getContextId() { return m_contextId; }
    void setContextId(const String& value) { m_contextId = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<ContextWillBeDestroyedNotification> clone() const;

    template<int STATE>
    class ContextWillBeDestroyedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ContextIdSet = 1 << 1,
            AllFieldsSet = (ContextIdSet | 0)};


        ContextWillBeDestroyedNotificationBuilder<STATE | ContextIdSet>& setContextId(const String& value)
        {
            static_assert(!(STATE & ContextIdSet), "property contextId should not be set yet");
            m_result->setContextId(value);
            return castState<ContextIdSet>();
        }

        std::unique_ptr<ContextWillBeDestroyedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ContextWillBeDestroyedNotification;
        ContextWillBeDestroyedNotificationBuilder() : m_result(new ContextWillBeDestroyedNotification()) { }

        template<int STEP> ContextWillBeDestroyedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ContextWillBeDestroyedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::WebAudio::ContextWillBeDestroyedNotification> m_result;
    };

    static ContextWillBeDestroyedNotificationBuilder<0> create()
    {
        return ContextWillBeDestroyedNotificationBuilder<0>();
    }

private:
    ContextWillBeDestroyedNotification()
    {
    }

    String m_contextId;
};


class CORE_EXPORT ContextChangedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(ContextChangedNotification);
public:
    static std::unique_ptr<ContextChangedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~ContextChangedNotification() override { }

    protocol::WebAudio::BaseAudioContext* getContext() { return m_context.get(); }
    void setContext(std::unique_ptr<protocol::WebAudio::BaseAudioContext> value) { m_context = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<ContextChangedNotification> clone() const;

    template<int STATE>
    class ContextChangedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ContextSet = 1 << 1,
            AllFieldsSet = (ContextSet | 0)};


        ContextChangedNotificationBuilder<STATE | ContextSet>& setContext(std::unique_ptr<protocol::WebAudio::BaseAudioContext> value)
        {
            static_assert(!(STATE & ContextSet), "property context should not be set yet");
            m_result->setContext(std::move(value));
            return castState<ContextSet>();
        }

        std::unique_ptr<ContextChangedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ContextChangedNotification;
        ContextChangedNotificationBuilder() : m_result(new ContextChangedNotification()) { }

        template<int STEP> ContextChangedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ContextChangedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::WebAudio::ContextChangedNotification> m_result;
    };

    static ContextChangedNotificationBuilder<0> create()
    {
        return ContextChangedNotificationBuilder<0>();
    }

private:
    ContextChangedNotification()
    {
    }

    std::unique_ptr<protocol::WebAudio::BaseAudioContext> m_context;
};


class CORE_EXPORT AudioListenerCreatedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(AudioListenerCreatedNotification);
public:
    static std::unique_ptr<AudioListenerCreatedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~AudioListenerCreatedNotification() override { }

    protocol::WebAudio::AudioListener* getListener() { return m_listener.get(); }
    void setListener(std::unique_ptr<protocol::WebAudio::AudioListener> value) { m_listener = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<AudioListenerCreatedNotification> clone() const;

    template<int STATE>
    class AudioListenerCreatedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ListenerSet = 1 << 1,
            AllFieldsSet = (ListenerSet | 0)};


        AudioListenerCreatedNotificationBuilder<STATE | ListenerSet>& setListener(std::unique_ptr<protocol::WebAudio::AudioListener> value)
        {
            static_assert(!(STATE & ListenerSet), "property listener should not be set yet");
            m_result->setListener(std::move(value));
            return castState<ListenerSet>();
        }

        std::unique_ptr<AudioListenerCreatedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AudioListenerCreatedNotification;
        AudioListenerCreatedNotificationBuilder() : m_result(new AudioListenerCreatedNotification()) { }

        template<int STEP> AudioListenerCreatedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AudioListenerCreatedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::WebAudio::AudioListenerCreatedNotification> m_result;
    };

    static AudioListenerCreatedNotificationBuilder<0> create()
    {
        return AudioListenerCreatedNotificationBuilder<0>();
    }

private:
    AudioListenerCreatedNotification()
    {
    }

    std::unique_ptr<protocol::WebAudio::AudioListener> m_listener;
};


class CORE_EXPORT AudioListenerWillBeDestroyedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(AudioListenerWillBeDestroyedNotification);
public:
    static std::unique_ptr<AudioListenerWillBeDestroyedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~AudioListenerWillBeDestroyedNotification() override { }

    String getContextId() { return m_contextId; }
    void setContextId(const String& value) { m_contextId = value; }

    String getListenerId() { return m_listenerId; }
    void setListenerId(const String& value) { m_listenerId = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<AudioListenerWillBeDestroyedNotification> clone() const;

    template<int STATE>
    class AudioListenerWillBeDestroyedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ContextIdSet = 1 << 1,
            ListenerIdSet = 1 << 2,
            AllFieldsSet = (ContextIdSet | ListenerIdSet | 0)};


        AudioListenerWillBeDestroyedNotificationBuilder<STATE | ContextIdSet>& setContextId(const String& value)
        {
            static_assert(!(STATE & ContextIdSet), "property contextId should not be set yet");
            m_result->setContextId(value);
            return castState<ContextIdSet>();
        }

        AudioListenerWillBeDestroyedNotificationBuilder<STATE | ListenerIdSet>& setListenerId(const String& value)
        {
            static_assert(!(STATE & ListenerIdSet), "property listenerId should not be set yet");
            m_result->setListenerId(value);
            return castState<ListenerIdSet>();
        }

        std::unique_ptr<AudioListenerWillBeDestroyedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AudioListenerWillBeDestroyedNotification;
        AudioListenerWillBeDestroyedNotificationBuilder() : m_result(new AudioListenerWillBeDestroyedNotification()) { }

        template<int STEP> AudioListenerWillBeDestroyedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AudioListenerWillBeDestroyedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::WebAudio::AudioListenerWillBeDestroyedNotification> m_result;
    };

    static AudioListenerWillBeDestroyedNotificationBuilder<0> create()
    {
        return AudioListenerWillBeDestroyedNotificationBuilder<0>();
    }

private:
    AudioListenerWillBeDestroyedNotification()
    {
    }

    String m_contextId;
    String m_listenerId;
};


class CORE_EXPORT AudioNodeCreatedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(AudioNodeCreatedNotification);
public:
    static std::unique_ptr<AudioNodeCreatedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~AudioNodeCreatedNotification() override { }

    protocol::WebAudio::AudioNode* getNode() { return m_node.get(); }
    void setNode(std::unique_ptr<protocol::WebAudio::AudioNode> value) { m_node = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<AudioNodeCreatedNotification> clone() const;

    template<int STATE>
    class AudioNodeCreatedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            NodeSet = 1 << 1,
            AllFieldsSet = (NodeSet | 0)};


        AudioNodeCreatedNotificationBuilder<STATE | NodeSet>& setNode(std::unique_ptr<protocol::WebAudio::AudioNode> value)
        {
            static_assert(!(STATE & NodeSet), "property node should not be set yet");
            m_result->setNode(std::move(value));
            return castState<NodeSet>();
        }

        std::unique_ptr<AudioNodeCreatedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AudioNodeCreatedNotification;
        AudioNodeCreatedNotificationBuilder() : m_result(new AudioNodeCreatedNotification()) { }

        template<int STEP> AudioNodeCreatedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AudioNodeCreatedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::WebAudio::AudioNodeCreatedNotification> m_result;
    };

    static AudioNodeCreatedNotificationBuilder<0> create()
    {
        return AudioNodeCreatedNotificationBuilder<0>();
    }

private:
    AudioNodeCreatedNotification()
    {
    }

    std::unique_ptr<protocol::WebAudio::AudioNode> m_node;
};


class CORE_EXPORT AudioNodeWillBeDestroyedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(AudioNodeWillBeDestroyedNotification);
public:
    static std::unique_ptr<AudioNodeWillBeDestroyedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~AudioNodeWillBeDestroyedNotification() override { }

    String getContextId() { return m_contextId; }
    void setContextId(const String& value) { m_contextId = value; }

    String getNodeId() { return m_nodeId; }
    void setNodeId(const String& value) { m_nodeId = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<AudioNodeWillBeDestroyedNotification> clone() const;

    template<int STATE>
    class AudioNodeWillBeDestroyedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ContextIdSet = 1 << 1,
            NodeIdSet = 1 << 2,
            AllFieldsSet = (ContextIdSet | NodeIdSet | 0)};


        AudioNodeWillBeDestroyedNotificationBuilder<STATE | ContextIdSet>& setContextId(const String& value)
        {
            static_assert(!(STATE & ContextIdSet), "property contextId should not be set yet");
            m_result->setContextId(value);
            return castState<ContextIdSet>();
        }

        AudioNodeWillBeDestroyedNotificationBuilder<STATE | NodeIdSet>& setNodeId(const String& value)
        {
            static_assert(!(STATE & NodeIdSet), "property nodeId should not be set yet");
            m_result->setNodeId(value);
            return castState<NodeIdSet>();
        }

        std::unique_ptr<AudioNodeWillBeDestroyedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AudioNodeWillBeDestroyedNotification;
        AudioNodeWillBeDestroyedNotificationBuilder() : m_result(new AudioNodeWillBeDestroyedNotification()) { }

        template<int STEP> AudioNodeWillBeDestroyedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AudioNodeWillBeDestroyedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::WebAudio::AudioNodeWillBeDestroyedNotification> m_result;
    };

    static AudioNodeWillBeDestroyedNotificationBuilder<0> create()
    {
        return AudioNodeWillBeDestroyedNotificationBuilder<0>();
    }

private:
    AudioNodeWillBeDestroyedNotification()
    {
    }

    String m_contextId;
    String m_nodeId;
};


class CORE_EXPORT AudioParamCreatedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(AudioParamCreatedNotification);
public:
    static std::unique_ptr<AudioParamCreatedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~AudioParamCreatedNotification() override { }

    protocol::WebAudio::AudioParam* getParam() { return m_param.get(); }
    void setParam(std::unique_ptr<protocol::WebAudio::AudioParam> value) { m_param = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<AudioParamCreatedNotification> clone() const;

    template<int STATE>
    class AudioParamCreatedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ParamSet = 1 << 1,
            AllFieldsSet = (ParamSet | 0)};


        AudioParamCreatedNotificationBuilder<STATE | ParamSet>& setParam(std::unique_ptr<protocol::WebAudio::AudioParam> value)
        {
            static_assert(!(STATE & ParamSet), "property param should not be set yet");
            m_result->setParam(std::move(value));
            return castState<ParamSet>();
        }

        std::unique_ptr<AudioParamCreatedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AudioParamCreatedNotification;
        AudioParamCreatedNotificationBuilder() : m_result(new AudioParamCreatedNotification()) { }

        template<int STEP> AudioParamCreatedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AudioParamCreatedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::WebAudio::AudioParamCreatedNotification> m_result;
    };

    static AudioParamCreatedNotificationBuilder<0> create()
    {
        return AudioParamCreatedNotificationBuilder<0>();
    }

private:
    AudioParamCreatedNotification()
    {
    }

    std::unique_ptr<protocol::WebAudio::AudioParam> m_param;
};


class CORE_EXPORT AudioParamWillBeDestroyedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(AudioParamWillBeDestroyedNotification);
public:
    static std::unique_ptr<AudioParamWillBeDestroyedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~AudioParamWillBeDestroyedNotification() override { }

    String getContextId() { return m_contextId; }
    void setContextId(const String& value) { m_contextId = value; }

    String getNodeId() { return m_nodeId; }
    void setNodeId(const String& value) { m_nodeId = value; }

    String getParamId() { return m_paramId; }
    void setParamId(const String& value) { m_paramId = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<AudioParamWillBeDestroyedNotification> clone() const;

    template<int STATE>
    class AudioParamWillBeDestroyedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ContextIdSet = 1 << 1,
            NodeIdSet = 1 << 2,
            ParamIdSet = 1 << 3,
            AllFieldsSet = (ContextIdSet | NodeIdSet | ParamIdSet | 0)};


        AudioParamWillBeDestroyedNotificationBuilder<STATE | ContextIdSet>& setContextId(const String& value)
        {
            static_assert(!(STATE & ContextIdSet), "property contextId should not be set yet");
            m_result->setContextId(value);
            return castState<ContextIdSet>();
        }

        AudioParamWillBeDestroyedNotificationBuilder<STATE | NodeIdSet>& setNodeId(const String& value)
        {
            static_assert(!(STATE & NodeIdSet), "property nodeId should not be set yet");
            m_result->setNodeId(value);
            return castState<NodeIdSet>();
        }

        AudioParamWillBeDestroyedNotificationBuilder<STATE | ParamIdSet>& setParamId(const String& value)
        {
            static_assert(!(STATE & ParamIdSet), "property paramId should not be set yet");
            m_result->setParamId(value);
            return castState<ParamIdSet>();
        }

        std::unique_ptr<AudioParamWillBeDestroyedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AudioParamWillBeDestroyedNotification;
        AudioParamWillBeDestroyedNotificationBuilder() : m_result(new AudioParamWillBeDestroyedNotification()) { }

        template<int STEP> AudioParamWillBeDestroyedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AudioParamWillBeDestroyedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::WebAudio::AudioParamWillBeDestroyedNotification> m_result;
    };

    static AudioParamWillBeDestroyedNotificationBuilder<0> create()
    {
        return AudioParamWillBeDestroyedNotificationBuilder<0>();
    }

private:
    AudioParamWillBeDestroyedNotification()
    {
    }

    String m_contextId;
    String m_nodeId;
    String m_paramId;
};


class CORE_EXPORT NodesConnectedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(NodesConnectedNotification);
public:
    static std::unique_ptr<NodesConnectedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~NodesConnectedNotification() override { }

    String getContextId() { return m_contextId; }
    void setContextId(const String& value) { m_contextId = value; }

    String getSourceId() { return m_sourceId; }
    void setSourceId(const String& value) { m_sourceId = value; }

    String getDestinationId() { return m_destinationId; }
    void setDestinationId(const String& value) { m_destinationId = value; }

    bool hasSourceOutputIndex() { return m_sourceOutputIndex.isJust(); }
    double getSourceOutputIndex(double defaultValue) { return m_sourceOutputIndex.isJust() ? m_sourceOutputIndex.fromJust() : defaultValue; }
    void setSourceOutputIndex(double value) { m_sourceOutputIndex = value; }

    bool hasDestinationInputIndex() { return m_destinationInputIndex.isJust(); }
    double getDestinationInputIndex(double defaultValue) { return m_destinationInputIndex.isJust() ? m_destinationInputIndex.fromJust() : defaultValue; }
    void setDestinationInputIndex(double value) { m_destinationInputIndex = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<NodesConnectedNotification> clone() const;

    template<int STATE>
    class NodesConnectedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ContextIdSet = 1 << 1,
            SourceIdSet = 1 << 2,
            DestinationIdSet = 1 << 3,
            AllFieldsSet = (ContextIdSet | SourceIdSet | DestinationIdSet | 0)};


        NodesConnectedNotificationBuilder<STATE | ContextIdSet>& setContextId(const String& value)
        {
            static_assert(!(STATE & ContextIdSet), "property contextId should not be set yet");
            m_result->setContextId(value);
            return castState<ContextIdSet>();
        }

        NodesConnectedNotificationBuilder<STATE | SourceIdSet>& setSourceId(const String& value)
        {
            static_assert(!(STATE & SourceIdSet), "property sourceId should not be set yet");
            m_result->setSourceId(value);
            return castState<SourceIdSet>();
        }

        NodesConnectedNotificationBuilder<STATE | DestinationIdSet>& setDestinationId(const String& value)
        {
            static_assert(!(STATE & DestinationIdSet), "property destinationId should not be set yet");
            m_result->setDestinationId(value);
            return castState<DestinationIdSet>();
        }

        NodesConnectedNotificationBuilder<STATE>& setSourceOutputIndex(double value)
        {
            m_result->setSourceOutputIndex(value);
            return *this;
        }

        NodesConnectedNotificationBuilder<STATE>& setDestinationInputIndex(double value)
        {
            m_result->setDestinationInputIndex(value);
            return *this;
        }

        std::unique_ptr<NodesConnectedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class NodesConnectedNotification;
        NodesConnectedNotificationBuilder() : m_result(new NodesConnectedNotification()) { }

        template<int STEP> NodesConnectedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<NodesConnectedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::WebAudio::NodesConnectedNotification> m_result;
    };

    static NodesConnectedNotificationBuilder<0> create()
    {
        return NodesConnectedNotificationBuilder<0>();
    }

private:
    NodesConnectedNotification()
    {
    }

    String m_contextId;
    String m_sourceId;
    String m_destinationId;
    Maybe<double> m_sourceOutputIndex;
    Maybe<double> m_destinationInputIndex;
};


class CORE_EXPORT NodesDisconnectedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(NodesDisconnectedNotification);
public:
    static std::unique_ptr<NodesDisconnectedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~NodesDisconnectedNotification() override { }

    String getContextId() { return m_contextId; }
    void setContextId(const String& value) { m_contextId = value; }

    String getSourceId() { return m_sourceId; }
    void setSourceId(const String& value) { m_sourceId = value; }

    String getDestinationId() { return m_destinationId; }
    void setDestinationId(const String& value) { m_destinationId = value; }

    bool hasSourceOutputIndex() { return m_sourceOutputIndex.isJust(); }
    double getSourceOutputIndex(double defaultValue) { return m_sourceOutputIndex.isJust() ? m_sourceOutputIndex.fromJust() : defaultValue; }
    void setSourceOutputIndex(double value) { m_sourceOutputIndex = value; }

    bool hasDestinationInputIndex() { return m_destinationInputIndex.isJust(); }
    double getDestinationInputIndex(double defaultValue) { return m_destinationInputIndex.isJust() ? m_destinationInputIndex.fromJust() : defaultValue; }
    void setDestinationInputIndex(double value) { m_destinationInputIndex = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<NodesDisconnectedNotification> clone() const;

    template<int STATE>
    class NodesDisconnectedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ContextIdSet = 1 << 1,
            SourceIdSet = 1 << 2,
            DestinationIdSet = 1 << 3,
            AllFieldsSet = (ContextIdSet | SourceIdSet | DestinationIdSet | 0)};


        NodesDisconnectedNotificationBuilder<STATE | ContextIdSet>& setContextId(const String& value)
        {
            static_assert(!(STATE & ContextIdSet), "property contextId should not be set yet");
            m_result->setContextId(value);
            return castState<ContextIdSet>();
        }

        NodesDisconnectedNotificationBuilder<STATE | SourceIdSet>& setSourceId(const String& value)
        {
            static_assert(!(STATE & SourceIdSet), "property sourceId should not be set yet");
            m_result->setSourceId(value);
            return castState<SourceIdSet>();
        }

        NodesDisconnectedNotificationBuilder<STATE | DestinationIdSet>& setDestinationId(const String& value)
        {
            static_assert(!(STATE & DestinationIdSet), "property destinationId should not be set yet");
            m_result->setDestinationId(value);
            return castState<DestinationIdSet>();
        }

        NodesDisconnectedNotificationBuilder<STATE>& setSourceOutputIndex(double value)
        {
            m_result->setSourceOutputIndex(value);
            return *this;
        }

        NodesDisconnectedNotificationBuilder<STATE>& setDestinationInputIndex(double value)
        {
            m_result->setDestinationInputIndex(value);
            return *this;
        }

        std::unique_ptr<NodesDisconnectedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class NodesDisconnectedNotification;
        NodesDisconnectedNotificationBuilder() : m_result(new NodesDisconnectedNotification()) { }

        template<int STEP> NodesDisconnectedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<NodesDisconnectedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::WebAudio::NodesDisconnectedNotification> m_result;
    };

    static NodesDisconnectedNotificationBuilder<0> create()
    {
        return NodesDisconnectedNotificationBuilder<0>();
    }

private:
    NodesDisconnectedNotification()
    {
    }

    String m_contextId;
    String m_sourceId;
    String m_destinationId;
    Maybe<double> m_sourceOutputIndex;
    Maybe<double> m_destinationInputIndex;
};


class CORE_EXPORT NodeParamConnectedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(NodeParamConnectedNotification);
public:
    static std::unique_ptr<NodeParamConnectedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~NodeParamConnectedNotification() override { }

    String getContextId() { return m_contextId; }
    void setContextId(const String& value) { m_contextId = value; }

    String getSourceId() { return m_sourceId; }
    void setSourceId(const String& value) { m_sourceId = value; }

    String getDestinationId() { return m_destinationId; }
    void setDestinationId(const String& value) { m_destinationId = value; }

    bool hasSourceOutputIndex() { return m_sourceOutputIndex.isJust(); }
    double getSourceOutputIndex(double defaultValue) { return m_sourceOutputIndex.isJust() ? m_sourceOutputIndex.fromJust() : defaultValue; }
    void setSourceOutputIndex(double value) { m_sourceOutputIndex = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<NodeParamConnectedNotification> clone() const;

    template<int STATE>
    class NodeParamConnectedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ContextIdSet = 1 << 1,
            SourceIdSet = 1 << 2,
            DestinationIdSet = 1 << 3,
            AllFieldsSet = (ContextIdSet | SourceIdSet | DestinationIdSet | 0)};


        NodeParamConnectedNotificationBuilder<STATE | ContextIdSet>& setContextId(const String& value)
        {
            static_assert(!(STATE & ContextIdSet), "property contextId should not be set yet");
            m_result->setContextId(value);
            return castState<ContextIdSet>();
        }

        NodeParamConnectedNotificationBuilder<STATE | SourceIdSet>& setSourceId(const String& value)
        {
            static_assert(!(STATE & SourceIdSet), "property sourceId should not be set yet");
            m_result->setSourceId(value);
            return castState<SourceIdSet>();
        }

        NodeParamConnectedNotificationBuilder<STATE | DestinationIdSet>& setDestinationId(const String& value)
        {
            static_assert(!(STATE & DestinationIdSet), "property destinationId should not be set yet");
            m_result->setDestinationId(value);
            return castState<DestinationIdSet>();
        }

        NodeParamConnectedNotificationBuilder<STATE>& setSourceOutputIndex(double value)
        {
            m_result->setSourceOutputIndex(value);
            return *this;
        }

        std::unique_ptr<NodeParamConnectedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class NodeParamConnectedNotification;
        NodeParamConnectedNotificationBuilder() : m_result(new NodeParamConnectedNotification()) { }

        template<int STEP> NodeParamConnectedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<NodeParamConnectedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::WebAudio::NodeParamConnectedNotification> m_result;
    };

    static NodeParamConnectedNotificationBuilder<0> create()
    {
        return NodeParamConnectedNotificationBuilder<0>();
    }

private:
    NodeParamConnectedNotification()
    {
    }

    String m_contextId;
    String m_sourceId;
    String m_destinationId;
    Maybe<double> m_sourceOutputIndex;
};


class CORE_EXPORT NodeParamDisconnectedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(NodeParamDisconnectedNotification);
public:
    static std::unique_ptr<NodeParamDisconnectedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~NodeParamDisconnectedNotification() override { }

    String getContextId() { return m_contextId; }
    void setContextId(const String& value) { m_contextId = value; }

    String getSourceId() { return m_sourceId; }
    void setSourceId(const String& value) { m_sourceId = value; }

    String getDestinationId() { return m_destinationId; }
    void setDestinationId(const String& value) { m_destinationId = value; }

    bool hasSourceOutputIndex() { return m_sourceOutputIndex.isJust(); }
    double getSourceOutputIndex(double defaultValue) { return m_sourceOutputIndex.isJust() ? m_sourceOutputIndex.fromJust() : defaultValue; }
    void setSourceOutputIndex(double value) { m_sourceOutputIndex = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<NodeParamDisconnectedNotification> clone() const;

    template<int STATE>
    class NodeParamDisconnectedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ContextIdSet = 1 << 1,
            SourceIdSet = 1 << 2,
            DestinationIdSet = 1 << 3,
            AllFieldsSet = (ContextIdSet | SourceIdSet | DestinationIdSet | 0)};


        NodeParamDisconnectedNotificationBuilder<STATE | ContextIdSet>& setContextId(const String& value)
        {
            static_assert(!(STATE & ContextIdSet), "property contextId should not be set yet");
            m_result->setContextId(value);
            return castState<ContextIdSet>();
        }

        NodeParamDisconnectedNotificationBuilder<STATE | SourceIdSet>& setSourceId(const String& value)
        {
            static_assert(!(STATE & SourceIdSet), "property sourceId should not be set yet");
            m_result->setSourceId(value);
            return castState<SourceIdSet>();
        }

        NodeParamDisconnectedNotificationBuilder<STATE | DestinationIdSet>& setDestinationId(const String& value)
        {
            static_assert(!(STATE & DestinationIdSet), "property destinationId should not be set yet");
            m_result->setDestinationId(value);
            return castState<DestinationIdSet>();
        }

        NodeParamDisconnectedNotificationBuilder<STATE>& setSourceOutputIndex(double value)
        {
            m_result->setSourceOutputIndex(value);
            return *this;
        }

        std::unique_ptr<NodeParamDisconnectedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class NodeParamDisconnectedNotification;
        NodeParamDisconnectedNotificationBuilder() : m_result(new NodeParamDisconnectedNotification()) { }

        template<int STEP> NodeParamDisconnectedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<NodeParamDisconnectedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::WebAudio::NodeParamDisconnectedNotification> m_result;
    };

    static NodeParamDisconnectedNotificationBuilder<0> create()
    {
        return NodeParamDisconnectedNotificationBuilder<0>();
    }

private:
    NodeParamDisconnectedNotification()
    {
    }

    String m_contextId;
    String m_sourceId;
    String m_destinationId;
    Maybe<double> m_sourceOutputIndex;
};


// ------------- Backend interface.

class CORE_EXPORT Backend {
public:
    virtual ~Backend() { }

    virtual DispatchResponse enable() = 0;
    virtual DispatchResponse disable() = 0;
    virtual DispatchResponse getRealtimeData(const String& in_contextId, std::unique_ptr<protocol::WebAudio::ContextRealtimeData>* out_realtimeData) = 0;

};

// ------------- Frontend interface.

class CORE_EXPORT Frontend {
public:
    explicit Frontend(FrontendChannel* frontendChannel) : m_frontendChannel(frontendChannel) { }
    void contextCreated(std::unique_ptr<protocol::WebAudio::BaseAudioContext> context);
    void contextWillBeDestroyed(const String& contextId);
    void contextChanged(std::unique_ptr<protocol::WebAudio::BaseAudioContext> context);
    void audioListenerCreated(std::unique_ptr<protocol::WebAudio::AudioListener> listener);
    void audioListenerWillBeDestroyed(const String& contextId, const String& listenerId);
    void audioNodeCreated(std::unique_ptr<protocol::WebAudio::AudioNode> node);
    void audioNodeWillBeDestroyed(const String& contextId, const String& nodeId);
    void audioParamCreated(std::unique_ptr<protocol::WebAudio::AudioParam> param);
    void audioParamWillBeDestroyed(const String& contextId, const String& nodeId, const String& paramId);
    void nodesConnected(const String& contextId, const String& sourceId, const String& destinationId, Maybe<double> sourceOutputIndex = Maybe<double>(), Maybe<double> destinationInputIndex = Maybe<double>());
    void nodesDisconnected(const String& contextId, const String& sourceId, const String& destinationId, Maybe<double> sourceOutputIndex = Maybe<double>(), Maybe<double> destinationInputIndex = Maybe<double>());
    void nodeParamConnected(const String& contextId, const String& sourceId, const String& destinationId, Maybe<double> sourceOutputIndex = Maybe<double>());
    void nodeParamDisconnected(const String& contextId, const String& sourceId, const String& destinationId, Maybe<double> sourceOutputIndex = Maybe<double>());

    void flush();
    void sendRawCBORNotification(std::vector<uint8_t>);
private:
    FrontendChannel* m_frontendChannel;
};

// ------------- Dispatcher.

class CORE_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher() { }
};

// ------------- Metainfo.

class CORE_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace WebAudio
} // namespace blink
} // namespace protocol

#endif // !defined(blink_protocol_WebAudio_h)
