// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ukm/report.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ukm_2freport_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ukm_2freport_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "ukm/aggregate.pb.h"
#include "ukm/entry.pb.h"
#include "ukm/source.pb.h"
#include "system_profile.pb.h"
#include "user_demographics.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ukm_2freport_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ukm_2freport_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[2]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace ukm {
class Report;
class ReportDefaultTypeInternal;
extern ReportDefaultTypeInternal _Report_default_instance_;
class Report_SourceCounts;
class Report_SourceCountsDefaultTypeInternal;
extern Report_SourceCountsDefaultTypeInternal _Report_SourceCounts_default_instance_;
}  // namespace ukm
PROTOBUF_NAMESPACE_OPEN
template<> ::ukm::Report* Arena::CreateMaybeMessage<::ukm::Report>(Arena*);
template<> ::ukm::Report_SourceCounts* Arena::CreateMaybeMessage<::ukm::Report_SourceCounts>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ukm {

enum Report_LogRotationReason : int {
  Report_LogRotationReason_UNKNOWN = 0,
  Report_LogRotationReason_SCHEDULED_ROTATION = 1,
  Report_LogRotationReason_BACKGROUNDED = 2,
  Report_LogRotationReason_SHUTDOWN = 3
};
bool Report_LogRotationReason_IsValid(int value);
constexpr Report_LogRotationReason Report_LogRotationReason_LogRotationReason_MIN = Report_LogRotationReason_UNKNOWN;
constexpr Report_LogRotationReason Report_LogRotationReason_LogRotationReason_MAX = Report_LogRotationReason_SHUTDOWN;
constexpr int Report_LogRotationReason_LogRotationReason_ARRAYSIZE = Report_LogRotationReason_LogRotationReason_MAX + 1;

const std::string& Report_LogRotationReason_Name(Report_LogRotationReason value);
template<typename T>
inline const std::string& Report_LogRotationReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Report_LogRotationReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Report_LogRotationReason_Name.");
  return Report_LogRotationReason_Name(static_cast<Report_LogRotationReason>(enum_t_value));
}
bool Report_LogRotationReason_Parse(
    const std::string& name, Report_LogRotationReason* value);
// ===================================================================

class Report_SourceCounts :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ukm.Report.SourceCounts) */ {
 public:
  Report_SourceCounts();
  virtual ~Report_SourceCounts();

  Report_SourceCounts(const Report_SourceCounts& from);
  Report_SourceCounts(Report_SourceCounts&& from) noexcept
    : Report_SourceCounts() {
    *this = ::std::move(from);
  }

  inline Report_SourceCounts& operator=(const Report_SourceCounts& from) {
    CopyFrom(from);
    return *this;
  }
  inline Report_SourceCounts& operator=(Report_SourceCounts&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Report_SourceCounts& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Report_SourceCounts* internal_default_instance() {
    return reinterpret_cast<const Report_SourceCounts*>(
               &_Report_SourceCounts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Report_SourceCounts& a, Report_SourceCounts& b) {
    a.Swap(&b);
  }
  inline void Swap(Report_SourceCounts* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Report_SourceCounts* New() const final {
    return CreateMaybeMessage<Report_SourceCounts>(nullptr);
  }

  Report_SourceCounts* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Report_SourceCounts>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Report_SourceCounts& from);
  void MergeFrom(const Report_SourceCounts& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Report_SourceCounts* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ukm.Report.SourceCounts";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObservedFieldNumber = 1,
    kNavigationSourcesFieldNumber = 2,
    kUnmatchedSourcesFieldNumber = 3,
    kCarryoverSourcesFieldNumber = 4,
    kDeferredSourcesFieldNumber = 5,
    kEntrylessSourcesFieldNumber = 6,
    kPrunedSourcesAgeSecondsFieldNumber = 7,
  };
  // optional int32 observed = 1;
  bool has_observed() const;
  void clear_observed();
  ::PROTOBUF_NAMESPACE_ID::int32 observed() const;
  void set_observed(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 navigation_sources = 2;
  bool has_navigation_sources() const;
  void clear_navigation_sources();
  ::PROTOBUF_NAMESPACE_ID::int32 navigation_sources() const;
  void set_navigation_sources(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 unmatched_sources = 3;
  bool has_unmatched_sources() const;
  void clear_unmatched_sources();
  ::PROTOBUF_NAMESPACE_ID::int32 unmatched_sources() const;
  void set_unmatched_sources(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 carryover_sources = 4;
  bool has_carryover_sources() const;
  void clear_carryover_sources();
  ::PROTOBUF_NAMESPACE_ID::int32 carryover_sources() const;
  void set_carryover_sources(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 deferred_sources = 5;
  bool has_deferred_sources() const;
  void clear_deferred_sources();
  ::PROTOBUF_NAMESPACE_ID::int32 deferred_sources() const;
  void set_deferred_sources(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 entryless_sources = 6;
  bool has_entryless_sources() const;
  void clear_entryless_sources();
  ::PROTOBUF_NAMESPACE_ID::int32 entryless_sources() const;
  void set_entryless_sources(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 pruned_sources_age_seconds = 7;
  bool has_pruned_sources_age_seconds() const;
  void clear_pruned_sources_age_seconds();
  ::PROTOBUF_NAMESPACE_ID::int32 pruned_sources_age_seconds() const;
  void set_pruned_sources_age_seconds(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:ukm.Report.SourceCounts)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 observed_;
  ::PROTOBUF_NAMESPACE_ID::int32 navigation_sources_;
  ::PROTOBUF_NAMESPACE_ID::int32 unmatched_sources_;
  ::PROTOBUF_NAMESPACE_ID::int32 carryover_sources_;
  ::PROTOBUF_NAMESPACE_ID::int32 deferred_sources_;
  ::PROTOBUF_NAMESPACE_ID::int32 entryless_sources_;
  ::PROTOBUF_NAMESPACE_ID::int32 pruned_sources_age_seconds_;
  friend struct ::TableStruct_ukm_2freport_2eproto;
};
// -------------------------------------------------------------------

class Report :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ukm.Report) */ {
 public:
  Report();
  virtual ~Report();

  Report(const Report& from);
  Report(Report&& from) noexcept
    : Report() {
    *this = ::std::move(from);
  }

  inline Report& operator=(const Report& from) {
    CopyFrom(from);
    return *this;
  }
  inline Report& operator=(Report&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Report& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Report* internal_default_instance() {
    return reinterpret_cast<const Report*>(
               &_Report_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Report& a, Report& b) {
    a.Swap(&b);
  }
  inline void Swap(Report* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Report* New() const final {
    return CreateMaybeMessage<Report>(nullptr);
  }

  Report* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Report>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Report& from);
  void MergeFrom(const Report& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Report* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ukm.Report";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Report_SourceCounts SourceCounts;

  typedef Report_LogRotationReason LogRotationReason;
  static constexpr LogRotationReason UNKNOWN =
    Report_LogRotationReason_UNKNOWN;
  static constexpr LogRotationReason SCHEDULED_ROTATION =
    Report_LogRotationReason_SCHEDULED_ROTATION;
  static constexpr LogRotationReason BACKGROUNDED =
    Report_LogRotationReason_BACKGROUNDED;
  static constexpr LogRotationReason SHUTDOWN =
    Report_LogRotationReason_SHUTDOWN;
  static inline bool LogRotationReason_IsValid(int value) {
    return Report_LogRotationReason_IsValid(value);
  }
  static constexpr LogRotationReason LogRotationReason_MIN =
    Report_LogRotationReason_LogRotationReason_MIN;
  static constexpr LogRotationReason LogRotationReason_MAX =
    Report_LogRotationReason_LogRotationReason_MAX;
  static constexpr int LogRotationReason_ARRAYSIZE =
    Report_LogRotationReason_LogRotationReason_ARRAYSIZE;
  template<typename T>
  static inline const std::string& LogRotationReason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LogRotationReason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LogRotationReason_Name.");
    return Report_LogRotationReason_Name(enum_t_value);
  }
  static inline bool LogRotationReason_Parse(const std::string& name,
      LogRotationReason* value) {
    return Report_LogRotationReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSourcesFieldNumber = 3,
    kEntriesFieldNumber = 4,
    kAggregatesFieldNumber = 7,
    kSystemProfileFieldNumber = 2,
    kSourceCountsFieldNumber = 10,
    kUserDemographicsFieldNumber = 11,
    kClientIdFieldNumber = 1,
    kSessionIdFieldNumber = 5,
    kReportIdFieldNumber = 6,
    kIsContinuousFieldNumber = 8,
    kLogRotationReasonFieldNumber = 9,
  };
  // repeated .ukm.Source sources = 3;
  int sources_size() const;
  void clear_sources();
  ::ukm::Source* mutable_sources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Source >*
      mutable_sources();
  const ::ukm::Source& sources(int index) const;
  ::ukm::Source* add_sources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Source >&
      sources() const;

  // repeated .ukm.Entry entries = 4;
  int entries_size() const;
  void clear_entries();
  ::ukm::Entry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Entry >*
      mutable_entries();
  const ::ukm::Entry& entries(int index) const;
  ::ukm::Entry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Entry >&
      entries() const;

  // repeated .ukm.Aggregate aggregates = 7;
  int aggregates_size() const;
  void clear_aggregates();
  ::ukm::Aggregate* mutable_aggregates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Aggregate >*
      mutable_aggregates();
  const ::ukm::Aggregate& aggregates(int index) const;
  ::ukm::Aggregate* add_aggregates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Aggregate >&
      aggregates() const;

  // optional .metrics.SystemProfileProto system_profile = 2;
  bool has_system_profile() const;
  void clear_system_profile();
  const ::metrics::SystemProfileProto& system_profile() const;
  ::metrics::SystemProfileProto* release_system_profile();
  ::metrics::SystemProfileProto* mutable_system_profile();
  void set_allocated_system_profile(::metrics::SystemProfileProto* system_profile);

  // optional .ukm.Report.SourceCounts source_counts = 10;
  bool has_source_counts() const;
  void clear_source_counts();
  const ::ukm::Report_SourceCounts& source_counts() const;
  ::ukm::Report_SourceCounts* release_source_counts();
  ::ukm::Report_SourceCounts* mutable_source_counts();
  void set_allocated_source_counts(::ukm::Report_SourceCounts* source_counts);

  // optional .metrics.UserDemographicsProto user_demographics = 11;
  bool has_user_demographics() const;
  void clear_user_demographics();
  const ::metrics::UserDemographicsProto& user_demographics() const;
  ::metrics::UserDemographicsProto* release_user_demographics();
  ::metrics::UserDemographicsProto* mutable_user_demographics();
  void set_allocated_user_demographics(::metrics::UserDemographicsProto* user_demographics);

  // optional fixed64 client_id = 1;
  bool has_client_id() const;
  void clear_client_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 client_id() const;
  void set_client_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional int32 session_id = 5;
  bool has_session_id() const;
  void clear_session_id();
  ::PROTOBUF_NAMESPACE_ID::int32 session_id() const;
  void set_session_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 report_id = 6;
  bool has_report_id() const;
  void clear_report_id();
  ::PROTOBUF_NAMESPACE_ID::int32 report_id() const;
  void set_report_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional bool is_continuous = 8;
  bool has_is_continuous() const;
  void clear_is_continuous();
  bool is_continuous() const;
  void set_is_continuous(bool value);

  // optional .ukm.Report.LogRotationReason log_rotation_reason = 9;
  bool has_log_rotation_reason() const;
  void clear_log_rotation_reason();
  ::ukm::Report_LogRotationReason log_rotation_reason() const;
  void set_log_rotation_reason(::ukm::Report_LogRotationReason value);

  // @@protoc_insertion_point(class_scope:ukm.Report)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Source > sources_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Entry > entries_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Aggregate > aggregates_;
  ::metrics::SystemProfileProto* system_profile_;
  ::ukm::Report_SourceCounts* source_counts_;
  ::metrics::UserDemographicsProto* user_demographics_;
  ::PROTOBUF_NAMESPACE_ID::uint64 client_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 session_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 report_id_;
  bool is_continuous_;
  int log_rotation_reason_;
  friend struct ::TableStruct_ukm_2freport_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Report_SourceCounts

// optional int32 observed = 1;
inline bool Report_SourceCounts::has_observed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Report_SourceCounts::clear_observed() {
  observed_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Report_SourceCounts::observed() const {
  // @@protoc_insertion_point(field_get:ukm.Report.SourceCounts.observed)
  return observed_;
}
inline void Report_SourceCounts::set_observed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  observed_ = value;
  // @@protoc_insertion_point(field_set:ukm.Report.SourceCounts.observed)
}

// optional int32 navigation_sources = 2;
inline bool Report_SourceCounts::has_navigation_sources() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Report_SourceCounts::clear_navigation_sources() {
  navigation_sources_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Report_SourceCounts::navigation_sources() const {
  // @@protoc_insertion_point(field_get:ukm.Report.SourceCounts.navigation_sources)
  return navigation_sources_;
}
inline void Report_SourceCounts::set_navigation_sources(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  navigation_sources_ = value;
  // @@protoc_insertion_point(field_set:ukm.Report.SourceCounts.navigation_sources)
}

// optional int32 unmatched_sources = 3;
inline bool Report_SourceCounts::has_unmatched_sources() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Report_SourceCounts::clear_unmatched_sources() {
  unmatched_sources_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Report_SourceCounts::unmatched_sources() const {
  // @@protoc_insertion_point(field_get:ukm.Report.SourceCounts.unmatched_sources)
  return unmatched_sources_;
}
inline void Report_SourceCounts::set_unmatched_sources(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  unmatched_sources_ = value;
  // @@protoc_insertion_point(field_set:ukm.Report.SourceCounts.unmatched_sources)
}

// optional int32 carryover_sources = 4;
inline bool Report_SourceCounts::has_carryover_sources() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Report_SourceCounts::clear_carryover_sources() {
  carryover_sources_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Report_SourceCounts::carryover_sources() const {
  // @@protoc_insertion_point(field_get:ukm.Report.SourceCounts.carryover_sources)
  return carryover_sources_;
}
inline void Report_SourceCounts::set_carryover_sources(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  carryover_sources_ = value;
  // @@protoc_insertion_point(field_set:ukm.Report.SourceCounts.carryover_sources)
}

// optional int32 deferred_sources = 5;
inline bool Report_SourceCounts::has_deferred_sources() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Report_SourceCounts::clear_deferred_sources() {
  deferred_sources_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Report_SourceCounts::deferred_sources() const {
  // @@protoc_insertion_point(field_get:ukm.Report.SourceCounts.deferred_sources)
  return deferred_sources_;
}
inline void Report_SourceCounts::set_deferred_sources(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  deferred_sources_ = value;
  // @@protoc_insertion_point(field_set:ukm.Report.SourceCounts.deferred_sources)
}

// optional int32 entryless_sources = 6;
inline bool Report_SourceCounts::has_entryless_sources() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Report_SourceCounts::clear_entryless_sources() {
  entryless_sources_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Report_SourceCounts::entryless_sources() const {
  // @@protoc_insertion_point(field_get:ukm.Report.SourceCounts.entryless_sources)
  return entryless_sources_;
}
inline void Report_SourceCounts::set_entryless_sources(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  entryless_sources_ = value;
  // @@protoc_insertion_point(field_set:ukm.Report.SourceCounts.entryless_sources)
}

// optional int32 pruned_sources_age_seconds = 7;
inline bool Report_SourceCounts::has_pruned_sources_age_seconds() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Report_SourceCounts::clear_pruned_sources_age_seconds() {
  pruned_sources_age_seconds_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Report_SourceCounts::pruned_sources_age_seconds() const {
  // @@protoc_insertion_point(field_get:ukm.Report.SourceCounts.pruned_sources_age_seconds)
  return pruned_sources_age_seconds_;
}
inline void Report_SourceCounts::set_pruned_sources_age_seconds(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  pruned_sources_age_seconds_ = value;
  // @@protoc_insertion_point(field_set:ukm.Report.SourceCounts.pruned_sources_age_seconds)
}

// -------------------------------------------------------------------

// Report

// optional fixed64 client_id = 1;
inline bool Report::has_client_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Report::clear_client_id() {
  client_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Report::client_id() const {
  // @@protoc_insertion_point(field_get:ukm.Report.client_id)
  return client_id_;
}
inline void Report::set_client_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  client_id_ = value;
  // @@protoc_insertion_point(field_set:ukm.Report.client_id)
}

// optional int32 session_id = 5;
inline bool Report::has_session_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Report::clear_session_id() {
  session_id_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Report::session_id() const {
  // @@protoc_insertion_point(field_get:ukm.Report.session_id)
  return session_id_;
}
inline void Report::set_session_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  session_id_ = value;
  // @@protoc_insertion_point(field_set:ukm.Report.session_id)
}

// optional int32 report_id = 6;
inline bool Report::has_report_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Report::clear_report_id() {
  report_id_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Report::report_id() const {
  // @@protoc_insertion_point(field_get:ukm.Report.report_id)
  return report_id_;
}
inline void Report::set_report_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  report_id_ = value;
  // @@protoc_insertion_point(field_set:ukm.Report.report_id)
}

// optional bool is_continuous = 8;
inline bool Report::has_is_continuous() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Report::clear_is_continuous() {
  is_continuous_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool Report::is_continuous() const {
  // @@protoc_insertion_point(field_get:ukm.Report.is_continuous)
  return is_continuous_;
}
inline void Report::set_is_continuous(bool value) {
  _has_bits_[0] |= 0x00000040u;
  is_continuous_ = value;
  // @@protoc_insertion_point(field_set:ukm.Report.is_continuous)
}

// optional .ukm.Report.LogRotationReason log_rotation_reason = 9;
inline bool Report::has_log_rotation_reason() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Report::clear_log_rotation_reason() {
  log_rotation_reason_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::ukm::Report_LogRotationReason Report::log_rotation_reason() const {
  // @@protoc_insertion_point(field_get:ukm.Report.log_rotation_reason)
  return static_cast< ::ukm::Report_LogRotationReason >(log_rotation_reason_);
}
inline void Report::set_log_rotation_reason(::ukm::Report_LogRotationReason value) {
  assert(::ukm::Report_LogRotationReason_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  log_rotation_reason_ = value;
  // @@protoc_insertion_point(field_set:ukm.Report.log_rotation_reason)
}

// optional .metrics.SystemProfileProto system_profile = 2;
inline bool Report::has_system_profile() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::metrics::SystemProfileProto& Report::system_profile() const {
  const ::metrics::SystemProfileProto* p = system_profile_;
  // @@protoc_insertion_point(field_get:ukm.Report.system_profile)
  return p != nullptr ? *p : *reinterpret_cast<const ::metrics::SystemProfileProto*>(
      &::metrics::_SystemProfileProto_default_instance_);
}
inline ::metrics::SystemProfileProto* Report::release_system_profile() {
  // @@protoc_insertion_point(field_release:ukm.Report.system_profile)
  _has_bits_[0] &= ~0x00000001u;
  ::metrics::SystemProfileProto* temp = system_profile_;
  system_profile_ = nullptr;
  return temp;
}
inline ::metrics::SystemProfileProto* Report::mutable_system_profile() {
  _has_bits_[0] |= 0x00000001u;
  if (system_profile_ == nullptr) {
    auto* p = CreateMaybeMessage<::metrics::SystemProfileProto>(GetArenaNoVirtual());
    system_profile_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ukm.Report.system_profile)
  return system_profile_;
}
inline void Report::set_allocated_system_profile(::metrics::SystemProfileProto* system_profile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(system_profile_);
  }
  if (system_profile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      system_profile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_profile, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  system_profile_ = system_profile;
  // @@protoc_insertion_point(field_set_allocated:ukm.Report.system_profile)
}

// optional .metrics.UserDemographicsProto user_demographics = 11;
inline bool Report::has_user_demographics() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline const ::metrics::UserDemographicsProto& Report::user_demographics() const {
  const ::metrics::UserDemographicsProto* p = user_demographics_;
  // @@protoc_insertion_point(field_get:ukm.Report.user_demographics)
  return p != nullptr ? *p : *reinterpret_cast<const ::metrics::UserDemographicsProto*>(
      &::metrics::_UserDemographicsProto_default_instance_);
}
inline ::metrics::UserDemographicsProto* Report::release_user_demographics() {
  // @@protoc_insertion_point(field_release:ukm.Report.user_demographics)
  _has_bits_[0] &= ~0x00000004u;
  ::metrics::UserDemographicsProto* temp = user_demographics_;
  user_demographics_ = nullptr;
  return temp;
}
inline ::metrics::UserDemographicsProto* Report::mutable_user_demographics() {
  _has_bits_[0] |= 0x00000004u;
  if (user_demographics_ == nullptr) {
    auto* p = CreateMaybeMessage<::metrics::UserDemographicsProto>(GetArenaNoVirtual());
    user_demographics_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ukm.Report.user_demographics)
  return user_demographics_;
}
inline void Report::set_allocated_user_demographics(::metrics::UserDemographicsProto* user_demographics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_demographics_);
  }
  if (user_demographics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      user_demographics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_demographics, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  user_demographics_ = user_demographics;
  // @@protoc_insertion_point(field_set_allocated:ukm.Report.user_demographics)
}

// repeated .ukm.Source sources = 3;
inline int Report::sources_size() const {
  return sources_.size();
}
inline ::ukm::Source* Report::mutable_sources(int index) {
  // @@protoc_insertion_point(field_mutable:ukm.Report.sources)
  return sources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Source >*
Report::mutable_sources() {
  // @@protoc_insertion_point(field_mutable_list:ukm.Report.sources)
  return &sources_;
}
inline const ::ukm::Source& Report::sources(int index) const {
  // @@protoc_insertion_point(field_get:ukm.Report.sources)
  return sources_.Get(index);
}
inline ::ukm::Source* Report::add_sources() {
  // @@protoc_insertion_point(field_add:ukm.Report.sources)
  return sources_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Source >&
Report::sources() const {
  // @@protoc_insertion_point(field_list:ukm.Report.sources)
  return sources_;
}

// optional .ukm.Report.SourceCounts source_counts = 10;
inline bool Report::has_source_counts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Report::clear_source_counts() {
  if (source_counts_ != nullptr) source_counts_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ukm::Report_SourceCounts& Report::source_counts() const {
  const ::ukm::Report_SourceCounts* p = source_counts_;
  // @@protoc_insertion_point(field_get:ukm.Report.source_counts)
  return p != nullptr ? *p : *reinterpret_cast<const ::ukm::Report_SourceCounts*>(
      &::ukm::_Report_SourceCounts_default_instance_);
}
inline ::ukm::Report_SourceCounts* Report::release_source_counts() {
  // @@protoc_insertion_point(field_release:ukm.Report.source_counts)
  _has_bits_[0] &= ~0x00000002u;
  ::ukm::Report_SourceCounts* temp = source_counts_;
  source_counts_ = nullptr;
  return temp;
}
inline ::ukm::Report_SourceCounts* Report::mutable_source_counts() {
  _has_bits_[0] |= 0x00000002u;
  if (source_counts_ == nullptr) {
    auto* p = CreateMaybeMessage<::ukm::Report_SourceCounts>(GetArenaNoVirtual());
    source_counts_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ukm.Report.source_counts)
  return source_counts_;
}
inline void Report::set_allocated_source_counts(::ukm::Report_SourceCounts* source_counts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete source_counts_;
  }
  if (source_counts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      source_counts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_counts, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  source_counts_ = source_counts;
  // @@protoc_insertion_point(field_set_allocated:ukm.Report.source_counts)
}

// repeated .ukm.Entry entries = 4;
inline int Report::entries_size() const {
  return entries_.size();
}
inline ::ukm::Entry* Report::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:ukm.Report.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Entry >*
Report::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:ukm.Report.entries)
  return &entries_;
}
inline const ::ukm::Entry& Report::entries(int index) const {
  // @@protoc_insertion_point(field_get:ukm.Report.entries)
  return entries_.Get(index);
}
inline ::ukm::Entry* Report::add_entries() {
  // @@protoc_insertion_point(field_add:ukm.Report.entries)
  return entries_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Entry >&
Report::entries() const {
  // @@protoc_insertion_point(field_list:ukm.Report.entries)
  return entries_;
}

// repeated .ukm.Aggregate aggregates = 7;
inline int Report::aggregates_size() const {
  return aggregates_.size();
}
inline ::ukm::Aggregate* Report::mutable_aggregates(int index) {
  // @@protoc_insertion_point(field_mutable:ukm.Report.aggregates)
  return aggregates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Aggregate >*
Report::mutable_aggregates() {
  // @@protoc_insertion_point(field_mutable_list:ukm.Report.aggregates)
  return &aggregates_;
}
inline const ::ukm::Aggregate& Report::aggregates(int index) const {
  // @@protoc_insertion_point(field_get:ukm.Report.aggregates)
  return aggregates_.Get(index);
}
inline ::ukm::Aggregate* Report::add_aggregates() {
  // @@protoc_insertion_point(field_add:ukm.Report.aggregates)
  return aggregates_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Aggregate >&
Report::aggregates() const {
  // @@protoc_insertion_point(field_list:ukm.Report.aggregates)
  return aggregates_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ukm

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ukm::Report_LogRotationReason> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ukm_2freport_2eproto
