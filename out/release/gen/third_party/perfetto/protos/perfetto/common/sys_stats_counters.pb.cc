// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/sys_stats_counters.proto

#include "protos/perfetto/common/sys_stats_counters.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace perfetto {
namespace protos {
}  // namespace protos
}  // namespace perfetto
namespace perfetto {
namespace protos {
bool MeminfoCounters_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MeminfoCounters_strings[34] = {};

static const char MeminfoCounters_names[] =
  "MEMINFO_ACTIVE"
  "MEMINFO_ACTIVE_ANON"
  "MEMINFO_ACTIVE_FILE"
  "MEMINFO_ANON_PAGES"
  "MEMINFO_BUFFERS"
  "MEMINFO_CACHED"
  "MEMINFO_CMA_FREE"
  "MEMINFO_CMA_TOTAL"
  "MEMINFO_COMMITED_AS"
  "MEMINFO_COMMIT_LIMIT"
  "MEMINFO_DIRTY"
  "MEMINFO_INACTIVE"
  "MEMINFO_INACTIVE_ANON"
  "MEMINFO_INACTIVE_FILE"
  "MEMINFO_KERNEL_STACK"
  "MEMINFO_MAPPED"
  "MEMINFO_MEM_AVAILABLE"
  "MEMINFO_MEM_FREE"
  "MEMINFO_MEM_TOTAL"
  "MEMINFO_MLOCKED"
  "MEMINFO_PAGE_TABLES"
  "MEMINFO_SHMEM"
  "MEMINFO_SLAB"
  "MEMINFO_SLAB_RECLAIMABLE"
  "MEMINFO_SLAB_UNRECLAIMABLE"
  "MEMINFO_SWAP_CACHED"
  "MEMINFO_SWAP_FREE"
  "MEMINFO_SWAP_TOTAL"
  "MEMINFO_UNEVICTABLE"
  "MEMINFO_UNSPECIFIED"
  "MEMINFO_VMALLOC_CHUNK"
  "MEMINFO_VMALLOC_TOTAL"
  "MEMINFO_VMALLOC_USED"
  "MEMINFO_WRITEBACK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MeminfoCounters_entries[] = {
  { {MeminfoCounters_names + 0, 14}, 7 },
  { {MeminfoCounters_names + 14, 19}, 9 },
  { {MeminfoCounters_names + 33, 19}, 11 },
  { {MeminfoCounters_names + 52, 18}, 19 },
  { {MeminfoCounters_names + 70, 15}, 4 },
  { {MeminfoCounters_names + 85, 14}, 5 },
  { {MeminfoCounters_names + 99, 16}, 33 },
  { {MeminfoCounters_names + 115, 17}, 32 },
  { {MeminfoCounters_names + 132, 19}, 28 },
  { {MeminfoCounters_names + 151, 20}, 27 },
  { {MeminfoCounters_names + 171, 13}, 17 },
  { {MeminfoCounters_names + 184, 16}, 8 },
  { {MeminfoCounters_names + 200, 21}, 10 },
  { {MeminfoCounters_names + 221, 21}, 12 },
  { {MeminfoCounters_names + 242, 20}, 25 },
  { {MeminfoCounters_names + 262, 14}, 20 },
  { {MeminfoCounters_names + 276, 21}, 3 },
  { {MeminfoCounters_names + 297, 16}, 2 },
  { {MeminfoCounters_names + 313, 17}, 1 },
  { {MeminfoCounters_names + 330, 15}, 14 },
  { {MeminfoCounters_names + 345, 19}, 26 },
  { {MeminfoCounters_names + 364, 13}, 21 },
  { {MeminfoCounters_names + 377, 12}, 22 },
  { {MeminfoCounters_names + 389, 24}, 23 },
  { {MeminfoCounters_names + 413, 26}, 24 },
  { {MeminfoCounters_names + 439, 19}, 6 },
  { {MeminfoCounters_names + 458, 17}, 16 },
  { {MeminfoCounters_names + 475, 18}, 15 },
  { {MeminfoCounters_names + 493, 19}, 13 },
  { {MeminfoCounters_names + 512, 19}, 0 },
  { {MeminfoCounters_names + 531, 21}, 31 },
  { {MeminfoCounters_names + 552, 21}, 29 },
  { {MeminfoCounters_names + 573, 20}, 30 },
  { {MeminfoCounters_names + 593, 17}, 18 },
};

static const int MeminfoCounters_entries_by_number[] = {
  29, // 0 -> MEMINFO_UNSPECIFIED
  18, // 1 -> MEMINFO_MEM_TOTAL
  17, // 2 -> MEMINFO_MEM_FREE
  16, // 3 -> MEMINFO_MEM_AVAILABLE
  4, // 4 -> MEMINFO_BUFFERS
  5, // 5 -> MEMINFO_CACHED
  25, // 6 -> MEMINFO_SWAP_CACHED
  0, // 7 -> MEMINFO_ACTIVE
  11, // 8 -> MEMINFO_INACTIVE
  1, // 9 -> MEMINFO_ACTIVE_ANON
  12, // 10 -> MEMINFO_INACTIVE_ANON
  2, // 11 -> MEMINFO_ACTIVE_FILE
  13, // 12 -> MEMINFO_INACTIVE_FILE
  28, // 13 -> MEMINFO_UNEVICTABLE
  19, // 14 -> MEMINFO_MLOCKED
  27, // 15 -> MEMINFO_SWAP_TOTAL
  26, // 16 -> MEMINFO_SWAP_FREE
  10, // 17 -> MEMINFO_DIRTY
  33, // 18 -> MEMINFO_WRITEBACK
  3, // 19 -> MEMINFO_ANON_PAGES
  15, // 20 -> MEMINFO_MAPPED
  21, // 21 -> MEMINFO_SHMEM
  22, // 22 -> MEMINFO_SLAB
  23, // 23 -> MEMINFO_SLAB_RECLAIMABLE
  24, // 24 -> MEMINFO_SLAB_UNRECLAIMABLE
  14, // 25 -> MEMINFO_KERNEL_STACK
  20, // 26 -> MEMINFO_PAGE_TABLES
  9, // 27 -> MEMINFO_COMMIT_LIMIT
  8, // 28 -> MEMINFO_COMMITED_AS
  31, // 29 -> MEMINFO_VMALLOC_TOTAL
  32, // 30 -> MEMINFO_VMALLOC_USED
  30, // 31 -> MEMINFO_VMALLOC_CHUNK
  7, // 32 -> MEMINFO_CMA_TOTAL
  6, // 33 -> MEMINFO_CMA_FREE
};

const std::string& MeminfoCounters_Name(
    MeminfoCounters value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MeminfoCounters_entries,
          MeminfoCounters_entries_by_number,
          34, MeminfoCounters_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MeminfoCounters_entries,
      MeminfoCounters_entries_by_number,
      34, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MeminfoCounters_strings[idx].get();
}
bool MeminfoCounters_Parse(
    const std::string& name, MeminfoCounters* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MeminfoCounters_entries, 34, name, &int_value);
  if (success) {
    *value = static_cast<MeminfoCounters>(int_value);
  }
  return success;
}
bool VmstatCounters_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> VmstatCounters_strings[96] = {};

static const char VmstatCounters_names[] =
  "VMSTAT_ALLOCSTALL"
  "VMSTAT_COMPACT_DAEMON_WAKE"
  "VMSTAT_COMPACT_FAIL"
  "VMSTAT_COMPACT_FREE_SCANNED"
  "VMSTAT_COMPACT_ISOLATED"
  "VMSTAT_COMPACT_MIGRATE_SCANNED"
  "VMSTAT_COMPACT_STALL"
  "VMSTAT_COMPACT_SUCCESS"
  "VMSTAT_DROP_PAGECACHE"
  "VMSTAT_DROP_SLAB"
  "VMSTAT_KSWAPD_HIGH_WMARK_HIT_QUICKLY"
  "VMSTAT_KSWAPD_INODESTEAL"
  "VMSTAT_KSWAPD_LOW_WMARK_HIT_QUICKLY"
  "VMSTAT_NR_ACTIVE_ANON"
  "VMSTAT_NR_ACTIVE_FILE"
  "VMSTAT_NR_ALLOC_BATCH"
  "VMSTAT_NR_ANON_PAGES"
  "VMSTAT_NR_ANON_TRANSPARENT_HUGEPAGES"
  "VMSTAT_NR_BOUNCE"
  "VMSTAT_NR_DIRTIED"
  "VMSTAT_NR_DIRTY"
  "VMSTAT_NR_DIRTY_BACKGROUND_THRESHOLD"
  "VMSTAT_NR_DIRTY_THRESHOLD"
  "VMSTAT_NR_FILE_PAGES"
  "VMSTAT_NR_FREE_CMA"
  "VMSTAT_NR_FREE_PAGES"
  "VMSTAT_NR_GPU_HEAP"
  "VMSTAT_NR_INACTIVE_ANON"
  "VMSTAT_NR_INACTIVE_FILE"
  "VMSTAT_NR_ION_HEAP"
  "VMSTAT_NR_ISOLATED_ANON"
  "VMSTAT_NR_ISOLATED_FILE"
  "VMSTAT_NR_KERNEL_STACK"
  "VMSTAT_NR_MAPPED"
  "VMSTAT_NR_MLOCK"
  "VMSTAT_NR_OVERHEAD"
  "VMSTAT_NR_PAGES_SCANNED"
  "VMSTAT_NR_PAGE_TABLE_PAGES"
  "VMSTAT_NR_SHMEM"
  "VMSTAT_NR_SLAB_RECLAIMABLE"
  "VMSTAT_NR_SLAB_UNRECLAIMABLE"
  "VMSTAT_NR_SWAPCACHE"
  "VMSTAT_NR_UNEVICTABLE"
  "VMSTAT_NR_UNSTABLE"
  "VMSTAT_NR_VMSCAN_IMMEDIATE_RECLAIM"
  "VMSTAT_NR_VMSCAN_WRITE"
  "VMSTAT_NR_WRITEBACK"
  "VMSTAT_NR_WRITEBACK_TEMP"
  "VMSTAT_NR_WRITTEN"
  "VMSTAT_NR_ZSPAGES"
  "VMSTAT_PAGEOUTRUN"
  "VMSTAT_PGACTIVATE"
  "VMSTAT_PGALLOC_DMA"
  "VMSTAT_PGALLOC_MOVABLE"
  "VMSTAT_PGALLOC_NORMAL"
  "VMSTAT_PGDEACTIVATE"
  "VMSTAT_PGFAULT"
  "VMSTAT_PGFREE"
  "VMSTAT_PGINODESTEAL"
  "VMSTAT_PGMAJFAULT"
  "VMSTAT_PGMIGRATE_FAIL"
  "VMSTAT_PGMIGRATE_SUCCESS"
  "VMSTAT_PGPGIN"
  "VMSTAT_PGPGOUT"
  "VMSTAT_PGPGOUTCLEAN"
  "VMSTAT_PGREFILL_DMA"
  "VMSTAT_PGREFILL_MOVABLE"
  "VMSTAT_PGREFILL_NORMAL"
  "VMSTAT_PGROTATED"
  "VMSTAT_PGSCAN_DIRECT_DMA"
  "VMSTAT_PGSCAN_DIRECT_MOVABLE"
  "VMSTAT_PGSCAN_DIRECT_NORMAL"
  "VMSTAT_PGSCAN_DIRECT_THROTTLE"
  "VMSTAT_PGSCAN_KSWAPD_DMA"
  "VMSTAT_PGSCAN_KSWAPD_MOVABLE"
  "VMSTAT_PGSCAN_KSWAPD_NORMAL"
  "VMSTAT_PGSTEAL_DIRECT_DMA"
  "VMSTAT_PGSTEAL_DIRECT_MOVABLE"
  "VMSTAT_PGSTEAL_DIRECT_NORMAL"
  "VMSTAT_PGSTEAL_KSWAPD_DMA"
  "VMSTAT_PGSTEAL_KSWAPD_MOVABLE"
  "VMSTAT_PGSTEAL_KSWAPD_NORMAL"
  "VMSTAT_PSWPIN"
  "VMSTAT_PSWPOUT"
  "VMSTAT_SLABS_SCANNED"
  "VMSTAT_UNEVICTABLE_PGS_CLEARED"
  "VMSTAT_UNEVICTABLE_PGS_CULLED"
  "VMSTAT_UNEVICTABLE_PGS_MLOCKED"
  "VMSTAT_UNEVICTABLE_PGS_MUNLOCKED"
  "VMSTAT_UNEVICTABLE_PGS_RESCUED"
  "VMSTAT_UNEVICTABLE_PGS_SCANNED"
  "VMSTAT_UNEVICTABLE_PGS_STRANDED"
  "VMSTAT_UNSPECIFIED"
  "VMSTAT_WORKINGSET_ACTIVATE"
  "VMSTAT_WORKINGSET_NODERECLAIM"
  "VMSTAT_WORKINGSET_REFAULT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry VmstatCounters_entries[] = {
  { {VmstatCounters_names + 0, 17}, 73 },
  { {VmstatCounters_names + 17, 26}, 85 },
  { {VmstatCounters_names + 43, 19}, 83 },
  { {VmstatCounters_names + 62, 27}, 80 },
  { {VmstatCounters_names + 89, 23}, 81 },
  { {VmstatCounters_names + 112, 30}, 79 },
  { {VmstatCounters_names + 142, 20}, 82 },
  { {VmstatCounters_names + 162, 22}, 84 },
  { {VmstatCounters_names + 184, 21}, 75 },
  { {VmstatCounters_names + 205, 16}, 76 },
  { {VmstatCounters_names + 221, 36}, 71 },
  { {VmstatCounters_names + 257, 24}, 69 },
  { {VmstatCounters_names + 281, 35}, 70 },
  { {VmstatCounters_names + 316, 21}, 4 },
  { {VmstatCounters_names + 337, 21}, 6 },
  { {VmstatCounters_names + 358, 21}, 2 },
  { {VmstatCounters_names + 379, 20}, 9 },
  { {VmstatCounters_names + 399, 36}, 33 },
  { {VmstatCounters_names + 435, 16}, 20 },
  { {VmstatCounters_names + 451, 17}, 27 },
  { {VmstatCounters_names + 468, 15}, 12 },
  { {VmstatCounters_names + 483, 36}, 37 },
  { {VmstatCounters_names + 519, 25}, 36 },
  { {VmstatCounters_names + 544, 20}, 11 },
  { {VmstatCounters_names + 564, 18}, 34 },
  { {VmstatCounters_names + 582, 20}, 1 },
  { {VmstatCounters_names + 602, 18}, 95 },
  { {VmstatCounters_names + 620, 23}, 3 },
  { {VmstatCounters_names + 643, 23}, 5 },
  { {VmstatCounters_names + 666, 18}, 94 },
  { {VmstatCounters_names + 684, 23}, 24 },
  { {VmstatCounters_names + 707, 23}, 25 },
  { {VmstatCounters_names + 730, 22}, 17 },
  { {VmstatCounters_names + 752, 16}, 10 },
  { {VmstatCounters_names + 768, 15}, 8 },
  { {VmstatCounters_names + 783, 18}, 18 },
  { {VmstatCounters_names + 801, 23}, 29 },
  { {VmstatCounters_names + 824, 26}, 16 },
  { {VmstatCounters_names + 850, 15}, 26 },
  { {VmstatCounters_names + 865, 26}, 14 },
  { {VmstatCounters_names + 891, 28}, 15 },
  { {VmstatCounters_names + 919, 19}, 35 },
  { {VmstatCounters_names + 938, 21}, 7 },
  { {VmstatCounters_names + 959, 18}, 19 },
  { {VmstatCounters_names + 977, 34}, 22 },
  { {VmstatCounters_names + 1011, 22}, 21 },
  { {VmstatCounters_names + 1033, 19}, 13 },
  { {VmstatCounters_names + 1052, 24}, 23 },
  { {VmstatCounters_names + 1076, 17}, 28 },
  { {VmstatCounters_names + 1093, 17}, 93 },
  { {VmstatCounters_names + 1110, 17}, 72 },
  { {VmstatCounters_names + 1127, 17}, 47 },
  { {VmstatCounters_names + 1144, 18}, 43 },
  { {VmstatCounters_names + 1162, 22}, 45 },
  { {VmstatCounters_names + 1184, 21}, 44 },
  { {VmstatCounters_names + 1205, 19}, 48 },
  { {VmstatCounters_names + 1224, 14}, 49 },
  { {VmstatCounters_names + 1238, 13}, 46 },
  { {VmstatCounters_names + 1251, 19}, 67 },
  { {VmstatCounters_names + 1270, 17}, 50 },
  { {VmstatCounters_names + 1287, 21}, 78 },
  { {VmstatCounters_names + 1308, 24}, 77 },
  { {VmstatCounters_names + 1332, 13}, 38 },
  { {VmstatCounters_names + 1345, 14}, 39 },
  { {VmstatCounters_names + 1359, 19}, 40 },
  { {VmstatCounters_names + 1378, 19}, 51 },
  { {VmstatCounters_names + 1397, 23}, 53 },
  { {VmstatCounters_names + 1420, 22}, 52 },
  { {VmstatCounters_names + 1442, 16}, 74 },
  { {VmstatCounters_names + 1458, 24}, 63 },
  { {VmstatCounters_names + 1482, 28}, 65 },
  { {VmstatCounters_names + 1510, 27}, 64 },
  { {VmstatCounters_names + 1537, 29}, 66 },
  { {VmstatCounters_names + 1566, 24}, 60 },
  { {VmstatCounters_names + 1590, 28}, 62 },
  { {VmstatCounters_names + 1618, 27}, 61 },
  { {VmstatCounters_names + 1645, 25}, 57 },
  { {VmstatCounters_names + 1670, 29}, 59 },
  { {VmstatCounters_names + 1699, 28}, 58 },
  { {VmstatCounters_names + 1727, 25}, 54 },
  { {VmstatCounters_names + 1752, 29}, 56 },
  { {VmstatCounters_names + 1781, 28}, 55 },
  { {VmstatCounters_names + 1809, 13}, 41 },
  { {VmstatCounters_names + 1822, 14}, 42 },
  { {VmstatCounters_names + 1836, 20}, 68 },
  { {VmstatCounters_names + 1856, 30}, 91 },
  { {VmstatCounters_names + 1886, 29}, 86 },
  { {VmstatCounters_names + 1915, 30}, 89 },
  { {VmstatCounters_names + 1945, 32}, 90 },
  { {VmstatCounters_names + 1977, 30}, 88 },
  { {VmstatCounters_names + 2007, 30}, 87 },
  { {VmstatCounters_names + 2037, 31}, 92 },
  { {VmstatCounters_names + 2068, 18}, 0 },
  { {VmstatCounters_names + 2086, 26}, 31 },
  { {VmstatCounters_names + 2112, 29}, 32 },
  { {VmstatCounters_names + 2141, 25}, 30 },
};

static const int VmstatCounters_entries_by_number[] = {
  92, // 0 -> VMSTAT_UNSPECIFIED
  25, // 1 -> VMSTAT_NR_FREE_PAGES
  15, // 2 -> VMSTAT_NR_ALLOC_BATCH
  27, // 3 -> VMSTAT_NR_INACTIVE_ANON
  13, // 4 -> VMSTAT_NR_ACTIVE_ANON
  28, // 5 -> VMSTAT_NR_INACTIVE_FILE
  14, // 6 -> VMSTAT_NR_ACTIVE_FILE
  42, // 7 -> VMSTAT_NR_UNEVICTABLE
  34, // 8 -> VMSTAT_NR_MLOCK
  16, // 9 -> VMSTAT_NR_ANON_PAGES
  33, // 10 -> VMSTAT_NR_MAPPED
  23, // 11 -> VMSTAT_NR_FILE_PAGES
  20, // 12 -> VMSTAT_NR_DIRTY
  46, // 13 -> VMSTAT_NR_WRITEBACK
  39, // 14 -> VMSTAT_NR_SLAB_RECLAIMABLE
  40, // 15 -> VMSTAT_NR_SLAB_UNRECLAIMABLE
  37, // 16 -> VMSTAT_NR_PAGE_TABLE_PAGES
  32, // 17 -> VMSTAT_NR_KERNEL_STACK
  35, // 18 -> VMSTAT_NR_OVERHEAD
  43, // 19 -> VMSTAT_NR_UNSTABLE
  18, // 20 -> VMSTAT_NR_BOUNCE
  45, // 21 -> VMSTAT_NR_VMSCAN_WRITE
  44, // 22 -> VMSTAT_NR_VMSCAN_IMMEDIATE_RECLAIM
  47, // 23 -> VMSTAT_NR_WRITEBACK_TEMP
  30, // 24 -> VMSTAT_NR_ISOLATED_ANON
  31, // 25 -> VMSTAT_NR_ISOLATED_FILE
  38, // 26 -> VMSTAT_NR_SHMEM
  19, // 27 -> VMSTAT_NR_DIRTIED
  48, // 28 -> VMSTAT_NR_WRITTEN
  36, // 29 -> VMSTAT_NR_PAGES_SCANNED
  95, // 30 -> VMSTAT_WORKINGSET_REFAULT
  93, // 31 -> VMSTAT_WORKINGSET_ACTIVATE
  94, // 32 -> VMSTAT_WORKINGSET_NODERECLAIM
  17, // 33 -> VMSTAT_NR_ANON_TRANSPARENT_HUGEPAGES
  24, // 34 -> VMSTAT_NR_FREE_CMA
  41, // 35 -> VMSTAT_NR_SWAPCACHE
  22, // 36 -> VMSTAT_NR_DIRTY_THRESHOLD
  21, // 37 -> VMSTAT_NR_DIRTY_BACKGROUND_THRESHOLD
  62, // 38 -> VMSTAT_PGPGIN
  63, // 39 -> VMSTAT_PGPGOUT
  64, // 40 -> VMSTAT_PGPGOUTCLEAN
  82, // 41 -> VMSTAT_PSWPIN
  83, // 42 -> VMSTAT_PSWPOUT
  52, // 43 -> VMSTAT_PGALLOC_DMA
  54, // 44 -> VMSTAT_PGALLOC_NORMAL
  53, // 45 -> VMSTAT_PGALLOC_MOVABLE
  57, // 46 -> VMSTAT_PGFREE
  51, // 47 -> VMSTAT_PGACTIVATE
  55, // 48 -> VMSTAT_PGDEACTIVATE
  56, // 49 -> VMSTAT_PGFAULT
  59, // 50 -> VMSTAT_PGMAJFAULT
  65, // 51 -> VMSTAT_PGREFILL_DMA
  67, // 52 -> VMSTAT_PGREFILL_NORMAL
  66, // 53 -> VMSTAT_PGREFILL_MOVABLE
  79, // 54 -> VMSTAT_PGSTEAL_KSWAPD_DMA
  81, // 55 -> VMSTAT_PGSTEAL_KSWAPD_NORMAL
  80, // 56 -> VMSTAT_PGSTEAL_KSWAPD_MOVABLE
  76, // 57 -> VMSTAT_PGSTEAL_DIRECT_DMA
  78, // 58 -> VMSTAT_PGSTEAL_DIRECT_NORMAL
  77, // 59 -> VMSTAT_PGSTEAL_DIRECT_MOVABLE
  73, // 60 -> VMSTAT_PGSCAN_KSWAPD_DMA
  75, // 61 -> VMSTAT_PGSCAN_KSWAPD_NORMAL
  74, // 62 -> VMSTAT_PGSCAN_KSWAPD_MOVABLE
  69, // 63 -> VMSTAT_PGSCAN_DIRECT_DMA
  71, // 64 -> VMSTAT_PGSCAN_DIRECT_NORMAL
  70, // 65 -> VMSTAT_PGSCAN_DIRECT_MOVABLE
  72, // 66 -> VMSTAT_PGSCAN_DIRECT_THROTTLE
  58, // 67 -> VMSTAT_PGINODESTEAL
  84, // 68 -> VMSTAT_SLABS_SCANNED
  11, // 69 -> VMSTAT_KSWAPD_INODESTEAL
  12, // 70 -> VMSTAT_KSWAPD_LOW_WMARK_HIT_QUICKLY
  10, // 71 -> VMSTAT_KSWAPD_HIGH_WMARK_HIT_QUICKLY
  50, // 72 -> VMSTAT_PAGEOUTRUN
  0, // 73 -> VMSTAT_ALLOCSTALL
  68, // 74 -> VMSTAT_PGROTATED
  8, // 75 -> VMSTAT_DROP_PAGECACHE
  9, // 76 -> VMSTAT_DROP_SLAB
  61, // 77 -> VMSTAT_PGMIGRATE_SUCCESS
  60, // 78 -> VMSTAT_PGMIGRATE_FAIL
  5, // 79 -> VMSTAT_COMPACT_MIGRATE_SCANNED
  3, // 80 -> VMSTAT_COMPACT_FREE_SCANNED
  4, // 81 -> VMSTAT_COMPACT_ISOLATED
  6, // 82 -> VMSTAT_COMPACT_STALL
  2, // 83 -> VMSTAT_COMPACT_FAIL
  7, // 84 -> VMSTAT_COMPACT_SUCCESS
  1, // 85 -> VMSTAT_COMPACT_DAEMON_WAKE
  86, // 86 -> VMSTAT_UNEVICTABLE_PGS_CULLED
  90, // 87 -> VMSTAT_UNEVICTABLE_PGS_SCANNED
  89, // 88 -> VMSTAT_UNEVICTABLE_PGS_RESCUED
  87, // 89 -> VMSTAT_UNEVICTABLE_PGS_MLOCKED
  88, // 90 -> VMSTAT_UNEVICTABLE_PGS_MUNLOCKED
  85, // 91 -> VMSTAT_UNEVICTABLE_PGS_CLEARED
  91, // 92 -> VMSTAT_UNEVICTABLE_PGS_STRANDED
  49, // 93 -> VMSTAT_NR_ZSPAGES
  29, // 94 -> VMSTAT_NR_ION_HEAP
  26, // 95 -> VMSTAT_NR_GPU_HEAP
};

const std::string& VmstatCounters_Name(
    VmstatCounters value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          VmstatCounters_entries,
          VmstatCounters_entries_by_number,
          96, VmstatCounters_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      VmstatCounters_entries,
      VmstatCounters_entries_by_number,
      96, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     VmstatCounters_strings[idx].get();
}
bool VmstatCounters_Parse(
    const std::string& name, VmstatCounters* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      VmstatCounters_entries, 96, name, &int_value);
  if (success) {
    *value = static_cast<VmstatCounters>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
