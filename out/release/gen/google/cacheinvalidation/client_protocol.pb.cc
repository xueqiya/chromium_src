// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client_protocol.proto

#include "client_protocol.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ApplicationClientIdP_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ClientConfigP_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ClientHeader_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ClientVersion_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ConfigChangeMessage_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ErrorMessage_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_InfoMessage_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_InfoRequestMessage_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_InitializeMessage_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_InvalidationMessage_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_InvalidationP_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ObjectIdP_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PropertyRecord_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ProtocolHandlerConfigP_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ProtocolVersion_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RateLimitP_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RegistrationMessage_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RegistrationP_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_RegistrationStatus_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RegistrationStatusMessage_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RegistrationSubtree_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RegistrationSummary_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RegistrationSyncMessage_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RegistrationSyncRequestMessage_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ServerHeader_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StatusP_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TokenControlMessage_client_5fprotocol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Version_client_5fprotocol_2eproto;
namespace ipc {
namespace invalidation {
class VersionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Version> _instance;
} _Version_default_instance_;
class ProtocolVersionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ProtocolVersion> _instance;
} _ProtocolVersion_default_instance_;
class ClientVersionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ClientVersion> _instance;
} _ClientVersion_default_instance_;
class StatusPDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StatusP> _instance;
} _StatusP_default_instance_;
class ObjectIdPDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ObjectIdP> _instance;
} _ObjectIdP_default_instance_;
class ApplicationClientIdPDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ApplicationClientIdP> _instance;
} _ApplicationClientIdP_default_instance_;
class InvalidationPDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<InvalidationP> _instance;
} _InvalidationP_default_instance_;
class RegistrationPDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RegistrationP> _instance;
} _RegistrationP_default_instance_;
class RegistrationSummaryDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RegistrationSummary> _instance;
} _RegistrationSummary_default_instance_;
class ClientHeaderDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ClientHeader> _instance;
} _ClientHeader_default_instance_;
class ClientToServerMessageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ClientToServerMessage> _instance;
} _ClientToServerMessage_default_instance_;
class InitializeMessageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<InitializeMessage> _instance;
} _InitializeMessage_default_instance_;
class RegistrationMessageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RegistrationMessage> _instance;
} _RegistrationMessage_default_instance_;
class RegistrationSyncMessageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RegistrationSyncMessage> _instance;
} _RegistrationSyncMessage_default_instance_;
class RegistrationSubtreeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RegistrationSubtree> _instance;
} _RegistrationSubtree_default_instance_;
class InfoMessageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<InfoMessage> _instance;
} _InfoMessage_default_instance_;
class PropertyRecordDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PropertyRecord> _instance;
} _PropertyRecord_default_instance_;
class ServerHeaderDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ServerHeader> _instance;
} _ServerHeader_default_instance_;
class ServerToClientMessageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ServerToClientMessage> _instance;
} _ServerToClientMessage_default_instance_;
class TokenControlMessageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TokenControlMessage> _instance;
} _TokenControlMessage_default_instance_;
class RegistrationStatusDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RegistrationStatus> _instance;
} _RegistrationStatus_default_instance_;
class RegistrationStatusMessageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RegistrationStatusMessage> _instance;
} _RegistrationStatusMessage_default_instance_;
class RegistrationSyncRequestMessageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RegistrationSyncRequestMessage> _instance;
} _RegistrationSyncRequestMessage_default_instance_;
class InvalidationMessageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<InvalidationMessage> _instance;
} _InvalidationMessage_default_instance_;
class InfoRequestMessageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<InfoRequestMessage> _instance;
} _InfoRequestMessage_default_instance_;
class RateLimitPDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RateLimitP> _instance;
} _RateLimitP_default_instance_;
class ProtocolHandlerConfigPDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ProtocolHandlerConfigP> _instance;
} _ProtocolHandlerConfigP_default_instance_;
class ClientConfigPDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ClientConfigP> _instance;
} _ClientConfigP_default_instance_;
class ConfigChangeMessageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ConfigChangeMessage> _instance;
} _ConfigChangeMessage_default_instance_;
class ErrorMessageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ErrorMessage> _instance;
} _ErrorMessage_default_instance_;
}  // namespace invalidation
}  // namespace ipc
static void InitDefaultsscc_info_ApplicationClientIdP_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_ApplicationClientIdP_default_instance_;
    new (ptr) ::ipc::invalidation::ApplicationClientIdP();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::ApplicationClientIdP::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ApplicationClientIdP_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_ApplicationClientIdP_client_5fprotocol_2eproto}, {}};

static void InitDefaultsscc_info_ClientConfigP_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_ClientConfigP_default_instance_;
    new (ptr) ::ipc::invalidation::ClientConfigP();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::ClientConfigP::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ClientConfigP_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_ClientConfigP_client_5fprotocol_2eproto}, {
      &scc_info_Version_client_5fprotocol_2eproto.base,
      &scc_info_ProtocolHandlerConfigP_client_5fprotocol_2eproto.base,}};

static void InitDefaultsscc_info_ClientHeader_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_ClientHeader_default_instance_;
    new (ptr) ::ipc::invalidation::ClientHeader();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::ClientHeader::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ClientHeader_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_ClientHeader_client_5fprotocol_2eproto}, {
      &scc_info_ProtocolVersion_client_5fprotocol_2eproto.base,
      &scc_info_RegistrationSummary_client_5fprotocol_2eproto.base,}};

static void InitDefaultsscc_info_ClientToServerMessage_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_ClientToServerMessage_default_instance_;
    new (ptr) ::ipc::invalidation::ClientToServerMessage();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::ClientToServerMessage::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<6> scc_info_ClientToServerMessage_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 6, InitDefaultsscc_info_ClientToServerMessage_client_5fprotocol_2eproto}, {
      &scc_info_ClientHeader_client_5fprotocol_2eproto.base,
      &scc_info_InitializeMessage_client_5fprotocol_2eproto.base,
      &scc_info_RegistrationMessage_client_5fprotocol_2eproto.base,
      &scc_info_RegistrationSyncMessage_client_5fprotocol_2eproto.base,
      &scc_info_InvalidationMessage_client_5fprotocol_2eproto.base,
      &scc_info_InfoMessage_client_5fprotocol_2eproto.base,}};

static void InitDefaultsscc_info_ClientVersion_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_ClientVersion_default_instance_;
    new (ptr) ::ipc::invalidation::ClientVersion();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::ClientVersion::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ClientVersion_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_ClientVersion_client_5fprotocol_2eproto}, {
      &scc_info_Version_client_5fprotocol_2eproto.base,}};

static void InitDefaultsscc_info_ConfigChangeMessage_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_ConfigChangeMessage_default_instance_;
    new (ptr) ::ipc::invalidation::ConfigChangeMessage();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::ConfigChangeMessage::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ConfigChangeMessage_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_ConfigChangeMessage_client_5fprotocol_2eproto}, {}};

static void InitDefaultsscc_info_ErrorMessage_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_ErrorMessage_default_instance_;
    new (ptr) ::ipc::invalidation::ErrorMessage();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::ErrorMessage::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ErrorMessage_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_ErrorMessage_client_5fprotocol_2eproto}, {}};

static void InitDefaultsscc_info_InfoMessage_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_InfoMessage_default_instance_;
    new (ptr) ::ipc::invalidation::InfoMessage();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::InfoMessage::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_InfoMessage_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsscc_info_InfoMessage_client_5fprotocol_2eproto}, {
      &scc_info_ClientVersion_client_5fprotocol_2eproto.base,
      &scc_info_PropertyRecord_client_5fprotocol_2eproto.base,
      &scc_info_ClientConfigP_client_5fprotocol_2eproto.base,}};

static void InitDefaultsscc_info_InfoRequestMessage_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_InfoRequestMessage_default_instance_;
    new (ptr) ::ipc::invalidation::InfoRequestMessage();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::InfoRequestMessage::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_InfoRequestMessage_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_InfoRequestMessage_client_5fprotocol_2eproto}, {}};

static void InitDefaultsscc_info_InitializeMessage_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_InitializeMessage_default_instance_;
    new (ptr) ::ipc::invalidation::InitializeMessage();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::InitializeMessage::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_InitializeMessage_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_InitializeMessage_client_5fprotocol_2eproto}, {
      &scc_info_ApplicationClientIdP_client_5fprotocol_2eproto.base,}};

static void InitDefaultsscc_info_InvalidationMessage_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_InvalidationMessage_default_instance_;
    new (ptr) ::ipc::invalidation::InvalidationMessage();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::InvalidationMessage::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_InvalidationMessage_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_InvalidationMessage_client_5fprotocol_2eproto}, {
      &scc_info_InvalidationP_client_5fprotocol_2eproto.base,}};

static void InitDefaultsscc_info_InvalidationP_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_InvalidationP_default_instance_;
    new (ptr) ::ipc::invalidation::InvalidationP();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::InvalidationP::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_InvalidationP_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_InvalidationP_client_5fprotocol_2eproto}, {
      &scc_info_ObjectIdP_client_5fprotocol_2eproto.base,}};

static void InitDefaultsscc_info_ObjectIdP_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_ObjectIdP_default_instance_;
    new (ptr) ::ipc::invalidation::ObjectIdP();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::ObjectIdP::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ObjectIdP_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_ObjectIdP_client_5fprotocol_2eproto}, {}};

static void InitDefaultsscc_info_PropertyRecord_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_PropertyRecord_default_instance_;
    new (ptr) ::ipc::invalidation::PropertyRecord();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::PropertyRecord::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PropertyRecord_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_PropertyRecord_client_5fprotocol_2eproto}, {}};

static void InitDefaultsscc_info_ProtocolHandlerConfigP_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_ProtocolHandlerConfigP_default_instance_;
    new (ptr) ::ipc::invalidation::ProtocolHandlerConfigP();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::ProtocolHandlerConfigP::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ProtocolHandlerConfigP_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_ProtocolHandlerConfigP_client_5fprotocol_2eproto}, {
      &scc_info_RateLimitP_client_5fprotocol_2eproto.base,}};

static void InitDefaultsscc_info_ProtocolVersion_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_ProtocolVersion_default_instance_;
    new (ptr) ::ipc::invalidation::ProtocolVersion();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::ProtocolVersion::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ProtocolVersion_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_ProtocolVersion_client_5fprotocol_2eproto}, {
      &scc_info_Version_client_5fprotocol_2eproto.base,}};

static void InitDefaultsscc_info_RateLimitP_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_RateLimitP_default_instance_;
    new (ptr) ::ipc::invalidation::RateLimitP();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::RateLimitP::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RateLimitP_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_RateLimitP_client_5fprotocol_2eproto}, {}};

static void InitDefaultsscc_info_RegistrationMessage_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_RegistrationMessage_default_instance_;
    new (ptr) ::ipc::invalidation::RegistrationMessage();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::RegistrationMessage::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RegistrationMessage_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_RegistrationMessage_client_5fprotocol_2eproto}, {
      &scc_info_RegistrationP_client_5fprotocol_2eproto.base,}};

static void InitDefaultsscc_info_RegistrationP_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_RegistrationP_default_instance_;
    new (ptr) ::ipc::invalidation::RegistrationP();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::RegistrationP::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RegistrationP_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_RegistrationP_client_5fprotocol_2eproto}, {
      &scc_info_ObjectIdP_client_5fprotocol_2eproto.base,}};

static void InitDefaultsscc_info_RegistrationStatus_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_RegistrationStatus_default_instance_;
    new (ptr) ::ipc::invalidation::RegistrationStatus();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::RegistrationStatus::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_RegistrationStatus_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_RegistrationStatus_client_5fprotocol_2eproto}, {
      &scc_info_RegistrationP_client_5fprotocol_2eproto.base,
      &scc_info_StatusP_client_5fprotocol_2eproto.base,}};

static void InitDefaultsscc_info_RegistrationStatusMessage_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_RegistrationStatusMessage_default_instance_;
    new (ptr) ::ipc::invalidation::RegistrationStatusMessage();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::RegistrationStatusMessage::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RegistrationStatusMessage_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_RegistrationStatusMessage_client_5fprotocol_2eproto}, {
      &scc_info_RegistrationStatus_client_5fprotocol_2eproto.base,}};

static void InitDefaultsscc_info_RegistrationSubtree_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_RegistrationSubtree_default_instance_;
    new (ptr) ::ipc::invalidation::RegistrationSubtree();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::RegistrationSubtree::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RegistrationSubtree_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_RegistrationSubtree_client_5fprotocol_2eproto}, {
      &scc_info_ObjectIdP_client_5fprotocol_2eproto.base,}};

static void InitDefaultsscc_info_RegistrationSummary_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_RegistrationSummary_default_instance_;
    new (ptr) ::ipc::invalidation::RegistrationSummary();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::RegistrationSummary::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RegistrationSummary_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_RegistrationSummary_client_5fprotocol_2eproto}, {}};

static void InitDefaultsscc_info_RegistrationSyncMessage_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_RegistrationSyncMessage_default_instance_;
    new (ptr) ::ipc::invalidation::RegistrationSyncMessage();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::RegistrationSyncMessage::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RegistrationSyncMessage_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_RegistrationSyncMessage_client_5fprotocol_2eproto}, {
      &scc_info_RegistrationSubtree_client_5fprotocol_2eproto.base,}};

static void InitDefaultsscc_info_RegistrationSyncRequestMessage_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_RegistrationSyncRequestMessage_default_instance_;
    new (ptr) ::ipc::invalidation::RegistrationSyncRequestMessage();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::RegistrationSyncRequestMessage::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RegistrationSyncRequestMessage_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_RegistrationSyncRequestMessage_client_5fprotocol_2eproto}, {}};

static void InitDefaultsscc_info_ServerHeader_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_ServerHeader_default_instance_;
    new (ptr) ::ipc::invalidation::ServerHeader();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::ServerHeader::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ServerHeader_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_ServerHeader_client_5fprotocol_2eproto}, {
      &scc_info_ProtocolVersion_client_5fprotocol_2eproto.base,
      &scc_info_RegistrationSummary_client_5fprotocol_2eproto.base,}};

static void InitDefaultsscc_info_ServerToClientMessage_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_ServerToClientMessage_default_instance_;
    new (ptr) ::ipc::invalidation::ServerToClientMessage();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::ServerToClientMessage::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<8> scc_info_ServerToClientMessage_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 8, InitDefaultsscc_info_ServerToClientMessage_client_5fprotocol_2eproto}, {
      &scc_info_ServerHeader_client_5fprotocol_2eproto.base,
      &scc_info_TokenControlMessage_client_5fprotocol_2eproto.base,
      &scc_info_InvalidationMessage_client_5fprotocol_2eproto.base,
      &scc_info_RegistrationStatusMessage_client_5fprotocol_2eproto.base,
      &scc_info_RegistrationSyncRequestMessage_client_5fprotocol_2eproto.base,
      &scc_info_ConfigChangeMessage_client_5fprotocol_2eproto.base,
      &scc_info_InfoRequestMessage_client_5fprotocol_2eproto.base,
      &scc_info_ErrorMessage_client_5fprotocol_2eproto.base,}};

static void InitDefaultsscc_info_StatusP_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_StatusP_default_instance_;
    new (ptr) ::ipc::invalidation::StatusP();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::StatusP::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StatusP_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_StatusP_client_5fprotocol_2eproto}, {}};

static void InitDefaultsscc_info_TokenControlMessage_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_TokenControlMessage_default_instance_;
    new (ptr) ::ipc::invalidation::TokenControlMessage();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::TokenControlMessage::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TokenControlMessage_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TokenControlMessage_client_5fprotocol_2eproto}, {}};

static void InitDefaultsscc_info_Version_client_5fprotocol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ipc::invalidation::_Version_default_instance_;
    new (ptr) ::ipc::invalidation::Version();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ipc::invalidation::Version::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Version_client_5fprotocol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Version_client_5fprotocol_2eproto}, {}};

namespace ipc {
namespace invalidation {
bool StatusP_Code_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> StatusP_Code_strings[3] = {};

static const char StatusP_Code_names[] =
  "PERMANENT_FAILURE"
  "SUCCESS"
  "TRANSIENT_FAILURE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry StatusP_Code_entries[] = {
  { {StatusP_Code_names + 0, 17}, 3 },
  { {StatusP_Code_names + 17, 7}, 1 },
  { {StatusP_Code_names + 24, 17}, 2 },
};

static const int StatusP_Code_entries_by_number[] = {
  1, // 1 -> SUCCESS
  2, // 2 -> TRANSIENT_FAILURE
  0, // 3 -> PERMANENT_FAILURE
};

const std::string& StatusP_Code_Name(
    StatusP_Code value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          StatusP_Code_entries,
          StatusP_Code_entries_by_number,
          3, StatusP_Code_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      StatusP_Code_entries,
      StatusP_Code_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     StatusP_Code_strings[idx].get();
}
bool StatusP_Code_Parse(
    const std::string& name, StatusP_Code* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      StatusP_Code_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<StatusP_Code>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr StatusP_Code StatusP::SUCCESS;
constexpr StatusP_Code StatusP::TRANSIENT_FAILURE;
constexpr StatusP_Code StatusP::PERMANENT_FAILURE;
constexpr StatusP_Code StatusP::Code_MIN;
constexpr StatusP_Code StatusP::Code_MAX;
constexpr int StatusP::Code_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool RegistrationP_OpType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RegistrationP_OpType_strings[2] = {};

static const char RegistrationP_OpType_names[] =
  "REGISTER"
  "UNREGISTER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RegistrationP_OpType_entries[] = {
  { {RegistrationP_OpType_names + 0, 8}, 1 },
  { {RegistrationP_OpType_names + 8, 10}, 2 },
};

static const int RegistrationP_OpType_entries_by_number[] = {
  0, // 1 -> REGISTER
  1, // 2 -> UNREGISTER
};

const std::string& RegistrationP_OpType_Name(
    RegistrationP_OpType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RegistrationP_OpType_entries,
          RegistrationP_OpType_entries_by_number,
          2, RegistrationP_OpType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RegistrationP_OpType_entries,
      RegistrationP_OpType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RegistrationP_OpType_strings[idx].get();
}
bool RegistrationP_OpType_Parse(
    const std::string& name, RegistrationP_OpType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RegistrationP_OpType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<RegistrationP_OpType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr RegistrationP_OpType RegistrationP::REGISTER;
constexpr RegistrationP_OpType RegistrationP::UNREGISTER;
constexpr RegistrationP_OpType RegistrationP::OpType_MIN;
constexpr RegistrationP_OpType RegistrationP::OpType_MAX;
constexpr int RegistrationP::OpType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool InitializeMessage_DigestSerializationType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> InitializeMessage_DigestSerializationType_strings[2] = {};

static const char InitializeMessage_DigestSerializationType_names[] =
  "BYTE_BASED"
  "NUMBER_BASED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry InitializeMessage_DigestSerializationType_entries[] = {
  { {InitializeMessage_DigestSerializationType_names + 0, 10}, 1 },
  { {InitializeMessage_DigestSerializationType_names + 10, 12}, 2 },
};

static const int InitializeMessage_DigestSerializationType_entries_by_number[] = {
  0, // 1 -> BYTE_BASED
  1, // 2 -> NUMBER_BASED
};

const std::string& InitializeMessage_DigestSerializationType_Name(
    InitializeMessage_DigestSerializationType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          InitializeMessage_DigestSerializationType_entries,
          InitializeMessage_DigestSerializationType_entries_by_number,
          2, InitializeMessage_DigestSerializationType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      InitializeMessage_DigestSerializationType_entries,
      InitializeMessage_DigestSerializationType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     InitializeMessage_DigestSerializationType_strings[idx].get();
}
bool InitializeMessage_DigestSerializationType_Parse(
    const std::string& name, InitializeMessage_DigestSerializationType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      InitializeMessage_DigestSerializationType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<InitializeMessage_DigestSerializationType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr InitializeMessage_DigestSerializationType InitializeMessage::BYTE_BASED;
constexpr InitializeMessage_DigestSerializationType InitializeMessage::NUMBER_BASED;
constexpr InitializeMessage_DigestSerializationType InitializeMessage::DigestSerializationType_MIN;
constexpr InitializeMessage_DigestSerializationType InitializeMessage::DigestSerializationType_MAX;
constexpr int InitializeMessage::DigestSerializationType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool InfoRequestMessage_InfoType_IsValid(int value) {
  switch (value) {
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> InfoRequestMessage_InfoType_strings[1] = {};

static const char InfoRequestMessage_InfoType_names[] =
  "GET_PERFORMANCE_COUNTERS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry InfoRequestMessage_InfoType_entries[] = {
  { {InfoRequestMessage_InfoType_names + 0, 24}, 1 },
};

static const int InfoRequestMessage_InfoType_entries_by_number[] = {
  0, // 1 -> GET_PERFORMANCE_COUNTERS
};

const std::string& InfoRequestMessage_InfoType_Name(
    InfoRequestMessage_InfoType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          InfoRequestMessage_InfoType_entries,
          InfoRequestMessage_InfoType_entries_by_number,
          1, InfoRequestMessage_InfoType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      InfoRequestMessage_InfoType_entries,
      InfoRequestMessage_InfoType_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     InfoRequestMessage_InfoType_strings[idx].get();
}
bool InfoRequestMessage_InfoType_Parse(
    const std::string& name, InfoRequestMessage_InfoType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      InfoRequestMessage_InfoType_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<InfoRequestMessage_InfoType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr InfoRequestMessage_InfoType InfoRequestMessage::GET_PERFORMANCE_COUNTERS;
constexpr InfoRequestMessage_InfoType InfoRequestMessage::InfoType_MIN;
constexpr InfoRequestMessage_InfoType InfoRequestMessage::InfoType_MAX;
constexpr int InfoRequestMessage::InfoType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool ErrorMessage_Code_IsValid(int value) {
  switch (value) {
    case 1:
    case 10000:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ErrorMessage_Code_strings[2] = {};

static const char ErrorMessage_Code_names[] =
  "AUTH_FAILURE"
  "UNKNOWN_FAILURE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ErrorMessage_Code_entries[] = {
  { {ErrorMessage_Code_names + 0, 12}, 1 },
  { {ErrorMessage_Code_names + 12, 15}, 10000 },
};

static const int ErrorMessage_Code_entries_by_number[] = {
  0, // 1 -> AUTH_FAILURE
  1, // 10000 -> UNKNOWN_FAILURE
};

const std::string& ErrorMessage_Code_Name(
    ErrorMessage_Code value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ErrorMessage_Code_entries,
          ErrorMessage_Code_entries_by_number,
          2, ErrorMessage_Code_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ErrorMessage_Code_entries,
      ErrorMessage_Code_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ErrorMessage_Code_strings[idx].get();
}
bool ErrorMessage_Code_Parse(
    const std::string& name, ErrorMessage_Code* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ErrorMessage_Code_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ErrorMessage_Code>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr ErrorMessage_Code ErrorMessage::AUTH_FAILURE;
constexpr ErrorMessage_Code ErrorMessage::UNKNOWN_FAILURE;
constexpr ErrorMessage_Code ErrorMessage::Code_MIN;
constexpr ErrorMessage_Code ErrorMessage::Code_MAX;
constexpr int ErrorMessage::Code_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void Version::InitAsDefaultInstance() {
}
class Version::_Internal {
 public:
  using HasBits = decltype(std::declval<Version>()._has_bits_);
  static void set_has_major_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_minor_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Version::Version()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.Version)
}
Version::Version(const Version& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&major_version_, &from.major_version_,
    static_cast<size_t>(reinterpret_cast<char*>(&minor_version_) -
    reinterpret_cast<char*>(&major_version_)) + sizeof(minor_version_));
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.Version)
}

void Version::SharedCtor() {
  ::memset(&major_version_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&minor_version_) -
      reinterpret_cast<char*>(&major_version_)) + sizeof(minor_version_));
}

Version::~Version() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.Version)
  SharedDtor();
}

void Version::SharedDtor() {
}

void Version::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Version& Version::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Version_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void Version::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.Version)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&major_version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&minor_version_) -
        reinterpret_cast<char*>(&major_version_)) + sizeof(minor_version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Version::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 major_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_major_version(&has_bits);
          major_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 minor_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_minor_version(&has_bits);
          minor_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Version::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.Version)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 major_version = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_major_version(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &major_version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 minor_version = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_minor_version(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &minor_version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.Version)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.Version)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Version::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.Version)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 major_version = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->major_version(), output);
  }

  // optional int32 minor_version = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->minor_version(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.Version)
}

size_t Version::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.Version)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 major_version = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->major_version());
    }

    // optional int32 minor_version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->minor_version());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Version::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Version*>(
      &from));
}

void Version::MergeFrom(const Version& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.Version)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      major_version_ = from.major_version_;
    }
    if (cached_has_bits & 0x00000002u) {
      minor_version_ = from.minor_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Version::CopyFrom(const Version& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.Version)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Version::IsInitialized() const {
  return true;
}

void Version::InternalSwap(Version* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(major_version_, other->major_version_);
  swap(minor_version_, other->minor_version_);
}

std::string Version::GetTypeName() const {
  return "ipc.invalidation.Version";
}


// ===================================================================

void ProtocolVersion::InitAsDefaultInstance() {
  ::ipc::invalidation::_ProtocolVersion_default_instance_._instance.get_mutable()->version_ = const_cast< ::ipc::invalidation::Version*>(
      ::ipc::invalidation::Version::internal_default_instance());
}
class ProtocolVersion::_Internal {
 public:
  using HasBits = decltype(std::declval<ProtocolVersion>()._has_bits_);
  static const ::ipc::invalidation::Version& version(const ProtocolVersion* msg);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::ipc::invalidation::Version&
ProtocolVersion::_Internal::version(const ProtocolVersion* msg) {
  return *msg->version_;
}
ProtocolVersion::ProtocolVersion()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ProtocolVersion)
}
ProtocolVersion::ProtocolVersion(const ProtocolVersion& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_version()) {
    version_ = new ::ipc::invalidation::Version(*from.version_);
  } else {
    version_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ProtocolVersion)
}

void ProtocolVersion::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ProtocolVersion_client_5fprotocol_2eproto.base);
  version_ = nullptr;
}

ProtocolVersion::~ProtocolVersion() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ProtocolVersion)
  SharedDtor();
}

void ProtocolVersion::SharedDtor() {
  if (this != internal_default_instance()) delete version_;
}

void ProtocolVersion::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ProtocolVersion& ProtocolVersion::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ProtocolVersion_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void ProtocolVersion::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ProtocolVersion)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(version_ != nullptr);
    version_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ProtocolVersion::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .ipc.invalidation.Version version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_version(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ProtocolVersion::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ProtocolVersion)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.Version version = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_version()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ProtocolVersion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ProtocolVersion)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ProtocolVersion::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ProtocolVersion)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.Version version = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::version(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ProtocolVersion)
}

size_t ProtocolVersion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ProtocolVersion)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .ipc.invalidation.Version version = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *version_);
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ProtocolVersion::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ProtocolVersion*>(
      &from));
}

void ProtocolVersion::MergeFrom(const ProtocolVersion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ProtocolVersion)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_version()) {
    mutable_version()->::ipc::invalidation::Version::MergeFrom(from.version());
  }
}

void ProtocolVersion::CopyFrom(const ProtocolVersion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ProtocolVersion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProtocolVersion::IsInitialized() const {
  return true;
}

void ProtocolVersion::InternalSwap(ProtocolVersion* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(version_, other->version_);
}

std::string ProtocolVersion::GetTypeName() const {
  return "ipc.invalidation.ProtocolVersion";
}


// ===================================================================

void ClientVersion::InitAsDefaultInstance() {
  ::ipc::invalidation::_ClientVersion_default_instance_._instance.get_mutable()->version_ = const_cast< ::ipc::invalidation::Version*>(
      ::ipc::invalidation::Version::internal_default_instance());
}
class ClientVersion::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientVersion>()._has_bits_);
  static const ::ipc::invalidation::Version& version(const ClientVersion* msg);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_application_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::ipc::invalidation::Version&
ClientVersion::_Internal::version(const ClientVersion* msg) {
  return *msg->version_;
}
ClientVersion::ClientVersion()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ClientVersion)
}
ClientVersion::ClientVersion(const ClientVersion& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  platform_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_platform()) {
    platform_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.platform_);
  }
  language_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_language()) {
    language_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.language_);
  }
  application_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_application_info()) {
    application_info_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.application_info_);
  }
  if (from.has_version()) {
    version_ = new ::ipc::invalidation::Version(*from.version_);
  } else {
    version_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ClientVersion)
}

void ClientVersion::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ClientVersion_client_5fprotocol_2eproto.base);
  platform_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  language_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  application_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_ = nullptr;
}

ClientVersion::~ClientVersion() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ClientVersion)
  SharedDtor();
}

void ClientVersion::SharedDtor() {
  platform_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  language_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  application_info_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete version_;
}

void ClientVersion::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ClientVersion& ClientVersion::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ClientVersion_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void ClientVersion::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ClientVersion)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      platform_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      language_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      application_info_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(version_ != nullptr);
      version_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ClientVersion::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .ipc.invalidation.Version version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_version(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string platform = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_platform(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string language = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_language(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string application_info = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_application_info(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ClientVersion::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ClientVersion)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.Version version = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_version()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string platform = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_platform()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string language = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_language()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string application_info = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_application_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ClientVersion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ClientVersion)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ClientVersion::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ClientVersion)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.Version version = 1;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::version(this), output);
  }

  // optional string platform = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->platform(), output);
  }

  // optional string language = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->language(), output);
  }

  // optional string application_info = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->application_info(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ClientVersion)
}

size_t ClientVersion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ClientVersion)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string platform = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->platform());
    }

    // optional string language = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->language());
    }

    // optional string application_info = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->application_info());
    }

    // optional .ipc.invalidation.Version version = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *version_);
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientVersion::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ClientVersion*>(
      &from));
}

void ClientVersion::MergeFrom(const ClientVersion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ClientVersion)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      platform_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.platform_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      language_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.language_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      application_info_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.application_info_);
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_version()->::ipc::invalidation::Version::MergeFrom(from.version());
    }
  }
}

void ClientVersion::CopyFrom(const ClientVersion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ClientVersion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientVersion::IsInitialized() const {
  return true;
}

void ClientVersion::InternalSwap(ClientVersion* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  platform_.Swap(&other->platform_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  language_.Swap(&other->language_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  application_info_.Swap(&other->application_info_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(version_, other->version_);
}

std::string ClientVersion::GetTypeName() const {
  return "ipc.invalidation.ClientVersion";
}


// ===================================================================

void StatusP::InitAsDefaultInstance() {
}
class StatusP::_Internal {
 public:
  using HasBits = decltype(std::declval<StatusP>()._has_bits_);
  static void set_has_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

StatusP::StatusP()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.StatusP)
}
StatusP::StatusP(const StatusP& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_description()) {
    description_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.description_);
  }
  code_ = from.code_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.StatusP)
}

void StatusP::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_StatusP_client_5fprotocol_2eproto.base);
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  code_ = 1;
}

StatusP::~StatusP() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.StatusP)
  SharedDtor();
}

void StatusP::SharedDtor() {
  description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StatusP::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StatusP& StatusP::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StatusP_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void StatusP::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.StatusP)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      description_.ClearNonDefaultToEmptyNoArena();
    }
    code_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* StatusP::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .ipc.invalidation.StatusP.Code code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ipc::invalidation::StatusP_Code_IsValid(val))) {
            set_code(static_cast<::ipc::invalidation::StatusP_Code>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_description(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool StatusP::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.StatusP)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.StatusP.Code code = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ipc::invalidation::StatusP_Code_IsValid(value)) {
            set_code(static_cast< ::ipc::invalidation::StatusP_Code >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string description = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.StatusP)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.StatusP)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void StatusP::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.StatusP)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.StatusP.Code code = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->code(), output);
  }

  // optional string description = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->description(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.StatusP)
}

size_t StatusP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.StatusP)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string description = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->description());
    }

    // optional .ipc.invalidation.StatusP.Code code = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->code());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StatusP::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const StatusP*>(
      &from));
}

void StatusP::MergeFrom(const StatusP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.StatusP)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      description_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.description_);
    }
    if (cached_has_bits & 0x00000002u) {
      code_ = from.code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void StatusP::CopyFrom(const StatusP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.StatusP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusP::IsInitialized() const {
  return true;
}

void StatusP::InternalSwap(StatusP* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  description_.Swap(&other->description_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(code_, other->code_);
}

std::string StatusP::GetTypeName() const {
  return "ipc.invalidation.StatusP";
}


// ===================================================================

void ObjectIdP::InitAsDefaultInstance() {
}
class ObjectIdP::_Internal {
 public:
  using HasBits = decltype(std::declval<ObjectIdP>()._has_bits_);
  static void set_has_source(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ObjectIdP::ObjectIdP()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ObjectIdP)
}
ObjectIdP::ObjectIdP(const ObjectIdP& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  source_ = from.source_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ObjectIdP)
}

void ObjectIdP::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ObjectIdP_client_5fprotocol_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  source_ = 0;
}

ObjectIdP::~ObjectIdP() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ObjectIdP)
  SharedDtor();
}

void ObjectIdP::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ObjectIdP::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ObjectIdP& ObjectIdP::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ObjectIdP_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void ObjectIdP::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ObjectIdP)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmptyNoArena();
  }
  source_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ObjectIdP::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 source = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_source(&has_bits);
          source_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ObjectIdP::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ObjectIdP)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 source = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_source(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &source_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes name = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ObjectIdP)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ObjectIdP)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ObjectIdP::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ObjectIdP)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 source = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->source(), output);
  }

  // optional bytes name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->name(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ObjectIdP)
}

size_t ObjectIdP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ObjectIdP)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->name());
    }

    // optional int32 source = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->source());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ObjectIdP::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ObjectIdP*>(
      &from));
}

void ObjectIdP::MergeFrom(const ObjectIdP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ObjectIdP)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      source_ = from.source_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ObjectIdP::CopyFrom(const ObjectIdP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ObjectIdP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectIdP::IsInitialized() const {
  return true;
}

void ObjectIdP::InternalSwap(ObjectIdP* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(source_, other->source_);
}

std::string ObjectIdP::GetTypeName() const {
  return "ipc.invalidation.ObjectIdP";
}


// ===================================================================

void ApplicationClientIdP::InitAsDefaultInstance() {
}
class ApplicationClientIdP::_Internal {
 public:
  using HasBits = decltype(std::declval<ApplicationClientIdP>()._has_bits_);
  static void set_has_client_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_client_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ApplicationClientIdP::ApplicationClientIdP()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ApplicationClientIdP)
}
ApplicationClientIdP::ApplicationClientIdP(const ApplicationClientIdP& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  client_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_client_name()) {
    client_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.client_name_);
  }
  client_type_ = from.client_type_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ApplicationClientIdP)
}

void ApplicationClientIdP::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ApplicationClientIdP_client_5fprotocol_2eproto.base);
  client_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  client_type_ = 0;
}

ApplicationClientIdP::~ApplicationClientIdP() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ApplicationClientIdP)
  SharedDtor();
}

void ApplicationClientIdP::SharedDtor() {
  client_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ApplicationClientIdP::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ApplicationClientIdP& ApplicationClientIdP::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ApplicationClientIdP_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void ApplicationClientIdP::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ApplicationClientIdP)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    client_name_.ClearNonDefaultToEmptyNoArena();
  }
  client_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ApplicationClientIdP::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 client_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_client_type(&has_bits);
          client_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes client_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_client_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ApplicationClientIdP::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ApplicationClientIdP)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 client_type = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_client_type(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &client_type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes client_name = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_client_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ApplicationClientIdP)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ApplicationClientIdP)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ApplicationClientIdP::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ApplicationClientIdP)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 client_type = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->client_type(), output);
  }

  // optional bytes client_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->client_name(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ApplicationClientIdP)
}

size_t ApplicationClientIdP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ApplicationClientIdP)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes client_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->client_name());
    }

    // optional int32 client_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->client_type());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ApplicationClientIdP::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ApplicationClientIdP*>(
      &from));
}

void ApplicationClientIdP::MergeFrom(const ApplicationClientIdP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ApplicationClientIdP)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      client_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.client_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      client_type_ = from.client_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ApplicationClientIdP::CopyFrom(const ApplicationClientIdP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ApplicationClientIdP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplicationClientIdP::IsInitialized() const {
  return true;
}

void ApplicationClientIdP::InternalSwap(ApplicationClientIdP* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  client_name_.Swap(&other->client_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(client_type_, other->client_type_);
}

std::string ApplicationClientIdP::GetTypeName() const {
  return "ipc.invalidation.ApplicationClientIdP";
}


// ===================================================================

void InvalidationP::InitAsDefaultInstance() {
  ::ipc::invalidation::_InvalidationP_default_instance_._instance.get_mutable()->object_id_ = const_cast< ::ipc::invalidation::ObjectIdP*>(
      ::ipc::invalidation::ObjectIdP::internal_default_instance());
}
class InvalidationP::_Internal {
 public:
  using HasBits = decltype(std::declval<InvalidationP>()._has_bits_);
  static const ::ipc::invalidation::ObjectIdP& object_id(const InvalidationP* msg);
  static void set_has_object_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_known_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_trickle_restart(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bridge_arrival_time_ms_deprecated(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::ipc::invalidation::ObjectIdP&
InvalidationP::_Internal::object_id(const InvalidationP* msg) {
  return *msg->object_id_;
}
InvalidationP::InvalidationP()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.InvalidationP)
}
InvalidationP::InvalidationP(const InvalidationP& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  payload_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_payload()) {
    payload_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.payload_);
  }
  if (from.has_object_id()) {
    object_id_ = new ::ipc::invalidation::ObjectIdP(*from.object_id_);
  } else {
    object_id_ = nullptr;
  }
  ::memcpy(&version_, &from.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_trickle_restart_) -
    reinterpret_cast<char*>(&version_)) + sizeof(is_trickle_restart_));
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.InvalidationP)
}

void InvalidationP::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_InvalidationP_client_5fprotocol_2eproto.base);
  payload_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&object_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_trickle_restart_) -
      reinterpret_cast<char*>(&object_id_)) + sizeof(is_trickle_restart_));
}

InvalidationP::~InvalidationP() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.InvalidationP)
  SharedDtor();
}

void InvalidationP::SharedDtor() {
  payload_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete object_id_;
}

void InvalidationP::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const InvalidationP& InvalidationP::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_InvalidationP_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void InvalidationP::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.InvalidationP)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      payload_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(object_id_ != nullptr);
      object_id_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_trickle_restart_) -
        reinterpret_cast<char*>(&version_)) + sizeof(is_trickle_restart_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* InvalidationP::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .ipc.invalidation.ObjectIdP object_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_object_id(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_known_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_is_known_version(&has_bits);
          is_known_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes payload = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_payload(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 bridge_arrival_time_ms_deprecated = 5 [deprecated = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_bridge_arrival_time_ms_deprecated(&has_bits);
          bridge_arrival_time_ms_deprecated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_trickle_restart = 6 [default = false];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_is_trickle_restart(&has_bits);
          is_trickle_restart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool InvalidationP::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.InvalidationP)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.ObjectIdP object_id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_object_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool is_known_version = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_is_known_version(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_known_version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 version = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_version(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes payload = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 bridge_arrival_time_ms_deprecated = 5 [deprecated = true];
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_bridge_arrival_time_ms_deprecated(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &bridge_arrival_time_ms_deprecated_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool is_trickle_restart = 6 [default = false];
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_is_trickle_restart(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_trickle_restart_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.InvalidationP)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.InvalidationP)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void InvalidationP::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.InvalidationP)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.ObjectIdP object_id = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::object_id(this), output);
  }

  // optional bool is_known_version = 2;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->is_known_version(), output);
  }

  // optional int64 version = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->version(), output);
  }

  // optional bytes payload = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->payload(), output);
  }

  // optional int64 bridge_arrival_time_ms_deprecated = 5 [deprecated = true];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(5, this->bridge_arrival_time_ms_deprecated(), output);
  }

  // optional bool is_trickle_restart = 6 [default = false];
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(6, this->is_trickle_restart(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.InvalidationP)
}

size_t InvalidationP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.InvalidationP)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes payload = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->payload());
    }

    // optional .ipc.invalidation.ObjectIdP object_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *object_id_);
    }

    // optional int64 version = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->version());
    }

    // optional int64 bridge_arrival_time_ms_deprecated = 5 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->bridge_arrival_time_ms_deprecated());
    }

    // optional bool is_known_version = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool is_trickle_restart = 6 [default = false];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InvalidationP::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const InvalidationP*>(
      &from));
}

void InvalidationP::MergeFrom(const InvalidationP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.InvalidationP)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      payload_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.payload_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_object_id()->::ipc::invalidation::ObjectIdP::MergeFrom(from.object_id());
    }
    if (cached_has_bits & 0x00000004u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00000008u) {
      bridge_arrival_time_ms_deprecated_ = from.bridge_arrival_time_ms_deprecated_;
    }
    if (cached_has_bits & 0x00000010u) {
      is_known_version_ = from.is_known_version_;
    }
    if (cached_has_bits & 0x00000020u) {
      is_trickle_restart_ = from.is_trickle_restart_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void InvalidationP::CopyFrom(const InvalidationP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.InvalidationP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InvalidationP::IsInitialized() const {
  return true;
}

void InvalidationP::InternalSwap(InvalidationP* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  payload_.Swap(&other->payload_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(object_id_, other->object_id_);
  swap(version_, other->version_);
  swap(bridge_arrival_time_ms_deprecated_, other->bridge_arrival_time_ms_deprecated_);
  swap(is_known_version_, other->is_known_version_);
  swap(is_trickle_restart_, other->is_trickle_restart_);
}

std::string InvalidationP::GetTypeName() const {
  return "ipc.invalidation.InvalidationP";
}


// ===================================================================

void RegistrationP::InitAsDefaultInstance() {
  ::ipc::invalidation::_RegistrationP_default_instance_._instance.get_mutable()->object_id_ = const_cast< ::ipc::invalidation::ObjectIdP*>(
      ::ipc::invalidation::ObjectIdP::internal_default_instance());
}
class RegistrationP::_Internal {
 public:
  using HasBits = decltype(std::declval<RegistrationP>()._has_bits_);
  static const ::ipc::invalidation::ObjectIdP& object_id(const RegistrationP* msg);
  static void set_has_object_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_op_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::ipc::invalidation::ObjectIdP&
RegistrationP::_Internal::object_id(const RegistrationP* msg) {
  return *msg->object_id_;
}
RegistrationP::RegistrationP()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationP)
}
RegistrationP::RegistrationP(const RegistrationP& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_object_id()) {
    object_id_ = new ::ipc::invalidation::ObjectIdP(*from.object_id_);
  } else {
    object_id_ = nullptr;
  }
  op_type_ = from.op_type_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationP)
}

void RegistrationP::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RegistrationP_client_5fprotocol_2eproto.base);
  object_id_ = nullptr;
  op_type_ = 1;
}

RegistrationP::~RegistrationP() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationP)
  SharedDtor();
}

void RegistrationP::SharedDtor() {
  if (this != internal_default_instance()) delete object_id_;
}

void RegistrationP::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RegistrationP& RegistrationP::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RegistrationP_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void RegistrationP::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationP)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(object_id_ != nullptr);
      object_id_->Clear();
    }
    op_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RegistrationP::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .ipc.invalidation.ObjectIdP object_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_object_id(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ipc.invalidation.RegistrationP.OpType op_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ipc::invalidation::RegistrationP_OpType_IsValid(val))) {
            set_op_type(static_cast<::ipc::invalidation::RegistrationP_OpType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RegistrationP::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationP)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.ObjectIdP object_id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_object_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.RegistrationP.OpType op_type = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ipc::invalidation::RegistrationP_OpType_IsValid(value)) {
            set_op_type(static_cast< ::ipc::invalidation::RegistrationP_OpType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationP)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationP)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RegistrationP::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationP)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.ObjectIdP object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::object_id(this), output);
  }

  // optional .ipc.invalidation.RegistrationP.OpType op_type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->op_type(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationP)
}

size_t RegistrationP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationP)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .ipc.invalidation.ObjectIdP object_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *object_id_);
    }

    // optional .ipc.invalidation.RegistrationP.OpType op_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->op_type());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RegistrationP::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RegistrationP*>(
      &from));
}

void RegistrationP::MergeFrom(const RegistrationP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationP)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_object_id()->::ipc::invalidation::ObjectIdP::MergeFrom(from.object_id());
    }
    if (cached_has_bits & 0x00000002u) {
      op_type_ = from.op_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RegistrationP::CopyFrom(const RegistrationP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegistrationP::IsInitialized() const {
  return true;
}

void RegistrationP::InternalSwap(RegistrationP* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(object_id_, other->object_id_);
  swap(op_type_, other->op_type_);
}

std::string RegistrationP::GetTypeName() const {
  return "ipc.invalidation.RegistrationP";
}


// ===================================================================

void RegistrationSummary::InitAsDefaultInstance() {
}
class RegistrationSummary::_Internal {
 public:
  using HasBits = decltype(std::declval<RegistrationSummary>()._has_bits_);
  static void set_has_num_registrations(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_registration_digest(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RegistrationSummary::RegistrationSummary()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationSummary)
}
RegistrationSummary::RegistrationSummary(const RegistrationSummary& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  registration_digest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_registration_digest()) {
    registration_digest_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.registration_digest_);
  }
  num_registrations_ = from.num_registrations_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationSummary)
}

void RegistrationSummary::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RegistrationSummary_client_5fprotocol_2eproto.base);
  registration_digest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  num_registrations_ = 0;
}

RegistrationSummary::~RegistrationSummary() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationSummary)
  SharedDtor();
}

void RegistrationSummary::SharedDtor() {
  registration_digest_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void RegistrationSummary::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RegistrationSummary& RegistrationSummary::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RegistrationSummary_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void RegistrationSummary::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationSummary)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    registration_digest_.ClearNonDefaultToEmptyNoArena();
  }
  num_registrations_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RegistrationSummary::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 num_registrations = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_num_registrations(&has_bits);
          num_registrations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes registration_digest = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_registration_digest(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RegistrationSummary::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationSummary)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 num_registrations = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_num_registrations(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_registrations_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes registration_digest = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_registration_digest()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationSummary)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationSummary)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RegistrationSummary::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationSummary)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 num_registrations = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->num_registrations(), output);
  }

  // optional bytes registration_digest = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->registration_digest(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationSummary)
}

size_t RegistrationSummary::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationSummary)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes registration_digest = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->registration_digest());
    }

    // optional int32 num_registrations = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_registrations());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RegistrationSummary::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RegistrationSummary*>(
      &from));
}

void RegistrationSummary::MergeFrom(const RegistrationSummary& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationSummary)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      registration_digest_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.registration_digest_);
    }
    if (cached_has_bits & 0x00000002u) {
      num_registrations_ = from.num_registrations_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RegistrationSummary::CopyFrom(const RegistrationSummary& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationSummary)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegistrationSummary::IsInitialized() const {
  return true;
}

void RegistrationSummary::InternalSwap(RegistrationSummary* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  registration_digest_.Swap(&other->registration_digest_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(num_registrations_, other->num_registrations_);
}

std::string RegistrationSummary::GetTypeName() const {
  return "ipc.invalidation.RegistrationSummary";
}


// ===================================================================

void ClientHeader::InitAsDefaultInstance() {
  ::ipc::invalidation::_ClientHeader_default_instance_._instance.get_mutable()->protocol_version_ = const_cast< ::ipc::invalidation::ProtocolVersion*>(
      ::ipc::invalidation::ProtocolVersion::internal_default_instance());
  ::ipc::invalidation::_ClientHeader_default_instance_._instance.get_mutable()->registration_summary_ = const_cast< ::ipc::invalidation::RegistrationSummary*>(
      ::ipc::invalidation::RegistrationSummary::internal_default_instance());
}
class ClientHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientHeader>()._has_bits_);
  static const ::ipc::invalidation::ProtocolVersion& protocol_version(const ClientHeader* msg);
  static void set_has_protocol_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_client_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ipc::invalidation::RegistrationSummary& registration_summary(const ClientHeader* msg);
  static void set_has_registration_summary(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_client_time_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_max_known_server_time_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_message_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_client_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::ipc::invalidation::ProtocolVersion&
ClientHeader::_Internal::protocol_version(const ClientHeader* msg) {
  return *msg->protocol_version_;
}
const ::ipc::invalidation::RegistrationSummary&
ClientHeader::_Internal::registration_summary(const ClientHeader* msg) {
  return *msg->registration_summary_;
}
ClientHeader::ClientHeader()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ClientHeader)
}
ClientHeader::ClientHeader(const ClientHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  client_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_client_token()) {
    client_token_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.client_token_);
  }
  message_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_message_id()) {
    message_id_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.message_id_);
  }
  if (from.has_protocol_version()) {
    protocol_version_ = new ::ipc::invalidation::ProtocolVersion(*from.protocol_version_);
  } else {
    protocol_version_ = nullptr;
  }
  if (from.has_registration_summary()) {
    registration_summary_ = new ::ipc::invalidation::RegistrationSummary(*from.registration_summary_);
  } else {
    registration_summary_ = nullptr;
  }
  ::memcpy(&client_time_ms_, &from.client_time_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&client_type_) -
    reinterpret_cast<char*>(&client_time_ms_)) + sizeof(client_type_));
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ClientHeader)
}

void ClientHeader::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ClientHeader_client_5fprotocol_2eproto.base);
  client_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  message_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&protocol_version_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&client_type_) -
      reinterpret_cast<char*>(&protocol_version_)) + sizeof(client_type_));
}

ClientHeader::~ClientHeader() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ClientHeader)
  SharedDtor();
}

void ClientHeader::SharedDtor() {
  client_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  message_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete protocol_version_;
  if (this != internal_default_instance()) delete registration_summary_;
}

void ClientHeader::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ClientHeader& ClientHeader::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ClientHeader_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void ClientHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ClientHeader)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      client_token_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      message_id_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(protocol_version_ != nullptr);
      protocol_version_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(registration_summary_ != nullptr);
      registration_summary_->Clear();
    }
  }
  if (cached_has_bits & 0x00000070u) {
    ::memset(&client_time_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&client_type_) -
        reinterpret_cast<char*>(&client_time_ms_)) + sizeof(client_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ClientHeader::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_protocol_version(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes client_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_client_token(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_registration_summary(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 client_time_ms = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_client_time_ms(&has_bits);
          client_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 max_known_server_time_ms = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_max_known_server_time_ms(&has_bits);
          max_known_server_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string message_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_message_id(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 client_type = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_client_type(&has_bits);
          client_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ClientHeader::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ClientHeader)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_protocol_version()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes client_token = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_client_token()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_registration_summary()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 client_time_ms = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_client_time_ms(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &client_time_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 max_known_server_time_ms = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_max_known_server_time_ms(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &max_known_server_time_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string message_id = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_message_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 client_type = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_client_type(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &client_type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ClientHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ClientHeader)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ClientHeader::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ClientHeader)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::protocol_version(this), output);
  }

  // optional bytes client_token = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->client_token(), output);
  }

  // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      3, _Internal::registration_summary(this), output);
  }

  // optional int64 client_time_ms = 4;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->client_time_ms(), output);
  }

  // optional int64 max_known_server_time_ms = 5;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(5, this->max_known_server_time_ms(), output);
  }

  // optional string message_id = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->message_id(), output);
  }

  // optional int32 client_type = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(7, this->client_type(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ClientHeader)
}

size_t ClientHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ClientHeader)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes client_token = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->client_token());
    }

    // optional string message_id = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->message_id());
    }

    // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *protocol_version_);
    }

    // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *registration_summary_);
    }

    // optional int64 client_time_ms = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->client_time_ms());
    }

    // optional int64 max_known_server_time_ms = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->max_known_server_time_ms());
    }

    // optional int32 client_type = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->client_type());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientHeader::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ClientHeader*>(
      &from));
}

void ClientHeader::MergeFrom(const ClientHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ClientHeader)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      client_token_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.client_token_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      message_id_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.message_id_);
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_protocol_version()->::ipc::invalidation::ProtocolVersion::MergeFrom(from.protocol_version());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_registration_summary()->::ipc::invalidation::RegistrationSummary::MergeFrom(from.registration_summary());
    }
    if (cached_has_bits & 0x00000010u) {
      client_time_ms_ = from.client_time_ms_;
    }
    if (cached_has_bits & 0x00000020u) {
      max_known_server_time_ms_ = from.max_known_server_time_ms_;
    }
    if (cached_has_bits & 0x00000040u) {
      client_type_ = from.client_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ClientHeader::CopyFrom(const ClientHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ClientHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientHeader::IsInitialized() const {
  return true;
}

void ClientHeader::InternalSwap(ClientHeader* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  client_token_.Swap(&other->client_token_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  message_id_.Swap(&other->message_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(protocol_version_, other->protocol_version_);
  swap(registration_summary_, other->registration_summary_);
  swap(client_time_ms_, other->client_time_ms_);
  swap(max_known_server_time_ms_, other->max_known_server_time_ms_);
  swap(client_type_, other->client_type_);
}

std::string ClientHeader::GetTypeName() const {
  return "ipc.invalidation.ClientHeader";
}


// ===================================================================

void ClientToServerMessage::InitAsDefaultInstance() {
  ::ipc::invalidation::_ClientToServerMessage_default_instance_._instance.get_mutable()->header_ = const_cast< ::ipc::invalidation::ClientHeader*>(
      ::ipc::invalidation::ClientHeader::internal_default_instance());
  ::ipc::invalidation::_ClientToServerMessage_default_instance_._instance.get_mutable()->initialize_message_ = const_cast< ::ipc::invalidation::InitializeMessage*>(
      ::ipc::invalidation::InitializeMessage::internal_default_instance());
  ::ipc::invalidation::_ClientToServerMessage_default_instance_._instance.get_mutable()->registration_message_ = const_cast< ::ipc::invalidation::RegistrationMessage*>(
      ::ipc::invalidation::RegistrationMessage::internal_default_instance());
  ::ipc::invalidation::_ClientToServerMessage_default_instance_._instance.get_mutable()->registration_sync_message_ = const_cast< ::ipc::invalidation::RegistrationSyncMessage*>(
      ::ipc::invalidation::RegistrationSyncMessage::internal_default_instance());
  ::ipc::invalidation::_ClientToServerMessage_default_instance_._instance.get_mutable()->invalidation_ack_message_ = const_cast< ::ipc::invalidation::InvalidationMessage*>(
      ::ipc::invalidation::InvalidationMessage::internal_default_instance());
  ::ipc::invalidation::_ClientToServerMessage_default_instance_._instance.get_mutable()->info_message_ = const_cast< ::ipc::invalidation::InfoMessage*>(
      ::ipc::invalidation::InfoMessage::internal_default_instance());
}
class ClientToServerMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientToServerMessage>()._has_bits_);
  static const ::ipc::invalidation::ClientHeader& header(const ClientToServerMessage* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ipc::invalidation::InitializeMessage& initialize_message(const ClientToServerMessage* msg);
  static void set_has_initialize_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::ipc::invalidation::RegistrationMessage& registration_message(const ClientToServerMessage* msg);
  static void set_has_registration_message(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::ipc::invalidation::RegistrationSyncMessage& registration_sync_message(const ClientToServerMessage* msg);
  static void set_has_registration_sync_message(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::ipc::invalidation::InvalidationMessage& invalidation_ack_message(const ClientToServerMessage* msg);
  static void set_has_invalidation_ack_message(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::ipc::invalidation::InfoMessage& info_message(const ClientToServerMessage* msg);
  static void set_has_info_message(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::ipc::invalidation::ClientHeader&
ClientToServerMessage::_Internal::header(const ClientToServerMessage* msg) {
  return *msg->header_;
}
const ::ipc::invalidation::InitializeMessage&
ClientToServerMessage::_Internal::initialize_message(const ClientToServerMessage* msg) {
  return *msg->initialize_message_;
}
const ::ipc::invalidation::RegistrationMessage&
ClientToServerMessage::_Internal::registration_message(const ClientToServerMessage* msg) {
  return *msg->registration_message_;
}
const ::ipc::invalidation::RegistrationSyncMessage&
ClientToServerMessage::_Internal::registration_sync_message(const ClientToServerMessage* msg) {
  return *msg->registration_sync_message_;
}
const ::ipc::invalidation::InvalidationMessage&
ClientToServerMessage::_Internal::invalidation_ack_message(const ClientToServerMessage* msg) {
  return *msg->invalidation_ack_message_;
}
const ::ipc::invalidation::InfoMessage&
ClientToServerMessage::_Internal::info_message(const ClientToServerMessage* msg) {
  return *msg->info_message_;
}
ClientToServerMessage::ClientToServerMessage()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ClientToServerMessage)
}
ClientToServerMessage::ClientToServerMessage(const ClientToServerMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::ipc::invalidation::ClientHeader(*from.header_);
  } else {
    header_ = nullptr;
  }
  if (from.has_initialize_message()) {
    initialize_message_ = new ::ipc::invalidation::InitializeMessage(*from.initialize_message_);
  } else {
    initialize_message_ = nullptr;
  }
  if (from.has_registration_message()) {
    registration_message_ = new ::ipc::invalidation::RegistrationMessage(*from.registration_message_);
  } else {
    registration_message_ = nullptr;
  }
  if (from.has_registration_sync_message()) {
    registration_sync_message_ = new ::ipc::invalidation::RegistrationSyncMessage(*from.registration_sync_message_);
  } else {
    registration_sync_message_ = nullptr;
  }
  if (from.has_invalidation_ack_message()) {
    invalidation_ack_message_ = new ::ipc::invalidation::InvalidationMessage(*from.invalidation_ack_message_);
  } else {
    invalidation_ack_message_ = nullptr;
  }
  if (from.has_info_message()) {
    info_message_ = new ::ipc::invalidation::InfoMessage(*from.info_message_);
  } else {
    info_message_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ClientToServerMessage)
}

void ClientToServerMessage::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ClientToServerMessage_client_5fprotocol_2eproto.base);
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&info_message_) -
      reinterpret_cast<char*>(&header_)) + sizeof(info_message_));
}

ClientToServerMessage::~ClientToServerMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ClientToServerMessage)
  SharedDtor();
}

void ClientToServerMessage::SharedDtor() {
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete initialize_message_;
  if (this != internal_default_instance()) delete registration_message_;
  if (this != internal_default_instance()) delete registration_sync_message_;
  if (this != internal_default_instance()) delete invalidation_ack_message_;
  if (this != internal_default_instance()) delete info_message_;
}

void ClientToServerMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ClientToServerMessage& ClientToServerMessage::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ClientToServerMessage_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void ClientToServerMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ClientToServerMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(header_ != nullptr);
      header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(initialize_message_ != nullptr);
      initialize_message_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(registration_message_ != nullptr);
      registration_message_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(registration_sync_message_ != nullptr);
      registration_sync_message_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(invalidation_ack_message_ != nullptr);
      invalidation_ack_message_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(info_message_ != nullptr);
      info_message_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ClientToServerMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .ipc.invalidation.ClientHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_header(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ipc.invalidation.InitializeMessage initialize_message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_initialize_message(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ipc.invalidation.RegistrationMessage registration_message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_registration_message(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ipc.invalidation.RegistrationSyncMessage registration_sync_message = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(mutable_registration_sync_message(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ipc.invalidation.InvalidationMessage invalidation_ack_message = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(mutable_invalidation_ack_message(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ipc.invalidation.InfoMessage info_message = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(mutable_info_message(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ClientToServerMessage::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ClientToServerMessage)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.ClientHeader header = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.InitializeMessage initialize_message = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_initialize_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.RegistrationMessage registration_message = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_registration_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.RegistrationSyncMessage registration_sync_message = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_registration_sync_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.InvalidationMessage invalidation_ack_message = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_invalidation_ack_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.InfoMessage info_message = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_info_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ClientToServerMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ClientToServerMessage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ClientToServerMessage::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ClientToServerMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.ClientHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::header(this), output);
  }

  // optional .ipc.invalidation.InitializeMessage initialize_message = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2, _Internal::initialize_message(this), output);
  }

  // optional .ipc.invalidation.RegistrationMessage registration_message = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      3, _Internal::registration_message(this), output);
  }

  // optional .ipc.invalidation.RegistrationSyncMessage registration_sync_message = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      4, _Internal::registration_sync_message(this), output);
  }

  // optional .ipc.invalidation.InvalidationMessage invalidation_ack_message = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      5, _Internal::invalidation_ack_message(this), output);
  }

  // optional .ipc.invalidation.InfoMessage info_message = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      6, _Internal::info_message(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ClientToServerMessage)
}

size_t ClientToServerMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ClientToServerMessage)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .ipc.invalidation.ClientHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *header_);
    }

    // optional .ipc.invalidation.InitializeMessage initialize_message = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *initialize_message_);
    }

    // optional .ipc.invalidation.RegistrationMessage registration_message = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *registration_message_);
    }

    // optional .ipc.invalidation.RegistrationSyncMessage registration_sync_message = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *registration_sync_message_);
    }

    // optional .ipc.invalidation.InvalidationMessage invalidation_ack_message = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *invalidation_ack_message_);
    }

    // optional .ipc.invalidation.InfoMessage info_message = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *info_message_);
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientToServerMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ClientToServerMessage*>(
      &from));
}

void ClientToServerMessage::MergeFrom(const ClientToServerMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ClientToServerMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_header()->::ipc::invalidation::ClientHeader::MergeFrom(from.header());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_initialize_message()->::ipc::invalidation::InitializeMessage::MergeFrom(from.initialize_message());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_registration_message()->::ipc::invalidation::RegistrationMessage::MergeFrom(from.registration_message());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_registration_sync_message()->::ipc::invalidation::RegistrationSyncMessage::MergeFrom(from.registration_sync_message());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_invalidation_ack_message()->::ipc::invalidation::InvalidationMessage::MergeFrom(from.invalidation_ack_message());
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_info_message()->::ipc::invalidation::InfoMessage::MergeFrom(from.info_message());
    }
  }
}

void ClientToServerMessage::CopyFrom(const ClientToServerMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ClientToServerMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientToServerMessage::IsInitialized() const {
  return true;
}

void ClientToServerMessage::InternalSwap(ClientToServerMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(header_, other->header_);
  swap(initialize_message_, other->initialize_message_);
  swap(registration_message_, other->registration_message_);
  swap(registration_sync_message_, other->registration_sync_message_);
  swap(invalidation_ack_message_, other->invalidation_ack_message_);
  swap(info_message_, other->info_message_);
}

std::string ClientToServerMessage::GetTypeName() const {
  return "ipc.invalidation.ClientToServerMessage";
}


// ===================================================================

void InitializeMessage::InitAsDefaultInstance() {
  ::ipc::invalidation::_InitializeMessage_default_instance_._instance.get_mutable()->application_client_id_ = const_cast< ::ipc::invalidation::ApplicationClientIdP*>(
      ::ipc::invalidation::ApplicationClientIdP::internal_default_instance());
}
class InitializeMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<InitializeMessage>()._has_bits_);
  static void set_has_client_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_nonce(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ipc::invalidation::ApplicationClientIdP& application_client_id(const InitializeMessage* msg);
  static void set_has_application_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_digest_serialization_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::ipc::invalidation::ApplicationClientIdP&
InitializeMessage::_Internal::application_client_id(const InitializeMessage* msg) {
  return *msg->application_client_id_;
}
InitializeMessage::InitializeMessage()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.InitializeMessage)
}
InitializeMessage::InitializeMessage(const InitializeMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  nonce_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_nonce()) {
    nonce_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nonce_);
  }
  if (from.has_application_client_id()) {
    application_client_id_ = new ::ipc::invalidation::ApplicationClientIdP(*from.application_client_id_);
  } else {
    application_client_id_ = nullptr;
  }
  ::memcpy(&client_type_, &from.client_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&digest_serialization_type_) -
    reinterpret_cast<char*>(&client_type_)) + sizeof(digest_serialization_type_));
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.InitializeMessage)
}

void InitializeMessage::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_InitializeMessage_client_5fprotocol_2eproto.base);
  nonce_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&application_client_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&client_type_) -
      reinterpret_cast<char*>(&application_client_id_)) + sizeof(client_type_));
  digest_serialization_type_ = 1;
}

InitializeMessage::~InitializeMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.InitializeMessage)
  SharedDtor();
}

void InitializeMessage::SharedDtor() {
  nonce_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete application_client_id_;
}

void InitializeMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const InitializeMessage& InitializeMessage::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_InitializeMessage_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void InitializeMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.InitializeMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      nonce_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(application_client_id_ != nullptr);
      application_client_id_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    client_type_ = 0;
    digest_serialization_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* InitializeMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 client_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_client_type(&has_bits);
          client_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes nonce = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_nonce(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ipc.invalidation.ApplicationClientIdP application_client_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_application_client_id(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ipc.invalidation.InitializeMessage.DigestSerializationType digest_serialization_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ipc::invalidation::InitializeMessage_DigestSerializationType_IsValid(val))) {
            set_digest_serialization_type(static_cast<::ipc::invalidation::InitializeMessage_DigestSerializationType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool InitializeMessage::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.InitializeMessage)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 client_type = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_client_type(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &client_type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes nonce = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nonce()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.ApplicationClientIdP application_client_id = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_application_client_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.InitializeMessage.DigestSerializationType digest_serialization_type = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ipc::invalidation::InitializeMessage_DigestSerializationType_IsValid(value)) {
            set_digest_serialization_type(static_cast< ::ipc::invalidation::InitializeMessage_DigestSerializationType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(32u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.InitializeMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.InitializeMessage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void InitializeMessage::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.InitializeMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 client_type = 1;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->client_type(), output);
  }

  // optional bytes nonce = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->nonce(), output);
  }

  // optional .ipc.invalidation.ApplicationClientIdP application_client_id = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      3, _Internal::application_client_id(this), output);
  }

  // optional .ipc.invalidation.InitializeMessage.DigestSerializationType digest_serialization_type = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      4, this->digest_serialization_type(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.InitializeMessage)
}

size_t InitializeMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.InitializeMessage)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes nonce = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->nonce());
    }

    // optional .ipc.invalidation.ApplicationClientIdP application_client_id = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *application_client_id_);
    }

    // optional int32 client_type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->client_type());
    }

    // optional .ipc.invalidation.InitializeMessage.DigestSerializationType digest_serialization_type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->digest_serialization_type());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InitializeMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const InitializeMessage*>(
      &from));
}

void InitializeMessage::MergeFrom(const InitializeMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.InitializeMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      nonce_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nonce_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_application_client_id()->::ipc::invalidation::ApplicationClientIdP::MergeFrom(from.application_client_id());
    }
    if (cached_has_bits & 0x00000004u) {
      client_type_ = from.client_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      digest_serialization_type_ = from.digest_serialization_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void InitializeMessage::CopyFrom(const InitializeMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.InitializeMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitializeMessage::IsInitialized() const {
  return true;
}

void InitializeMessage::InternalSwap(InitializeMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  nonce_.Swap(&other->nonce_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(application_client_id_, other->application_client_id_);
  swap(client_type_, other->client_type_);
  swap(digest_serialization_type_, other->digest_serialization_type_);
}

std::string InitializeMessage::GetTypeName() const {
  return "ipc.invalidation.InitializeMessage";
}


// ===================================================================

void RegistrationMessage::InitAsDefaultInstance() {
}
class RegistrationMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<RegistrationMessage>()._has_bits_);
};

RegistrationMessage::RegistrationMessage()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationMessage)
}
RegistrationMessage::RegistrationMessage(const RegistrationMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      registration_(from.registration_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationMessage)
}

void RegistrationMessage::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RegistrationMessage_client_5fprotocol_2eproto.base);
}

RegistrationMessage::~RegistrationMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationMessage)
  SharedDtor();
}

void RegistrationMessage::SharedDtor() {
}

void RegistrationMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RegistrationMessage& RegistrationMessage::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RegistrationMessage_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void RegistrationMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  registration_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RegistrationMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .ipc.invalidation.RegistrationP registration = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_registration(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RegistrationMessage::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationMessage)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ipc.invalidation.RegistrationP registration = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_registration()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationMessage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RegistrationMessage::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ipc.invalidation.RegistrationP registration = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->registration_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1,
      this->registration(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationMessage)
}

size_t RegistrationMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationMessage)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ipc.invalidation.RegistrationP registration = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->registration_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->registration(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RegistrationMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RegistrationMessage*>(
      &from));
}

void RegistrationMessage::MergeFrom(const RegistrationMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  registration_.MergeFrom(from.registration_);
}

void RegistrationMessage::CopyFrom(const RegistrationMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegistrationMessage::IsInitialized() const {
  return true;
}

void RegistrationMessage::InternalSwap(RegistrationMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&registration_)->InternalSwap(CastToBase(&other->registration_));
}

std::string RegistrationMessage::GetTypeName() const {
  return "ipc.invalidation.RegistrationMessage";
}


// ===================================================================

void RegistrationSyncMessage::InitAsDefaultInstance() {
}
class RegistrationSyncMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<RegistrationSyncMessage>()._has_bits_);
};

RegistrationSyncMessage::RegistrationSyncMessage()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationSyncMessage)
}
RegistrationSyncMessage::RegistrationSyncMessage(const RegistrationSyncMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      subtree_(from.subtree_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationSyncMessage)
}

void RegistrationSyncMessage::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RegistrationSyncMessage_client_5fprotocol_2eproto.base);
}

RegistrationSyncMessage::~RegistrationSyncMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationSyncMessage)
  SharedDtor();
}

void RegistrationSyncMessage::SharedDtor() {
}

void RegistrationSyncMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RegistrationSyncMessage& RegistrationSyncMessage::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RegistrationSyncMessage_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void RegistrationSyncMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationSyncMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  subtree_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RegistrationSyncMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .ipc.invalidation.RegistrationSubtree subtree = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_subtree(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RegistrationSyncMessage::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationSyncMessage)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ipc.invalidation.RegistrationSubtree subtree = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_subtree()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationSyncMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationSyncMessage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RegistrationSyncMessage::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationSyncMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ipc.invalidation.RegistrationSubtree subtree = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->subtree_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1,
      this->subtree(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationSyncMessage)
}

size_t RegistrationSyncMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationSyncMessage)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ipc.invalidation.RegistrationSubtree subtree = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->subtree_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->subtree(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RegistrationSyncMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RegistrationSyncMessage*>(
      &from));
}

void RegistrationSyncMessage::MergeFrom(const RegistrationSyncMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationSyncMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  subtree_.MergeFrom(from.subtree_);
}

void RegistrationSyncMessage::CopyFrom(const RegistrationSyncMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationSyncMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegistrationSyncMessage::IsInitialized() const {
  return true;
}

void RegistrationSyncMessage::InternalSwap(RegistrationSyncMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&subtree_)->InternalSwap(CastToBase(&other->subtree_));
}

std::string RegistrationSyncMessage::GetTypeName() const {
  return "ipc.invalidation.RegistrationSyncMessage";
}


// ===================================================================

void RegistrationSubtree::InitAsDefaultInstance() {
}
class RegistrationSubtree::_Internal {
 public:
  using HasBits = decltype(std::declval<RegistrationSubtree>()._has_bits_);
};

RegistrationSubtree::RegistrationSubtree()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationSubtree)
}
RegistrationSubtree::RegistrationSubtree(const RegistrationSubtree& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      registered_object_(from.registered_object_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationSubtree)
}

void RegistrationSubtree::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RegistrationSubtree_client_5fprotocol_2eproto.base);
}

RegistrationSubtree::~RegistrationSubtree() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationSubtree)
  SharedDtor();
}

void RegistrationSubtree::SharedDtor() {
}

void RegistrationSubtree::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RegistrationSubtree& RegistrationSubtree::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RegistrationSubtree_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void RegistrationSubtree::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationSubtree)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  registered_object_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RegistrationSubtree::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .ipc.invalidation.ObjectIdP registered_object = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_registered_object(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RegistrationSubtree::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationSubtree)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ipc.invalidation.ObjectIdP registered_object = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_registered_object()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationSubtree)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationSubtree)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RegistrationSubtree::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationSubtree)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ipc.invalidation.ObjectIdP registered_object = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->registered_object_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1,
      this->registered_object(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationSubtree)
}

size_t RegistrationSubtree::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationSubtree)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ipc.invalidation.ObjectIdP registered_object = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->registered_object_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->registered_object(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RegistrationSubtree::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RegistrationSubtree*>(
      &from));
}

void RegistrationSubtree::MergeFrom(const RegistrationSubtree& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationSubtree)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  registered_object_.MergeFrom(from.registered_object_);
}

void RegistrationSubtree::CopyFrom(const RegistrationSubtree& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationSubtree)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegistrationSubtree::IsInitialized() const {
  return true;
}

void RegistrationSubtree::InternalSwap(RegistrationSubtree* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&registered_object_)->InternalSwap(CastToBase(&other->registered_object_));
}

std::string RegistrationSubtree::GetTypeName() const {
  return "ipc.invalidation.RegistrationSubtree";
}


// ===================================================================

void InfoMessage::InitAsDefaultInstance() {
  ::ipc::invalidation::_InfoMessage_default_instance_._instance.get_mutable()->client_version_ = const_cast< ::ipc::invalidation::ClientVersion*>(
      ::ipc::invalidation::ClientVersion::internal_default_instance());
  ::ipc::invalidation::_InfoMessage_default_instance_._instance.get_mutable()->client_config_ = const_cast< ::ipc::invalidation::ClientConfigP*>(
      ::ipc::invalidation::ClientConfigP::internal_default_instance());
}
class InfoMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<InfoMessage>()._has_bits_);
  static const ::ipc::invalidation::ClientVersion& client_version(const InfoMessage* msg);
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_server_registration_summary_requested(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::ipc::invalidation::ClientConfigP& client_config(const InfoMessage* msg);
  static void set_has_client_config(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::ipc::invalidation::ClientVersion&
InfoMessage::_Internal::client_version(const InfoMessage* msg) {
  return *msg->client_version_;
}
const ::ipc::invalidation::ClientConfigP&
InfoMessage::_Internal::client_config(const InfoMessage* msg) {
  return *msg->client_config_;
}
InfoMessage::InfoMessage()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.InfoMessage)
}
InfoMessage::InfoMessage(const InfoMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      config_parameter_(from.config_parameter_),
      performance_counter_(from.performance_counter_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_client_version()) {
    client_version_ = new ::ipc::invalidation::ClientVersion(*from.client_version_);
  } else {
    client_version_ = nullptr;
  }
  if (from.has_client_config()) {
    client_config_ = new ::ipc::invalidation::ClientConfigP(*from.client_config_);
  } else {
    client_config_ = nullptr;
  }
  server_registration_summary_requested_ = from.server_registration_summary_requested_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.InfoMessage)
}

void InfoMessage::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_InfoMessage_client_5fprotocol_2eproto.base);
  ::memset(&client_version_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&server_registration_summary_requested_) -
      reinterpret_cast<char*>(&client_version_)) + sizeof(server_registration_summary_requested_));
}

InfoMessage::~InfoMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.InfoMessage)
  SharedDtor();
}

void InfoMessage::SharedDtor() {
  if (this != internal_default_instance()) delete client_version_;
  if (this != internal_default_instance()) delete client_config_;
}

void InfoMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const InfoMessage& InfoMessage::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_InfoMessage_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void InfoMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.InfoMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  config_parameter_.Clear();
  performance_counter_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(client_version_ != nullptr);
      client_version_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(client_config_ != nullptr);
      client_config_->Clear();
    }
  }
  server_registration_summary_requested_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* InfoMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .ipc.invalidation.ClientVersion client_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_client_version(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .ipc.invalidation.PropertyRecord config_parameter = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_config_parameter(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      // repeated .ipc.invalidation.PropertyRecord performance_counter = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_performance_counter(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 26);
        } else goto handle_unusual;
        continue;
      // optional bool server_registration_summary_requested = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_server_registration_summary_requested(&has_bits);
          server_registration_summary_requested_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ipc.invalidation.ClientConfigP client_config = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(mutable_client_config(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool InfoMessage::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.InfoMessage)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.ClientVersion client_version = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_client_version()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .ipc.invalidation.PropertyRecord config_parameter = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_config_parameter()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .ipc.invalidation.PropertyRecord performance_counter = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_performance_counter()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool server_registration_summary_requested = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_server_registration_summary_requested(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &server_registration_summary_requested_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.ClientConfigP client_config = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_client_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.InfoMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.InfoMessage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void InfoMessage::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.InfoMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.ClientVersion client_version = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::client_version(this), output);
  }

  // repeated .ipc.invalidation.PropertyRecord config_parameter = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->config_parameter_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2,
      this->config_parameter(static_cast<int>(i)),
      output);
  }

  // repeated .ipc.invalidation.PropertyRecord performance_counter = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->performance_counter_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      3,
      this->performance_counter(static_cast<int>(i)),
      output);
  }

  // optional bool server_registration_summary_requested = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(4, this->server_registration_summary_requested(), output);
  }

  // optional .ipc.invalidation.ClientConfigP client_config = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      5, _Internal::client_config(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.InfoMessage)
}

size_t InfoMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.InfoMessage)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ipc.invalidation.PropertyRecord config_parameter = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->config_parameter_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->config_parameter(static_cast<int>(i)));
    }
  }

  // repeated .ipc.invalidation.PropertyRecord performance_counter = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->performance_counter_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->performance_counter(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .ipc.invalidation.ClientVersion client_version = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_version_);
    }

    // optional .ipc.invalidation.ClientConfigP client_config = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_config_);
    }

    // optional bool server_registration_summary_requested = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InfoMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const InfoMessage*>(
      &from));
}

void InfoMessage::MergeFrom(const InfoMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.InfoMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  config_parameter_.MergeFrom(from.config_parameter_);
  performance_counter_.MergeFrom(from.performance_counter_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_client_version()->::ipc::invalidation::ClientVersion::MergeFrom(from.client_version());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_client_config()->::ipc::invalidation::ClientConfigP::MergeFrom(from.client_config());
    }
    if (cached_has_bits & 0x00000004u) {
      server_registration_summary_requested_ = from.server_registration_summary_requested_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void InfoMessage::CopyFrom(const InfoMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.InfoMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InfoMessage::IsInitialized() const {
  return true;
}

void InfoMessage::InternalSwap(InfoMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&config_parameter_)->InternalSwap(CastToBase(&other->config_parameter_));
  CastToBase(&performance_counter_)->InternalSwap(CastToBase(&other->performance_counter_));
  swap(client_version_, other->client_version_);
  swap(client_config_, other->client_config_);
  swap(server_registration_summary_requested_, other->server_registration_summary_requested_);
}

std::string InfoMessage::GetTypeName() const {
  return "ipc.invalidation.InfoMessage";
}


// ===================================================================

void PropertyRecord::InitAsDefaultInstance() {
}
class PropertyRecord::_Internal {
 public:
  using HasBits = decltype(std::declval<PropertyRecord>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PropertyRecord::PropertyRecord()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.PropertyRecord)
}
PropertyRecord::PropertyRecord(const PropertyRecord& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  value_ = from.value_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.PropertyRecord)
}

void PropertyRecord::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PropertyRecord_client_5fprotocol_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  value_ = 0;
}

PropertyRecord::~PropertyRecord() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.PropertyRecord)
  SharedDtor();
}

void PropertyRecord::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PropertyRecord::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PropertyRecord& PropertyRecord::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PropertyRecord_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void PropertyRecord::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.PropertyRecord)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmptyNoArena();
  }
  value_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PropertyRecord::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_value(&has_bits);
          value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PropertyRecord::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.PropertyRecord)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 value = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_value(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &value_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.PropertyRecord)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.PropertyRecord)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PropertyRecord::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.PropertyRecord)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional int32 value = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->value(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.PropertyRecord)
}

size_t PropertyRecord::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.PropertyRecord)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->value());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PropertyRecord::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PropertyRecord*>(
      &from));
}

void PropertyRecord::MergeFrom(const PropertyRecord& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.PropertyRecord)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      value_ = from.value_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PropertyRecord::CopyFrom(const PropertyRecord& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.PropertyRecord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PropertyRecord::IsInitialized() const {
  return true;
}

void PropertyRecord::InternalSwap(PropertyRecord* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(value_, other->value_);
}

std::string PropertyRecord::GetTypeName() const {
  return "ipc.invalidation.PropertyRecord";
}


// ===================================================================

void ServerHeader::InitAsDefaultInstance() {
  ::ipc::invalidation::_ServerHeader_default_instance_._instance.get_mutable()->protocol_version_ = const_cast< ::ipc::invalidation::ProtocolVersion*>(
      ::ipc::invalidation::ProtocolVersion::internal_default_instance());
  ::ipc::invalidation::_ServerHeader_default_instance_._instance.get_mutable()->registration_summary_ = const_cast< ::ipc::invalidation::RegistrationSummary*>(
      ::ipc::invalidation::RegistrationSummary::internal_default_instance());
}
class ServerHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<ServerHeader>()._has_bits_);
  static const ::ipc::invalidation::ProtocolVersion& protocol_version(const ServerHeader* msg);
  static void set_has_protocol_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_client_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ipc::invalidation::RegistrationSummary& registration_summary(const ServerHeader* msg);
  static void set_has_registration_summary(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_server_time_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_message_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::ipc::invalidation::ProtocolVersion&
ServerHeader::_Internal::protocol_version(const ServerHeader* msg) {
  return *msg->protocol_version_;
}
const ::ipc::invalidation::RegistrationSummary&
ServerHeader::_Internal::registration_summary(const ServerHeader* msg) {
  return *msg->registration_summary_;
}
ServerHeader::ServerHeader()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ServerHeader)
}
ServerHeader::ServerHeader(const ServerHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  client_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_client_token()) {
    client_token_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.client_token_);
  }
  message_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_message_id()) {
    message_id_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.message_id_);
  }
  if (from.has_protocol_version()) {
    protocol_version_ = new ::ipc::invalidation::ProtocolVersion(*from.protocol_version_);
  } else {
    protocol_version_ = nullptr;
  }
  if (from.has_registration_summary()) {
    registration_summary_ = new ::ipc::invalidation::RegistrationSummary(*from.registration_summary_);
  } else {
    registration_summary_ = nullptr;
  }
  server_time_ms_ = from.server_time_ms_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ServerHeader)
}

void ServerHeader::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ServerHeader_client_5fprotocol_2eproto.base);
  client_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  message_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&protocol_version_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&server_time_ms_) -
      reinterpret_cast<char*>(&protocol_version_)) + sizeof(server_time_ms_));
}

ServerHeader::~ServerHeader() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ServerHeader)
  SharedDtor();
}

void ServerHeader::SharedDtor() {
  client_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  message_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete protocol_version_;
  if (this != internal_default_instance()) delete registration_summary_;
}

void ServerHeader::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ServerHeader& ServerHeader::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ServerHeader_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void ServerHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ServerHeader)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      client_token_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      message_id_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(protocol_version_ != nullptr);
      protocol_version_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(registration_summary_ != nullptr);
      registration_summary_->Clear();
    }
  }
  server_time_ms_ = PROTOBUF_LONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ServerHeader::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_protocol_version(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes client_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_client_token(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_registration_summary(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 server_time_ms = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_server_time_ms(&has_bits);
          server_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string message_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_message_id(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ServerHeader::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ServerHeader)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_protocol_version()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes client_token = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_client_token()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_registration_summary()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 server_time_ms = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_server_time_ms(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &server_time_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string message_id = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_message_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ServerHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ServerHeader)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ServerHeader::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ServerHeader)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::protocol_version(this), output);
  }

  // optional bytes client_token = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->client_token(), output);
  }

  // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      3, _Internal::registration_summary(this), output);
  }

  // optional int64 server_time_ms = 4;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->server_time_ms(), output);
  }

  // optional string message_id = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->message_id(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ServerHeader)
}

size_t ServerHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ServerHeader)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes client_token = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->client_token());
    }

    // optional string message_id = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->message_id());
    }

    // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *protocol_version_);
    }

    // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *registration_summary_);
    }

    // optional int64 server_time_ms = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->server_time_ms());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ServerHeader::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ServerHeader*>(
      &from));
}

void ServerHeader::MergeFrom(const ServerHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ServerHeader)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      client_token_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.client_token_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      message_id_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.message_id_);
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_protocol_version()->::ipc::invalidation::ProtocolVersion::MergeFrom(from.protocol_version());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_registration_summary()->::ipc::invalidation::RegistrationSummary::MergeFrom(from.registration_summary());
    }
    if (cached_has_bits & 0x00000010u) {
      server_time_ms_ = from.server_time_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ServerHeader::CopyFrom(const ServerHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ServerHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerHeader::IsInitialized() const {
  return true;
}

void ServerHeader::InternalSwap(ServerHeader* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  client_token_.Swap(&other->client_token_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  message_id_.Swap(&other->message_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(protocol_version_, other->protocol_version_);
  swap(registration_summary_, other->registration_summary_);
  swap(server_time_ms_, other->server_time_ms_);
}

std::string ServerHeader::GetTypeName() const {
  return "ipc.invalidation.ServerHeader";
}


// ===================================================================

void ServerToClientMessage::InitAsDefaultInstance() {
  ::ipc::invalidation::_ServerToClientMessage_default_instance_._instance.get_mutable()->header_ = const_cast< ::ipc::invalidation::ServerHeader*>(
      ::ipc::invalidation::ServerHeader::internal_default_instance());
  ::ipc::invalidation::_ServerToClientMessage_default_instance_._instance.get_mutable()->token_control_message_ = const_cast< ::ipc::invalidation::TokenControlMessage*>(
      ::ipc::invalidation::TokenControlMessage::internal_default_instance());
  ::ipc::invalidation::_ServerToClientMessage_default_instance_._instance.get_mutable()->invalidation_message_ = const_cast< ::ipc::invalidation::InvalidationMessage*>(
      ::ipc::invalidation::InvalidationMessage::internal_default_instance());
  ::ipc::invalidation::_ServerToClientMessage_default_instance_._instance.get_mutable()->registration_status_message_ = const_cast< ::ipc::invalidation::RegistrationStatusMessage*>(
      ::ipc::invalidation::RegistrationStatusMessage::internal_default_instance());
  ::ipc::invalidation::_ServerToClientMessage_default_instance_._instance.get_mutable()->registration_sync_request_message_ = const_cast< ::ipc::invalidation::RegistrationSyncRequestMessage*>(
      ::ipc::invalidation::RegistrationSyncRequestMessage::internal_default_instance());
  ::ipc::invalidation::_ServerToClientMessage_default_instance_._instance.get_mutable()->config_change_message_ = const_cast< ::ipc::invalidation::ConfigChangeMessage*>(
      ::ipc::invalidation::ConfigChangeMessage::internal_default_instance());
  ::ipc::invalidation::_ServerToClientMessage_default_instance_._instance.get_mutable()->info_request_message_ = const_cast< ::ipc::invalidation::InfoRequestMessage*>(
      ::ipc::invalidation::InfoRequestMessage::internal_default_instance());
  ::ipc::invalidation::_ServerToClientMessage_default_instance_._instance.get_mutable()->error_message_ = const_cast< ::ipc::invalidation::ErrorMessage*>(
      ::ipc::invalidation::ErrorMessage::internal_default_instance());
}
class ServerToClientMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ServerToClientMessage>()._has_bits_);
  static const ::ipc::invalidation::ServerHeader& header(const ServerToClientMessage* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ipc::invalidation::TokenControlMessage& token_control_message(const ServerToClientMessage* msg);
  static void set_has_token_control_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::ipc::invalidation::InvalidationMessage& invalidation_message(const ServerToClientMessage* msg);
  static void set_has_invalidation_message(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::ipc::invalidation::RegistrationStatusMessage& registration_status_message(const ServerToClientMessage* msg);
  static void set_has_registration_status_message(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::ipc::invalidation::RegistrationSyncRequestMessage& registration_sync_request_message(const ServerToClientMessage* msg);
  static void set_has_registration_sync_request_message(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::ipc::invalidation::ConfigChangeMessage& config_change_message(const ServerToClientMessage* msg);
  static void set_has_config_change_message(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::ipc::invalidation::InfoRequestMessage& info_request_message(const ServerToClientMessage* msg);
  static void set_has_info_request_message(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::ipc::invalidation::ErrorMessage& error_message(const ServerToClientMessage* msg);
  static void set_has_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::ipc::invalidation::ServerHeader&
ServerToClientMessage::_Internal::header(const ServerToClientMessage* msg) {
  return *msg->header_;
}
const ::ipc::invalidation::TokenControlMessage&
ServerToClientMessage::_Internal::token_control_message(const ServerToClientMessage* msg) {
  return *msg->token_control_message_;
}
const ::ipc::invalidation::InvalidationMessage&
ServerToClientMessage::_Internal::invalidation_message(const ServerToClientMessage* msg) {
  return *msg->invalidation_message_;
}
const ::ipc::invalidation::RegistrationStatusMessage&
ServerToClientMessage::_Internal::registration_status_message(const ServerToClientMessage* msg) {
  return *msg->registration_status_message_;
}
const ::ipc::invalidation::RegistrationSyncRequestMessage&
ServerToClientMessage::_Internal::registration_sync_request_message(const ServerToClientMessage* msg) {
  return *msg->registration_sync_request_message_;
}
const ::ipc::invalidation::ConfigChangeMessage&
ServerToClientMessage::_Internal::config_change_message(const ServerToClientMessage* msg) {
  return *msg->config_change_message_;
}
const ::ipc::invalidation::InfoRequestMessage&
ServerToClientMessage::_Internal::info_request_message(const ServerToClientMessage* msg) {
  return *msg->info_request_message_;
}
const ::ipc::invalidation::ErrorMessage&
ServerToClientMessage::_Internal::error_message(const ServerToClientMessage* msg) {
  return *msg->error_message_;
}
ServerToClientMessage::ServerToClientMessage()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ServerToClientMessage)
}
ServerToClientMessage::ServerToClientMessage(const ServerToClientMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::ipc::invalidation::ServerHeader(*from.header_);
  } else {
    header_ = nullptr;
  }
  if (from.has_token_control_message()) {
    token_control_message_ = new ::ipc::invalidation::TokenControlMessage(*from.token_control_message_);
  } else {
    token_control_message_ = nullptr;
  }
  if (from.has_invalidation_message()) {
    invalidation_message_ = new ::ipc::invalidation::InvalidationMessage(*from.invalidation_message_);
  } else {
    invalidation_message_ = nullptr;
  }
  if (from.has_registration_status_message()) {
    registration_status_message_ = new ::ipc::invalidation::RegistrationStatusMessage(*from.registration_status_message_);
  } else {
    registration_status_message_ = nullptr;
  }
  if (from.has_registration_sync_request_message()) {
    registration_sync_request_message_ = new ::ipc::invalidation::RegistrationSyncRequestMessage(*from.registration_sync_request_message_);
  } else {
    registration_sync_request_message_ = nullptr;
  }
  if (from.has_config_change_message()) {
    config_change_message_ = new ::ipc::invalidation::ConfigChangeMessage(*from.config_change_message_);
  } else {
    config_change_message_ = nullptr;
  }
  if (from.has_info_request_message()) {
    info_request_message_ = new ::ipc::invalidation::InfoRequestMessage(*from.info_request_message_);
  } else {
    info_request_message_ = nullptr;
  }
  if (from.has_error_message()) {
    error_message_ = new ::ipc::invalidation::ErrorMessage(*from.error_message_);
  } else {
    error_message_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ServerToClientMessage)
}

void ServerToClientMessage::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ServerToClientMessage_client_5fprotocol_2eproto.base);
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&error_message_) -
      reinterpret_cast<char*>(&header_)) + sizeof(error_message_));
}

ServerToClientMessage::~ServerToClientMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ServerToClientMessage)
  SharedDtor();
}

void ServerToClientMessage::SharedDtor() {
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete token_control_message_;
  if (this != internal_default_instance()) delete invalidation_message_;
  if (this != internal_default_instance()) delete registration_status_message_;
  if (this != internal_default_instance()) delete registration_sync_request_message_;
  if (this != internal_default_instance()) delete config_change_message_;
  if (this != internal_default_instance()) delete info_request_message_;
  if (this != internal_default_instance()) delete error_message_;
}

void ServerToClientMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ServerToClientMessage& ServerToClientMessage::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ServerToClientMessage_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void ServerToClientMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ServerToClientMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(header_ != nullptr);
      header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(token_control_message_ != nullptr);
      token_control_message_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(invalidation_message_ != nullptr);
      invalidation_message_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(registration_status_message_ != nullptr);
      registration_status_message_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(registration_sync_request_message_ != nullptr);
      registration_sync_request_message_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(config_change_message_ != nullptr);
      config_change_message_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(info_request_message_ != nullptr);
      info_request_message_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(error_message_ != nullptr);
      error_message_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ServerToClientMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .ipc.invalidation.ServerHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_header(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ipc.invalidation.TokenControlMessage token_control_message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_token_control_message(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ipc.invalidation.InvalidationMessage invalidation_message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_invalidation_message(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ipc.invalidation.RegistrationStatusMessage registration_status_message = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(mutable_registration_status_message(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ipc.invalidation.RegistrationSyncRequestMessage registration_sync_request_message = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(mutable_registration_sync_request_message(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ipc.invalidation.ConfigChangeMessage config_change_message = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(mutable_config_change_message(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ipc.invalidation.InfoRequestMessage info_request_message = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(mutable_info_request_message(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ipc.invalidation.ErrorMessage error_message = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(mutable_error_message(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ServerToClientMessage::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ServerToClientMessage)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.ServerHeader header = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.TokenControlMessage token_control_message = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_token_control_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.InvalidationMessage invalidation_message = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_invalidation_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.RegistrationStatusMessage registration_status_message = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_registration_status_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.RegistrationSyncRequestMessage registration_sync_request_message = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_registration_sync_request_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.ConfigChangeMessage config_change_message = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_config_change_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.InfoRequestMessage info_request_message = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_info_request_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.ErrorMessage error_message = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (66 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_error_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ServerToClientMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ServerToClientMessage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ServerToClientMessage::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ServerToClientMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.ServerHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::header(this), output);
  }

  // optional .ipc.invalidation.TokenControlMessage token_control_message = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2, _Internal::token_control_message(this), output);
  }

  // optional .ipc.invalidation.InvalidationMessage invalidation_message = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      3, _Internal::invalidation_message(this), output);
  }

  // optional .ipc.invalidation.RegistrationStatusMessage registration_status_message = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      4, _Internal::registration_status_message(this), output);
  }

  // optional .ipc.invalidation.RegistrationSyncRequestMessage registration_sync_request_message = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      5, _Internal::registration_sync_request_message(this), output);
  }

  // optional .ipc.invalidation.ConfigChangeMessage config_change_message = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      6, _Internal::config_change_message(this), output);
  }

  // optional .ipc.invalidation.InfoRequestMessage info_request_message = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      7, _Internal::info_request_message(this), output);
  }

  // optional .ipc.invalidation.ErrorMessage error_message = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      8, _Internal::error_message(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ServerToClientMessage)
}

size_t ServerToClientMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ServerToClientMessage)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .ipc.invalidation.ServerHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *header_);
    }

    // optional .ipc.invalidation.TokenControlMessage token_control_message = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *token_control_message_);
    }

    // optional .ipc.invalidation.InvalidationMessage invalidation_message = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *invalidation_message_);
    }

    // optional .ipc.invalidation.RegistrationStatusMessage registration_status_message = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *registration_status_message_);
    }

    // optional .ipc.invalidation.RegistrationSyncRequestMessage registration_sync_request_message = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *registration_sync_request_message_);
    }

    // optional .ipc.invalidation.ConfigChangeMessage config_change_message = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *config_change_message_);
    }

    // optional .ipc.invalidation.InfoRequestMessage info_request_message = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *info_request_message_);
    }

    // optional .ipc.invalidation.ErrorMessage error_message = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *error_message_);
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ServerToClientMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ServerToClientMessage*>(
      &from));
}

void ServerToClientMessage::MergeFrom(const ServerToClientMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ServerToClientMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_header()->::ipc::invalidation::ServerHeader::MergeFrom(from.header());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_token_control_message()->::ipc::invalidation::TokenControlMessage::MergeFrom(from.token_control_message());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_invalidation_message()->::ipc::invalidation::InvalidationMessage::MergeFrom(from.invalidation_message());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_registration_status_message()->::ipc::invalidation::RegistrationStatusMessage::MergeFrom(from.registration_status_message());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_registration_sync_request_message()->::ipc::invalidation::RegistrationSyncRequestMessage::MergeFrom(from.registration_sync_request_message());
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_config_change_message()->::ipc::invalidation::ConfigChangeMessage::MergeFrom(from.config_change_message());
    }
    if (cached_has_bits & 0x00000040u) {
      mutable_info_request_message()->::ipc::invalidation::InfoRequestMessage::MergeFrom(from.info_request_message());
    }
    if (cached_has_bits & 0x00000080u) {
      mutable_error_message()->::ipc::invalidation::ErrorMessage::MergeFrom(from.error_message());
    }
  }
}

void ServerToClientMessage::CopyFrom(const ServerToClientMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ServerToClientMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerToClientMessage::IsInitialized() const {
  return true;
}

void ServerToClientMessage::InternalSwap(ServerToClientMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(header_, other->header_);
  swap(token_control_message_, other->token_control_message_);
  swap(invalidation_message_, other->invalidation_message_);
  swap(registration_status_message_, other->registration_status_message_);
  swap(registration_sync_request_message_, other->registration_sync_request_message_);
  swap(config_change_message_, other->config_change_message_);
  swap(info_request_message_, other->info_request_message_);
  swap(error_message_, other->error_message_);
}

std::string ServerToClientMessage::GetTypeName() const {
  return "ipc.invalidation.ServerToClientMessage";
}


// ===================================================================

void TokenControlMessage::InitAsDefaultInstance() {
}
class TokenControlMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<TokenControlMessage>()._has_bits_);
  static void set_has_new_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

TokenControlMessage::TokenControlMessage()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.TokenControlMessage)
}
TokenControlMessage::TokenControlMessage(const TokenControlMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  new_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_new_token()) {
    new_token_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.new_token_);
  }
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.TokenControlMessage)
}

void TokenControlMessage::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TokenControlMessage_client_5fprotocol_2eproto.base);
  new_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

TokenControlMessage::~TokenControlMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.TokenControlMessage)
  SharedDtor();
}

void TokenControlMessage::SharedDtor() {
  new_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TokenControlMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TokenControlMessage& TokenControlMessage::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TokenControlMessage_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void TokenControlMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.TokenControlMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    new_token_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TokenControlMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bytes new_token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_new_token(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TokenControlMessage::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.TokenControlMessage)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes new_token = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_new_token()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.TokenControlMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.TokenControlMessage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TokenControlMessage::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.TokenControlMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes new_token = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->new_token(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.TokenControlMessage)
}

size_t TokenControlMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.TokenControlMessage)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes new_token = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->new_token());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TokenControlMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TokenControlMessage*>(
      &from));
}

void TokenControlMessage::MergeFrom(const TokenControlMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.TokenControlMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_new_token()) {
    _has_bits_[0] |= 0x00000001u;
    new_token_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.new_token_);
  }
}

void TokenControlMessage::CopyFrom(const TokenControlMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.TokenControlMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TokenControlMessage::IsInitialized() const {
  return true;
}

void TokenControlMessage::InternalSwap(TokenControlMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  new_token_.Swap(&other->new_token_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string TokenControlMessage::GetTypeName() const {
  return "ipc.invalidation.TokenControlMessage";
}


// ===================================================================

void RegistrationStatus::InitAsDefaultInstance() {
  ::ipc::invalidation::_RegistrationStatus_default_instance_._instance.get_mutable()->registration_ = const_cast< ::ipc::invalidation::RegistrationP*>(
      ::ipc::invalidation::RegistrationP::internal_default_instance());
  ::ipc::invalidation::_RegistrationStatus_default_instance_._instance.get_mutable()->status_ = const_cast< ::ipc::invalidation::StatusP*>(
      ::ipc::invalidation::StatusP::internal_default_instance());
}
class RegistrationStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<RegistrationStatus>()._has_bits_);
  static const ::ipc::invalidation::RegistrationP& registration(const RegistrationStatus* msg);
  static void set_has_registration(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ipc::invalidation::StatusP& status(const RegistrationStatus* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::ipc::invalidation::RegistrationP&
RegistrationStatus::_Internal::registration(const RegistrationStatus* msg) {
  return *msg->registration_;
}
const ::ipc::invalidation::StatusP&
RegistrationStatus::_Internal::status(const RegistrationStatus* msg) {
  return *msg->status_;
}
RegistrationStatus::RegistrationStatus()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationStatus)
}
RegistrationStatus::RegistrationStatus(const RegistrationStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_registration()) {
    registration_ = new ::ipc::invalidation::RegistrationP(*from.registration_);
  } else {
    registration_ = nullptr;
  }
  if (from.has_status()) {
    status_ = new ::ipc::invalidation::StatusP(*from.status_);
  } else {
    status_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationStatus)
}

void RegistrationStatus::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RegistrationStatus_client_5fprotocol_2eproto.base);
  ::memset(&registration_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&status_) -
      reinterpret_cast<char*>(&registration_)) + sizeof(status_));
}

RegistrationStatus::~RegistrationStatus() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationStatus)
  SharedDtor();
}

void RegistrationStatus::SharedDtor() {
  if (this != internal_default_instance()) delete registration_;
  if (this != internal_default_instance()) delete status_;
}

void RegistrationStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RegistrationStatus& RegistrationStatus::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RegistrationStatus_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void RegistrationStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(registration_ != nullptr);
      registration_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(status_ != nullptr);
      status_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RegistrationStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .ipc.invalidation.RegistrationP registration = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_registration(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ipc.invalidation.StatusP status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_status(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RegistrationStatus::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationStatus)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.RegistrationP registration = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_registration()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.StatusP status = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_status()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationStatus)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RegistrationStatus::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.RegistrationP registration = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::registration(this), output);
  }

  // optional .ipc.invalidation.StatusP status = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2, _Internal::status(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationStatus)
}

size_t RegistrationStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationStatus)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .ipc.invalidation.RegistrationP registration = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *registration_);
    }

    // optional .ipc.invalidation.StatusP status = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *status_);
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RegistrationStatus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RegistrationStatus*>(
      &from));
}

void RegistrationStatus::MergeFrom(const RegistrationStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_registration()->::ipc::invalidation::RegistrationP::MergeFrom(from.registration());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_status()->::ipc::invalidation::StatusP::MergeFrom(from.status());
    }
  }
}

void RegistrationStatus::CopyFrom(const RegistrationStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegistrationStatus::IsInitialized() const {
  return true;
}

void RegistrationStatus::InternalSwap(RegistrationStatus* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(registration_, other->registration_);
  swap(status_, other->status_);
}

std::string RegistrationStatus::GetTypeName() const {
  return "ipc.invalidation.RegistrationStatus";
}


// ===================================================================

void RegistrationStatusMessage::InitAsDefaultInstance() {
}
class RegistrationStatusMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<RegistrationStatusMessage>()._has_bits_);
};

RegistrationStatusMessage::RegistrationStatusMessage()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationStatusMessage)
}
RegistrationStatusMessage::RegistrationStatusMessage(const RegistrationStatusMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      registration_status_(from.registration_status_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationStatusMessage)
}

void RegistrationStatusMessage::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RegistrationStatusMessage_client_5fprotocol_2eproto.base);
}

RegistrationStatusMessage::~RegistrationStatusMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationStatusMessage)
  SharedDtor();
}

void RegistrationStatusMessage::SharedDtor() {
}

void RegistrationStatusMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RegistrationStatusMessage& RegistrationStatusMessage::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RegistrationStatusMessage_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void RegistrationStatusMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationStatusMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  registration_status_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RegistrationStatusMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .ipc.invalidation.RegistrationStatus registration_status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_registration_status(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RegistrationStatusMessage::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationStatusMessage)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ipc.invalidation.RegistrationStatus registration_status = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_registration_status()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationStatusMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationStatusMessage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RegistrationStatusMessage::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationStatusMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ipc.invalidation.RegistrationStatus registration_status = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->registration_status_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1,
      this->registration_status(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationStatusMessage)
}

size_t RegistrationStatusMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationStatusMessage)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ipc.invalidation.RegistrationStatus registration_status = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->registration_status_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->registration_status(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RegistrationStatusMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RegistrationStatusMessage*>(
      &from));
}

void RegistrationStatusMessage::MergeFrom(const RegistrationStatusMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationStatusMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  registration_status_.MergeFrom(from.registration_status_);
}

void RegistrationStatusMessage::CopyFrom(const RegistrationStatusMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationStatusMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegistrationStatusMessage::IsInitialized() const {
  return true;
}

void RegistrationStatusMessage::InternalSwap(RegistrationStatusMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&registration_status_)->InternalSwap(CastToBase(&other->registration_status_));
}

std::string RegistrationStatusMessage::GetTypeName() const {
  return "ipc.invalidation.RegistrationStatusMessage";
}


// ===================================================================

void RegistrationSyncRequestMessage::InitAsDefaultInstance() {
}
class RegistrationSyncRequestMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<RegistrationSyncRequestMessage>()._has_bits_);
};

RegistrationSyncRequestMessage::RegistrationSyncRequestMessage()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationSyncRequestMessage)
}
RegistrationSyncRequestMessage::RegistrationSyncRequestMessage(const RegistrationSyncRequestMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationSyncRequestMessage)
}

void RegistrationSyncRequestMessage::SharedCtor() {
}

RegistrationSyncRequestMessage::~RegistrationSyncRequestMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationSyncRequestMessage)
  SharedDtor();
}

void RegistrationSyncRequestMessage::SharedDtor() {
}

void RegistrationSyncRequestMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RegistrationSyncRequestMessage& RegistrationSyncRequestMessage::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RegistrationSyncRequestMessage_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void RegistrationSyncRequestMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationSyncRequestMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RegistrationSyncRequestMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RegistrationSyncRequestMessage::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationSyncRequestMessage)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationSyncRequestMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationSyncRequestMessage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RegistrationSyncRequestMessage::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationSyncRequestMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationSyncRequestMessage)
}

size_t RegistrationSyncRequestMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationSyncRequestMessage)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RegistrationSyncRequestMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RegistrationSyncRequestMessage*>(
      &from));
}

void RegistrationSyncRequestMessage::MergeFrom(const RegistrationSyncRequestMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationSyncRequestMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void RegistrationSyncRequestMessage::CopyFrom(const RegistrationSyncRequestMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationSyncRequestMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegistrationSyncRequestMessage::IsInitialized() const {
  return true;
}

void RegistrationSyncRequestMessage::InternalSwap(RegistrationSyncRequestMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

std::string RegistrationSyncRequestMessage::GetTypeName() const {
  return "ipc.invalidation.RegistrationSyncRequestMessage";
}


// ===================================================================

void InvalidationMessage::InitAsDefaultInstance() {
}
class InvalidationMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<InvalidationMessage>()._has_bits_);
};

InvalidationMessage::InvalidationMessage()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.InvalidationMessage)
}
InvalidationMessage::InvalidationMessage(const InvalidationMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      invalidation_(from.invalidation_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.InvalidationMessage)
}

void InvalidationMessage::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_InvalidationMessage_client_5fprotocol_2eproto.base);
}

InvalidationMessage::~InvalidationMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.InvalidationMessage)
  SharedDtor();
}

void InvalidationMessage::SharedDtor() {
}

void InvalidationMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const InvalidationMessage& InvalidationMessage::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_InvalidationMessage_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void InvalidationMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.InvalidationMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  invalidation_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* InvalidationMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .ipc.invalidation.InvalidationP invalidation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_invalidation(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool InvalidationMessage::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.InvalidationMessage)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ipc.invalidation.InvalidationP invalidation = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_invalidation()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.InvalidationMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.InvalidationMessage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void InvalidationMessage::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.InvalidationMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ipc.invalidation.InvalidationP invalidation = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->invalidation_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1,
      this->invalidation(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.InvalidationMessage)
}

size_t InvalidationMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.InvalidationMessage)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ipc.invalidation.InvalidationP invalidation = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->invalidation_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->invalidation(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InvalidationMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const InvalidationMessage*>(
      &from));
}

void InvalidationMessage::MergeFrom(const InvalidationMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.InvalidationMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  invalidation_.MergeFrom(from.invalidation_);
}

void InvalidationMessage::CopyFrom(const InvalidationMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.InvalidationMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InvalidationMessage::IsInitialized() const {
  return true;
}

void InvalidationMessage::InternalSwap(InvalidationMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&invalidation_)->InternalSwap(CastToBase(&other->invalidation_));
}

std::string InvalidationMessage::GetTypeName() const {
  return "ipc.invalidation.InvalidationMessage";
}


// ===================================================================

void InfoRequestMessage::InitAsDefaultInstance() {
}
class InfoRequestMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<InfoRequestMessage>()._has_bits_);
};

InfoRequestMessage::InfoRequestMessage()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.InfoRequestMessage)
}
InfoRequestMessage::InfoRequestMessage(const InfoRequestMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      info_type_(from.info_type_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.InfoRequestMessage)
}

void InfoRequestMessage::SharedCtor() {
}

InfoRequestMessage::~InfoRequestMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.InfoRequestMessage)
  SharedDtor();
}

void InfoRequestMessage::SharedDtor() {
}

void InfoRequestMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const InfoRequestMessage& InfoRequestMessage::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_InfoRequestMessage_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void InfoRequestMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.InfoRequestMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  info_type_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* InfoRequestMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .ipc.invalidation.InfoRequestMessage.InfoType info_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::ipc::invalidation::InfoRequestMessage_InfoType_IsValid(val))) {
              add_info_type(static_cast<::ipc::invalidation::InfoRequestMessage_InfoType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 8);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(mutable_info_type(), ptr, ctx, ::ipc::invalidation::InfoRequestMessage_InfoType_IsValid, &_internal_metadata_, 1);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool InfoRequestMessage::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.InfoRequestMessage)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ipc.invalidation.InfoRequestMessage.InfoType info_type = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ipc::invalidation::InfoRequestMessage_InfoType_IsValid(value)) {
            add_info_type(static_cast< ::ipc::invalidation::InfoRequestMessage_InfoType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 1,
                 ::ipc::invalidation::InfoRequestMessage_InfoType_IsValid,
                 &unknown_fields_stream,
                 this->mutable_info_type())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.InfoRequestMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.InfoRequestMessage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void InfoRequestMessage::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.InfoRequestMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ipc.invalidation.InfoRequestMessage.InfoType info_type = 1;
  for (int i = 0, n = this->info_type_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->info_type(i), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.InfoRequestMessage)
}

size_t InfoRequestMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.InfoRequestMessage)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ipc.invalidation.InfoRequestMessage.InfoType info_type = 1;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->info_type_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->info_type(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InfoRequestMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const InfoRequestMessage*>(
      &from));
}

void InfoRequestMessage::MergeFrom(const InfoRequestMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.InfoRequestMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  info_type_.MergeFrom(from.info_type_);
}

void InfoRequestMessage::CopyFrom(const InfoRequestMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.InfoRequestMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InfoRequestMessage::IsInitialized() const {
  return true;
}

void InfoRequestMessage::InternalSwap(InfoRequestMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  info_type_.InternalSwap(&other->info_type_);
}

std::string InfoRequestMessage::GetTypeName() const {
  return "ipc.invalidation.InfoRequestMessage";
}


// ===================================================================

void RateLimitP::InitAsDefaultInstance() {
}
class RateLimitP::_Internal {
 public:
  using HasBits = decltype(std::declval<RateLimitP>()._has_bits_);
  static void set_has_window_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

RateLimitP::RateLimitP()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.RateLimitP)
}
RateLimitP::RateLimitP(const RateLimitP& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&window_ms_, &from.window_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&window_ms_)) + sizeof(count_));
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RateLimitP)
}

void RateLimitP::SharedCtor() {
  ::memset(&window_ms_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&count_) -
      reinterpret_cast<char*>(&window_ms_)) + sizeof(count_));
}

RateLimitP::~RateLimitP() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.RateLimitP)
  SharedDtor();
}

void RateLimitP::SharedDtor() {
}

void RateLimitP::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RateLimitP& RateLimitP::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RateLimitP_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void RateLimitP::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.RateLimitP)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&window_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&count_) -
        reinterpret_cast<char*>(&window_ms_)) + sizeof(count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RateLimitP::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 window_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_window_ms(&has_bits);
          window_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RateLimitP::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.RateLimitP)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 window_ms = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_window_ms(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &window_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 count = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_count(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.RateLimitP)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.RateLimitP)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RateLimitP::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.RateLimitP)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 window_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->window_ms(), output);
  }

  // optional int32 count = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->count(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.RateLimitP)
}

size_t RateLimitP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RateLimitP)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 window_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->window_ms());
    }

    // optional int32 count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->count());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RateLimitP::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RateLimitP*>(
      &from));
}

void RateLimitP::MergeFrom(const RateLimitP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RateLimitP)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      window_ms_ = from.window_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RateLimitP::CopyFrom(const RateLimitP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RateLimitP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RateLimitP::IsInitialized() const {
  return true;
}

void RateLimitP::InternalSwap(RateLimitP* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(window_ms_, other->window_ms_);
  swap(count_, other->count_);
}

std::string RateLimitP::GetTypeName() const {
  return "ipc.invalidation.RateLimitP";
}


// ===================================================================

void ProtocolHandlerConfigP::InitAsDefaultInstance() {
}
class ProtocolHandlerConfigP::_Internal {
 public:
  using HasBits = decltype(std::declval<ProtocolHandlerConfigP>()._has_bits_);
  static void set_has_batching_delay_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ProtocolHandlerConfigP::ProtocolHandlerConfigP()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ProtocolHandlerConfigP)
}
ProtocolHandlerConfigP::ProtocolHandlerConfigP(const ProtocolHandlerConfigP& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      rate_limit_(from.rate_limit_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  batching_delay_ms_ = from.batching_delay_ms_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ProtocolHandlerConfigP)
}

void ProtocolHandlerConfigP::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ProtocolHandlerConfigP_client_5fprotocol_2eproto.base);
  batching_delay_ms_ = 500;
}

ProtocolHandlerConfigP::~ProtocolHandlerConfigP() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ProtocolHandlerConfigP)
  SharedDtor();
}

void ProtocolHandlerConfigP::SharedDtor() {
}

void ProtocolHandlerConfigP::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ProtocolHandlerConfigP& ProtocolHandlerConfigP::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ProtocolHandlerConfigP_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void ProtocolHandlerConfigP::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ProtocolHandlerConfigP)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  rate_limit_.Clear();
  batching_delay_ms_ = 500;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ProtocolHandlerConfigP::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 batching_delay_ms = 1 [default = 500];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_batching_delay_ms(&has_bits);
          batching_delay_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .ipc.invalidation.RateLimitP rate_limit = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_rate_limit(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ProtocolHandlerConfigP::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ProtocolHandlerConfigP)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 batching_delay_ms = 1 [default = 500];
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_batching_delay_ms(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &batching_delay_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .ipc.invalidation.RateLimitP rate_limit = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_rate_limit()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ProtocolHandlerConfigP)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ProtocolHandlerConfigP)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ProtocolHandlerConfigP::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ProtocolHandlerConfigP)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 batching_delay_ms = 1 [default = 500];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->batching_delay_ms(), output);
  }

  // repeated .ipc.invalidation.RateLimitP rate_limit = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->rate_limit_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2,
      this->rate_limit(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ProtocolHandlerConfigP)
}

size_t ProtocolHandlerConfigP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ProtocolHandlerConfigP)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ipc.invalidation.RateLimitP rate_limit = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->rate_limit_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->rate_limit(static_cast<int>(i)));
    }
  }

  // optional int32 batching_delay_ms = 1 [default = 500];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->batching_delay_ms());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ProtocolHandlerConfigP::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ProtocolHandlerConfigP*>(
      &from));
}

void ProtocolHandlerConfigP::MergeFrom(const ProtocolHandlerConfigP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ProtocolHandlerConfigP)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  rate_limit_.MergeFrom(from.rate_limit_);
  if (from.has_batching_delay_ms()) {
    set_batching_delay_ms(from.batching_delay_ms());
  }
}

void ProtocolHandlerConfigP::CopyFrom(const ProtocolHandlerConfigP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ProtocolHandlerConfigP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProtocolHandlerConfigP::IsInitialized() const {
  return true;
}

void ProtocolHandlerConfigP::InternalSwap(ProtocolHandlerConfigP* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&rate_limit_)->InternalSwap(CastToBase(&other->rate_limit_));
  swap(batching_delay_ms_, other->batching_delay_ms_);
}

std::string ProtocolHandlerConfigP::GetTypeName() const {
  return "ipc.invalidation.ProtocolHandlerConfigP";
}


// ===================================================================

void ClientConfigP::InitAsDefaultInstance() {
  ::ipc::invalidation::_ClientConfigP_default_instance_._instance.get_mutable()->version_ = const_cast< ::ipc::invalidation::Version*>(
      ::ipc::invalidation::Version::internal_default_instance());
  ::ipc::invalidation::_ClientConfigP_default_instance_._instance.get_mutable()->protocol_handler_config_ = const_cast< ::ipc::invalidation::ProtocolHandlerConfigP*>(
      ::ipc::invalidation::ProtocolHandlerConfigP::internal_default_instance());
}
class ClientConfigP::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientConfigP>()._has_bits_);
  static const ::ipc::invalidation::Version& version(const ClientConfigP* msg);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_network_timeout_delay_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_write_retry_delay_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_heartbeat_interval_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_perf_counter_delay_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_max_exponential_backoff_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_smear_percent(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_is_transient(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_initial_persistent_heartbeat_delay_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::ipc::invalidation::ProtocolHandlerConfigP& protocol_handler_config(const ClientConfigP* msg);
  static void set_has_protocol_handler_config(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_channel_supports_offline_delivery(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_offline_heartbeat_threshold_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_allow_suppression(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::ipc::invalidation::Version&
ClientConfigP::_Internal::version(const ClientConfigP* msg) {
  return *msg->version_;
}
const ::ipc::invalidation::ProtocolHandlerConfigP&
ClientConfigP::_Internal::protocol_handler_config(const ClientConfigP* msg) {
  return *msg->protocol_handler_config_;
}
ClientConfigP::ClientConfigP()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ClientConfigP)
}
ClientConfigP::ClientConfigP(const ClientConfigP& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_version()) {
    version_ = new ::ipc::invalidation::Version(*from.version_);
  } else {
    version_ = nullptr;
  }
  if (from.has_protocol_handler_config()) {
    protocol_handler_config_ = new ::ipc::invalidation::ProtocolHandlerConfigP(*from.protocol_handler_config_);
  } else {
    protocol_handler_config_ = nullptr;
  }
  ::memcpy(&is_transient_, &from.is_transient_,
    static_cast<size_t>(reinterpret_cast<char*>(&offline_heartbeat_threshold_ms_) -
    reinterpret_cast<char*>(&is_transient_)) + sizeof(offline_heartbeat_threshold_ms_));
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ClientConfigP)
}

void ClientConfigP::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ClientConfigP_client_5fprotocol_2eproto.base);
  ::memset(&version_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&channel_supports_offline_delivery_) -
      reinterpret_cast<char*>(&version_)) + sizeof(channel_supports_offline_delivery_));
  allow_suppression_ = true;
  network_timeout_delay_ms_ = 60000;
  write_retry_delay_ms_ = 10000;
  heartbeat_interval_ms_ = 1200000;
  perf_counter_delay_ms_ = 21600000;
  max_exponential_backoff_factor_ = 500;
  smear_percent_ = 20;
  initial_persistent_heartbeat_delay_ms_ = 2000;
  offline_heartbeat_threshold_ms_ = 60000;
}

ClientConfigP::~ClientConfigP() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ClientConfigP)
  SharedDtor();
}

void ClientConfigP::SharedDtor() {
  if (this != internal_default_instance()) delete version_;
  if (this != internal_default_instance()) delete protocol_handler_config_;
}

void ClientConfigP::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ClientConfigP& ClientConfigP::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ClientConfigP_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void ClientConfigP::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ClientConfigP)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(version_ != nullptr);
      version_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(protocol_handler_config_ != nullptr);
      protocol_handler_config_->Clear();
    }
  }
  ::memset(&is_transient_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&channel_supports_offline_delivery_) -
      reinterpret_cast<char*>(&is_transient_)) + sizeof(channel_supports_offline_delivery_));
  if (cached_has_bits & 0x000000f0u) {
    allow_suppression_ = true;
    network_timeout_delay_ms_ = 60000;
    write_retry_delay_ms_ = 10000;
    heartbeat_interval_ms_ = 1200000;
  }
  if (cached_has_bits & 0x00001f00u) {
    perf_counter_delay_ms_ = 21600000;
    max_exponential_backoff_factor_ = 500;
    smear_percent_ = 20;
    initial_persistent_heartbeat_delay_ms_ = 2000;
    offline_heartbeat_threshold_ms_ = 60000;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ClientConfigP::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .ipc.invalidation.Version version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_version(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 network_timeout_delay_ms = 2 [default = 60000];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_network_timeout_delay_ms(&has_bits);
          network_timeout_delay_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 write_retry_delay_ms = 3 [default = 10000];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_write_retry_delay_ms(&has_bits);
          write_retry_delay_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 heartbeat_interval_ms = 4 [default = 1200000];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_heartbeat_interval_ms(&has_bits);
          heartbeat_interval_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 perf_counter_delay_ms = 5 [default = 21600000];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_perf_counter_delay_ms(&has_bits);
          perf_counter_delay_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 max_exponential_backoff_factor = 6 [default = 500];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_max_exponential_backoff_factor(&has_bits);
          max_exponential_backoff_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 smear_percent = 7 [default = 20];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_smear_percent(&has_bits);
          smear_percent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_transient = 8 [default = false];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_is_transient(&has_bits);
          is_transient_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 initial_persistent_heartbeat_delay_ms = 9 [default = 2000];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_initial_persistent_heartbeat_delay_ms(&has_bits);
          initial_persistent_heartbeat_delay_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ipc.invalidation.ProtocolHandlerConfigP protocol_handler_config = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(mutable_protocol_handler_config(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool channel_supports_offline_delivery = 11 [default = false];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_channel_supports_offline_delivery(&has_bits);
          channel_supports_offline_delivery_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 offline_heartbeat_threshold_ms = 12 [default = 60000];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_offline_heartbeat_threshold_ms(&has_bits);
          offline_heartbeat_threshold_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool allow_suppression = 13 [default = true];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_allow_suppression(&has_bits);
          allow_suppression_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ClientConfigP::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ClientConfigP)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.Version version = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_version()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 network_timeout_delay_ms = 2 [default = 60000];
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_network_timeout_delay_ms(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &network_timeout_delay_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 write_retry_delay_ms = 3 [default = 10000];
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_write_retry_delay_ms(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &write_retry_delay_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 heartbeat_interval_ms = 4 [default = 1200000];
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_heartbeat_interval_ms(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &heartbeat_interval_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 perf_counter_delay_ms = 5 [default = 21600000];
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_perf_counter_delay_ms(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &perf_counter_delay_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 max_exponential_backoff_factor = 6 [default = 500];
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_max_exponential_backoff_factor(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_exponential_backoff_factor_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 smear_percent = 7 [default = 20];
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_smear_percent(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &smear_percent_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool is_transient = 8 [default = false];
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_is_transient(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_transient_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 initial_persistent_heartbeat_delay_ms = 9 [default = 2000];
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          _Internal::set_has_initial_persistent_heartbeat_delay_ms(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &initial_persistent_heartbeat_delay_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.ProtocolHandlerConfigP protocol_handler_config = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (82 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_protocol_handler_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool channel_supports_offline_delivery = 11 [default = false];
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (88 & 0xFF)) {
          _Internal::set_has_channel_supports_offline_delivery(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &channel_supports_offline_delivery_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 offline_heartbeat_threshold_ms = 12 [default = 60000];
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (96 & 0xFF)) {
          _Internal::set_has_offline_heartbeat_threshold_ms(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &offline_heartbeat_threshold_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool allow_suppression = 13 [default = true];
      case 13: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (104 & 0xFF)) {
          _Internal::set_has_allow_suppression(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &allow_suppression_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ClientConfigP)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ClientConfigP)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ClientConfigP::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ClientConfigP)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.Version version = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::version(this), output);
  }

  // optional int32 network_timeout_delay_ms = 2 [default = 60000];
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->network_timeout_delay_ms(), output);
  }

  // optional int32 write_retry_delay_ms = 3 [default = 10000];
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->write_retry_delay_ms(), output);
  }

  // optional int32 heartbeat_interval_ms = 4 [default = 1200000];
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->heartbeat_interval_ms(), output);
  }

  // optional int32 perf_counter_delay_ms = 5 [default = 21600000];
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->perf_counter_delay_ms(), output);
  }

  // optional int32 max_exponential_backoff_factor = 6 [default = 500];
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->max_exponential_backoff_factor(), output);
  }

  // optional int32 smear_percent = 7 [default = 20];
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(7, this->smear_percent(), output);
  }

  // optional bool is_transient = 8 [default = false];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(8, this->is_transient(), output);
  }

  // optional int32 initial_persistent_heartbeat_delay_ms = 9 [default = 2000];
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(9, this->initial_persistent_heartbeat_delay_ms(), output);
  }

  // optional .ipc.invalidation.ProtocolHandlerConfigP protocol_handler_config = 10;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      10, _Internal::protocol_handler_config(this), output);
  }

  // optional bool channel_supports_offline_delivery = 11 [default = false];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(11, this->channel_supports_offline_delivery(), output);
  }

  // optional int32 offline_heartbeat_threshold_ms = 12 [default = 60000];
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(12, this->offline_heartbeat_threshold_ms(), output);
  }

  // optional bool allow_suppression = 13 [default = true];
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(13, this->allow_suppression(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ClientConfigP)
}

size_t ClientConfigP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ClientConfigP)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .ipc.invalidation.Version version = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *version_);
    }

    // optional .ipc.invalidation.ProtocolHandlerConfigP protocol_handler_config = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *protocol_handler_config_);
    }

    // optional bool is_transient = 8 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool channel_supports_offline_delivery = 11 [default = false];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool allow_suppression = 13 [default = true];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional int32 network_timeout_delay_ms = 2 [default = 60000];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->network_timeout_delay_ms());
    }

    // optional int32 write_retry_delay_ms = 3 [default = 10000];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->write_retry_delay_ms());
    }

    // optional int32 heartbeat_interval_ms = 4 [default = 1200000];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->heartbeat_interval_ms());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional int32 perf_counter_delay_ms = 5 [default = 21600000];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->perf_counter_delay_ms());
    }

    // optional int32 max_exponential_backoff_factor = 6 [default = 500];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->max_exponential_backoff_factor());
    }

    // optional int32 smear_percent = 7 [default = 20];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->smear_percent());
    }

    // optional int32 initial_persistent_heartbeat_delay_ms = 9 [default = 2000];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->initial_persistent_heartbeat_delay_ms());
    }

    // optional int32 offline_heartbeat_threshold_ms = 12 [default = 60000];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->offline_heartbeat_threshold_ms());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientConfigP::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ClientConfigP*>(
      &from));
}

void ClientConfigP::MergeFrom(const ClientConfigP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ClientConfigP)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_version()->::ipc::invalidation::Version::MergeFrom(from.version());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_protocol_handler_config()->::ipc::invalidation::ProtocolHandlerConfigP::MergeFrom(from.protocol_handler_config());
    }
    if (cached_has_bits & 0x00000004u) {
      is_transient_ = from.is_transient_;
    }
    if (cached_has_bits & 0x00000008u) {
      channel_supports_offline_delivery_ = from.channel_supports_offline_delivery_;
    }
    if (cached_has_bits & 0x00000010u) {
      allow_suppression_ = from.allow_suppression_;
    }
    if (cached_has_bits & 0x00000020u) {
      network_timeout_delay_ms_ = from.network_timeout_delay_ms_;
    }
    if (cached_has_bits & 0x00000040u) {
      write_retry_delay_ms_ = from.write_retry_delay_ms_;
    }
    if (cached_has_bits & 0x00000080u) {
      heartbeat_interval_ms_ = from.heartbeat_interval_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      perf_counter_delay_ms_ = from.perf_counter_delay_ms_;
    }
    if (cached_has_bits & 0x00000200u) {
      max_exponential_backoff_factor_ = from.max_exponential_backoff_factor_;
    }
    if (cached_has_bits & 0x00000400u) {
      smear_percent_ = from.smear_percent_;
    }
    if (cached_has_bits & 0x00000800u) {
      initial_persistent_heartbeat_delay_ms_ = from.initial_persistent_heartbeat_delay_ms_;
    }
    if (cached_has_bits & 0x00001000u) {
      offline_heartbeat_threshold_ms_ = from.offline_heartbeat_threshold_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ClientConfigP::CopyFrom(const ClientConfigP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ClientConfigP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientConfigP::IsInitialized() const {
  return true;
}

void ClientConfigP::InternalSwap(ClientConfigP* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(version_, other->version_);
  swap(protocol_handler_config_, other->protocol_handler_config_);
  swap(is_transient_, other->is_transient_);
  swap(channel_supports_offline_delivery_, other->channel_supports_offline_delivery_);
  swap(allow_suppression_, other->allow_suppression_);
  swap(network_timeout_delay_ms_, other->network_timeout_delay_ms_);
  swap(write_retry_delay_ms_, other->write_retry_delay_ms_);
  swap(heartbeat_interval_ms_, other->heartbeat_interval_ms_);
  swap(perf_counter_delay_ms_, other->perf_counter_delay_ms_);
  swap(max_exponential_backoff_factor_, other->max_exponential_backoff_factor_);
  swap(smear_percent_, other->smear_percent_);
  swap(initial_persistent_heartbeat_delay_ms_, other->initial_persistent_heartbeat_delay_ms_);
  swap(offline_heartbeat_threshold_ms_, other->offline_heartbeat_threshold_ms_);
}

std::string ClientConfigP::GetTypeName() const {
  return "ipc.invalidation.ClientConfigP";
}


// ===================================================================

void ConfigChangeMessage::InitAsDefaultInstance() {
}
class ConfigChangeMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfigChangeMessage>()._has_bits_);
  static void set_has_next_message_delay_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ConfigChangeMessage::ConfigChangeMessage()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ConfigChangeMessage)
}
ConfigChangeMessage::ConfigChangeMessage(const ConfigChangeMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  next_message_delay_ms_ = from.next_message_delay_ms_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ConfigChangeMessage)
}

void ConfigChangeMessage::SharedCtor() {
  next_message_delay_ms_ = PROTOBUF_LONGLONG(0);
}

ConfigChangeMessage::~ConfigChangeMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ConfigChangeMessage)
  SharedDtor();
}

void ConfigChangeMessage::SharedDtor() {
}

void ConfigChangeMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ConfigChangeMessage& ConfigChangeMessage::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ConfigChangeMessage_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void ConfigChangeMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ConfigChangeMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  next_message_delay_ms_ = PROTOBUF_LONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ConfigChangeMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int64 next_message_delay_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_next_message_delay_ms(&has_bits);
          next_message_delay_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ConfigChangeMessage::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ConfigChangeMessage)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 next_message_delay_ms = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_next_message_delay_ms(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &next_message_delay_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ConfigChangeMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ConfigChangeMessage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ConfigChangeMessage::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ConfigChangeMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 next_message_delay_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(1, this->next_message_delay_ms(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ConfigChangeMessage)
}

size_t ConfigChangeMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ConfigChangeMessage)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int64 next_message_delay_ms = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->next_message_delay_ms());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConfigChangeMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ConfigChangeMessage*>(
      &from));
}

void ConfigChangeMessage::MergeFrom(const ConfigChangeMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ConfigChangeMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_next_message_delay_ms()) {
    set_next_message_delay_ms(from.next_message_delay_ms());
  }
}

void ConfigChangeMessage::CopyFrom(const ConfigChangeMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ConfigChangeMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigChangeMessage::IsInitialized() const {
  return true;
}

void ConfigChangeMessage::InternalSwap(ConfigChangeMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(next_message_delay_ms_, other->next_message_delay_ms_);
}

std::string ConfigChangeMessage::GetTypeName() const {
  return "ipc.invalidation.ConfigChangeMessage";
}


// ===================================================================

void ErrorMessage::InitAsDefaultInstance() {
}
class ErrorMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ErrorMessage>()._has_bits_);
  static void set_has_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ErrorMessage::ErrorMessage()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ErrorMessage)
}
ErrorMessage::ErrorMessage(const ErrorMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_description()) {
    description_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.description_);
  }
  code_ = from.code_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ErrorMessage)
}

void ErrorMessage::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ErrorMessage_client_5fprotocol_2eproto.base);
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  code_ = 1;
}

ErrorMessage::~ErrorMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ErrorMessage)
  SharedDtor();
}

void ErrorMessage::SharedDtor() {
  description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ErrorMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ErrorMessage& ErrorMessage::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ErrorMessage_client_5fprotocol_2eproto.base);
  return *internal_default_instance();
}


void ErrorMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ErrorMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      description_.ClearNonDefaultToEmptyNoArena();
    }
    code_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ErrorMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .ipc.invalidation.ErrorMessage.Code code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ipc::invalidation::ErrorMessage_Code_IsValid(val))) {
            set_code(static_cast<::ipc::invalidation::ErrorMessage_Code>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_description(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ErrorMessage::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ErrorMessage)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.ErrorMessage.Code code = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ipc::invalidation::ErrorMessage_Code_IsValid(value)) {
            set_code(static_cast< ::ipc::invalidation::ErrorMessage_Code >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string description = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ErrorMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ErrorMessage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ErrorMessage::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ErrorMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.ErrorMessage.Code code = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->code(), output);
  }

  // optional string description = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->description(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ErrorMessage)
}

size_t ErrorMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ErrorMessage)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string description = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->description());
    }

    // optional .ipc.invalidation.ErrorMessage.Code code = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->code());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ErrorMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ErrorMessage*>(
      &from));
}

void ErrorMessage::MergeFrom(const ErrorMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ErrorMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      description_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.description_);
    }
    if (cached_has_bits & 0x00000002u) {
      code_ = from.code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ErrorMessage::CopyFrom(const ErrorMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ErrorMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ErrorMessage::IsInitialized() const {
  return true;
}

void ErrorMessage::InternalSwap(ErrorMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  description_.Swap(&other->description_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(code_, other->code_);
}

std::string ErrorMessage::GetTypeName() const {
  return "ipc.invalidation.ErrorMessage";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace invalidation
}  // namespace ipc
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::ipc::invalidation::Version* Arena::CreateMaybeMessage< ::ipc::invalidation::Version >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::Version >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::ProtocolVersion* Arena::CreateMaybeMessage< ::ipc::invalidation::ProtocolVersion >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::ProtocolVersion >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::ClientVersion* Arena::CreateMaybeMessage< ::ipc::invalidation::ClientVersion >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::ClientVersion >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::StatusP* Arena::CreateMaybeMessage< ::ipc::invalidation::StatusP >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::StatusP >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::ObjectIdP* Arena::CreateMaybeMessage< ::ipc::invalidation::ObjectIdP >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::ObjectIdP >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::ApplicationClientIdP* Arena::CreateMaybeMessage< ::ipc::invalidation::ApplicationClientIdP >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::ApplicationClientIdP >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::InvalidationP* Arena::CreateMaybeMessage< ::ipc::invalidation::InvalidationP >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::InvalidationP >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::RegistrationP* Arena::CreateMaybeMessage< ::ipc::invalidation::RegistrationP >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::RegistrationP >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::RegistrationSummary* Arena::CreateMaybeMessage< ::ipc::invalidation::RegistrationSummary >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::RegistrationSummary >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::ClientHeader* Arena::CreateMaybeMessage< ::ipc::invalidation::ClientHeader >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::ClientHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::ClientToServerMessage* Arena::CreateMaybeMessage< ::ipc::invalidation::ClientToServerMessage >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::ClientToServerMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::InitializeMessage* Arena::CreateMaybeMessage< ::ipc::invalidation::InitializeMessage >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::InitializeMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::RegistrationMessage* Arena::CreateMaybeMessage< ::ipc::invalidation::RegistrationMessage >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::RegistrationMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::RegistrationSyncMessage* Arena::CreateMaybeMessage< ::ipc::invalidation::RegistrationSyncMessage >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::RegistrationSyncMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::RegistrationSubtree* Arena::CreateMaybeMessage< ::ipc::invalidation::RegistrationSubtree >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::RegistrationSubtree >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::InfoMessage* Arena::CreateMaybeMessage< ::ipc::invalidation::InfoMessage >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::InfoMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::PropertyRecord* Arena::CreateMaybeMessage< ::ipc::invalidation::PropertyRecord >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::PropertyRecord >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::ServerHeader* Arena::CreateMaybeMessage< ::ipc::invalidation::ServerHeader >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::ServerHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::ServerToClientMessage* Arena::CreateMaybeMessage< ::ipc::invalidation::ServerToClientMessage >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::ServerToClientMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::TokenControlMessage* Arena::CreateMaybeMessage< ::ipc::invalidation::TokenControlMessage >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::TokenControlMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::RegistrationStatus* Arena::CreateMaybeMessage< ::ipc::invalidation::RegistrationStatus >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::RegistrationStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::RegistrationStatusMessage* Arena::CreateMaybeMessage< ::ipc::invalidation::RegistrationStatusMessage >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::RegistrationStatusMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::RegistrationSyncRequestMessage* Arena::CreateMaybeMessage< ::ipc::invalidation::RegistrationSyncRequestMessage >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::RegistrationSyncRequestMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::InvalidationMessage* Arena::CreateMaybeMessage< ::ipc::invalidation::InvalidationMessage >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::InvalidationMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::InfoRequestMessage* Arena::CreateMaybeMessage< ::ipc::invalidation::InfoRequestMessage >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::InfoRequestMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::RateLimitP* Arena::CreateMaybeMessage< ::ipc::invalidation::RateLimitP >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::RateLimitP >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::ProtocolHandlerConfigP* Arena::CreateMaybeMessage< ::ipc::invalidation::ProtocolHandlerConfigP >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::ProtocolHandlerConfigP >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::ClientConfigP* Arena::CreateMaybeMessage< ::ipc::invalidation::ClientConfigP >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::ClientConfigP >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::ConfigChangeMessage* Arena::CreateMaybeMessage< ::ipc::invalidation::ConfigChangeMessage >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::ConfigChangeMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ipc::invalidation::ErrorMessage* Arena::CreateMaybeMessage< ::ipc::invalidation::ErrorMessage >(Arena* arena) {
  return Arena::CreateInternal< ::ipc::invalidation::ErrorMessage >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
