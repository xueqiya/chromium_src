// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client_protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_client_5fprotocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_client_5fprotocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_client_5fprotocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_client_5fprotocol_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[30]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace ipc {
namespace invalidation {
class ApplicationClientIdP;
class ApplicationClientIdPDefaultTypeInternal;
extern ApplicationClientIdPDefaultTypeInternal _ApplicationClientIdP_default_instance_;
class ClientConfigP;
class ClientConfigPDefaultTypeInternal;
extern ClientConfigPDefaultTypeInternal _ClientConfigP_default_instance_;
class ClientHeader;
class ClientHeaderDefaultTypeInternal;
extern ClientHeaderDefaultTypeInternal _ClientHeader_default_instance_;
class ClientToServerMessage;
class ClientToServerMessageDefaultTypeInternal;
extern ClientToServerMessageDefaultTypeInternal _ClientToServerMessage_default_instance_;
class ClientVersion;
class ClientVersionDefaultTypeInternal;
extern ClientVersionDefaultTypeInternal _ClientVersion_default_instance_;
class ConfigChangeMessage;
class ConfigChangeMessageDefaultTypeInternal;
extern ConfigChangeMessageDefaultTypeInternal _ConfigChangeMessage_default_instance_;
class ErrorMessage;
class ErrorMessageDefaultTypeInternal;
extern ErrorMessageDefaultTypeInternal _ErrorMessage_default_instance_;
class InfoMessage;
class InfoMessageDefaultTypeInternal;
extern InfoMessageDefaultTypeInternal _InfoMessage_default_instance_;
class InfoRequestMessage;
class InfoRequestMessageDefaultTypeInternal;
extern InfoRequestMessageDefaultTypeInternal _InfoRequestMessage_default_instance_;
class InitializeMessage;
class InitializeMessageDefaultTypeInternal;
extern InitializeMessageDefaultTypeInternal _InitializeMessage_default_instance_;
class InvalidationMessage;
class InvalidationMessageDefaultTypeInternal;
extern InvalidationMessageDefaultTypeInternal _InvalidationMessage_default_instance_;
class InvalidationP;
class InvalidationPDefaultTypeInternal;
extern InvalidationPDefaultTypeInternal _InvalidationP_default_instance_;
class ObjectIdP;
class ObjectIdPDefaultTypeInternal;
extern ObjectIdPDefaultTypeInternal _ObjectIdP_default_instance_;
class PropertyRecord;
class PropertyRecordDefaultTypeInternal;
extern PropertyRecordDefaultTypeInternal _PropertyRecord_default_instance_;
class ProtocolHandlerConfigP;
class ProtocolHandlerConfigPDefaultTypeInternal;
extern ProtocolHandlerConfigPDefaultTypeInternal _ProtocolHandlerConfigP_default_instance_;
class ProtocolVersion;
class ProtocolVersionDefaultTypeInternal;
extern ProtocolVersionDefaultTypeInternal _ProtocolVersion_default_instance_;
class RateLimitP;
class RateLimitPDefaultTypeInternal;
extern RateLimitPDefaultTypeInternal _RateLimitP_default_instance_;
class RegistrationMessage;
class RegistrationMessageDefaultTypeInternal;
extern RegistrationMessageDefaultTypeInternal _RegistrationMessage_default_instance_;
class RegistrationP;
class RegistrationPDefaultTypeInternal;
extern RegistrationPDefaultTypeInternal _RegistrationP_default_instance_;
class RegistrationStatus;
class RegistrationStatusDefaultTypeInternal;
extern RegistrationStatusDefaultTypeInternal _RegistrationStatus_default_instance_;
class RegistrationStatusMessage;
class RegistrationStatusMessageDefaultTypeInternal;
extern RegistrationStatusMessageDefaultTypeInternal _RegistrationStatusMessage_default_instance_;
class RegistrationSubtree;
class RegistrationSubtreeDefaultTypeInternal;
extern RegistrationSubtreeDefaultTypeInternal _RegistrationSubtree_default_instance_;
class RegistrationSummary;
class RegistrationSummaryDefaultTypeInternal;
extern RegistrationSummaryDefaultTypeInternal _RegistrationSummary_default_instance_;
class RegistrationSyncMessage;
class RegistrationSyncMessageDefaultTypeInternal;
extern RegistrationSyncMessageDefaultTypeInternal _RegistrationSyncMessage_default_instance_;
class RegistrationSyncRequestMessage;
class RegistrationSyncRequestMessageDefaultTypeInternal;
extern RegistrationSyncRequestMessageDefaultTypeInternal _RegistrationSyncRequestMessage_default_instance_;
class ServerHeader;
class ServerHeaderDefaultTypeInternal;
extern ServerHeaderDefaultTypeInternal _ServerHeader_default_instance_;
class ServerToClientMessage;
class ServerToClientMessageDefaultTypeInternal;
extern ServerToClientMessageDefaultTypeInternal _ServerToClientMessage_default_instance_;
class StatusP;
class StatusPDefaultTypeInternal;
extern StatusPDefaultTypeInternal _StatusP_default_instance_;
class TokenControlMessage;
class TokenControlMessageDefaultTypeInternal;
extern TokenControlMessageDefaultTypeInternal _TokenControlMessage_default_instance_;
class Version;
class VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
}  // namespace invalidation
}  // namespace ipc
PROTOBUF_NAMESPACE_OPEN
template<> ::ipc::invalidation::ApplicationClientIdP* Arena::CreateMaybeMessage<::ipc::invalidation::ApplicationClientIdP>(Arena*);
template<> ::ipc::invalidation::ClientConfigP* Arena::CreateMaybeMessage<::ipc::invalidation::ClientConfigP>(Arena*);
template<> ::ipc::invalidation::ClientHeader* Arena::CreateMaybeMessage<::ipc::invalidation::ClientHeader>(Arena*);
template<> ::ipc::invalidation::ClientToServerMessage* Arena::CreateMaybeMessage<::ipc::invalidation::ClientToServerMessage>(Arena*);
template<> ::ipc::invalidation::ClientVersion* Arena::CreateMaybeMessage<::ipc::invalidation::ClientVersion>(Arena*);
template<> ::ipc::invalidation::ConfigChangeMessage* Arena::CreateMaybeMessage<::ipc::invalidation::ConfigChangeMessage>(Arena*);
template<> ::ipc::invalidation::ErrorMessage* Arena::CreateMaybeMessage<::ipc::invalidation::ErrorMessage>(Arena*);
template<> ::ipc::invalidation::InfoMessage* Arena::CreateMaybeMessage<::ipc::invalidation::InfoMessage>(Arena*);
template<> ::ipc::invalidation::InfoRequestMessage* Arena::CreateMaybeMessage<::ipc::invalidation::InfoRequestMessage>(Arena*);
template<> ::ipc::invalidation::InitializeMessage* Arena::CreateMaybeMessage<::ipc::invalidation::InitializeMessage>(Arena*);
template<> ::ipc::invalidation::InvalidationMessage* Arena::CreateMaybeMessage<::ipc::invalidation::InvalidationMessage>(Arena*);
template<> ::ipc::invalidation::InvalidationP* Arena::CreateMaybeMessage<::ipc::invalidation::InvalidationP>(Arena*);
template<> ::ipc::invalidation::ObjectIdP* Arena::CreateMaybeMessage<::ipc::invalidation::ObjectIdP>(Arena*);
template<> ::ipc::invalidation::PropertyRecord* Arena::CreateMaybeMessage<::ipc::invalidation::PropertyRecord>(Arena*);
template<> ::ipc::invalidation::ProtocolHandlerConfigP* Arena::CreateMaybeMessage<::ipc::invalidation::ProtocolHandlerConfigP>(Arena*);
template<> ::ipc::invalidation::ProtocolVersion* Arena::CreateMaybeMessage<::ipc::invalidation::ProtocolVersion>(Arena*);
template<> ::ipc::invalidation::RateLimitP* Arena::CreateMaybeMessage<::ipc::invalidation::RateLimitP>(Arena*);
template<> ::ipc::invalidation::RegistrationMessage* Arena::CreateMaybeMessage<::ipc::invalidation::RegistrationMessage>(Arena*);
template<> ::ipc::invalidation::RegistrationP* Arena::CreateMaybeMessage<::ipc::invalidation::RegistrationP>(Arena*);
template<> ::ipc::invalidation::RegistrationStatus* Arena::CreateMaybeMessage<::ipc::invalidation::RegistrationStatus>(Arena*);
template<> ::ipc::invalidation::RegistrationStatusMessage* Arena::CreateMaybeMessage<::ipc::invalidation::RegistrationStatusMessage>(Arena*);
template<> ::ipc::invalidation::RegistrationSubtree* Arena::CreateMaybeMessage<::ipc::invalidation::RegistrationSubtree>(Arena*);
template<> ::ipc::invalidation::RegistrationSummary* Arena::CreateMaybeMessage<::ipc::invalidation::RegistrationSummary>(Arena*);
template<> ::ipc::invalidation::RegistrationSyncMessage* Arena::CreateMaybeMessage<::ipc::invalidation::RegistrationSyncMessage>(Arena*);
template<> ::ipc::invalidation::RegistrationSyncRequestMessage* Arena::CreateMaybeMessage<::ipc::invalidation::RegistrationSyncRequestMessage>(Arena*);
template<> ::ipc::invalidation::ServerHeader* Arena::CreateMaybeMessage<::ipc::invalidation::ServerHeader>(Arena*);
template<> ::ipc::invalidation::ServerToClientMessage* Arena::CreateMaybeMessage<::ipc::invalidation::ServerToClientMessage>(Arena*);
template<> ::ipc::invalidation::StatusP* Arena::CreateMaybeMessage<::ipc::invalidation::StatusP>(Arena*);
template<> ::ipc::invalidation::TokenControlMessage* Arena::CreateMaybeMessage<::ipc::invalidation::TokenControlMessage>(Arena*);
template<> ::ipc::invalidation::Version* Arena::CreateMaybeMessage<::ipc::invalidation::Version>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ipc {
namespace invalidation {

enum StatusP_Code : int {
  StatusP_Code_SUCCESS = 1,
  StatusP_Code_TRANSIENT_FAILURE = 2,
  StatusP_Code_PERMANENT_FAILURE = 3
};
bool StatusP_Code_IsValid(int value);
constexpr StatusP_Code StatusP_Code_Code_MIN = StatusP_Code_SUCCESS;
constexpr StatusP_Code StatusP_Code_Code_MAX = StatusP_Code_PERMANENT_FAILURE;
constexpr int StatusP_Code_Code_ARRAYSIZE = StatusP_Code_Code_MAX + 1;

const std::string& StatusP_Code_Name(StatusP_Code value);
template<typename T>
inline const std::string& StatusP_Code_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StatusP_Code>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StatusP_Code_Name.");
  return StatusP_Code_Name(static_cast<StatusP_Code>(enum_t_value));
}
bool StatusP_Code_Parse(
    const std::string& name, StatusP_Code* value);
enum RegistrationP_OpType : int {
  RegistrationP_OpType_REGISTER = 1,
  RegistrationP_OpType_UNREGISTER = 2
};
bool RegistrationP_OpType_IsValid(int value);
constexpr RegistrationP_OpType RegistrationP_OpType_OpType_MIN = RegistrationP_OpType_REGISTER;
constexpr RegistrationP_OpType RegistrationP_OpType_OpType_MAX = RegistrationP_OpType_UNREGISTER;
constexpr int RegistrationP_OpType_OpType_ARRAYSIZE = RegistrationP_OpType_OpType_MAX + 1;

const std::string& RegistrationP_OpType_Name(RegistrationP_OpType value);
template<typename T>
inline const std::string& RegistrationP_OpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RegistrationP_OpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RegistrationP_OpType_Name.");
  return RegistrationP_OpType_Name(static_cast<RegistrationP_OpType>(enum_t_value));
}
bool RegistrationP_OpType_Parse(
    const std::string& name, RegistrationP_OpType* value);
enum InitializeMessage_DigestSerializationType : int {
  InitializeMessage_DigestSerializationType_BYTE_BASED = 1,
  InitializeMessage_DigestSerializationType_NUMBER_BASED = 2
};
bool InitializeMessage_DigestSerializationType_IsValid(int value);
constexpr InitializeMessage_DigestSerializationType InitializeMessage_DigestSerializationType_DigestSerializationType_MIN = InitializeMessage_DigestSerializationType_BYTE_BASED;
constexpr InitializeMessage_DigestSerializationType InitializeMessage_DigestSerializationType_DigestSerializationType_MAX = InitializeMessage_DigestSerializationType_NUMBER_BASED;
constexpr int InitializeMessage_DigestSerializationType_DigestSerializationType_ARRAYSIZE = InitializeMessage_DigestSerializationType_DigestSerializationType_MAX + 1;

const std::string& InitializeMessage_DigestSerializationType_Name(InitializeMessage_DigestSerializationType value);
template<typename T>
inline const std::string& InitializeMessage_DigestSerializationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InitializeMessage_DigestSerializationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InitializeMessage_DigestSerializationType_Name.");
  return InitializeMessage_DigestSerializationType_Name(static_cast<InitializeMessage_DigestSerializationType>(enum_t_value));
}
bool InitializeMessage_DigestSerializationType_Parse(
    const std::string& name, InitializeMessage_DigestSerializationType* value);
enum InfoRequestMessage_InfoType : int {
  InfoRequestMessage_InfoType_GET_PERFORMANCE_COUNTERS = 1
};
bool InfoRequestMessage_InfoType_IsValid(int value);
constexpr InfoRequestMessage_InfoType InfoRequestMessage_InfoType_InfoType_MIN = InfoRequestMessage_InfoType_GET_PERFORMANCE_COUNTERS;
constexpr InfoRequestMessage_InfoType InfoRequestMessage_InfoType_InfoType_MAX = InfoRequestMessage_InfoType_GET_PERFORMANCE_COUNTERS;
constexpr int InfoRequestMessage_InfoType_InfoType_ARRAYSIZE = InfoRequestMessage_InfoType_InfoType_MAX + 1;

const std::string& InfoRequestMessage_InfoType_Name(InfoRequestMessage_InfoType value);
template<typename T>
inline const std::string& InfoRequestMessage_InfoType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InfoRequestMessage_InfoType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InfoRequestMessage_InfoType_Name.");
  return InfoRequestMessage_InfoType_Name(static_cast<InfoRequestMessage_InfoType>(enum_t_value));
}
bool InfoRequestMessage_InfoType_Parse(
    const std::string& name, InfoRequestMessage_InfoType* value);
enum ErrorMessage_Code : int {
  ErrorMessage_Code_AUTH_FAILURE = 1,
  ErrorMessage_Code_UNKNOWN_FAILURE = 10000
};
bool ErrorMessage_Code_IsValid(int value);
constexpr ErrorMessage_Code ErrorMessage_Code_Code_MIN = ErrorMessage_Code_AUTH_FAILURE;
constexpr ErrorMessage_Code ErrorMessage_Code_Code_MAX = ErrorMessage_Code_UNKNOWN_FAILURE;
constexpr int ErrorMessage_Code_Code_ARRAYSIZE = ErrorMessage_Code_Code_MAX + 1;

const std::string& ErrorMessage_Code_Name(ErrorMessage_Code value);
template<typename T>
inline const std::string& ErrorMessage_Code_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ErrorMessage_Code>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ErrorMessage_Code_Name.");
  return ErrorMessage_Code_Name(static_cast<ErrorMessage_Code>(enum_t_value));
}
bool ErrorMessage_Code_Parse(
    const std::string& name, ErrorMessage_Code* value);
// ===================================================================

class Version :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.Version) */ {
 public:
  Version();
  virtual ~Version();

  Version(const Version& from);
  Version(Version&& from) noexcept
    : Version() {
    *this = ::std::move(from);
  }

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  inline Version& operator=(Version&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Version& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Version& a, Version& b) {
    a.Swap(&b);
  }
  inline void Swap(Version* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Version* New() const final {
    return CreateMaybeMessage<Version>(nullptr);
  }

  Version* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Version>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Version& from);
  void MergeFrom(const Version& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Version* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.Version";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMajorVersionFieldNumber = 1,
    kMinorVersionFieldNumber = 2,
  };
  // optional int32 major_version = 1;
  bool has_major_version() const;
  void clear_major_version();
  ::PROTOBUF_NAMESPACE_ID::int32 major_version() const;
  void set_major_version(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 minor_version = 2;
  bool has_minor_version() const;
  void clear_minor_version();
  ::PROTOBUF_NAMESPACE_ID::int32 minor_version() const;
  void set_minor_version(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.Version)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 major_version_;
  ::PROTOBUF_NAMESPACE_ID::int32 minor_version_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class ProtocolVersion :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.ProtocolVersion) */ {
 public:
  ProtocolVersion();
  virtual ~ProtocolVersion();

  ProtocolVersion(const ProtocolVersion& from);
  ProtocolVersion(ProtocolVersion&& from) noexcept
    : ProtocolVersion() {
    *this = ::std::move(from);
  }

  inline ProtocolVersion& operator=(const ProtocolVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtocolVersion& operator=(ProtocolVersion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ProtocolVersion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtocolVersion* internal_default_instance() {
    return reinterpret_cast<const ProtocolVersion*>(
               &_ProtocolVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ProtocolVersion& a, ProtocolVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtocolVersion* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProtocolVersion* New() const final {
    return CreateMaybeMessage<ProtocolVersion>(nullptr);
  }

  ProtocolVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProtocolVersion>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ProtocolVersion& from);
  void MergeFrom(const ProtocolVersion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProtocolVersion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.ProtocolVersion";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
  };
  // optional .ipc.invalidation.Version version = 1;
  bool has_version() const;
  void clear_version();
  const ::ipc::invalidation::Version& version() const;
  ::ipc::invalidation::Version* release_version();
  ::ipc::invalidation::Version* mutable_version();
  void set_allocated_version(::ipc::invalidation::Version* version);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.ProtocolVersion)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ipc::invalidation::Version* version_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class ClientVersion :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.ClientVersion) */ {
 public:
  ClientVersion();
  virtual ~ClientVersion();

  ClientVersion(const ClientVersion& from);
  ClientVersion(ClientVersion&& from) noexcept
    : ClientVersion() {
    *this = ::std::move(from);
  }

  inline ClientVersion& operator=(const ClientVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientVersion& operator=(ClientVersion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ClientVersion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientVersion* internal_default_instance() {
    return reinterpret_cast<const ClientVersion*>(
               &_ClientVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ClientVersion& a, ClientVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientVersion* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientVersion* New() const final {
    return CreateMaybeMessage<ClientVersion>(nullptr);
  }

  ClientVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientVersion>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ClientVersion& from);
  void MergeFrom(const ClientVersion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientVersion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.ClientVersion";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlatformFieldNumber = 2,
    kLanguageFieldNumber = 3,
    kApplicationInfoFieldNumber = 4,
    kVersionFieldNumber = 1,
  };
  // optional string platform = 2;
  bool has_platform() const;
  void clear_platform();
  const std::string& platform() const;
  void set_platform(const std::string& value);
  void set_platform(std::string&& value);
  void set_platform(const char* value);
  void set_platform(const char* value, size_t size);
  std::string* mutable_platform();
  std::string* release_platform();
  void set_allocated_platform(std::string* platform);

  // optional string language = 3;
  bool has_language() const;
  void clear_language();
  const std::string& language() const;
  void set_language(const std::string& value);
  void set_language(std::string&& value);
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  std::string* mutable_language();
  std::string* release_language();
  void set_allocated_language(std::string* language);

  // optional string application_info = 4;
  bool has_application_info() const;
  void clear_application_info();
  const std::string& application_info() const;
  void set_application_info(const std::string& value);
  void set_application_info(std::string&& value);
  void set_application_info(const char* value);
  void set_application_info(const char* value, size_t size);
  std::string* mutable_application_info();
  std::string* release_application_info();
  void set_allocated_application_info(std::string* application_info);

  // optional .ipc.invalidation.Version version = 1;
  bool has_version() const;
  void clear_version();
  const ::ipc::invalidation::Version& version() const;
  ::ipc::invalidation::Version* release_version();
  ::ipc::invalidation::Version* mutable_version();
  void set_allocated_version(::ipc::invalidation::Version* version);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.ClientVersion)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr application_info_;
  ::ipc::invalidation::Version* version_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class StatusP :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.StatusP) */ {
 public:
  StatusP();
  virtual ~StatusP();

  StatusP(const StatusP& from);
  StatusP(StatusP&& from) noexcept
    : StatusP() {
    *this = ::std::move(from);
  }

  inline StatusP& operator=(const StatusP& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusP& operator=(StatusP&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const StatusP& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusP* internal_default_instance() {
    return reinterpret_cast<const StatusP*>(
               &_StatusP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StatusP& a, StatusP& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusP* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatusP* New() const final {
    return CreateMaybeMessage<StatusP>(nullptr);
  }

  StatusP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatusP>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const StatusP& from);
  void MergeFrom(const StatusP& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StatusP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.StatusP";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef StatusP_Code Code;
  static constexpr Code SUCCESS =
    StatusP_Code_SUCCESS;
  static constexpr Code TRANSIENT_FAILURE =
    StatusP_Code_TRANSIENT_FAILURE;
  static constexpr Code PERMANENT_FAILURE =
    StatusP_Code_PERMANENT_FAILURE;
  static inline bool Code_IsValid(int value) {
    return StatusP_Code_IsValid(value);
  }
  static constexpr Code Code_MIN =
    StatusP_Code_Code_MIN;
  static constexpr Code Code_MAX =
    StatusP_Code_Code_MAX;
  static constexpr int Code_ARRAYSIZE =
    StatusP_Code_Code_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Code_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Code>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Code_Name.");
    return StatusP_Code_Name(enum_t_value);
  }
  static inline bool Code_Parse(const std::string& name,
      Code* value) {
    return StatusP_Code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // optional string description = 2;
  bool has_description() const;
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);

  // optional .ipc.invalidation.StatusP.Code code = 1;
  bool has_code() const;
  void clear_code();
  ::ipc::invalidation::StatusP_Code code() const;
  void set_code(::ipc::invalidation::StatusP_Code value);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.StatusP)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  int code_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class ObjectIdP :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.ObjectIdP) */ {
 public:
  ObjectIdP();
  virtual ~ObjectIdP();

  ObjectIdP(const ObjectIdP& from);
  ObjectIdP(ObjectIdP&& from) noexcept
    : ObjectIdP() {
    *this = ::std::move(from);
  }

  inline ObjectIdP& operator=(const ObjectIdP& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectIdP& operator=(ObjectIdP&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ObjectIdP& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectIdP* internal_default_instance() {
    return reinterpret_cast<const ObjectIdP*>(
               &_ObjectIdP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ObjectIdP& a, ObjectIdP& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectIdP* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectIdP* New() const final {
    return CreateMaybeMessage<ObjectIdP>(nullptr);
  }

  ObjectIdP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectIdP>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ObjectIdP& from);
  void MergeFrom(const ObjectIdP& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ObjectIdP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.ObjectIdP";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kSourceFieldNumber = 1,
  };
  // optional bytes name = 2;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional int32 source = 1;
  bool has_source() const;
  void clear_source();
  ::PROTOBUF_NAMESPACE_ID::int32 source() const;
  void set_source(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.ObjectIdP)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 source_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class ApplicationClientIdP :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.ApplicationClientIdP) */ {
 public:
  ApplicationClientIdP();
  virtual ~ApplicationClientIdP();

  ApplicationClientIdP(const ApplicationClientIdP& from);
  ApplicationClientIdP(ApplicationClientIdP&& from) noexcept
    : ApplicationClientIdP() {
    *this = ::std::move(from);
  }

  inline ApplicationClientIdP& operator=(const ApplicationClientIdP& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplicationClientIdP& operator=(ApplicationClientIdP&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ApplicationClientIdP& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ApplicationClientIdP* internal_default_instance() {
    return reinterpret_cast<const ApplicationClientIdP*>(
               &_ApplicationClientIdP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ApplicationClientIdP& a, ApplicationClientIdP& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplicationClientIdP* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ApplicationClientIdP* New() const final {
    return CreateMaybeMessage<ApplicationClientIdP>(nullptr);
  }

  ApplicationClientIdP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ApplicationClientIdP>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ApplicationClientIdP& from);
  void MergeFrom(const ApplicationClientIdP& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ApplicationClientIdP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.ApplicationClientIdP";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 2,
    kClientTypeFieldNumber = 1,
  };
  // optional bytes client_name = 2;
  bool has_client_name() const;
  void clear_client_name();
  const std::string& client_name() const;
  void set_client_name(const std::string& value);
  void set_client_name(std::string&& value);
  void set_client_name(const char* value);
  void set_client_name(const void* value, size_t size);
  std::string* mutable_client_name();
  std::string* release_client_name();
  void set_allocated_client_name(std::string* client_name);

  // optional int32 client_type = 1;
  bool has_client_type() const;
  void clear_client_type();
  ::PROTOBUF_NAMESPACE_ID::int32 client_type() const;
  void set_client_type(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.ApplicationClientIdP)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
  ::PROTOBUF_NAMESPACE_ID::int32 client_type_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class InvalidationP :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.InvalidationP) */ {
 public:
  InvalidationP();
  virtual ~InvalidationP();

  InvalidationP(const InvalidationP& from);
  InvalidationP(InvalidationP&& from) noexcept
    : InvalidationP() {
    *this = ::std::move(from);
  }

  inline InvalidationP& operator=(const InvalidationP& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvalidationP& operator=(InvalidationP&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const InvalidationP& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InvalidationP* internal_default_instance() {
    return reinterpret_cast<const InvalidationP*>(
               &_InvalidationP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InvalidationP& a, InvalidationP& b) {
    a.Swap(&b);
  }
  inline void Swap(InvalidationP* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InvalidationP* New() const final {
    return CreateMaybeMessage<InvalidationP>(nullptr);
  }

  InvalidationP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InvalidationP>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const InvalidationP& from);
  void MergeFrom(const InvalidationP& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InvalidationP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.InvalidationP";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 4,
    kObjectIdFieldNumber = 1,
    kVersionFieldNumber = 3,
    kBridgeArrivalTimeMsDeprecatedFieldNumber = 5,
    kIsKnownVersionFieldNumber = 2,
    kIsTrickleRestartFieldNumber = 6,
  };
  // optional bytes payload = 4;
  bool has_payload() const;
  void clear_payload();
  const std::string& payload() const;
  void set_payload(const std::string& value);
  void set_payload(std::string&& value);
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  std::string* mutable_payload();
  std::string* release_payload();
  void set_allocated_payload(std::string* payload);

  // optional .ipc.invalidation.ObjectIdP object_id = 1;
  bool has_object_id() const;
  void clear_object_id();
  const ::ipc::invalidation::ObjectIdP& object_id() const;
  ::ipc::invalidation::ObjectIdP* release_object_id();
  ::ipc::invalidation::ObjectIdP* mutable_object_id();
  void set_allocated_object_id(::ipc::invalidation::ObjectIdP* object_id);

  // optional int64 version = 3;
  bool has_version() const;
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 bridge_arrival_time_ms_deprecated = 5 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_bridge_arrival_time_ms_deprecated() const;
  PROTOBUF_DEPRECATED void clear_bridge_arrival_time_ms_deprecated();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int64 bridge_arrival_time_ms_deprecated() const;
  PROTOBUF_DEPRECATED void set_bridge_arrival_time_ms_deprecated(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional bool is_known_version = 2;
  bool has_is_known_version() const;
  void clear_is_known_version();
  bool is_known_version() const;
  void set_is_known_version(bool value);

  // optional bool is_trickle_restart = 6 [default = false];
  bool has_is_trickle_restart() const;
  void clear_is_trickle_restart();
  bool is_trickle_restart() const;
  void set_is_trickle_restart(bool value);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.InvalidationP)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  ::ipc::invalidation::ObjectIdP* object_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  ::PROTOBUF_NAMESPACE_ID::int64 bridge_arrival_time_ms_deprecated_;
  bool is_known_version_;
  bool is_trickle_restart_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class RegistrationP :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.RegistrationP) */ {
 public:
  RegistrationP();
  virtual ~RegistrationP();

  RegistrationP(const RegistrationP& from);
  RegistrationP(RegistrationP&& from) noexcept
    : RegistrationP() {
    *this = ::std::move(from);
  }

  inline RegistrationP& operator=(const RegistrationP& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistrationP& operator=(RegistrationP&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RegistrationP& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegistrationP* internal_default_instance() {
    return reinterpret_cast<const RegistrationP*>(
               &_RegistrationP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RegistrationP& a, RegistrationP& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistrationP* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegistrationP* New() const final {
    return CreateMaybeMessage<RegistrationP>(nullptr);
  }

  RegistrationP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegistrationP>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RegistrationP& from);
  void MergeFrom(const RegistrationP& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegistrationP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.RegistrationP";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef RegistrationP_OpType OpType;
  static constexpr OpType REGISTER =
    RegistrationP_OpType_REGISTER;
  static constexpr OpType UNREGISTER =
    RegistrationP_OpType_UNREGISTER;
  static inline bool OpType_IsValid(int value) {
    return RegistrationP_OpType_IsValid(value);
  }
  static constexpr OpType OpType_MIN =
    RegistrationP_OpType_OpType_MIN;
  static constexpr OpType OpType_MAX =
    RegistrationP_OpType_OpType_MAX;
  static constexpr int OpType_ARRAYSIZE =
    RegistrationP_OpType_OpType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& OpType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OpType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OpType_Name.");
    return RegistrationP_OpType_Name(enum_t_value);
  }
  static inline bool OpType_Parse(const std::string& name,
      OpType* value) {
    return RegistrationP_OpType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kOpTypeFieldNumber = 2,
  };
  // optional .ipc.invalidation.ObjectIdP object_id = 1;
  bool has_object_id() const;
  void clear_object_id();
  const ::ipc::invalidation::ObjectIdP& object_id() const;
  ::ipc::invalidation::ObjectIdP* release_object_id();
  ::ipc::invalidation::ObjectIdP* mutable_object_id();
  void set_allocated_object_id(::ipc::invalidation::ObjectIdP* object_id);

  // optional .ipc.invalidation.RegistrationP.OpType op_type = 2;
  bool has_op_type() const;
  void clear_op_type();
  ::ipc::invalidation::RegistrationP_OpType op_type() const;
  void set_op_type(::ipc::invalidation::RegistrationP_OpType value);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.RegistrationP)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ipc::invalidation::ObjectIdP* object_id_;
  int op_type_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class RegistrationSummary :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.RegistrationSummary) */ {
 public:
  RegistrationSummary();
  virtual ~RegistrationSummary();

  RegistrationSummary(const RegistrationSummary& from);
  RegistrationSummary(RegistrationSummary&& from) noexcept
    : RegistrationSummary() {
    *this = ::std::move(from);
  }

  inline RegistrationSummary& operator=(const RegistrationSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistrationSummary& operator=(RegistrationSummary&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RegistrationSummary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegistrationSummary* internal_default_instance() {
    return reinterpret_cast<const RegistrationSummary*>(
               &_RegistrationSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RegistrationSummary& a, RegistrationSummary& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistrationSummary* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegistrationSummary* New() const final {
    return CreateMaybeMessage<RegistrationSummary>(nullptr);
  }

  RegistrationSummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegistrationSummary>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RegistrationSummary& from);
  void MergeFrom(const RegistrationSummary& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegistrationSummary* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.RegistrationSummary";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegistrationDigestFieldNumber = 2,
    kNumRegistrationsFieldNumber = 1,
  };
  // optional bytes registration_digest = 2;
  bool has_registration_digest() const;
  void clear_registration_digest();
  const std::string& registration_digest() const;
  void set_registration_digest(const std::string& value);
  void set_registration_digest(std::string&& value);
  void set_registration_digest(const char* value);
  void set_registration_digest(const void* value, size_t size);
  std::string* mutable_registration_digest();
  std::string* release_registration_digest();
  void set_allocated_registration_digest(std::string* registration_digest);

  // optional int32 num_registrations = 1;
  bool has_num_registrations() const;
  void clear_num_registrations();
  ::PROTOBUF_NAMESPACE_ID::int32 num_registrations() const;
  void set_num_registrations(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.RegistrationSummary)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr registration_digest_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_registrations_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class ClientHeader :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.ClientHeader) */ {
 public:
  ClientHeader();
  virtual ~ClientHeader();

  ClientHeader(const ClientHeader& from);
  ClientHeader(ClientHeader&& from) noexcept
    : ClientHeader() {
    *this = ::std::move(from);
  }

  inline ClientHeader& operator=(const ClientHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientHeader& operator=(ClientHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ClientHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientHeader* internal_default_instance() {
    return reinterpret_cast<const ClientHeader*>(
               &_ClientHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ClientHeader& a, ClientHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientHeader* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientHeader* New() const final {
    return CreateMaybeMessage<ClientHeader>(nullptr);
  }

  ClientHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientHeader>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ClientHeader& from);
  void MergeFrom(const ClientHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.ClientHeader";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientTokenFieldNumber = 2,
    kMessageIdFieldNumber = 6,
    kProtocolVersionFieldNumber = 1,
    kRegistrationSummaryFieldNumber = 3,
    kClientTimeMsFieldNumber = 4,
    kMaxKnownServerTimeMsFieldNumber = 5,
    kClientTypeFieldNumber = 7,
  };
  // optional bytes client_token = 2;
  bool has_client_token() const;
  void clear_client_token();
  const std::string& client_token() const;
  void set_client_token(const std::string& value);
  void set_client_token(std::string&& value);
  void set_client_token(const char* value);
  void set_client_token(const void* value, size_t size);
  std::string* mutable_client_token();
  std::string* release_client_token();
  void set_allocated_client_token(std::string* client_token);

  // optional string message_id = 6;
  bool has_message_id() const;
  void clear_message_id();
  const std::string& message_id() const;
  void set_message_id(const std::string& value);
  void set_message_id(std::string&& value);
  void set_message_id(const char* value);
  void set_message_id(const char* value, size_t size);
  std::string* mutable_message_id();
  std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);

  // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
  bool has_protocol_version() const;
  void clear_protocol_version();
  const ::ipc::invalidation::ProtocolVersion& protocol_version() const;
  ::ipc::invalidation::ProtocolVersion* release_protocol_version();
  ::ipc::invalidation::ProtocolVersion* mutable_protocol_version();
  void set_allocated_protocol_version(::ipc::invalidation::ProtocolVersion* protocol_version);

  // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
  bool has_registration_summary() const;
  void clear_registration_summary();
  const ::ipc::invalidation::RegistrationSummary& registration_summary() const;
  ::ipc::invalidation::RegistrationSummary* release_registration_summary();
  ::ipc::invalidation::RegistrationSummary* mutable_registration_summary();
  void set_allocated_registration_summary(::ipc::invalidation::RegistrationSummary* registration_summary);

  // optional int64 client_time_ms = 4;
  bool has_client_time_ms() const;
  void clear_client_time_ms();
  ::PROTOBUF_NAMESPACE_ID::int64 client_time_ms() const;
  void set_client_time_ms(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 max_known_server_time_ms = 5;
  bool has_max_known_server_time_ms() const;
  void clear_max_known_server_time_ms();
  ::PROTOBUF_NAMESPACE_ID::int64 max_known_server_time_ms() const;
  void set_max_known_server_time_ms(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int32 client_type = 7;
  bool has_client_type() const;
  void clear_client_type();
  ::PROTOBUF_NAMESPACE_ID::int32 client_type() const;
  void set_client_type(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.ClientHeader)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
  ::ipc::invalidation::ProtocolVersion* protocol_version_;
  ::ipc::invalidation::RegistrationSummary* registration_summary_;
  ::PROTOBUF_NAMESPACE_ID::int64 client_time_ms_;
  ::PROTOBUF_NAMESPACE_ID::int64 max_known_server_time_ms_;
  ::PROTOBUF_NAMESPACE_ID::int32 client_type_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class ClientToServerMessage :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.ClientToServerMessage) */ {
 public:
  ClientToServerMessage();
  virtual ~ClientToServerMessage();

  ClientToServerMessage(const ClientToServerMessage& from);
  ClientToServerMessage(ClientToServerMessage&& from) noexcept
    : ClientToServerMessage() {
    *this = ::std::move(from);
  }

  inline ClientToServerMessage& operator=(const ClientToServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServerMessage& operator=(ClientToServerMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ClientToServerMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServerMessage* internal_default_instance() {
    return reinterpret_cast<const ClientToServerMessage*>(
               &_ClientToServerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ClientToServerMessage& a, ClientToServerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServerMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServerMessage* New() const final {
    return CreateMaybeMessage<ClientToServerMessage>(nullptr);
  }

  ClientToServerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServerMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ClientToServerMessage& from);
  void MergeFrom(const ClientToServerMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientToServerMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.ClientToServerMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kInitializeMessageFieldNumber = 2,
    kRegistrationMessageFieldNumber = 3,
    kRegistrationSyncMessageFieldNumber = 4,
    kInvalidationAckMessageFieldNumber = 5,
    kInfoMessageFieldNumber = 6,
  };
  // optional .ipc.invalidation.ClientHeader header = 1;
  bool has_header() const;
  void clear_header();
  const ::ipc::invalidation::ClientHeader& header() const;
  ::ipc::invalidation::ClientHeader* release_header();
  ::ipc::invalidation::ClientHeader* mutable_header();
  void set_allocated_header(::ipc::invalidation::ClientHeader* header);

  // optional .ipc.invalidation.InitializeMessage initialize_message = 2;
  bool has_initialize_message() const;
  void clear_initialize_message();
  const ::ipc::invalidation::InitializeMessage& initialize_message() const;
  ::ipc::invalidation::InitializeMessage* release_initialize_message();
  ::ipc::invalidation::InitializeMessage* mutable_initialize_message();
  void set_allocated_initialize_message(::ipc::invalidation::InitializeMessage* initialize_message);

  // optional .ipc.invalidation.RegistrationMessage registration_message = 3;
  bool has_registration_message() const;
  void clear_registration_message();
  const ::ipc::invalidation::RegistrationMessage& registration_message() const;
  ::ipc::invalidation::RegistrationMessage* release_registration_message();
  ::ipc::invalidation::RegistrationMessage* mutable_registration_message();
  void set_allocated_registration_message(::ipc::invalidation::RegistrationMessage* registration_message);

  // optional .ipc.invalidation.RegistrationSyncMessage registration_sync_message = 4;
  bool has_registration_sync_message() const;
  void clear_registration_sync_message();
  const ::ipc::invalidation::RegistrationSyncMessage& registration_sync_message() const;
  ::ipc::invalidation::RegistrationSyncMessage* release_registration_sync_message();
  ::ipc::invalidation::RegistrationSyncMessage* mutable_registration_sync_message();
  void set_allocated_registration_sync_message(::ipc::invalidation::RegistrationSyncMessage* registration_sync_message);

  // optional .ipc.invalidation.InvalidationMessage invalidation_ack_message = 5;
  bool has_invalidation_ack_message() const;
  void clear_invalidation_ack_message();
  const ::ipc::invalidation::InvalidationMessage& invalidation_ack_message() const;
  ::ipc::invalidation::InvalidationMessage* release_invalidation_ack_message();
  ::ipc::invalidation::InvalidationMessage* mutable_invalidation_ack_message();
  void set_allocated_invalidation_ack_message(::ipc::invalidation::InvalidationMessage* invalidation_ack_message);

  // optional .ipc.invalidation.InfoMessage info_message = 6;
  bool has_info_message() const;
  void clear_info_message();
  const ::ipc::invalidation::InfoMessage& info_message() const;
  ::ipc::invalidation::InfoMessage* release_info_message();
  ::ipc::invalidation::InfoMessage* mutable_info_message();
  void set_allocated_info_message(::ipc::invalidation::InfoMessage* info_message);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.ClientToServerMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ipc::invalidation::ClientHeader* header_;
  ::ipc::invalidation::InitializeMessage* initialize_message_;
  ::ipc::invalidation::RegistrationMessage* registration_message_;
  ::ipc::invalidation::RegistrationSyncMessage* registration_sync_message_;
  ::ipc::invalidation::InvalidationMessage* invalidation_ack_message_;
  ::ipc::invalidation::InfoMessage* info_message_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class InitializeMessage :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.InitializeMessage) */ {
 public:
  InitializeMessage();
  virtual ~InitializeMessage();

  InitializeMessage(const InitializeMessage& from);
  InitializeMessage(InitializeMessage&& from) noexcept
    : InitializeMessage() {
    *this = ::std::move(from);
  }

  inline InitializeMessage& operator=(const InitializeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitializeMessage& operator=(InitializeMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const InitializeMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitializeMessage* internal_default_instance() {
    return reinterpret_cast<const InitializeMessage*>(
               &_InitializeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(InitializeMessage& a, InitializeMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(InitializeMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InitializeMessage* New() const final {
    return CreateMaybeMessage<InitializeMessage>(nullptr);
  }

  InitializeMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InitializeMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const InitializeMessage& from);
  void MergeFrom(const InitializeMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InitializeMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.InitializeMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef InitializeMessage_DigestSerializationType DigestSerializationType;
  static constexpr DigestSerializationType BYTE_BASED =
    InitializeMessage_DigestSerializationType_BYTE_BASED;
  static constexpr DigestSerializationType NUMBER_BASED =
    InitializeMessage_DigestSerializationType_NUMBER_BASED;
  static inline bool DigestSerializationType_IsValid(int value) {
    return InitializeMessage_DigestSerializationType_IsValid(value);
  }
  static constexpr DigestSerializationType DigestSerializationType_MIN =
    InitializeMessage_DigestSerializationType_DigestSerializationType_MIN;
  static constexpr DigestSerializationType DigestSerializationType_MAX =
    InitializeMessage_DigestSerializationType_DigestSerializationType_MAX;
  static constexpr int DigestSerializationType_ARRAYSIZE =
    InitializeMessage_DigestSerializationType_DigestSerializationType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& DigestSerializationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DigestSerializationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DigestSerializationType_Name.");
    return InitializeMessage_DigestSerializationType_Name(enum_t_value);
  }
  static inline bool DigestSerializationType_Parse(const std::string& name,
      DigestSerializationType* value) {
    return InitializeMessage_DigestSerializationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNonceFieldNumber = 2,
    kApplicationClientIdFieldNumber = 3,
    kClientTypeFieldNumber = 1,
    kDigestSerializationTypeFieldNumber = 4,
  };
  // optional bytes nonce = 2;
  bool has_nonce() const;
  void clear_nonce();
  const std::string& nonce() const;
  void set_nonce(const std::string& value);
  void set_nonce(std::string&& value);
  void set_nonce(const char* value);
  void set_nonce(const void* value, size_t size);
  std::string* mutable_nonce();
  std::string* release_nonce();
  void set_allocated_nonce(std::string* nonce);

  // optional .ipc.invalidation.ApplicationClientIdP application_client_id = 3;
  bool has_application_client_id() const;
  void clear_application_client_id();
  const ::ipc::invalidation::ApplicationClientIdP& application_client_id() const;
  ::ipc::invalidation::ApplicationClientIdP* release_application_client_id();
  ::ipc::invalidation::ApplicationClientIdP* mutable_application_client_id();
  void set_allocated_application_client_id(::ipc::invalidation::ApplicationClientIdP* application_client_id);

  // optional int32 client_type = 1;
  bool has_client_type() const;
  void clear_client_type();
  ::PROTOBUF_NAMESPACE_ID::int32 client_type() const;
  void set_client_type(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional .ipc.invalidation.InitializeMessage.DigestSerializationType digest_serialization_type = 4;
  bool has_digest_serialization_type() const;
  void clear_digest_serialization_type();
  ::ipc::invalidation::InitializeMessage_DigestSerializationType digest_serialization_type() const;
  void set_digest_serialization_type(::ipc::invalidation::InitializeMessage_DigestSerializationType value);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.InitializeMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nonce_;
  ::ipc::invalidation::ApplicationClientIdP* application_client_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 client_type_;
  int digest_serialization_type_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class RegistrationMessage :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.RegistrationMessage) */ {
 public:
  RegistrationMessage();
  virtual ~RegistrationMessage();

  RegistrationMessage(const RegistrationMessage& from);
  RegistrationMessage(RegistrationMessage&& from) noexcept
    : RegistrationMessage() {
    *this = ::std::move(from);
  }

  inline RegistrationMessage& operator=(const RegistrationMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistrationMessage& operator=(RegistrationMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RegistrationMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegistrationMessage* internal_default_instance() {
    return reinterpret_cast<const RegistrationMessage*>(
               &_RegistrationMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RegistrationMessage& a, RegistrationMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistrationMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegistrationMessage* New() const final {
    return CreateMaybeMessage<RegistrationMessage>(nullptr);
  }

  RegistrationMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegistrationMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RegistrationMessage& from);
  void MergeFrom(const RegistrationMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegistrationMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.RegistrationMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegistrationFieldNumber = 1,
  };
  // repeated .ipc.invalidation.RegistrationP registration = 1;
  int registration_size() const;
  void clear_registration();
  ::ipc::invalidation::RegistrationP* mutable_registration(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::RegistrationP >*
      mutable_registration();
  const ::ipc::invalidation::RegistrationP& registration(int index) const;
  ::ipc::invalidation::RegistrationP* add_registration();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::RegistrationP >&
      registration() const;

  // @@protoc_insertion_point(class_scope:ipc.invalidation.RegistrationMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::RegistrationP > registration_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class RegistrationSyncMessage :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.RegistrationSyncMessage) */ {
 public:
  RegistrationSyncMessage();
  virtual ~RegistrationSyncMessage();

  RegistrationSyncMessage(const RegistrationSyncMessage& from);
  RegistrationSyncMessage(RegistrationSyncMessage&& from) noexcept
    : RegistrationSyncMessage() {
    *this = ::std::move(from);
  }

  inline RegistrationSyncMessage& operator=(const RegistrationSyncMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistrationSyncMessage& operator=(RegistrationSyncMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RegistrationSyncMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegistrationSyncMessage* internal_default_instance() {
    return reinterpret_cast<const RegistrationSyncMessage*>(
               &_RegistrationSyncMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RegistrationSyncMessage& a, RegistrationSyncMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistrationSyncMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegistrationSyncMessage* New() const final {
    return CreateMaybeMessage<RegistrationSyncMessage>(nullptr);
  }

  RegistrationSyncMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegistrationSyncMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RegistrationSyncMessage& from);
  void MergeFrom(const RegistrationSyncMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegistrationSyncMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.RegistrationSyncMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubtreeFieldNumber = 1,
  };
  // repeated .ipc.invalidation.RegistrationSubtree subtree = 1;
  int subtree_size() const;
  void clear_subtree();
  ::ipc::invalidation::RegistrationSubtree* mutable_subtree(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::RegistrationSubtree >*
      mutable_subtree();
  const ::ipc::invalidation::RegistrationSubtree& subtree(int index) const;
  ::ipc::invalidation::RegistrationSubtree* add_subtree();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::RegistrationSubtree >&
      subtree() const;

  // @@protoc_insertion_point(class_scope:ipc.invalidation.RegistrationSyncMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::RegistrationSubtree > subtree_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class RegistrationSubtree :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.RegistrationSubtree) */ {
 public:
  RegistrationSubtree();
  virtual ~RegistrationSubtree();

  RegistrationSubtree(const RegistrationSubtree& from);
  RegistrationSubtree(RegistrationSubtree&& from) noexcept
    : RegistrationSubtree() {
    *this = ::std::move(from);
  }

  inline RegistrationSubtree& operator=(const RegistrationSubtree& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistrationSubtree& operator=(RegistrationSubtree&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RegistrationSubtree& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegistrationSubtree* internal_default_instance() {
    return reinterpret_cast<const RegistrationSubtree*>(
               &_RegistrationSubtree_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RegistrationSubtree& a, RegistrationSubtree& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistrationSubtree* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegistrationSubtree* New() const final {
    return CreateMaybeMessage<RegistrationSubtree>(nullptr);
  }

  RegistrationSubtree* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegistrationSubtree>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RegistrationSubtree& from);
  void MergeFrom(const RegistrationSubtree& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegistrationSubtree* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.RegistrationSubtree";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegisteredObjectFieldNumber = 1,
  };
  // repeated .ipc.invalidation.ObjectIdP registered_object = 1;
  int registered_object_size() const;
  void clear_registered_object();
  ::ipc::invalidation::ObjectIdP* mutable_registered_object(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::ObjectIdP >*
      mutable_registered_object();
  const ::ipc::invalidation::ObjectIdP& registered_object(int index) const;
  ::ipc::invalidation::ObjectIdP* add_registered_object();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::ObjectIdP >&
      registered_object() const;

  // @@protoc_insertion_point(class_scope:ipc.invalidation.RegistrationSubtree)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::ObjectIdP > registered_object_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class InfoMessage :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.InfoMessage) */ {
 public:
  InfoMessage();
  virtual ~InfoMessage();

  InfoMessage(const InfoMessage& from);
  InfoMessage(InfoMessage&& from) noexcept
    : InfoMessage() {
    *this = ::std::move(from);
  }

  inline InfoMessage& operator=(const InfoMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfoMessage& operator=(InfoMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const InfoMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InfoMessage* internal_default_instance() {
    return reinterpret_cast<const InfoMessage*>(
               &_InfoMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(InfoMessage& a, InfoMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(InfoMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InfoMessage* New() const final {
    return CreateMaybeMessage<InfoMessage>(nullptr);
  }

  InfoMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InfoMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const InfoMessage& from);
  void MergeFrom(const InfoMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InfoMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.InfoMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigParameterFieldNumber = 2,
    kPerformanceCounterFieldNumber = 3,
    kClientVersionFieldNumber = 1,
    kClientConfigFieldNumber = 5,
    kServerRegistrationSummaryRequestedFieldNumber = 4,
  };
  // repeated .ipc.invalidation.PropertyRecord config_parameter = 2;
  int config_parameter_size() const;
  void clear_config_parameter();
  ::ipc::invalidation::PropertyRecord* mutable_config_parameter(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::PropertyRecord >*
      mutable_config_parameter();
  const ::ipc::invalidation::PropertyRecord& config_parameter(int index) const;
  ::ipc::invalidation::PropertyRecord* add_config_parameter();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::PropertyRecord >&
      config_parameter() const;

  // repeated .ipc.invalidation.PropertyRecord performance_counter = 3;
  int performance_counter_size() const;
  void clear_performance_counter();
  ::ipc::invalidation::PropertyRecord* mutable_performance_counter(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::PropertyRecord >*
      mutable_performance_counter();
  const ::ipc::invalidation::PropertyRecord& performance_counter(int index) const;
  ::ipc::invalidation::PropertyRecord* add_performance_counter();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::PropertyRecord >&
      performance_counter() const;

  // optional .ipc.invalidation.ClientVersion client_version = 1;
  bool has_client_version() const;
  void clear_client_version();
  const ::ipc::invalidation::ClientVersion& client_version() const;
  ::ipc::invalidation::ClientVersion* release_client_version();
  ::ipc::invalidation::ClientVersion* mutable_client_version();
  void set_allocated_client_version(::ipc::invalidation::ClientVersion* client_version);

  // optional .ipc.invalidation.ClientConfigP client_config = 5;
  bool has_client_config() const;
  void clear_client_config();
  const ::ipc::invalidation::ClientConfigP& client_config() const;
  ::ipc::invalidation::ClientConfigP* release_client_config();
  ::ipc::invalidation::ClientConfigP* mutable_client_config();
  void set_allocated_client_config(::ipc::invalidation::ClientConfigP* client_config);

  // optional bool server_registration_summary_requested = 4;
  bool has_server_registration_summary_requested() const;
  void clear_server_registration_summary_requested();
  bool server_registration_summary_requested() const;
  void set_server_registration_summary_requested(bool value);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.InfoMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::PropertyRecord > config_parameter_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::PropertyRecord > performance_counter_;
  ::ipc::invalidation::ClientVersion* client_version_;
  ::ipc::invalidation::ClientConfigP* client_config_;
  bool server_registration_summary_requested_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class PropertyRecord :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.PropertyRecord) */ {
 public:
  PropertyRecord();
  virtual ~PropertyRecord();

  PropertyRecord(const PropertyRecord& from);
  PropertyRecord(PropertyRecord&& from) noexcept
    : PropertyRecord() {
    *this = ::std::move(from);
  }

  inline PropertyRecord& operator=(const PropertyRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropertyRecord& operator=(PropertyRecord&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PropertyRecord& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PropertyRecord* internal_default_instance() {
    return reinterpret_cast<const PropertyRecord*>(
               &_PropertyRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PropertyRecord& a, PropertyRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(PropertyRecord* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PropertyRecord* New() const final {
    return CreateMaybeMessage<PropertyRecord>(nullptr);
  }

  PropertyRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PropertyRecord>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PropertyRecord& from);
  void MergeFrom(const PropertyRecord& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PropertyRecord* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.PropertyRecord";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional int32 value = 2;
  bool has_value() const;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.PropertyRecord)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 value_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class ServerHeader :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.ServerHeader) */ {
 public:
  ServerHeader();
  virtual ~ServerHeader();

  ServerHeader(const ServerHeader& from);
  ServerHeader(ServerHeader&& from) noexcept
    : ServerHeader() {
    *this = ::std::move(from);
  }

  inline ServerHeader& operator=(const ServerHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerHeader& operator=(ServerHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ServerHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerHeader* internal_default_instance() {
    return reinterpret_cast<const ServerHeader*>(
               &_ServerHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ServerHeader& a, ServerHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerHeader* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerHeader* New() const final {
    return CreateMaybeMessage<ServerHeader>(nullptr);
  }

  ServerHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerHeader>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ServerHeader& from);
  void MergeFrom(const ServerHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.ServerHeader";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientTokenFieldNumber = 2,
    kMessageIdFieldNumber = 5,
    kProtocolVersionFieldNumber = 1,
    kRegistrationSummaryFieldNumber = 3,
    kServerTimeMsFieldNumber = 4,
  };
  // optional bytes client_token = 2;
  bool has_client_token() const;
  void clear_client_token();
  const std::string& client_token() const;
  void set_client_token(const std::string& value);
  void set_client_token(std::string&& value);
  void set_client_token(const char* value);
  void set_client_token(const void* value, size_t size);
  std::string* mutable_client_token();
  std::string* release_client_token();
  void set_allocated_client_token(std::string* client_token);

  // optional string message_id = 5;
  bool has_message_id() const;
  void clear_message_id();
  const std::string& message_id() const;
  void set_message_id(const std::string& value);
  void set_message_id(std::string&& value);
  void set_message_id(const char* value);
  void set_message_id(const char* value, size_t size);
  std::string* mutable_message_id();
  std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);

  // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
  bool has_protocol_version() const;
  void clear_protocol_version();
  const ::ipc::invalidation::ProtocolVersion& protocol_version() const;
  ::ipc::invalidation::ProtocolVersion* release_protocol_version();
  ::ipc::invalidation::ProtocolVersion* mutable_protocol_version();
  void set_allocated_protocol_version(::ipc::invalidation::ProtocolVersion* protocol_version);

  // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
  bool has_registration_summary() const;
  void clear_registration_summary();
  const ::ipc::invalidation::RegistrationSummary& registration_summary() const;
  ::ipc::invalidation::RegistrationSummary* release_registration_summary();
  ::ipc::invalidation::RegistrationSummary* mutable_registration_summary();
  void set_allocated_registration_summary(::ipc::invalidation::RegistrationSummary* registration_summary);

  // optional int64 server_time_ms = 4;
  bool has_server_time_ms() const;
  void clear_server_time_ms();
  ::PROTOBUF_NAMESPACE_ID::int64 server_time_ms() const;
  void set_server_time_ms(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.ServerHeader)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
  ::ipc::invalidation::ProtocolVersion* protocol_version_;
  ::ipc::invalidation::RegistrationSummary* registration_summary_;
  ::PROTOBUF_NAMESPACE_ID::int64 server_time_ms_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class ServerToClientMessage :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.ServerToClientMessage) */ {
 public:
  ServerToClientMessage();
  virtual ~ServerToClientMessage();

  ServerToClientMessage(const ServerToClientMessage& from);
  ServerToClientMessage(ServerToClientMessage&& from) noexcept
    : ServerToClientMessage() {
    *this = ::std::move(from);
  }

  inline ServerToClientMessage& operator=(const ServerToClientMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClientMessage& operator=(ServerToClientMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ServerToClientMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClientMessage* internal_default_instance() {
    return reinterpret_cast<const ServerToClientMessage*>(
               &_ServerToClientMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ServerToClientMessage& a, ServerToClientMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClientMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClientMessage* New() const final {
    return CreateMaybeMessage<ServerToClientMessage>(nullptr);
  }

  ServerToClientMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClientMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ServerToClientMessage& from);
  void MergeFrom(const ServerToClientMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerToClientMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.ServerToClientMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kTokenControlMessageFieldNumber = 2,
    kInvalidationMessageFieldNumber = 3,
    kRegistrationStatusMessageFieldNumber = 4,
    kRegistrationSyncRequestMessageFieldNumber = 5,
    kConfigChangeMessageFieldNumber = 6,
    kInfoRequestMessageFieldNumber = 7,
    kErrorMessageFieldNumber = 8,
  };
  // optional .ipc.invalidation.ServerHeader header = 1;
  bool has_header() const;
  void clear_header();
  const ::ipc::invalidation::ServerHeader& header() const;
  ::ipc::invalidation::ServerHeader* release_header();
  ::ipc::invalidation::ServerHeader* mutable_header();
  void set_allocated_header(::ipc::invalidation::ServerHeader* header);

  // optional .ipc.invalidation.TokenControlMessage token_control_message = 2;
  bool has_token_control_message() const;
  void clear_token_control_message();
  const ::ipc::invalidation::TokenControlMessage& token_control_message() const;
  ::ipc::invalidation::TokenControlMessage* release_token_control_message();
  ::ipc::invalidation::TokenControlMessage* mutable_token_control_message();
  void set_allocated_token_control_message(::ipc::invalidation::TokenControlMessage* token_control_message);

  // optional .ipc.invalidation.InvalidationMessage invalidation_message = 3;
  bool has_invalidation_message() const;
  void clear_invalidation_message();
  const ::ipc::invalidation::InvalidationMessage& invalidation_message() const;
  ::ipc::invalidation::InvalidationMessage* release_invalidation_message();
  ::ipc::invalidation::InvalidationMessage* mutable_invalidation_message();
  void set_allocated_invalidation_message(::ipc::invalidation::InvalidationMessage* invalidation_message);

  // optional .ipc.invalidation.RegistrationStatusMessage registration_status_message = 4;
  bool has_registration_status_message() const;
  void clear_registration_status_message();
  const ::ipc::invalidation::RegistrationStatusMessage& registration_status_message() const;
  ::ipc::invalidation::RegistrationStatusMessage* release_registration_status_message();
  ::ipc::invalidation::RegistrationStatusMessage* mutable_registration_status_message();
  void set_allocated_registration_status_message(::ipc::invalidation::RegistrationStatusMessage* registration_status_message);

  // optional .ipc.invalidation.RegistrationSyncRequestMessage registration_sync_request_message = 5;
  bool has_registration_sync_request_message() const;
  void clear_registration_sync_request_message();
  const ::ipc::invalidation::RegistrationSyncRequestMessage& registration_sync_request_message() const;
  ::ipc::invalidation::RegistrationSyncRequestMessage* release_registration_sync_request_message();
  ::ipc::invalidation::RegistrationSyncRequestMessage* mutable_registration_sync_request_message();
  void set_allocated_registration_sync_request_message(::ipc::invalidation::RegistrationSyncRequestMessage* registration_sync_request_message);

  // optional .ipc.invalidation.ConfigChangeMessage config_change_message = 6;
  bool has_config_change_message() const;
  void clear_config_change_message();
  const ::ipc::invalidation::ConfigChangeMessage& config_change_message() const;
  ::ipc::invalidation::ConfigChangeMessage* release_config_change_message();
  ::ipc::invalidation::ConfigChangeMessage* mutable_config_change_message();
  void set_allocated_config_change_message(::ipc::invalidation::ConfigChangeMessage* config_change_message);

  // optional .ipc.invalidation.InfoRequestMessage info_request_message = 7;
  bool has_info_request_message() const;
  void clear_info_request_message();
  const ::ipc::invalidation::InfoRequestMessage& info_request_message() const;
  ::ipc::invalidation::InfoRequestMessage* release_info_request_message();
  ::ipc::invalidation::InfoRequestMessage* mutable_info_request_message();
  void set_allocated_info_request_message(::ipc::invalidation::InfoRequestMessage* info_request_message);

  // optional .ipc.invalidation.ErrorMessage error_message = 8;
  bool has_error_message() const;
  void clear_error_message();
  const ::ipc::invalidation::ErrorMessage& error_message() const;
  ::ipc::invalidation::ErrorMessage* release_error_message();
  ::ipc::invalidation::ErrorMessage* mutable_error_message();
  void set_allocated_error_message(::ipc::invalidation::ErrorMessage* error_message);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.ServerToClientMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ipc::invalidation::ServerHeader* header_;
  ::ipc::invalidation::TokenControlMessage* token_control_message_;
  ::ipc::invalidation::InvalidationMessage* invalidation_message_;
  ::ipc::invalidation::RegistrationStatusMessage* registration_status_message_;
  ::ipc::invalidation::RegistrationSyncRequestMessage* registration_sync_request_message_;
  ::ipc::invalidation::ConfigChangeMessage* config_change_message_;
  ::ipc::invalidation::InfoRequestMessage* info_request_message_;
  ::ipc::invalidation::ErrorMessage* error_message_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class TokenControlMessage :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.TokenControlMessage) */ {
 public:
  TokenControlMessage();
  virtual ~TokenControlMessage();

  TokenControlMessage(const TokenControlMessage& from);
  TokenControlMessage(TokenControlMessage&& from) noexcept
    : TokenControlMessage() {
    *this = ::std::move(from);
  }

  inline TokenControlMessage& operator=(const TokenControlMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenControlMessage& operator=(TokenControlMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const TokenControlMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TokenControlMessage* internal_default_instance() {
    return reinterpret_cast<const TokenControlMessage*>(
               &_TokenControlMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(TokenControlMessage& a, TokenControlMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenControlMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TokenControlMessage* New() const final {
    return CreateMaybeMessage<TokenControlMessage>(nullptr);
  }

  TokenControlMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TokenControlMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const TokenControlMessage& from);
  void MergeFrom(const TokenControlMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TokenControlMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.TokenControlMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewTokenFieldNumber = 1,
  };
  // optional bytes new_token = 1;
  bool has_new_token() const;
  void clear_new_token();
  const std::string& new_token() const;
  void set_new_token(const std::string& value);
  void set_new_token(std::string&& value);
  void set_new_token(const char* value);
  void set_new_token(const void* value, size_t size);
  std::string* mutable_new_token();
  std::string* release_new_token();
  void set_allocated_new_token(std::string* new_token);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.TokenControlMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_token_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class RegistrationStatus :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.RegistrationStatus) */ {
 public:
  RegistrationStatus();
  virtual ~RegistrationStatus();

  RegistrationStatus(const RegistrationStatus& from);
  RegistrationStatus(RegistrationStatus&& from) noexcept
    : RegistrationStatus() {
    *this = ::std::move(from);
  }

  inline RegistrationStatus& operator=(const RegistrationStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistrationStatus& operator=(RegistrationStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RegistrationStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegistrationStatus* internal_default_instance() {
    return reinterpret_cast<const RegistrationStatus*>(
               &_RegistrationStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RegistrationStatus& a, RegistrationStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistrationStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegistrationStatus* New() const final {
    return CreateMaybeMessage<RegistrationStatus>(nullptr);
  }

  RegistrationStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegistrationStatus>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RegistrationStatus& from);
  void MergeFrom(const RegistrationStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegistrationStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.RegistrationStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegistrationFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // optional .ipc.invalidation.RegistrationP registration = 1;
  bool has_registration() const;
  void clear_registration();
  const ::ipc::invalidation::RegistrationP& registration() const;
  ::ipc::invalidation::RegistrationP* release_registration();
  ::ipc::invalidation::RegistrationP* mutable_registration();
  void set_allocated_registration(::ipc::invalidation::RegistrationP* registration);

  // optional .ipc.invalidation.StatusP status = 2;
  bool has_status() const;
  void clear_status();
  const ::ipc::invalidation::StatusP& status() const;
  ::ipc::invalidation::StatusP* release_status();
  ::ipc::invalidation::StatusP* mutable_status();
  void set_allocated_status(::ipc::invalidation::StatusP* status);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.RegistrationStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ipc::invalidation::RegistrationP* registration_;
  ::ipc::invalidation::StatusP* status_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class RegistrationStatusMessage :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.RegistrationStatusMessage) */ {
 public:
  RegistrationStatusMessage();
  virtual ~RegistrationStatusMessage();

  RegistrationStatusMessage(const RegistrationStatusMessage& from);
  RegistrationStatusMessage(RegistrationStatusMessage&& from) noexcept
    : RegistrationStatusMessage() {
    *this = ::std::move(from);
  }

  inline RegistrationStatusMessage& operator=(const RegistrationStatusMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistrationStatusMessage& operator=(RegistrationStatusMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RegistrationStatusMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegistrationStatusMessage* internal_default_instance() {
    return reinterpret_cast<const RegistrationStatusMessage*>(
               &_RegistrationStatusMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(RegistrationStatusMessage& a, RegistrationStatusMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistrationStatusMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegistrationStatusMessage* New() const final {
    return CreateMaybeMessage<RegistrationStatusMessage>(nullptr);
  }

  RegistrationStatusMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegistrationStatusMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RegistrationStatusMessage& from);
  void MergeFrom(const RegistrationStatusMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegistrationStatusMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.RegistrationStatusMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegistrationStatusFieldNumber = 1,
  };
  // repeated .ipc.invalidation.RegistrationStatus registration_status = 1;
  int registration_status_size() const;
  void clear_registration_status();
  ::ipc::invalidation::RegistrationStatus* mutable_registration_status(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::RegistrationStatus >*
      mutable_registration_status();
  const ::ipc::invalidation::RegistrationStatus& registration_status(int index) const;
  ::ipc::invalidation::RegistrationStatus* add_registration_status();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::RegistrationStatus >&
      registration_status() const;

  // @@protoc_insertion_point(class_scope:ipc.invalidation.RegistrationStatusMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::RegistrationStatus > registration_status_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class RegistrationSyncRequestMessage :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.RegistrationSyncRequestMessage) */ {
 public:
  RegistrationSyncRequestMessage();
  virtual ~RegistrationSyncRequestMessage();

  RegistrationSyncRequestMessage(const RegistrationSyncRequestMessage& from);
  RegistrationSyncRequestMessage(RegistrationSyncRequestMessage&& from) noexcept
    : RegistrationSyncRequestMessage() {
    *this = ::std::move(from);
  }

  inline RegistrationSyncRequestMessage& operator=(const RegistrationSyncRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistrationSyncRequestMessage& operator=(RegistrationSyncRequestMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RegistrationSyncRequestMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegistrationSyncRequestMessage* internal_default_instance() {
    return reinterpret_cast<const RegistrationSyncRequestMessage*>(
               &_RegistrationSyncRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(RegistrationSyncRequestMessage& a, RegistrationSyncRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistrationSyncRequestMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegistrationSyncRequestMessage* New() const final {
    return CreateMaybeMessage<RegistrationSyncRequestMessage>(nullptr);
  }

  RegistrationSyncRequestMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegistrationSyncRequestMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RegistrationSyncRequestMessage& from);
  void MergeFrom(const RegistrationSyncRequestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegistrationSyncRequestMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.RegistrationSyncRequestMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ipc.invalidation.RegistrationSyncRequestMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class InvalidationMessage :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.InvalidationMessage) */ {
 public:
  InvalidationMessage();
  virtual ~InvalidationMessage();

  InvalidationMessage(const InvalidationMessage& from);
  InvalidationMessage(InvalidationMessage&& from) noexcept
    : InvalidationMessage() {
    *this = ::std::move(from);
  }

  inline InvalidationMessage& operator=(const InvalidationMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvalidationMessage& operator=(InvalidationMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const InvalidationMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InvalidationMessage* internal_default_instance() {
    return reinterpret_cast<const InvalidationMessage*>(
               &_InvalidationMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(InvalidationMessage& a, InvalidationMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(InvalidationMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InvalidationMessage* New() const final {
    return CreateMaybeMessage<InvalidationMessage>(nullptr);
  }

  InvalidationMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InvalidationMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const InvalidationMessage& from);
  void MergeFrom(const InvalidationMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InvalidationMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.InvalidationMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInvalidationFieldNumber = 1,
  };
  // repeated .ipc.invalidation.InvalidationP invalidation = 1;
  int invalidation_size() const;
  void clear_invalidation();
  ::ipc::invalidation::InvalidationP* mutable_invalidation(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::InvalidationP >*
      mutable_invalidation();
  const ::ipc::invalidation::InvalidationP& invalidation(int index) const;
  ::ipc::invalidation::InvalidationP* add_invalidation();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::InvalidationP >&
      invalidation() const;

  // @@protoc_insertion_point(class_scope:ipc.invalidation.InvalidationMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::InvalidationP > invalidation_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class InfoRequestMessage :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.InfoRequestMessage) */ {
 public:
  InfoRequestMessage();
  virtual ~InfoRequestMessage();

  InfoRequestMessage(const InfoRequestMessage& from);
  InfoRequestMessage(InfoRequestMessage&& from) noexcept
    : InfoRequestMessage() {
    *this = ::std::move(from);
  }

  inline InfoRequestMessage& operator=(const InfoRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfoRequestMessage& operator=(InfoRequestMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const InfoRequestMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InfoRequestMessage* internal_default_instance() {
    return reinterpret_cast<const InfoRequestMessage*>(
               &_InfoRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(InfoRequestMessage& a, InfoRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(InfoRequestMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InfoRequestMessage* New() const final {
    return CreateMaybeMessage<InfoRequestMessage>(nullptr);
  }

  InfoRequestMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InfoRequestMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const InfoRequestMessage& from);
  void MergeFrom(const InfoRequestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InfoRequestMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.InfoRequestMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef InfoRequestMessage_InfoType InfoType;
  static constexpr InfoType GET_PERFORMANCE_COUNTERS =
    InfoRequestMessage_InfoType_GET_PERFORMANCE_COUNTERS;
  static inline bool InfoType_IsValid(int value) {
    return InfoRequestMessage_InfoType_IsValid(value);
  }
  static constexpr InfoType InfoType_MIN =
    InfoRequestMessage_InfoType_InfoType_MIN;
  static constexpr InfoType InfoType_MAX =
    InfoRequestMessage_InfoType_InfoType_MAX;
  static constexpr int InfoType_ARRAYSIZE =
    InfoRequestMessage_InfoType_InfoType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& InfoType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InfoType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InfoType_Name.");
    return InfoRequestMessage_InfoType_Name(enum_t_value);
  }
  static inline bool InfoType_Parse(const std::string& name,
      InfoType* value) {
    return InfoRequestMessage_InfoType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInfoTypeFieldNumber = 1,
  };
  // repeated .ipc.invalidation.InfoRequestMessage.InfoType info_type = 1;
  int info_type_size() const;
  void clear_info_type();
  ::ipc::invalidation::InfoRequestMessage_InfoType info_type(int index) const;
  void set_info_type(int index, ::ipc::invalidation::InfoRequestMessage_InfoType value);
  void add_info_type(::ipc::invalidation::InfoRequestMessage_InfoType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& info_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_info_type();

  // @@protoc_insertion_point(class_scope:ipc.invalidation.InfoRequestMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> info_type_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class RateLimitP :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.RateLimitP) */ {
 public:
  RateLimitP();
  virtual ~RateLimitP();

  RateLimitP(const RateLimitP& from);
  RateLimitP(RateLimitP&& from) noexcept
    : RateLimitP() {
    *this = ::std::move(from);
  }

  inline RateLimitP& operator=(const RateLimitP& from) {
    CopyFrom(from);
    return *this;
  }
  inline RateLimitP& operator=(RateLimitP&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RateLimitP& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RateLimitP* internal_default_instance() {
    return reinterpret_cast<const RateLimitP*>(
               &_RateLimitP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(RateLimitP& a, RateLimitP& b) {
    a.Swap(&b);
  }
  inline void Swap(RateLimitP* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RateLimitP* New() const final {
    return CreateMaybeMessage<RateLimitP>(nullptr);
  }

  RateLimitP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RateLimitP>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RateLimitP& from);
  void MergeFrom(const RateLimitP& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RateLimitP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.RateLimitP";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWindowMsFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // optional int32 window_ms = 1;
  bool has_window_ms() const;
  void clear_window_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 window_ms() const;
  void set_window_ms(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 count = 2;
  bool has_count() const;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::int32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.RateLimitP)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 window_ms_;
  ::PROTOBUF_NAMESPACE_ID::int32 count_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class ProtocolHandlerConfigP :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.ProtocolHandlerConfigP) */ {
 public:
  ProtocolHandlerConfigP();
  virtual ~ProtocolHandlerConfigP();

  ProtocolHandlerConfigP(const ProtocolHandlerConfigP& from);
  ProtocolHandlerConfigP(ProtocolHandlerConfigP&& from) noexcept
    : ProtocolHandlerConfigP() {
    *this = ::std::move(from);
  }

  inline ProtocolHandlerConfigP& operator=(const ProtocolHandlerConfigP& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtocolHandlerConfigP& operator=(ProtocolHandlerConfigP&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ProtocolHandlerConfigP& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtocolHandlerConfigP* internal_default_instance() {
    return reinterpret_cast<const ProtocolHandlerConfigP*>(
               &_ProtocolHandlerConfigP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ProtocolHandlerConfigP& a, ProtocolHandlerConfigP& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtocolHandlerConfigP* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProtocolHandlerConfigP* New() const final {
    return CreateMaybeMessage<ProtocolHandlerConfigP>(nullptr);
  }

  ProtocolHandlerConfigP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProtocolHandlerConfigP>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ProtocolHandlerConfigP& from);
  void MergeFrom(const ProtocolHandlerConfigP& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProtocolHandlerConfigP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.ProtocolHandlerConfigP";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRateLimitFieldNumber = 2,
    kBatchingDelayMsFieldNumber = 1,
  };
  // repeated .ipc.invalidation.RateLimitP rate_limit = 2;
  int rate_limit_size() const;
  void clear_rate_limit();
  ::ipc::invalidation::RateLimitP* mutable_rate_limit(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::RateLimitP >*
      mutable_rate_limit();
  const ::ipc::invalidation::RateLimitP& rate_limit(int index) const;
  ::ipc::invalidation::RateLimitP* add_rate_limit();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::RateLimitP >&
      rate_limit() const;

  // optional int32 batching_delay_ms = 1 [default = 500];
  bool has_batching_delay_ms() const;
  void clear_batching_delay_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 batching_delay_ms() const;
  void set_batching_delay_ms(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.ProtocolHandlerConfigP)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::RateLimitP > rate_limit_;
  ::PROTOBUF_NAMESPACE_ID::int32 batching_delay_ms_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class ClientConfigP :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.ClientConfigP) */ {
 public:
  ClientConfigP();
  virtual ~ClientConfigP();

  ClientConfigP(const ClientConfigP& from);
  ClientConfigP(ClientConfigP&& from) noexcept
    : ClientConfigP() {
    *this = ::std::move(from);
  }

  inline ClientConfigP& operator=(const ClientConfigP& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientConfigP& operator=(ClientConfigP&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ClientConfigP& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientConfigP* internal_default_instance() {
    return reinterpret_cast<const ClientConfigP*>(
               &_ClientConfigP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ClientConfigP& a, ClientConfigP& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientConfigP* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientConfigP* New() const final {
    return CreateMaybeMessage<ClientConfigP>(nullptr);
  }

  ClientConfigP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientConfigP>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ClientConfigP& from);
  void MergeFrom(const ClientConfigP& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientConfigP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.ClientConfigP";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kProtocolHandlerConfigFieldNumber = 10,
    kIsTransientFieldNumber = 8,
    kChannelSupportsOfflineDeliveryFieldNumber = 11,
    kAllowSuppressionFieldNumber = 13,
    kNetworkTimeoutDelayMsFieldNumber = 2,
    kWriteRetryDelayMsFieldNumber = 3,
    kHeartbeatIntervalMsFieldNumber = 4,
    kPerfCounterDelayMsFieldNumber = 5,
    kMaxExponentialBackoffFactorFieldNumber = 6,
    kSmearPercentFieldNumber = 7,
    kInitialPersistentHeartbeatDelayMsFieldNumber = 9,
    kOfflineHeartbeatThresholdMsFieldNumber = 12,
  };
  // optional .ipc.invalidation.Version version = 1;
  bool has_version() const;
  void clear_version();
  const ::ipc::invalidation::Version& version() const;
  ::ipc::invalidation::Version* release_version();
  ::ipc::invalidation::Version* mutable_version();
  void set_allocated_version(::ipc::invalidation::Version* version);

  // optional .ipc.invalidation.ProtocolHandlerConfigP protocol_handler_config = 10;
  bool has_protocol_handler_config() const;
  void clear_protocol_handler_config();
  const ::ipc::invalidation::ProtocolHandlerConfigP& protocol_handler_config() const;
  ::ipc::invalidation::ProtocolHandlerConfigP* release_protocol_handler_config();
  ::ipc::invalidation::ProtocolHandlerConfigP* mutable_protocol_handler_config();
  void set_allocated_protocol_handler_config(::ipc::invalidation::ProtocolHandlerConfigP* protocol_handler_config);

  // optional bool is_transient = 8 [default = false];
  bool has_is_transient() const;
  void clear_is_transient();
  bool is_transient() const;
  void set_is_transient(bool value);

  // optional bool channel_supports_offline_delivery = 11 [default = false];
  bool has_channel_supports_offline_delivery() const;
  void clear_channel_supports_offline_delivery();
  bool channel_supports_offline_delivery() const;
  void set_channel_supports_offline_delivery(bool value);

  // optional bool allow_suppression = 13 [default = true];
  bool has_allow_suppression() const;
  void clear_allow_suppression();
  bool allow_suppression() const;
  void set_allow_suppression(bool value);

  // optional int32 network_timeout_delay_ms = 2 [default = 60000];
  bool has_network_timeout_delay_ms() const;
  void clear_network_timeout_delay_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 network_timeout_delay_ms() const;
  void set_network_timeout_delay_ms(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 write_retry_delay_ms = 3 [default = 10000];
  bool has_write_retry_delay_ms() const;
  void clear_write_retry_delay_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 write_retry_delay_ms() const;
  void set_write_retry_delay_ms(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 heartbeat_interval_ms = 4 [default = 1200000];
  bool has_heartbeat_interval_ms() const;
  void clear_heartbeat_interval_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 heartbeat_interval_ms() const;
  void set_heartbeat_interval_ms(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 perf_counter_delay_ms = 5 [default = 21600000];
  bool has_perf_counter_delay_ms() const;
  void clear_perf_counter_delay_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 perf_counter_delay_ms() const;
  void set_perf_counter_delay_ms(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 max_exponential_backoff_factor = 6 [default = 500];
  bool has_max_exponential_backoff_factor() const;
  void clear_max_exponential_backoff_factor();
  ::PROTOBUF_NAMESPACE_ID::int32 max_exponential_backoff_factor() const;
  void set_max_exponential_backoff_factor(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 smear_percent = 7 [default = 20];
  bool has_smear_percent() const;
  void clear_smear_percent();
  ::PROTOBUF_NAMESPACE_ID::int32 smear_percent() const;
  void set_smear_percent(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 initial_persistent_heartbeat_delay_ms = 9 [default = 2000];
  bool has_initial_persistent_heartbeat_delay_ms() const;
  void clear_initial_persistent_heartbeat_delay_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 initial_persistent_heartbeat_delay_ms() const;
  void set_initial_persistent_heartbeat_delay_ms(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 offline_heartbeat_threshold_ms = 12 [default = 60000];
  bool has_offline_heartbeat_threshold_ms() const;
  void clear_offline_heartbeat_threshold_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 offline_heartbeat_threshold_ms() const;
  void set_offline_heartbeat_threshold_ms(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.ClientConfigP)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ipc::invalidation::Version* version_;
  ::ipc::invalidation::ProtocolHandlerConfigP* protocol_handler_config_;
  bool is_transient_;
  bool channel_supports_offline_delivery_;
  bool allow_suppression_;
  ::PROTOBUF_NAMESPACE_ID::int32 network_timeout_delay_ms_;
  ::PROTOBUF_NAMESPACE_ID::int32 write_retry_delay_ms_;
  ::PROTOBUF_NAMESPACE_ID::int32 heartbeat_interval_ms_;
  ::PROTOBUF_NAMESPACE_ID::int32 perf_counter_delay_ms_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_exponential_backoff_factor_;
  ::PROTOBUF_NAMESPACE_ID::int32 smear_percent_;
  ::PROTOBUF_NAMESPACE_ID::int32 initial_persistent_heartbeat_delay_ms_;
  ::PROTOBUF_NAMESPACE_ID::int32 offline_heartbeat_threshold_ms_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class ConfigChangeMessage :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.ConfigChangeMessage) */ {
 public:
  ConfigChangeMessage();
  virtual ~ConfigChangeMessage();

  ConfigChangeMessage(const ConfigChangeMessage& from);
  ConfigChangeMessage(ConfigChangeMessage&& from) noexcept
    : ConfigChangeMessage() {
    *this = ::std::move(from);
  }

  inline ConfigChangeMessage& operator=(const ConfigChangeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigChangeMessage& operator=(ConfigChangeMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ConfigChangeMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConfigChangeMessage* internal_default_instance() {
    return reinterpret_cast<const ConfigChangeMessage*>(
               &_ConfigChangeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ConfigChangeMessage& a, ConfigChangeMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigChangeMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConfigChangeMessage* New() const final {
    return CreateMaybeMessage<ConfigChangeMessage>(nullptr);
  }

  ConfigChangeMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConfigChangeMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ConfigChangeMessage& from);
  void MergeFrom(const ConfigChangeMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConfigChangeMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.ConfigChangeMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNextMessageDelayMsFieldNumber = 1,
  };
  // optional int64 next_message_delay_ms = 1;
  bool has_next_message_delay_ms() const;
  void clear_next_message_delay_ms();
  ::PROTOBUF_NAMESPACE_ID::int64 next_message_delay_ms() const;
  void set_next_message_delay_ms(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.ConfigChangeMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 next_message_delay_ms_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class ErrorMessage :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ipc.invalidation.ErrorMessage) */ {
 public:
  ErrorMessage();
  virtual ~ErrorMessage();

  ErrorMessage(const ErrorMessage& from);
  ErrorMessage(ErrorMessage&& from) noexcept
    : ErrorMessage() {
    *this = ::std::move(from);
  }

  inline ErrorMessage& operator=(const ErrorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorMessage& operator=(ErrorMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ErrorMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ErrorMessage* internal_default_instance() {
    return reinterpret_cast<const ErrorMessage*>(
               &_ErrorMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ErrorMessage& a, ErrorMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ErrorMessage* New() const final {
    return CreateMaybeMessage<ErrorMessage>(nullptr);
  }

  ErrorMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ErrorMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ErrorMessage& from);
  void MergeFrom(const ErrorMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ErrorMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.invalidation.ErrorMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ErrorMessage_Code Code;
  static constexpr Code AUTH_FAILURE =
    ErrorMessage_Code_AUTH_FAILURE;
  static constexpr Code UNKNOWN_FAILURE =
    ErrorMessage_Code_UNKNOWN_FAILURE;
  static inline bool Code_IsValid(int value) {
    return ErrorMessage_Code_IsValid(value);
  }
  static constexpr Code Code_MIN =
    ErrorMessage_Code_Code_MIN;
  static constexpr Code Code_MAX =
    ErrorMessage_Code_Code_MAX;
  static constexpr int Code_ARRAYSIZE =
    ErrorMessage_Code_Code_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Code_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Code>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Code_Name.");
    return ErrorMessage_Code_Name(enum_t_value);
  }
  static inline bool Code_Parse(const std::string& name,
      Code* value) {
    return ErrorMessage_Code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // optional string description = 2;
  bool has_description() const;
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);

  // optional .ipc.invalidation.ErrorMessage.Code code = 1;
  bool has_code() const;
  void clear_code();
  ::ipc::invalidation::ErrorMessage_Code code() const;
  void set_code(::ipc::invalidation::ErrorMessage_Code value);

  // @@protoc_insertion_point(class_scope:ipc.invalidation.ErrorMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  int code_;
  friend struct ::TableStruct_client_5fprotocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Version

// optional int32 major_version = 1;
inline bool Version::has_major_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Version::clear_major_version() {
  major_version_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Version::major_version() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.Version.major_version)
  return major_version_;
}
inline void Version::set_major_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  major_version_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.Version.major_version)
}

// optional int32 minor_version = 2;
inline bool Version::has_minor_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Version::clear_minor_version() {
  minor_version_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Version::minor_version() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.Version.minor_version)
  return minor_version_;
}
inline void Version::set_minor_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  minor_version_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.Version.minor_version)
}

// -------------------------------------------------------------------

// ProtocolVersion

// optional .ipc.invalidation.Version version = 1;
inline bool ProtocolVersion::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtocolVersion::clear_version() {
  if (version_ != nullptr) version_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ipc::invalidation::Version& ProtocolVersion::version() const {
  const ::ipc::invalidation::Version* p = version_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ProtocolVersion.version)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::Version*>(
      &::ipc::invalidation::_Version_default_instance_);
}
inline ::ipc::invalidation::Version* ProtocolVersion::release_version() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ProtocolVersion.version)
  _has_bits_[0] &= ~0x00000001u;
  ::ipc::invalidation::Version* temp = version_;
  version_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::Version* ProtocolVersion::mutable_version() {
  _has_bits_[0] |= 0x00000001u;
  if (version_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::Version>(GetArenaNoVirtual());
    version_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ProtocolVersion.version)
  return version_;
}
inline void ProtocolVersion::set_allocated_version(::ipc::invalidation::Version* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete version_;
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ProtocolVersion.version)
}

// -------------------------------------------------------------------

// ClientVersion

// optional .ipc.invalidation.Version version = 1;
inline bool ClientVersion::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientVersion::clear_version() {
  if (version_ != nullptr) version_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ipc::invalidation::Version& ClientVersion::version() const {
  const ::ipc::invalidation::Version* p = version_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientVersion.version)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::Version*>(
      &::ipc::invalidation::_Version_default_instance_);
}
inline ::ipc::invalidation::Version* ClientVersion::release_version() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientVersion.version)
  _has_bits_[0] &= ~0x00000008u;
  ::ipc::invalidation::Version* temp = version_;
  version_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::Version* ClientVersion::mutable_version() {
  _has_bits_[0] |= 0x00000008u;
  if (version_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::Version>(GetArenaNoVirtual());
    version_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientVersion.version)
  return version_;
}
inline void ClientVersion::set_allocated_version(::ipc::invalidation::Version* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete version_;
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientVersion.version)
}

// optional string platform = 2;
inline bool ClientVersion::has_platform() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientVersion::clear_platform() {
  platform_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientVersion::platform() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientVersion.platform)
  return platform_.GetNoArena();
}
inline void ClientVersion::set_platform(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  platform_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientVersion.platform)
}
inline void ClientVersion::set_platform(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  platform_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.ClientVersion.platform)
}
inline void ClientVersion::set_platform(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  platform_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.ClientVersion.platform)
}
inline void ClientVersion::set_platform(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  platform_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ClientVersion.platform)
}
inline std::string* ClientVersion::mutable_platform() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientVersion.platform)
  return platform_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ClientVersion::release_platform() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientVersion.platform)
  if (!has_platform()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return platform_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ClientVersion::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  platform_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), platform);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientVersion.platform)
}

// optional string language = 3;
inline bool ClientVersion::has_language() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientVersion::clear_language() {
  language_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ClientVersion::language() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientVersion.language)
  return language_.GetNoArena();
}
inline void ClientVersion::set_language(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientVersion.language)
}
inline void ClientVersion::set_language(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  language_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.ClientVersion.language)
}
inline void ClientVersion::set_language(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.ClientVersion.language)
}
inline void ClientVersion::set_language(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ClientVersion.language)
}
inline std::string* ClientVersion::mutable_language() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientVersion.language)
  return language_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ClientVersion::release_language() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientVersion.language)
  if (!has_language()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return language_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ClientVersion::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  language_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientVersion.language)
}

// optional string application_info = 4;
inline bool ClientVersion::has_application_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientVersion::clear_application_info() {
  application_info_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ClientVersion::application_info() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientVersion.application_info)
  return application_info_.GetNoArena();
}
inline void ClientVersion::set_application_info(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  application_info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientVersion.application_info)
}
inline void ClientVersion::set_application_info(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  application_info_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.ClientVersion.application_info)
}
inline void ClientVersion::set_application_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  application_info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.ClientVersion.application_info)
}
inline void ClientVersion::set_application_info(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  application_info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ClientVersion.application_info)
}
inline std::string* ClientVersion::mutable_application_info() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientVersion.application_info)
  return application_info_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ClientVersion::release_application_info() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientVersion.application_info)
  if (!has_application_info()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return application_info_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ClientVersion::set_allocated_application_info(std::string* application_info) {
  if (application_info != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  application_info_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), application_info);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientVersion.application_info)
}

// -------------------------------------------------------------------

// StatusP

// optional .ipc.invalidation.StatusP.Code code = 1;
inline bool StatusP::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatusP::clear_code() {
  code_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::ipc::invalidation::StatusP_Code StatusP::code() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.StatusP.code)
  return static_cast< ::ipc::invalidation::StatusP_Code >(code_);
}
inline void StatusP::set_code(::ipc::invalidation::StatusP_Code value) {
  assert(::ipc::invalidation::StatusP_Code_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  code_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.StatusP.code)
}

// optional string description = 2;
inline bool StatusP::has_description() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatusP::clear_description() {
  description_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StatusP::description() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.StatusP.description)
  return description_.GetNoArena();
}
inline void StatusP::set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.StatusP.description)
}
inline void StatusP::set_description(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  description_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.StatusP.description)
}
inline void StatusP::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.StatusP.description)
}
inline void StatusP::set_description(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.StatusP.description)
}
inline std::string* StatusP::mutable_description() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.StatusP.description)
  return description_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StatusP::release_description() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.StatusP.description)
  if (!has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return description_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StatusP::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  description_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.StatusP.description)
}

// -------------------------------------------------------------------

// ObjectIdP

// optional int32 source = 1;
inline bool ObjectIdP::has_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectIdP::clear_source() {
  source_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ObjectIdP::source() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ObjectIdP.source)
  return source_;
}
inline void ObjectIdP::set_source(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  source_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ObjectIdP.source)
}

// optional bytes name = 2;
inline bool ObjectIdP::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectIdP::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ObjectIdP::name() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ObjectIdP.name)
  return name_.GetNoArena();
}
inline void ObjectIdP::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.ObjectIdP.name)
}
inline void ObjectIdP::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.ObjectIdP.name)
}
inline void ObjectIdP::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.ObjectIdP.name)
}
inline void ObjectIdP::set_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ObjectIdP.name)
}
inline std::string* ObjectIdP::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ObjectIdP.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ObjectIdP::release_name() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ObjectIdP.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ObjectIdP::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ObjectIdP.name)
}

// -------------------------------------------------------------------

// ApplicationClientIdP

// optional int32 client_type = 1;
inline bool ApplicationClientIdP::has_client_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplicationClientIdP::clear_client_type() {
  client_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ApplicationClientIdP::client_type() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ApplicationClientIdP.client_type)
  return client_type_;
}
inline void ApplicationClientIdP::set_client_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  client_type_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ApplicationClientIdP.client_type)
}

// optional bytes client_name = 2;
inline bool ApplicationClientIdP::has_client_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplicationClientIdP::clear_client_name() {
  client_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ApplicationClientIdP::client_name() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ApplicationClientIdP.client_name)
  return client_name_.GetNoArena();
}
inline void ApplicationClientIdP::set_client_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.ApplicationClientIdP.client_name)
}
inline void ApplicationClientIdP::set_client_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  client_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.ApplicationClientIdP.client_name)
}
inline void ApplicationClientIdP::set_client_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  client_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.ApplicationClientIdP.client_name)
}
inline void ApplicationClientIdP::set_client_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  client_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ApplicationClientIdP.client_name)
}
inline std::string* ApplicationClientIdP::mutable_client_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ApplicationClientIdP.client_name)
  return client_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ApplicationClientIdP::release_client_name() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ApplicationClientIdP.client_name)
  if (!has_client_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return client_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ApplicationClientIdP::set_allocated_client_name(std::string* client_name) {
  if (client_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_name);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ApplicationClientIdP.client_name)
}

// -------------------------------------------------------------------

// InvalidationP

// optional .ipc.invalidation.ObjectIdP object_id = 1;
inline bool InvalidationP::has_object_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvalidationP::clear_object_id() {
  if (object_id_ != nullptr) object_id_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ipc::invalidation::ObjectIdP& InvalidationP::object_id() const {
  const ::ipc::invalidation::ObjectIdP* p = object_id_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.object_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::ObjectIdP*>(
      &::ipc::invalidation::_ObjectIdP_default_instance_);
}
inline ::ipc::invalidation::ObjectIdP* InvalidationP::release_object_id() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.InvalidationP.object_id)
  _has_bits_[0] &= ~0x00000002u;
  ::ipc::invalidation::ObjectIdP* temp = object_id_;
  object_id_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::ObjectIdP* InvalidationP::mutable_object_id() {
  _has_bits_[0] |= 0x00000002u;
  if (object_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::ObjectIdP>(GetArenaNoVirtual());
    object_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.InvalidationP.object_id)
  return object_id_;
}
inline void InvalidationP::set_allocated_object_id(::ipc::invalidation::ObjectIdP* object_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete object_id_;
  }
  if (object_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      object_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  object_id_ = object_id;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InvalidationP.object_id)
}

// optional bool is_known_version = 2;
inline bool InvalidationP::has_is_known_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InvalidationP::clear_is_known_version() {
  is_known_version_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool InvalidationP::is_known_version() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.is_known_version)
  return is_known_version_;
}
inline void InvalidationP::set_is_known_version(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_known_version_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.InvalidationP.is_known_version)
}

// optional int64 version = 3;
inline bool InvalidationP::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvalidationP::clear_version() {
  version_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InvalidationP::version() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.version)
  return version_;
}
inline void InvalidationP::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  version_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.InvalidationP.version)
}

// optional bool is_trickle_restart = 6 [default = false];
inline bool InvalidationP::has_is_trickle_restart() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InvalidationP::clear_is_trickle_restart() {
  is_trickle_restart_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool InvalidationP::is_trickle_restart() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.is_trickle_restart)
  return is_trickle_restart_;
}
inline void InvalidationP::set_is_trickle_restart(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_trickle_restart_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.InvalidationP.is_trickle_restart)
}

// optional bytes payload = 4;
inline bool InvalidationP::has_payload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvalidationP::clear_payload() {
  payload_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InvalidationP::payload() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.payload)
  return payload_.GetNoArena();
}
inline void InvalidationP::set_payload(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.InvalidationP.payload)
}
inline void InvalidationP::set_payload(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  payload_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.InvalidationP.payload)
}
inline void InvalidationP::set_payload(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.InvalidationP.payload)
}
inline void InvalidationP::set_payload(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.InvalidationP.payload)
}
inline std::string* InvalidationP::mutable_payload() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.InvalidationP.payload)
  return payload_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InvalidationP::release_payload() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.InvalidationP.payload)
  if (!has_payload()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return payload_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InvalidationP::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  payload_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InvalidationP.payload)
}

// optional int64 bridge_arrival_time_ms_deprecated = 5 [deprecated = true];
inline bool InvalidationP::has_bridge_arrival_time_ms_deprecated() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InvalidationP::clear_bridge_arrival_time_ms_deprecated() {
  bridge_arrival_time_ms_deprecated_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InvalidationP::bridge_arrival_time_ms_deprecated() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.bridge_arrival_time_ms_deprecated)
  return bridge_arrival_time_ms_deprecated_;
}
inline void InvalidationP::set_bridge_arrival_time_ms_deprecated(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  bridge_arrival_time_ms_deprecated_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.InvalidationP.bridge_arrival_time_ms_deprecated)
}

// -------------------------------------------------------------------

// RegistrationP

// optional .ipc.invalidation.ObjectIdP object_id = 1;
inline bool RegistrationP::has_object_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegistrationP::clear_object_id() {
  if (object_id_ != nullptr) object_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ipc::invalidation::ObjectIdP& RegistrationP::object_id() const {
  const ::ipc::invalidation::ObjectIdP* p = object_id_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationP.object_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::ObjectIdP*>(
      &::ipc::invalidation::_ObjectIdP_default_instance_);
}
inline ::ipc::invalidation::ObjectIdP* RegistrationP::release_object_id() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.RegistrationP.object_id)
  _has_bits_[0] &= ~0x00000001u;
  ::ipc::invalidation::ObjectIdP* temp = object_id_;
  object_id_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::ObjectIdP* RegistrationP::mutable_object_id() {
  _has_bits_[0] |= 0x00000001u;
  if (object_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::ObjectIdP>(GetArenaNoVirtual());
    object_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationP.object_id)
  return object_id_;
}
inline void RegistrationP::set_allocated_object_id(::ipc::invalidation::ObjectIdP* object_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete object_id_;
  }
  if (object_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      object_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  object_id_ = object_id;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.RegistrationP.object_id)
}

// optional .ipc.invalidation.RegistrationP.OpType op_type = 2;
inline bool RegistrationP::has_op_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegistrationP::clear_op_type() {
  op_type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::ipc::invalidation::RegistrationP_OpType RegistrationP::op_type() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationP.op_type)
  return static_cast< ::ipc::invalidation::RegistrationP_OpType >(op_type_);
}
inline void RegistrationP::set_op_type(::ipc::invalidation::RegistrationP_OpType value) {
  assert(::ipc::invalidation::RegistrationP_OpType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  op_type_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.RegistrationP.op_type)
}

// -------------------------------------------------------------------

// RegistrationSummary

// optional int32 num_registrations = 1;
inline bool RegistrationSummary::has_num_registrations() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegistrationSummary::clear_num_registrations() {
  num_registrations_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RegistrationSummary::num_registrations() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationSummary.num_registrations)
  return num_registrations_;
}
inline void RegistrationSummary::set_num_registrations(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  num_registrations_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.RegistrationSummary.num_registrations)
}

// optional bytes registration_digest = 2;
inline bool RegistrationSummary::has_registration_digest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegistrationSummary::clear_registration_digest() {
  registration_digest_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegistrationSummary::registration_digest() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationSummary.registration_digest)
  return registration_digest_.GetNoArena();
}
inline void RegistrationSummary::set_registration_digest(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  registration_digest_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.RegistrationSummary.registration_digest)
}
inline void RegistrationSummary::set_registration_digest(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  registration_digest_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.RegistrationSummary.registration_digest)
}
inline void RegistrationSummary::set_registration_digest(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  registration_digest_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.RegistrationSummary.registration_digest)
}
inline void RegistrationSummary::set_registration_digest(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  registration_digest_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.RegistrationSummary.registration_digest)
}
inline std::string* RegistrationSummary::mutable_registration_digest() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationSummary.registration_digest)
  return registration_digest_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RegistrationSummary::release_registration_digest() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.RegistrationSummary.registration_digest)
  if (!has_registration_digest()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return registration_digest_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RegistrationSummary::set_allocated_registration_digest(std::string* registration_digest) {
  if (registration_digest != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  registration_digest_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), registration_digest);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.RegistrationSummary.registration_digest)
}

// -------------------------------------------------------------------

// ClientHeader

// optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
inline bool ClientHeader::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientHeader::clear_protocol_version() {
  if (protocol_version_ != nullptr) protocol_version_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ipc::invalidation::ProtocolVersion& ClientHeader::protocol_version() const {
  const ::ipc::invalidation::ProtocolVersion* p = protocol_version_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.protocol_version)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::ProtocolVersion*>(
      &::ipc::invalidation::_ProtocolVersion_default_instance_);
}
inline ::ipc::invalidation::ProtocolVersion* ClientHeader::release_protocol_version() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientHeader.protocol_version)
  _has_bits_[0] &= ~0x00000004u;
  ::ipc::invalidation::ProtocolVersion* temp = protocol_version_;
  protocol_version_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::ProtocolVersion* ClientHeader::mutable_protocol_version() {
  _has_bits_[0] |= 0x00000004u;
  if (protocol_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::ProtocolVersion>(GetArenaNoVirtual());
    protocol_version_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientHeader.protocol_version)
  return protocol_version_;
}
inline void ClientHeader::set_allocated_protocol_version(::ipc::invalidation::ProtocolVersion* protocol_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete protocol_version_;
  }
  if (protocol_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      protocol_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, protocol_version, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  protocol_version_ = protocol_version;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientHeader.protocol_version)
}

// optional bytes client_token = 2;
inline bool ClientHeader::has_client_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientHeader::clear_client_token() {
  client_token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientHeader::client_token() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.client_token)
  return client_token_.GetNoArena();
}
inline void ClientHeader::set_client_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientHeader.client_token)
}
inline void ClientHeader::set_client_token(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  client_token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.ClientHeader.client_token)
}
inline void ClientHeader::set_client_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  client_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.ClientHeader.client_token)
}
inline void ClientHeader::set_client_token(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  client_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ClientHeader.client_token)
}
inline std::string* ClientHeader::mutable_client_token() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientHeader.client_token)
  return client_token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ClientHeader::release_client_token() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientHeader.client_token)
  if (!has_client_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return client_token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ClientHeader::set_allocated_client_token(std::string* client_token) {
  if (client_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_token);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientHeader.client_token)
}

// optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
inline bool ClientHeader::has_registration_summary() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientHeader::clear_registration_summary() {
  if (registration_summary_ != nullptr) registration_summary_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ipc::invalidation::RegistrationSummary& ClientHeader::registration_summary() const {
  const ::ipc::invalidation::RegistrationSummary* p = registration_summary_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.registration_summary)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::RegistrationSummary*>(
      &::ipc::invalidation::_RegistrationSummary_default_instance_);
}
inline ::ipc::invalidation::RegistrationSummary* ClientHeader::release_registration_summary() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientHeader.registration_summary)
  _has_bits_[0] &= ~0x00000008u;
  ::ipc::invalidation::RegistrationSummary* temp = registration_summary_;
  registration_summary_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::RegistrationSummary* ClientHeader::mutable_registration_summary() {
  _has_bits_[0] |= 0x00000008u;
  if (registration_summary_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::RegistrationSummary>(GetArenaNoVirtual());
    registration_summary_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientHeader.registration_summary)
  return registration_summary_;
}
inline void ClientHeader::set_allocated_registration_summary(::ipc::invalidation::RegistrationSummary* registration_summary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete registration_summary_;
  }
  if (registration_summary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      registration_summary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, registration_summary, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  registration_summary_ = registration_summary;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientHeader.registration_summary)
}

// optional int64 client_time_ms = 4;
inline bool ClientHeader::has_client_time_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientHeader::clear_client_time_ms() {
  client_time_ms_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClientHeader::client_time_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.client_time_ms)
  return client_time_ms_;
}
inline void ClientHeader::set_client_time_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  client_time_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientHeader.client_time_ms)
}

// optional int64 max_known_server_time_ms = 5;
inline bool ClientHeader::has_max_known_server_time_ms() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientHeader::clear_max_known_server_time_ms() {
  max_known_server_time_ms_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClientHeader::max_known_server_time_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.max_known_server_time_ms)
  return max_known_server_time_ms_;
}
inline void ClientHeader::set_max_known_server_time_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  max_known_server_time_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientHeader.max_known_server_time_ms)
}

// optional string message_id = 6;
inline bool ClientHeader::has_message_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientHeader::clear_message_id() {
  message_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ClientHeader::message_id() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.message_id)
  return message_id_.GetNoArena();
}
inline void ClientHeader::set_message_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  message_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientHeader.message_id)
}
inline void ClientHeader::set_message_id(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  message_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.ClientHeader.message_id)
}
inline void ClientHeader::set_message_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  message_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.ClientHeader.message_id)
}
inline void ClientHeader::set_message_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  message_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ClientHeader.message_id)
}
inline std::string* ClientHeader::mutable_message_id() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientHeader.message_id)
  return message_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ClientHeader::release_message_id() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientHeader.message_id)
  if (!has_message_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return message_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ClientHeader::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message_id);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientHeader.message_id)
}

// optional int32 client_type = 7;
inline bool ClientHeader::has_client_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientHeader::clear_client_type() {
  client_type_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientHeader::client_type() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.client_type)
  return client_type_;
}
inline void ClientHeader::set_client_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  client_type_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientHeader.client_type)
}

// -------------------------------------------------------------------

// ClientToServerMessage

// optional .ipc.invalidation.ClientHeader header = 1;
inline bool ClientToServerMessage::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientToServerMessage::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ipc::invalidation::ClientHeader& ClientToServerMessage::header() const {
  const ::ipc::invalidation::ClientHeader* p = header_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::ClientHeader*>(
      &::ipc::invalidation::_ClientHeader_default_instance_);
}
inline ::ipc::invalidation::ClientHeader* ClientToServerMessage::release_header() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.header)
  _has_bits_[0] &= ~0x00000001u;
  ::ipc::invalidation::ClientHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::ClientHeader* ClientToServerMessage::mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::ClientHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.header)
  return header_;
}
inline void ClientToServerMessage::set_allocated_header(::ipc::invalidation::ClientHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.header)
}

// optional .ipc.invalidation.InitializeMessage initialize_message = 2;
inline bool ClientToServerMessage::has_initialize_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientToServerMessage::clear_initialize_message() {
  if (initialize_message_ != nullptr) initialize_message_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ipc::invalidation::InitializeMessage& ClientToServerMessage::initialize_message() const {
  const ::ipc::invalidation::InitializeMessage* p = initialize_message_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.initialize_message)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::InitializeMessage*>(
      &::ipc::invalidation::_InitializeMessage_default_instance_);
}
inline ::ipc::invalidation::InitializeMessage* ClientToServerMessage::release_initialize_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.initialize_message)
  _has_bits_[0] &= ~0x00000002u;
  ::ipc::invalidation::InitializeMessage* temp = initialize_message_;
  initialize_message_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::InitializeMessage* ClientToServerMessage::mutable_initialize_message() {
  _has_bits_[0] |= 0x00000002u;
  if (initialize_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::InitializeMessage>(GetArenaNoVirtual());
    initialize_message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.initialize_message)
  return initialize_message_;
}
inline void ClientToServerMessage::set_allocated_initialize_message(::ipc::invalidation::InitializeMessage* initialize_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete initialize_message_;
  }
  if (initialize_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      initialize_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initialize_message, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  initialize_message_ = initialize_message;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.initialize_message)
}

// optional .ipc.invalidation.RegistrationMessage registration_message = 3;
inline bool ClientToServerMessage::has_registration_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientToServerMessage::clear_registration_message() {
  if (registration_message_ != nullptr) registration_message_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ipc::invalidation::RegistrationMessage& ClientToServerMessage::registration_message() const {
  const ::ipc::invalidation::RegistrationMessage* p = registration_message_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.registration_message)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::RegistrationMessage*>(
      &::ipc::invalidation::_RegistrationMessage_default_instance_);
}
inline ::ipc::invalidation::RegistrationMessage* ClientToServerMessage::release_registration_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.registration_message)
  _has_bits_[0] &= ~0x00000004u;
  ::ipc::invalidation::RegistrationMessage* temp = registration_message_;
  registration_message_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::RegistrationMessage* ClientToServerMessage::mutable_registration_message() {
  _has_bits_[0] |= 0x00000004u;
  if (registration_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::RegistrationMessage>(GetArenaNoVirtual());
    registration_message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.registration_message)
  return registration_message_;
}
inline void ClientToServerMessage::set_allocated_registration_message(::ipc::invalidation::RegistrationMessage* registration_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete registration_message_;
  }
  if (registration_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      registration_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, registration_message, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  registration_message_ = registration_message;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.registration_message)
}

// optional .ipc.invalidation.RegistrationSyncMessage registration_sync_message = 4;
inline bool ClientToServerMessage::has_registration_sync_message() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientToServerMessage::clear_registration_sync_message() {
  if (registration_sync_message_ != nullptr) registration_sync_message_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ipc::invalidation::RegistrationSyncMessage& ClientToServerMessage::registration_sync_message() const {
  const ::ipc::invalidation::RegistrationSyncMessage* p = registration_sync_message_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.registration_sync_message)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::RegistrationSyncMessage*>(
      &::ipc::invalidation::_RegistrationSyncMessage_default_instance_);
}
inline ::ipc::invalidation::RegistrationSyncMessage* ClientToServerMessage::release_registration_sync_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.registration_sync_message)
  _has_bits_[0] &= ~0x00000008u;
  ::ipc::invalidation::RegistrationSyncMessage* temp = registration_sync_message_;
  registration_sync_message_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::RegistrationSyncMessage* ClientToServerMessage::mutable_registration_sync_message() {
  _has_bits_[0] |= 0x00000008u;
  if (registration_sync_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::RegistrationSyncMessage>(GetArenaNoVirtual());
    registration_sync_message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.registration_sync_message)
  return registration_sync_message_;
}
inline void ClientToServerMessage::set_allocated_registration_sync_message(::ipc::invalidation::RegistrationSyncMessage* registration_sync_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete registration_sync_message_;
  }
  if (registration_sync_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      registration_sync_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, registration_sync_message, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  registration_sync_message_ = registration_sync_message;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.registration_sync_message)
}

// optional .ipc.invalidation.InvalidationMessage invalidation_ack_message = 5;
inline bool ClientToServerMessage::has_invalidation_ack_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientToServerMessage::clear_invalidation_ack_message() {
  if (invalidation_ack_message_ != nullptr) invalidation_ack_message_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ipc::invalidation::InvalidationMessage& ClientToServerMessage::invalidation_ack_message() const {
  const ::ipc::invalidation::InvalidationMessage* p = invalidation_ack_message_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.invalidation_ack_message)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::InvalidationMessage*>(
      &::ipc::invalidation::_InvalidationMessage_default_instance_);
}
inline ::ipc::invalidation::InvalidationMessage* ClientToServerMessage::release_invalidation_ack_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.invalidation_ack_message)
  _has_bits_[0] &= ~0x00000010u;
  ::ipc::invalidation::InvalidationMessage* temp = invalidation_ack_message_;
  invalidation_ack_message_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::InvalidationMessage* ClientToServerMessage::mutable_invalidation_ack_message() {
  _has_bits_[0] |= 0x00000010u;
  if (invalidation_ack_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::InvalidationMessage>(GetArenaNoVirtual());
    invalidation_ack_message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.invalidation_ack_message)
  return invalidation_ack_message_;
}
inline void ClientToServerMessage::set_allocated_invalidation_ack_message(::ipc::invalidation::InvalidationMessage* invalidation_ack_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete invalidation_ack_message_;
  }
  if (invalidation_ack_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      invalidation_ack_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invalidation_ack_message, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  invalidation_ack_message_ = invalidation_ack_message;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.invalidation_ack_message)
}

// optional .ipc.invalidation.InfoMessage info_message = 6;
inline bool ClientToServerMessage::has_info_message() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientToServerMessage::clear_info_message() {
  if (info_message_ != nullptr) info_message_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::ipc::invalidation::InfoMessage& ClientToServerMessage::info_message() const {
  const ::ipc::invalidation::InfoMessage* p = info_message_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.info_message)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::InfoMessage*>(
      &::ipc::invalidation::_InfoMessage_default_instance_);
}
inline ::ipc::invalidation::InfoMessage* ClientToServerMessage::release_info_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.info_message)
  _has_bits_[0] &= ~0x00000020u;
  ::ipc::invalidation::InfoMessage* temp = info_message_;
  info_message_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::InfoMessage* ClientToServerMessage::mutable_info_message() {
  _has_bits_[0] |= 0x00000020u;
  if (info_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::InfoMessage>(GetArenaNoVirtual());
    info_message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.info_message)
  return info_message_;
}
inline void ClientToServerMessage::set_allocated_info_message(::ipc::invalidation::InfoMessage* info_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete info_message_;
  }
  if (info_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      info_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info_message, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  info_message_ = info_message;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.info_message)
}

// -------------------------------------------------------------------

// InitializeMessage

// optional int32 client_type = 1;
inline bool InitializeMessage::has_client_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InitializeMessage::clear_client_type() {
  client_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InitializeMessage::client_type() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InitializeMessage.client_type)
  return client_type_;
}
inline void InitializeMessage::set_client_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  client_type_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.InitializeMessage.client_type)
}

// optional bytes nonce = 2;
inline bool InitializeMessage::has_nonce() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitializeMessage::clear_nonce() {
  nonce_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InitializeMessage::nonce() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InitializeMessage.nonce)
  return nonce_.GetNoArena();
}
inline void InitializeMessage::set_nonce(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  nonce_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.InitializeMessage.nonce)
}
inline void InitializeMessage::set_nonce(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  nonce_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.InitializeMessage.nonce)
}
inline void InitializeMessage::set_nonce(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  nonce_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.InitializeMessage.nonce)
}
inline void InitializeMessage::set_nonce(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  nonce_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.InitializeMessage.nonce)
}
inline std::string* InitializeMessage::mutable_nonce() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.InitializeMessage.nonce)
  return nonce_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InitializeMessage::release_nonce() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.InitializeMessage.nonce)
  if (!has_nonce()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return nonce_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InitializeMessage::set_allocated_nonce(std::string* nonce) {
  if (nonce != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  nonce_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nonce);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InitializeMessage.nonce)
}

// optional .ipc.invalidation.ApplicationClientIdP application_client_id = 3;
inline bool InitializeMessage::has_application_client_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitializeMessage::clear_application_client_id() {
  if (application_client_id_ != nullptr) application_client_id_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ipc::invalidation::ApplicationClientIdP& InitializeMessage::application_client_id() const {
  const ::ipc::invalidation::ApplicationClientIdP* p = application_client_id_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.InitializeMessage.application_client_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::ApplicationClientIdP*>(
      &::ipc::invalidation::_ApplicationClientIdP_default_instance_);
}
inline ::ipc::invalidation::ApplicationClientIdP* InitializeMessage::release_application_client_id() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.InitializeMessage.application_client_id)
  _has_bits_[0] &= ~0x00000002u;
  ::ipc::invalidation::ApplicationClientIdP* temp = application_client_id_;
  application_client_id_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::ApplicationClientIdP* InitializeMessage::mutable_application_client_id() {
  _has_bits_[0] |= 0x00000002u;
  if (application_client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::ApplicationClientIdP>(GetArenaNoVirtual());
    application_client_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.InitializeMessage.application_client_id)
  return application_client_id_;
}
inline void InitializeMessage::set_allocated_application_client_id(::ipc::invalidation::ApplicationClientIdP* application_client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete application_client_id_;
  }
  if (application_client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      application_client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, application_client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  application_client_id_ = application_client_id;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InitializeMessage.application_client_id)
}

// optional .ipc.invalidation.InitializeMessage.DigestSerializationType digest_serialization_type = 4;
inline bool InitializeMessage::has_digest_serialization_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InitializeMessage::clear_digest_serialization_type() {
  digest_serialization_type_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::ipc::invalidation::InitializeMessage_DigestSerializationType InitializeMessage::digest_serialization_type() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InitializeMessage.digest_serialization_type)
  return static_cast< ::ipc::invalidation::InitializeMessage_DigestSerializationType >(digest_serialization_type_);
}
inline void InitializeMessage::set_digest_serialization_type(::ipc::invalidation::InitializeMessage_DigestSerializationType value) {
  assert(::ipc::invalidation::InitializeMessage_DigestSerializationType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  digest_serialization_type_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.InitializeMessage.digest_serialization_type)
}

// -------------------------------------------------------------------

// RegistrationMessage

// repeated .ipc.invalidation.RegistrationP registration = 1;
inline int RegistrationMessage::registration_size() const {
  return registration_.size();
}
inline void RegistrationMessage::clear_registration() {
  registration_.Clear();
}
inline ::ipc::invalidation::RegistrationP* RegistrationMessage::mutable_registration(int index) {
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationMessage.registration)
  return registration_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::RegistrationP >*
RegistrationMessage::mutable_registration() {
  // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.RegistrationMessage.registration)
  return &registration_;
}
inline const ::ipc::invalidation::RegistrationP& RegistrationMessage::registration(int index) const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationMessage.registration)
  return registration_.Get(index);
}
inline ::ipc::invalidation::RegistrationP* RegistrationMessage::add_registration() {
  // @@protoc_insertion_point(field_add:ipc.invalidation.RegistrationMessage.registration)
  return registration_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::RegistrationP >&
RegistrationMessage::registration() const {
  // @@protoc_insertion_point(field_list:ipc.invalidation.RegistrationMessage.registration)
  return registration_;
}

// -------------------------------------------------------------------

// RegistrationSyncMessage

// repeated .ipc.invalidation.RegistrationSubtree subtree = 1;
inline int RegistrationSyncMessage::subtree_size() const {
  return subtree_.size();
}
inline void RegistrationSyncMessage::clear_subtree() {
  subtree_.Clear();
}
inline ::ipc::invalidation::RegistrationSubtree* RegistrationSyncMessage::mutable_subtree(int index) {
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationSyncMessage.subtree)
  return subtree_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::RegistrationSubtree >*
RegistrationSyncMessage::mutable_subtree() {
  // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.RegistrationSyncMessage.subtree)
  return &subtree_;
}
inline const ::ipc::invalidation::RegistrationSubtree& RegistrationSyncMessage::subtree(int index) const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationSyncMessage.subtree)
  return subtree_.Get(index);
}
inline ::ipc::invalidation::RegistrationSubtree* RegistrationSyncMessage::add_subtree() {
  // @@protoc_insertion_point(field_add:ipc.invalidation.RegistrationSyncMessage.subtree)
  return subtree_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::RegistrationSubtree >&
RegistrationSyncMessage::subtree() const {
  // @@protoc_insertion_point(field_list:ipc.invalidation.RegistrationSyncMessage.subtree)
  return subtree_;
}

// -------------------------------------------------------------------

// RegistrationSubtree

// repeated .ipc.invalidation.ObjectIdP registered_object = 1;
inline int RegistrationSubtree::registered_object_size() const {
  return registered_object_.size();
}
inline void RegistrationSubtree::clear_registered_object() {
  registered_object_.Clear();
}
inline ::ipc::invalidation::ObjectIdP* RegistrationSubtree::mutable_registered_object(int index) {
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationSubtree.registered_object)
  return registered_object_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::ObjectIdP >*
RegistrationSubtree::mutable_registered_object() {
  // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.RegistrationSubtree.registered_object)
  return &registered_object_;
}
inline const ::ipc::invalidation::ObjectIdP& RegistrationSubtree::registered_object(int index) const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationSubtree.registered_object)
  return registered_object_.Get(index);
}
inline ::ipc::invalidation::ObjectIdP* RegistrationSubtree::add_registered_object() {
  // @@protoc_insertion_point(field_add:ipc.invalidation.RegistrationSubtree.registered_object)
  return registered_object_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::ObjectIdP >&
RegistrationSubtree::registered_object() const {
  // @@protoc_insertion_point(field_list:ipc.invalidation.RegistrationSubtree.registered_object)
  return registered_object_;
}

// -------------------------------------------------------------------

// InfoMessage

// optional .ipc.invalidation.ClientVersion client_version = 1;
inline bool InfoMessage::has_client_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InfoMessage::clear_client_version() {
  if (client_version_ != nullptr) client_version_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ipc::invalidation::ClientVersion& InfoMessage::client_version() const {
  const ::ipc::invalidation::ClientVersion* p = client_version_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.InfoMessage.client_version)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::ClientVersion*>(
      &::ipc::invalidation::_ClientVersion_default_instance_);
}
inline ::ipc::invalidation::ClientVersion* InfoMessage::release_client_version() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.InfoMessage.client_version)
  _has_bits_[0] &= ~0x00000001u;
  ::ipc::invalidation::ClientVersion* temp = client_version_;
  client_version_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::ClientVersion* InfoMessage::mutable_client_version() {
  _has_bits_[0] |= 0x00000001u;
  if (client_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::ClientVersion>(GetArenaNoVirtual());
    client_version_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.InfoMessage.client_version)
  return client_version_;
}
inline void InfoMessage::set_allocated_client_version(::ipc::invalidation::ClientVersion* client_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete client_version_;
  }
  if (client_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      client_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_version, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_version_ = client_version;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InfoMessage.client_version)
}

// repeated .ipc.invalidation.PropertyRecord config_parameter = 2;
inline int InfoMessage::config_parameter_size() const {
  return config_parameter_.size();
}
inline void InfoMessage::clear_config_parameter() {
  config_parameter_.Clear();
}
inline ::ipc::invalidation::PropertyRecord* InfoMessage::mutable_config_parameter(int index) {
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.InfoMessage.config_parameter)
  return config_parameter_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::PropertyRecord >*
InfoMessage::mutable_config_parameter() {
  // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.InfoMessage.config_parameter)
  return &config_parameter_;
}
inline const ::ipc::invalidation::PropertyRecord& InfoMessage::config_parameter(int index) const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InfoMessage.config_parameter)
  return config_parameter_.Get(index);
}
inline ::ipc::invalidation::PropertyRecord* InfoMessage::add_config_parameter() {
  // @@protoc_insertion_point(field_add:ipc.invalidation.InfoMessage.config_parameter)
  return config_parameter_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::PropertyRecord >&
InfoMessage::config_parameter() const {
  // @@protoc_insertion_point(field_list:ipc.invalidation.InfoMessage.config_parameter)
  return config_parameter_;
}

// repeated .ipc.invalidation.PropertyRecord performance_counter = 3;
inline int InfoMessage::performance_counter_size() const {
  return performance_counter_.size();
}
inline void InfoMessage::clear_performance_counter() {
  performance_counter_.Clear();
}
inline ::ipc::invalidation::PropertyRecord* InfoMessage::mutable_performance_counter(int index) {
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.InfoMessage.performance_counter)
  return performance_counter_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::PropertyRecord >*
InfoMessage::mutable_performance_counter() {
  // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.InfoMessage.performance_counter)
  return &performance_counter_;
}
inline const ::ipc::invalidation::PropertyRecord& InfoMessage::performance_counter(int index) const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InfoMessage.performance_counter)
  return performance_counter_.Get(index);
}
inline ::ipc::invalidation::PropertyRecord* InfoMessage::add_performance_counter() {
  // @@protoc_insertion_point(field_add:ipc.invalidation.InfoMessage.performance_counter)
  return performance_counter_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::PropertyRecord >&
InfoMessage::performance_counter() const {
  // @@protoc_insertion_point(field_list:ipc.invalidation.InfoMessage.performance_counter)
  return performance_counter_;
}

// optional bool server_registration_summary_requested = 4;
inline bool InfoMessage::has_server_registration_summary_requested() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InfoMessage::clear_server_registration_summary_requested() {
  server_registration_summary_requested_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool InfoMessage::server_registration_summary_requested() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InfoMessage.server_registration_summary_requested)
  return server_registration_summary_requested_;
}
inline void InfoMessage::set_server_registration_summary_requested(bool value) {
  _has_bits_[0] |= 0x00000004u;
  server_registration_summary_requested_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.InfoMessage.server_registration_summary_requested)
}

// optional .ipc.invalidation.ClientConfigP client_config = 5;
inline bool InfoMessage::has_client_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InfoMessage::clear_client_config() {
  if (client_config_ != nullptr) client_config_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ipc::invalidation::ClientConfigP& InfoMessage::client_config() const {
  const ::ipc::invalidation::ClientConfigP* p = client_config_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.InfoMessage.client_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::ClientConfigP*>(
      &::ipc::invalidation::_ClientConfigP_default_instance_);
}
inline ::ipc::invalidation::ClientConfigP* InfoMessage::release_client_config() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.InfoMessage.client_config)
  _has_bits_[0] &= ~0x00000002u;
  ::ipc::invalidation::ClientConfigP* temp = client_config_;
  client_config_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::ClientConfigP* InfoMessage::mutable_client_config() {
  _has_bits_[0] |= 0x00000002u;
  if (client_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::ClientConfigP>(GetArenaNoVirtual());
    client_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.InfoMessage.client_config)
  return client_config_;
}
inline void InfoMessage::set_allocated_client_config(::ipc::invalidation::ClientConfigP* client_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete client_config_;
  }
  if (client_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      client_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  client_config_ = client_config;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InfoMessage.client_config)
}

// -------------------------------------------------------------------

// PropertyRecord

// optional string name = 1;
inline bool PropertyRecord::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PropertyRecord::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PropertyRecord::name() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.PropertyRecord.name)
  return name_.GetNoArena();
}
inline void PropertyRecord::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.PropertyRecord.name)
}
inline void PropertyRecord::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.PropertyRecord.name)
}
inline void PropertyRecord::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.PropertyRecord.name)
}
inline void PropertyRecord::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.PropertyRecord.name)
}
inline std::string* PropertyRecord::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.PropertyRecord.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PropertyRecord::release_name() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.PropertyRecord.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PropertyRecord::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.PropertyRecord.name)
}

// optional int32 value = 2;
inline bool PropertyRecord::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PropertyRecord::clear_value() {
  value_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PropertyRecord::value() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.PropertyRecord.value)
  return value_;
}
inline void PropertyRecord::set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  value_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.PropertyRecord.value)
}

// -------------------------------------------------------------------

// ServerHeader

// optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
inline bool ServerHeader::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerHeader::clear_protocol_version() {
  if (protocol_version_ != nullptr) protocol_version_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ipc::invalidation::ProtocolVersion& ServerHeader::protocol_version() const {
  const ::ipc::invalidation::ProtocolVersion* p = protocol_version_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerHeader.protocol_version)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::ProtocolVersion*>(
      &::ipc::invalidation::_ProtocolVersion_default_instance_);
}
inline ::ipc::invalidation::ProtocolVersion* ServerHeader::release_protocol_version() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerHeader.protocol_version)
  _has_bits_[0] &= ~0x00000004u;
  ::ipc::invalidation::ProtocolVersion* temp = protocol_version_;
  protocol_version_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::ProtocolVersion* ServerHeader::mutable_protocol_version() {
  _has_bits_[0] |= 0x00000004u;
  if (protocol_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::ProtocolVersion>(GetArenaNoVirtual());
    protocol_version_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerHeader.protocol_version)
  return protocol_version_;
}
inline void ServerHeader::set_allocated_protocol_version(::ipc::invalidation::ProtocolVersion* protocol_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete protocol_version_;
  }
  if (protocol_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      protocol_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, protocol_version, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  protocol_version_ = protocol_version;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerHeader.protocol_version)
}

// optional bytes client_token = 2;
inline bool ServerHeader::has_client_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerHeader::clear_client_token() {
  client_token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServerHeader::client_token() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerHeader.client_token)
  return client_token_.GetNoArena();
}
inline void ServerHeader::set_client_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.ServerHeader.client_token)
}
inline void ServerHeader::set_client_token(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  client_token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.ServerHeader.client_token)
}
inline void ServerHeader::set_client_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  client_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.ServerHeader.client_token)
}
inline void ServerHeader::set_client_token(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  client_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ServerHeader.client_token)
}
inline std::string* ServerHeader::mutable_client_token() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerHeader.client_token)
  return client_token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ServerHeader::release_client_token() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerHeader.client_token)
  if (!has_client_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return client_token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ServerHeader::set_allocated_client_token(std::string* client_token) {
  if (client_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_token);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerHeader.client_token)
}

// optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
inline bool ServerHeader::has_registration_summary() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerHeader::clear_registration_summary() {
  if (registration_summary_ != nullptr) registration_summary_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ipc::invalidation::RegistrationSummary& ServerHeader::registration_summary() const {
  const ::ipc::invalidation::RegistrationSummary* p = registration_summary_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerHeader.registration_summary)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::RegistrationSummary*>(
      &::ipc::invalidation::_RegistrationSummary_default_instance_);
}
inline ::ipc::invalidation::RegistrationSummary* ServerHeader::release_registration_summary() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerHeader.registration_summary)
  _has_bits_[0] &= ~0x00000008u;
  ::ipc::invalidation::RegistrationSummary* temp = registration_summary_;
  registration_summary_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::RegistrationSummary* ServerHeader::mutable_registration_summary() {
  _has_bits_[0] |= 0x00000008u;
  if (registration_summary_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::RegistrationSummary>(GetArenaNoVirtual());
    registration_summary_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerHeader.registration_summary)
  return registration_summary_;
}
inline void ServerHeader::set_allocated_registration_summary(::ipc::invalidation::RegistrationSummary* registration_summary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete registration_summary_;
  }
  if (registration_summary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      registration_summary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, registration_summary, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  registration_summary_ = registration_summary;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerHeader.registration_summary)
}

// optional int64 server_time_ms = 4;
inline bool ServerHeader::has_server_time_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerHeader::clear_server_time_ms() {
  server_time_ms_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ServerHeader::server_time_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerHeader.server_time_ms)
  return server_time_ms_;
}
inline void ServerHeader::set_server_time_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  server_time_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ServerHeader.server_time_ms)
}

// optional string message_id = 5;
inline bool ServerHeader::has_message_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerHeader::clear_message_id() {
  message_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ServerHeader::message_id() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerHeader.message_id)
  return message_id_.GetNoArena();
}
inline void ServerHeader::set_message_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  message_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.ServerHeader.message_id)
}
inline void ServerHeader::set_message_id(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  message_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.ServerHeader.message_id)
}
inline void ServerHeader::set_message_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  message_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.ServerHeader.message_id)
}
inline void ServerHeader::set_message_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  message_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ServerHeader.message_id)
}
inline std::string* ServerHeader::mutable_message_id() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerHeader.message_id)
  return message_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ServerHeader::release_message_id() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerHeader.message_id)
  if (!has_message_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return message_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ServerHeader::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message_id);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerHeader.message_id)
}

// -------------------------------------------------------------------

// ServerToClientMessage

// optional .ipc.invalidation.ServerHeader header = 1;
inline bool ServerToClientMessage::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerToClientMessage::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ipc::invalidation::ServerHeader& ServerToClientMessage::header() const {
  const ::ipc::invalidation::ServerHeader* p = header_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::ServerHeader*>(
      &::ipc::invalidation::_ServerHeader_default_instance_);
}
inline ::ipc::invalidation::ServerHeader* ServerToClientMessage::release_header() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.header)
  _has_bits_[0] &= ~0x00000001u;
  ::ipc::invalidation::ServerHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::ServerHeader* ServerToClientMessage::mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::ServerHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.header)
  return header_;
}
inline void ServerToClientMessage::set_allocated_header(::ipc::invalidation::ServerHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.header)
}

// optional .ipc.invalidation.TokenControlMessage token_control_message = 2;
inline bool ServerToClientMessage::has_token_control_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerToClientMessage::clear_token_control_message() {
  if (token_control_message_ != nullptr) token_control_message_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ipc::invalidation::TokenControlMessage& ServerToClientMessage::token_control_message() const {
  const ::ipc::invalidation::TokenControlMessage* p = token_control_message_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.token_control_message)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::TokenControlMessage*>(
      &::ipc::invalidation::_TokenControlMessage_default_instance_);
}
inline ::ipc::invalidation::TokenControlMessage* ServerToClientMessage::release_token_control_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.token_control_message)
  _has_bits_[0] &= ~0x00000002u;
  ::ipc::invalidation::TokenControlMessage* temp = token_control_message_;
  token_control_message_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::TokenControlMessage* ServerToClientMessage::mutable_token_control_message() {
  _has_bits_[0] |= 0x00000002u;
  if (token_control_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::TokenControlMessage>(GetArenaNoVirtual());
    token_control_message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.token_control_message)
  return token_control_message_;
}
inline void ServerToClientMessage::set_allocated_token_control_message(::ipc::invalidation::TokenControlMessage* token_control_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete token_control_message_;
  }
  if (token_control_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      token_control_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token_control_message, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  token_control_message_ = token_control_message;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.token_control_message)
}

// optional .ipc.invalidation.InvalidationMessage invalidation_message = 3;
inline bool ServerToClientMessage::has_invalidation_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerToClientMessage::clear_invalidation_message() {
  if (invalidation_message_ != nullptr) invalidation_message_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ipc::invalidation::InvalidationMessage& ServerToClientMessage::invalidation_message() const {
  const ::ipc::invalidation::InvalidationMessage* p = invalidation_message_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.invalidation_message)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::InvalidationMessage*>(
      &::ipc::invalidation::_InvalidationMessage_default_instance_);
}
inline ::ipc::invalidation::InvalidationMessage* ServerToClientMessage::release_invalidation_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.invalidation_message)
  _has_bits_[0] &= ~0x00000004u;
  ::ipc::invalidation::InvalidationMessage* temp = invalidation_message_;
  invalidation_message_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::InvalidationMessage* ServerToClientMessage::mutable_invalidation_message() {
  _has_bits_[0] |= 0x00000004u;
  if (invalidation_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::InvalidationMessage>(GetArenaNoVirtual());
    invalidation_message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.invalidation_message)
  return invalidation_message_;
}
inline void ServerToClientMessage::set_allocated_invalidation_message(::ipc::invalidation::InvalidationMessage* invalidation_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete invalidation_message_;
  }
  if (invalidation_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      invalidation_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invalidation_message, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  invalidation_message_ = invalidation_message;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.invalidation_message)
}

// optional .ipc.invalidation.RegistrationStatusMessage registration_status_message = 4;
inline bool ServerToClientMessage::has_registration_status_message() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerToClientMessage::clear_registration_status_message() {
  if (registration_status_message_ != nullptr) registration_status_message_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ipc::invalidation::RegistrationStatusMessage& ServerToClientMessage::registration_status_message() const {
  const ::ipc::invalidation::RegistrationStatusMessage* p = registration_status_message_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.registration_status_message)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::RegistrationStatusMessage*>(
      &::ipc::invalidation::_RegistrationStatusMessage_default_instance_);
}
inline ::ipc::invalidation::RegistrationStatusMessage* ServerToClientMessage::release_registration_status_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.registration_status_message)
  _has_bits_[0] &= ~0x00000008u;
  ::ipc::invalidation::RegistrationStatusMessage* temp = registration_status_message_;
  registration_status_message_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::RegistrationStatusMessage* ServerToClientMessage::mutable_registration_status_message() {
  _has_bits_[0] |= 0x00000008u;
  if (registration_status_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::RegistrationStatusMessage>(GetArenaNoVirtual());
    registration_status_message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.registration_status_message)
  return registration_status_message_;
}
inline void ServerToClientMessage::set_allocated_registration_status_message(::ipc::invalidation::RegistrationStatusMessage* registration_status_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete registration_status_message_;
  }
  if (registration_status_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      registration_status_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, registration_status_message, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  registration_status_message_ = registration_status_message;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.registration_status_message)
}

// optional .ipc.invalidation.RegistrationSyncRequestMessage registration_sync_request_message = 5;
inline bool ServerToClientMessage::has_registration_sync_request_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerToClientMessage::clear_registration_sync_request_message() {
  if (registration_sync_request_message_ != nullptr) registration_sync_request_message_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ipc::invalidation::RegistrationSyncRequestMessage& ServerToClientMessage::registration_sync_request_message() const {
  const ::ipc::invalidation::RegistrationSyncRequestMessage* p = registration_sync_request_message_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.registration_sync_request_message)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::RegistrationSyncRequestMessage*>(
      &::ipc::invalidation::_RegistrationSyncRequestMessage_default_instance_);
}
inline ::ipc::invalidation::RegistrationSyncRequestMessage* ServerToClientMessage::release_registration_sync_request_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.registration_sync_request_message)
  _has_bits_[0] &= ~0x00000010u;
  ::ipc::invalidation::RegistrationSyncRequestMessage* temp = registration_sync_request_message_;
  registration_sync_request_message_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::RegistrationSyncRequestMessage* ServerToClientMessage::mutable_registration_sync_request_message() {
  _has_bits_[0] |= 0x00000010u;
  if (registration_sync_request_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::RegistrationSyncRequestMessage>(GetArenaNoVirtual());
    registration_sync_request_message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.registration_sync_request_message)
  return registration_sync_request_message_;
}
inline void ServerToClientMessage::set_allocated_registration_sync_request_message(::ipc::invalidation::RegistrationSyncRequestMessage* registration_sync_request_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete registration_sync_request_message_;
  }
  if (registration_sync_request_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      registration_sync_request_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, registration_sync_request_message, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  registration_sync_request_message_ = registration_sync_request_message;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.registration_sync_request_message)
}

// optional .ipc.invalidation.ConfigChangeMessage config_change_message = 6;
inline bool ServerToClientMessage::has_config_change_message() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerToClientMessage::clear_config_change_message() {
  if (config_change_message_ != nullptr) config_change_message_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::ipc::invalidation::ConfigChangeMessage& ServerToClientMessage::config_change_message() const {
  const ::ipc::invalidation::ConfigChangeMessage* p = config_change_message_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.config_change_message)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::ConfigChangeMessage*>(
      &::ipc::invalidation::_ConfigChangeMessage_default_instance_);
}
inline ::ipc::invalidation::ConfigChangeMessage* ServerToClientMessage::release_config_change_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.config_change_message)
  _has_bits_[0] &= ~0x00000020u;
  ::ipc::invalidation::ConfigChangeMessage* temp = config_change_message_;
  config_change_message_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::ConfigChangeMessage* ServerToClientMessage::mutable_config_change_message() {
  _has_bits_[0] |= 0x00000020u;
  if (config_change_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::ConfigChangeMessage>(GetArenaNoVirtual());
    config_change_message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.config_change_message)
  return config_change_message_;
}
inline void ServerToClientMessage::set_allocated_config_change_message(::ipc::invalidation::ConfigChangeMessage* config_change_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete config_change_message_;
  }
  if (config_change_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      config_change_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config_change_message, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  config_change_message_ = config_change_message;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.config_change_message)
}

// optional .ipc.invalidation.InfoRequestMessage info_request_message = 7;
inline bool ServerToClientMessage::has_info_request_message() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ServerToClientMessage::clear_info_request_message() {
  if (info_request_message_ != nullptr) info_request_message_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::ipc::invalidation::InfoRequestMessage& ServerToClientMessage::info_request_message() const {
  const ::ipc::invalidation::InfoRequestMessage* p = info_request_message_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.info_request_message)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::InfoRequestMessage*>(
      &::ipc::invalidation::_InfoRequestMessage_default_instance_);
}
inline ::ipc::invalidation::InfoRequestMessage* ServerToClientMessage::release_info_request_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.info_request_message)
  _has_bits_[0] &= ~0x00000040u;
  ::ipc::invalidation::InfoRequestMessage* temp = info_request_message_;
  info_request_message_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::InfoRequestMessage* ServerToClientMessage::mutable_info_request_message() {
  _has_bits_[0] |= 0x00000040u;
  if (info_request_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::InfoRequestMessage>(GetArenaNoVirtual());
    info_request_message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.info_request_message)
  return info_request_message_;
}
inline void ServerToClientMessage::set_allocated_info_request_message(::ipc::invalidation::InfoRequestMessage* info_request_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete info_request_message_;
  }
  if (info_request_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      info_request_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info_request_message, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  info_request_message_ = info_request_message;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.info_request_message)
}

// optional .ipc.invalidation.ErrorMessage error_message = 8;
inline bool ServerToClientMessage::has_error_message() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ServerToClientMessage::clear_error_message() {
  if (error_message_ != nullptr) error_message_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::ipc::invalidation::ErrorMessage& ServerToClientMessage::error_message() const {
  const ::ipc::invalidation::ErrorMessage* p = error_message_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.error_message)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::ErrorMessage*>(
      &::ipc::invalidation::_ErrorMessage_default_instance_);
}
inline ::ipc::invalidation::ErrorMessage* ServerToClientMessage::release_error_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.error_message)
  _has_bits_[0] &= ~0x00000080u;
  ::ipc::invalidation::ErrorMessage* temp = error_message_;
  error_message_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::ErrorMessage* ServerToClientMessage::mutable_error_message() {
  _has_bits_[0] |= 0x00000080u;
  if (error_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::ErrorMessage>(GetArenaNoVirtual());
    error_message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.error_message)
  return error_message_;
}
inline void ServerToClientMessage::set_allocated_error_message(::ipc::invalidation::ErrorMessage* error_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete error_message_;
  }
  if (error_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      error_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error_message, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  error_message_ = error_message;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.error_message)
}

// -------------------------------------------------------------------

// TokenControlMessage

// optional bytes new_token = 1;
inline bool TokenControlMessage::has_new_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TokenControlMessage::clear_new_token() {
  new_token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TokenControlMessage::new_token() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.TokenControlMessage.new_token)
  return new_token_.GetNoArena();
}
inline void TokenControlMessage::set_new_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  new_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.TokenControlMessage.new_token)
}
inline void TokenControlMessage::set_new_token(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  new_token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.TokenControlMessage.new_token)
}
inline void TokenControlMessage::set_new_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  new_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.TokenControlMessage.new_token)
}
inline void TokenControlMessage::set_new_token(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  new_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.TokenControlMessage.new_token)
}
inline std::string* TokenControlMessage::mutable_new_token() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.TokenControlMessage.new_token)
  return new_token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TokenControlMessage::release_new_token() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.TokenControlMessage.new_token)
  if (!has_new_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return new_token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TokenControlMessage::set_allocated_new_token(std::string* new_token) {
  if (new_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  new_token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_token);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.TokenControlMessage.new_token)
}

// -------------------------------------------------------------------

// RegistrationStatus

// optional .ipc.invalidation.RegistrationP registration = 1;
inline bool RegistrationStatus::has_registration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegistrationStatus::clear_registration() {
  if (registration_ != nullptr) registration_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ipc::invalidation::RegistrationP& RegistrationStatus::registration() const {
  const ::ipc::invalidation::RegistrationP* p = registration_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationStatus.registration)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::RegistrationP*>(
      &::ipc::invalidation::_RegistrationP_default_instance_);
}
inline ::ipc::invalidation::RegistrationP* RegistrationStatus::release_registration() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.RegistrationStatus.registration)
  _has_bits_[0] &= ~0x00000001u;
  ::ipc::invalidation::RegistrationP* temp = registration_;
  registration_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::RegistrationP* RegistrationStatus::mutable_registration() {
  _has_bits_[0] |= 0x00000001u;
  if (registration_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::RegistrationP>(GetArenaNoVirtual());
    registration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationStatus.registration)
  return registration_;
}
inline void RegistrationStatus::set_allocated_registration(::ipc::invalidation::RegistrationP* registration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete registration_;
  }
  if (registration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      registration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, registration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  registration_ = registration;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.RegistrationStatus.registration)
}

// optional .ipc.invalidation.StatusP status = 2;
inline bool RegistrationStatus::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegistrationStatus::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ipc::invalidation::StatusP& RegistrationStatus::status() const {
  const ::ipc::invalidation::StatusP* p = status_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationStatus.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::StatusP*>(
      &::ipc::invalidation::_StatusP_default_instance_);
}
inline ::ipc::invalidation::StatusP* RegistrationStatus::release_status() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.RegistrationStatus.status)
  _has_bits_[0] &= ~0x00000002u;
  ::ipc::invalidation::StatusP* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::StatusP* RegistrationStatus::mutable_status() {
  _has_bits_[0] |= 0x00000002u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::StatusP>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationStatus.status)
  return status_;
}
inline void RegistrationStatus::set_allocated_status(::ipc::invalidation::StatusP* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.RegistrationStatus.status)
}

// -------------------------------------------------------------------

// RegistrationStatusMessage

// repeated .ipc.invalidation.RegistrationStatus registration_status = 1;
inline int RegistrationStatusMessage::registration_status_size() const {
  return registration_status_.size();
}
inline void RegistrationStatusMessage::clear_registration_status() {
  registration_status_.Clear();
}
inline ::ipc::invalidation::RegistrationStatus* RegistrationStatusMessage::mutable_registration_status(int index) {
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationStatusMessage.registration_status)
  return registration_status_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::RegistrationStatus >*
RegistrationStatusMessage::mutable_registration_status() {
  // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.RegistrationStatusMessage.registration_status)
  return &registration_status_;
}
inline const ::ipc::invalidation::RegistrationStatus& RegistrationStatusMessage::registration_status(int index) const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationStatusMessage.registration_status)
  return registration_status_.Get(index);
}
inline ::ipc::invalidation::RegistrationStatus* RegistrationStatusMessage::add_registration_status() {
  // @@protoc_insertion_point(field_add:ipc.invalidation.RegistrationStatusMessage.registration_status)
  return registration_status_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::RegistrationStatus >&
RegistrationStatusMessage::registration_status() const {
  // @@protoc_insertion_point(field_list:ipc.invalidation.RegistrationStatusMessage.registration_status)
  return registration_status_;
}

// -------------------------------------------------------------------

// RegistrationSyncRequestMessage

// -------------------------------------------------------------------

// InvalidationMessage

// repeated .ipc.invalidation.InvalidationP invalidation = 1;
inline int InvalidationMessage::invalidation_size() const {
  return invalidation_.size();
}
inline void InvalidationMessage::clear_invalidation() {
  invalidation_.Clear();
}
inline ::ipc::invalidation::InvalidationP* InvalidationMessage::mutable_invalidation(int index) {
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.InvalidationMessage.invalidation)
  return invalidation_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::InvalidationP >*
InvalidationMessage::mutable_invalidation() {
  // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.InvalidationMessage.invalidation)
  return &invalidation_;
}
inline const ::ipc::invalidation::InvalidationP& InvalidationMessage::invalidation(int index) const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationMessage.invalidation)
  return invalidation_.Get(index);
}
inline ::ipc::invalidation::InvalidationP* InvalidationMessage::add_invalidation() {
  // @@protoc_insertion_point(field_add:ipc.invalidation.InvalidationMessage.invalidation)
  return invalidation_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::InvalidationP >&
InvalidationMessage::invalidation() const {
  // @@protoc_insertion_point(field_list:ipc.invalidation.InvalidationMessage.invalidation)
  return invalidation_;
}

// -------------------------------------------------------------------

// InfoRequestMessage

// repeated .ipc.invalidation.InfoRequestMessage.InfoType info_type = 1;
inline int InfoRequestMessage::info_type_size() const {
  return info_type_.size();
}
inline void InfoRequestMessage::clear_info_type() {
  info_type_.Clear();
}
inline ::ipc::invalidation::InfoRequestMessage_InfoType InfoRequestMessage::info_type(int index) const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InfoRequestMessage.info_type)
  return static_cast< ::ipc::invalidation::InfoRequestMessage_InfoType >(info_type_.Get(index));
}
inline void InfoRequestMessage::set_info_type(int index, ::ipc::invalidation::InfoRequestMessage_InfoType value) {
  assert(::ipc::invalidation::InfoRequestMessage_InfoType_IsValid(value));
  info_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.InfoRequestMessage.info_type)
}
inline void InfoRequestMessage::add_info_type(::ipc::invalidation::InfoRequestMessage_InfoType value) {
  assert(::ipc::invalidation::InfoRequestMessage_InfoType_IsValid(value));
  info_type_.Add(value);
  // @@protoc_insertion_point(field_add:ipc.invalidation.InfoRequestMessage.info_type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
InfoRequestMessage::info_type() const {
  // @@protoc_insertion_point(field_list:ipc.invalidation.InfoRequestMessage.info_type)
  return info_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
InfoRequestMessage::mutable_info_type() {
  // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.InfoRequestMessage.info_type)
  return &info_type_;
}

// -------------------------------------------------------------------

// RateLimitP

// optional int32 window_ms = 1;
inline bool RateLimitP::has_window_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RateLimitP::clear_window_ms() {
  window_ms_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RateLimitP::window_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.RateLimitP.window_ms)
  return window_ms_;
}
inline void RateLimitP::set_window_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  window_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.RateLimitP.window_ms)
}

// optional int32 count = 2;
inline bool RateLimitP::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RateLimitP::clear_count() {
  count_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RateLimitP::count() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.RateLimitP.count)
  return count_;
}
inline void RateLimitP::set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  count_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.RateLimitP.count)
}

// -------------------------------------------------------------------

// ProtocolHandlerConfigP

// optional int32 batching_delay_ms = 1 [default = 500];
inline bool ProtocolHandlerConfigP::has_batching_delay_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtocolHandlerConfigP::clear_batching_delay_ms() {
  batching_delay_ms_ = 500;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ProtocolHandlerConfigP::batching_delay_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ProtocolHandlerConfigP.batching_delay_ms)
  return batching_delay_ms_;
}
inline void ProtocolHandlerConfigP::set_batching_delay_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  batching_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ProtocolHandlerConfigP.batching_delay_ms)
}

// repeated .ipc.invalidation.RateLimitP rate_limit = 2;
inline int ProtocolHandlerConfigP::rate_limit_size() const {
  return rate_limit_.size();
}
inline void ProtocolHandlerConfigP::clear_rate_limit() {
  rate_limit_.Clear();
}
inline ::ipc::invalidation::RateLimitP* ProtocolHandlerConfigP::mutable_rate_limit(int index) {
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ProtocolHandlerConfigP.rate_limit)
  return rate_limit_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::RateLimitP >*
ProtocolHandlerConfigP::mutable_rate_limit() {
  // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.ProtocolHandlerConfigP.rate_limit)
  return &rate_limit_;
}
inline const ::ipc::invalidation::RateLimitP& ProtocolHandlerConfigP::rate_limit(int index) const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ProtocolHandlerConfigP.rate_limit)
  return rate_limit_.Get(index);
}
inline ::ipc::invalidation::RateLimitP* ProtocolHandlerConfigP::add_rate_limit() {
  // @@protoc_insertion_point(field_add:ipc.invalidation.ProtocolHandlerConfigP.rate_limit)
  return rate_limit_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ipc::invalidation::RateLimitP >&
ProtocolHandlerConfigP::rate_limit() const {
  // @@protoc_insertion_point(field_list:ipc.invalidation.ProtocolHandlerConfigP.rate_limit)
  return rate_limit_;
}

// -------------------------------------------------------------------

// ClientConfigP

// optional .ipc.invalidation.Version version = 1;
inline bool ClientConfigP::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientConfigP::clear_version() {
  if (version_ != nullptr) version_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ipc::invalidation::Version& ClientConfigP::version() const {
  const ::ipc::invalidation::Version* p = version_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.version)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::Version*>(
      &::ipc::invalidation::_Version_default_instance_);
}
inline ::ipc::invalidation::Version* ClientConfigP::release_version() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientConfigP.version)
  _has_bits_[0] &= ~0x00000001u;
  ::ipc::invalidation::Version* temp = version_;
  version_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::Version* ClientConfigP::mutable_version() {
  _has_bits_[0] |= 0x00000001u;
  if (version_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::Version>(GetArenaNoVirtual());
    version_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientConfigP.version)
  return version_;
}
inline void ClientConfigP::set_allocated_version(::ipc::invalidation::Version* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete version_;
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientConfigP.version)
}

// optional int32 network_timeout_delay_ms = 2 [default = 60000];
inline bool ClientConfigP::has_network_timeout_delay_ms() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientConfigP::clear_network_timeout_delay_ms() {
  network_timeout_delay_ms_ = 60000;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientConfigP::network_timeout_delay_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.network_timeout_delay_ms)
  return network_timeout_delay_ms_;
}
inline void ClientConfigP::set_network_timeout_delay_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  network_timeout_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.network_timeout_delay_ms)
}

// optional int32 write_retry_delay_ms = 3 [default = 10000];
inline bool ClientConfigP::has_write_retry_delay_ms() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientConfigP::clear_write_retry_delay_ms() {
  write_retry_delay_ms_ = 10000;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientConfigP::write_retry_delay_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.write_retry_delay_ms)
  return write_retry_delay_ms_;
}
inline void ClientConfigP::set_write_retry_delay_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  write_retry_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.write_retry_delay_ms)
}

// optional int32 heartbeat_interval_ms = 4 [default = 1200000];
inline bool ClientConfigP::has_heartbeat_interval_ms() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientConfigP::clear_heartbeat_interval_ms() {
  heartbeat_interval_ms_ = 1200000;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientConfigP::heartbeat_interval_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.heartbeat_interval_ms)
  return heartbeat_interval_ms_;
}
inline void ClientConfigP::set_heartbeat_interval_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  heartbeat_interval_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.heartbeat_interval_ms)
}

// optional int32 perf_counter_delay_ms = 5 [default = 21600000];
inline bool ClientConfigP::has_perf_counter_delay_ms() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClientConfigP::clear_perf_counter_delay_ms() {
  perf_counter_delay_ms_ = 21600000;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientConfigP::perf_counter_delay_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.perf_counter_delay_ms)
  return perf_counter_delay_ms_;
}
inline void ClientConfigP::set_perf_counter_delay_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  perf_counter_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.perf_counter_delay_ms)
}

// optional int32 max_exponential_backoff_factor = 6 [default = 500];
inline bool ClientConfigP::has_max_exponential_backoff_factor() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClientConfigP::clear_max_exponential_backoff_factor() {
  max_exponential_backoff_factor_ = 500;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientConfigP::max_exponential_backoff_factor() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.max_exponential_backoff_factor)
  return max_exponential_backoff_factor_;
}
inline void ClientConfigP::set_max_exponential_backoff_factor(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000200u;
  max_exponential_backoff_factor_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.max_exponential_backoff_factor)
}

// optional int32 smear_percent = 7 [default = 20];
inline bool ClientConfigP::has_smear_percent() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClientConfigP::clear_smear_percent() {
  smear_percent_ = 20;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientConfigP::smear_percent() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.smear_percent)
  return smear_percent_;
}
inline void ClientConfigP::set_smear_percent(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000400u;
  smear_percent_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.smear_percent)
}

// optional bool is_transient = 8 [default = false];
inline bool ClientConfigP::has_is_transient() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientConfigP::clear_is_transient() {
  is_transient_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ClientConfigP::is_transient() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.is_transient)
  return is_transient_;
}
inline void ClientConfigP::set_is_transient(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_transient_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.is_transient)
}

// optional int32 initial_persistent_heartbeat_delay_ms = 9 [default = 2000];
inline bool ClientConfigP::has_initial_persistent_heartbeat_delay_ms() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ClientConfigP::clear_initial_persistent_heartbeat_delay_ms() {
  initial_persistent_heartbeat_delay_ms_ = 2000;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientConfigP::initial_persistent_heartbeat_delay_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.initial_persistent_heartbeat_delay_ms)
  return initial_persistent_heartbeat_delay_ms_;
}
inline void ClientConfigP::set_initial_persistent_heartbeat_delay_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000800u;
  initial_persistent_heartbeat_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.initial_persistent_heartbeat_delay_ms)
}

// optional .ipc.invalidation.ProtocolHandlerConfigP protocol_handler_config = 10;
inline bool ClientConfigP::has_protocol_handler_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientConfigP::clear_protocol_handler_config() {
  if (protocol_handler_config_ != nullptr) protocol_handler_config_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ipc::invalidation::ProtocolHandlerConfigP& ClientConfigP::protocol_handler_config() const {
  const ::ipc::invalidation::ProtocolHandlerConfigP* p = protocol_handler_config_;
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.protocol_handler_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::ipc::invalidation::ProtocolHandlerConfigP*>(
      &::ipc::invalidation::_ProtocolHandlerConfigP_default_instance_);
}
inline ::ipc::invalidation::ProtocolHandlerConfigP* ClientConfigP::release_protocol_handler_config() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientConfigP.protocol_handler_config)
  _has_bits_[0] &= ~0x00000002u;
  ::ipc::invalidation::ProtocolHandlerConfigP* temp = protocol_handler_config_;
  protocol_handler_config_ = nullptr;
  return temp;
}
inline ::ipc::invalidation::ProtocolHandlerConfigP* ClientConfigP::mutable_protocol_handler_config() {
  _has_bits_[0] |= 0x00000002u;
  if (protocol_handler_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::ipc::invalidation::ProtocolHandlerConfigP>(GetArenaNoVirtual());
    protocol_handler_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientConfigP.protocol_handler_config)
  return protocol_handler_config_;
}
inline void ClientConfigP::set_allocated_protocol_handler_config(::ipc::invalidation::ProtocolHandlerConfigP* protocol_handler_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete protocol_handler_config_;
  }
  if (protocol_handler_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      protocol_handler_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, protocol_handler_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  protocol_handler_config_ = protocol_handler_config;
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientConfigP.protocol_handler_config)
}

// optional bool channel_supports_offline_delivery = 11 [default = false];
inline bool ClientConfigP::has_channel_supports_offline_delivery() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientConfigP::clear_channel_supports_offline_delivery() {
  channel_supports_offline_delivery_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ClientConfigP::channel_supports_offline_delivery() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.channel_supports_offline_delivery)
  return channel_supports_offline_delivery_;
}
inline void ClientConfigP::set_channel_supports_offline_delivery(bool value) {
  _has_bits_[0] |= 0x00000008u;
  channel_supports_offline_delivery_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.channel_supports_offline_delivery)
}

// optional int32 offline_heartbeat_threshold_ms = 12 [default = 60000];
inline bool ClientConfigP::has_offline_heartbeat_threshold_ms() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ClientConfigP::clear_offline_heartbeat_threshold_ms() {
  offline_heartbeat_threshold_ms_ = 60000;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientConfigP::offline_heartbeat_threshold_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.offline_heartbeat_threshold_ms)
  return offline_heartbeat_threshold_ms_;
}
inline void ClientConfigP::set_offline_heartbeat_threshold_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00001000u;
  offline_heartbeat_threshold_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.offline_heartbeat_threshold_ms)
}

// optional bool allow_suppression = 13 [default = true];
inline bool ClientConfigP::has_allow_suppression() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientConfigP::clear_allow_suppression() {
  allow_suppression_ = true;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ClientConfigP::allow_suppression() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.allow_suppression)
  return allow_suppression_;
}
inline void ClientConfigP::set_allow_suppression(bool value) {
  _has_bits_[0] |= 0x00000010u;
  allow_suppression_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.allow_suppression)
}

// -------------------------------------------------------------------

// ConfigChangeMessage

// optional int64 next_message_delay_ms = 1;
inline bool ConfigChangeMessage::has_next_message_delay_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigChangeMessage::clear_next_message_delay_ms() {
  next_message_delay_ms_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ConfigChangeMessage::next_message_delay_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ConfigChangeMessage.next_message_delay_ms)
  return next_message_delay_ms_;
}
inline void ConfigChangeMessage::set_next_message_delay_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  next_message_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ConfigChangeMessage.next_message_delay_ms)
}

// -------------------------------------------------------------------

// ErrorMessage

// optional .ipc.invalidation.ErrorMessage.Code code = 1;
inline bool ErrorMessage::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ErrorMessage::clear_code() {
  code_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::ipc::invalidation::ErrorMessage_Code ErrorMessage::code() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ErrorMessage.code)
  return static_cast< ::ipc::invalidation::ErrorMessage_Code >(code_);
}
inline void ErrorMessage::set_code(::ipc::invalidation::ErrorMessage_Code value) {
  assert(::ipc::invalidation::ErrorMessage_Code_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  code_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ErrorMessage.code)
}

// optional string description = 2;
inline bool ErrorMessage::has_description() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ErrorMessage::clear_description() {
  description_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ErrorMessage::description() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ErrorMessage.description)
  return description_.GetNoArena();
}
inline void ErrorMessage::set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.ErrorMessage.description)
}
inline void ErrorMessage::set_description(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  description_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.ErrorMessage.description)
}
inline void ErrorMessage::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.ErrorMessage.description)
}
inline void ErrorMessage::set_description(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ErrorMessage.description)
}
inline std::string* ErrorMessage::mutable_description() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ErrorMessage.description)
  return description_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ErrorMessage::release_description() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ErrorMessage.description)
  if (!has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return description_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ErrorMessage::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  description_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ErrorMessage.description)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace invalidation
}  // namespace ipc

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ipc::invalidation::StatusP_Code> : ::std::true_type {};
template <> struct is_proto_enum< ::ipc::invalidation::RegistrationP_OpType> : ::std::true_type {};
template <> struct is_proto_enum< ::ipc::invalidation::InitializeMessage_DigestSerializationType> : ::std::true_type {};
template <> struct is_proto_enum< ::ipc::invalidation::InfoRequestMessage_InfoType> : ::std::true_type {};
template <> struct is_proto_enum< ::ipc::invalidation::ErrorMessage_Code> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_client_5fprotocol_2eproto
