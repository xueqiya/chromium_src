// device/vr/public/mojom/vr_service.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif


#include "device/vr/public/mojom/vr_service.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"
#include "device/gamepad/public/mojom/gamepad.mojom.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "gpu/ipc/common/mailbox_holder.mojom.h"
#include "gpu/ipc/common/sync_token.mojom.h"
#include "ui/display/mojom/display.mojom.h"
#include "ui/gfx/geometry/mojom/geometry.mojom.h"
#include "ui/gfx/mojom/gpu_fence_handle.mojom.h"
#include "ui/gfx/mojom/transform.mojom.h"


#ifndef DEVICE_VR_PUBLIC_MOJOM_VR_SERVICE_MOJOM_JUMBO_H_
#define DEVICE_VR_PUBLIC_MOJOM_VR_SERVICE_MOJOM_JUMBO_H_
#include "device/gamepad/public/cpp/gamepad_mojom_traits.h"
#include "device/vr/public/mojom/vr_service_mojom_traits.h"
#include "gpu/ipc/common/mailbox_holder_mojom_traits.h"
#include "gpu/ipc/common/mailbox_mojom_traits.h"
#include "gpu/ipc/common/sync_token_mojom_traits.h"
#include "mojo/public/cpp/base/time_mojom_traits.h"
#include "ui/gfx/geometry/mojom/geometry_mojom_traits.h"
#include "ui/gfx/mojom/gpu_fence_handle_mojom_traits.h"
#include "ui/gfx/mojom/transform_mojom_traits.h"
#endif


namespace device {
namespace mojom {


void VRServiceInterceptorForTesting::SetClient(mojo::PendingRemote<VRServiceClient> client) {
  GetForwardingInterface()->SetClient(std::move(client));
}
void VRServiceInterceptorForTesting::RequestSession(XRSessionOptionsPtr options, RequestSessionCallback callback) {
  GetForwardingInterface()->RequestSession(std::move(options), std::move(callback));
}
void VRServiceInterceptorForTesting::SupportsSession(XRSessionOptionsPtr options, SupportsSessionCallback callback) {
  GetForwardingInterface()->SupportsSession(std::move(options), std::move(callback));
}
void VRServiceInterceptorForTesting::ExitPresent(ExitPresentCallback callback) {
  GetForwardingInterface()->ExitPresent(std::move(callback));
}
void VRServiceInterceptorForTesting::SetFramesThrottled(bool throttled) {
  GetForwardingInterface()->SetFramesThrottled(std::move(throttled));
}
VRServiceAsyncWaiter::VRServiceAsyncWaiter(
    VRService* proxy) : proxy_(proxy) {}

VRServiceAsyncWaiter::~VRServiceAsyncWaiter() = default;

void VRServiceAsyncWaiter::RequestSession(
    XRSessionOptionsPtr options, RequestSessionResultPtr* out_result) {
  base::RunLoop loop;
  proxy_->RequestSession(std::move(options),
      base::BindOnce(
          [](base::RunLoop* loop,
             RequestSessionResultPtr* out_result
,
             RequestSessionResultPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void VRServiceAsyncWaiter::SupportsSession(
    XRSessionOptionsPtr options, bool* out_supports_session) {
  base::RunLoop loop;
  proxy_->SupportsSession(std::move(options),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_supports_session
,
             bool supports_session) {*out_supports_session = std::move(supports_session);
            loop->Quit();
          },
          &loop,
          out_supports_session));
  loop.Run();
}
void VRServiceAsyncWaiter::ExitPresent(
    ) {
  base::RunLoop loop;
  proxy_->ExitPresent(
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}



void XRSessionMetricsRecorderInterceptorForTesting::ReportFeatureUsed(XRSessionFeature feature) {
  GetForwardingInterface()->ReportFeatureUsed(std::move(feature));
}
XRSessionMetricsRecorderAsyncWaiter::XRSessionMetricsRecorderAsyncWaiter(
    XRSessionMetricsRecorder* proxy) : proxy_(proxy) {}

XRSessionMetricsRecorderAsyncWaiter::~XRSessionMetricsRecorderAsyncWaiter() = default;




void VRServiceClientInterceptorForTesting::OnDeviceChanged() {
  GetForwardingInterface()->OnDeviceChanged();
}
VRServiceClientAsyncWaiter::VRServiceClientAsyncWaiter(
    VRServiceClient* proxy) : proxy_(proxy) {}

VRServiceClientAsyncWaiter::~VRServiceClientAsyncWaiter() = default;




void XREnvironmentIntegrationProviderInterceptorForTesting::RequestHitTest(XRRayPtr ray, RequestHitTestCallback callback) {
  GetForwardingInterface()->RequestHitTest(std::move(ray), std::move(callback));
}
void XREnvironmentIntegrationProviderInterceptorForTesting::SubscribeToHitTest(XRNativeOriginInformationPtr native_origin_information, const std::vector<EntityTypeForHitTest>& entity_types, XRRayPtr ray, SubscribeToHitTestCallback callback) {
  GetForwardingInterface()->SubscribeToHitTest(std::move(native_origin_information), std::move(entity_types), std::move(ray), std::move(callback));
}
void XREnvironmentIntegrationProviderInterceptorForTesting::SubscribeToHitTestForTransientInput(const std::string& profile_name, const std::vector<EntityTypeForHitTest>& entity_types, XRRayPtr ray, SubscribeToHitTestForTransientInputCallback callback) {
  GetForwardingInterface()->SubscribeToHitTestForTransientInput(std::move(profile_name), std::move(entity_types), std::move(ray), std::move(callback));
}
void XREnvironmentIntegrationProviderInterceptorForTesting::UnsubscribeFromHitTest(uint64_t subscription_id) {
  GetForwardingInterface()->UnsubscribeFromHitTest(std::move(subscription_id));
}
void XREnvironmentIntegrationProviderInterceptorForTesting::CreateAnchor(PosePtr anchor_pose, CreateAnchorCallback callback) {
  GetForwardingInterface()->CreateAnchor(std::move(anchor_pose), std::move(callback));
}
void XREnvironmentIntegrationProviderInterceptorForTesting::CreatePlaneAnchor(PosePtr anchor_pose, uint64_t plane_id, CreatePlaneAnchorCallback callback) {
  GetForwardingInterface()->CreatePlaneAnchor(std::move(anchor_pose), std::move(plane_id), std::move(callback));
}
void XREnvironmentIntegrationProviderInterceptorForTesting::DetachAnchor(uint64_t anchor_id) {
  GetForwardingInterface()->DetachAnchor(std::move(anchor_id));
}
XREnvironmentIntegrationProviderAsyncWaiter::XREnvironmentIntegrationProviderAsyncWaiter(
    XREnvironmentIntegrationProvider* proxy) : proxy_(proxy) {}

XREnvironmentIntegrationProviderAsyncWaiter::~XREnvironmentIntegrationProviderAsyncWaiter() = default;

void XREnvironmentIntegrationProviderAsyncWaiter::RequestHitTest(
    XRRayPtr ray, base::Optional<std::vector<XRHitResultPtr>>* out_results) {
  base::RunLoop loop;
  proxy_->RequestHitTest(std::move(ray),
      base::BindOnce(
          [](base::RunLoop* loop,
             base::Optional<std::vector<XRHitResultPtr>>* out_results
,
             base::Optional<std::vector<XRHitResultPtr>> results) {*out_results = std::move(results);
            loop->Quit();
          },
          &loop,
          out_results));
  loop.Run();
}
void XREnvironmentIntegrationProviderAsyncWaiter::SubscribeToHitTest(
    XRNativeOriginInformationPtr native_origin_information, const std::vector<EntityTypeForHitTest>& entity_types, XRRayPtr ray, SubscribeToHitTestResult* out_result, uint64_t* out_subscription_id) {
  base::RunLoop loop;
  proxy_->SubscribeToHitTest(std::move(native_origin_information),std::move(entity_types),std::move(ray),
      base::BindOnce(
          [](base::RunLoop* loop,
             SubscribeToHitTestResult* out_result
,
             uint64_t* out_subscription_id
,
             SubscribeToHitTestResult result,
             uint64_t subscription_id) {*out_result = std::move(result);*out_subscription_id = std::move(subscription_id);
            loop->Quit();
          },
          &loop,
          out_result,
          out_subscription_id));
  loop.Run();
}
void XREnvironmentIntegrationProviderAsyncWaiter::SubscribeToHitTestForTransientInput(
    const std::string& profile_name, const std::vector<EntityTypeForHitTest>& entity_types, XRRayPtr ray, SubscribeToHitTestResult* out_result, uint64_t* out_subscription_id) {
  base::RunLoop loop;
  proxy_->SubscribeToHitTestForTransientInput(std::move(profile_name),std::move(entity_types),std::move(ray),
      base::BindOnce(
          [](base::RunLoop* loop,
             SubscribeToHitTestResult* out_result
,
             uint64_t* out_subscription_id
,
             SubscribeToHitTestResult result,
             uint64_t subscription_id) {*out_result = std::move(result);*out_subscription_id = std::move(subscription_id);
            loop->Quit();
          },
          &loop,
          out_result,
          out_subscription_id));
  loop.Run();
}
void XREnvironmentIntegrationProviderAsyncWaiter::CreateAnchor(
    PosePtr anchor_pose, CreateAnchorResult* out_result, uint64_t* out_anchor_id) {
  base::RunLoop loop;
  proxy_->CreateAnchor(std::move(anchor_pose),
      base::BindOnce(
          [](base::RunLoop* loop,
             CreateAnchorResult* out_result
,
             uint64_t* out_anchor_id
,
             CreateAnchorResult result,
             uint64_t anchor_id) {*out_result = std::move(result);*out_anchor_id = std::move(anchor_id);
            loop->Quit();
          },
          &loop,
          out_result,
          out_anchor_id));
  loop.Run();
}
void XREnvironmentIntegrationProviderAsyncWaiter::CreatePlaneAnchor(
    PosePtr anchor_pose, uint64_t plane_id, CreateAnchorResult* out_result, uint64_t* out_anchor_id) {
  base::RunLoop loop;
  proxy_->CreatePlaneAnchor(std::move(anchor_pose),std::move(plane_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             CreateAnchorResult* out_result
,
             uint64_t* out_anchor_id
,
             CreateAnchorResult result,
             uint64_t anchor_id) {*out_result = std::move(result);*out_anchor_id = std::move(anchor_id);
            loop->Quit();
          },
          &loop,
          out_result,
          out_anchor_id));
  loop.Run();
}



void XRInputSourceButtonListenerInterceptorForTesting::OnButtonEvent(XRInputSourceStatePtr input_source) {
  GetForwardingInterface()->OnButtonEvent(std::move(input_source));
}
XRInputSourceButtonListenerAsyncWaiter::XRInputSourceButtonListenerAsyncWaiter(
    XRInputSourceButtonListener* proxy) : proxy_(proxy) {}

XRInputSourceButtonListenerAsyncWaiter::~XRInputSourceButtonListenerAsyncWaiter() = default;




void XRFrameDataProviderInterceptorForTesting::GetFrameData(XRFrameDataRequestOptionsPtr options, GetFrameDataCallback callback) {
  GetForwardingInterface()->GetFrameData(std::move(options), std::move(callback));
}
void XRFrameDataProviderInterceptorForTesting::GetEnvironmentIntegrationProvider(mojo::PendingAssociatedReceiver<XREnvironmentIntegrationProvider> environment_provider) {
  GetForwardingInterface()->GetEnvironmentIntegrationProvider(std::move(environment_provider));
}
void XRFrameDataProviderInterceptorForTesting::SetInputSourceButtonListener(mojo::PendingAssociatedRemote<XRInputSourceButtonListener> event_listener) {
  GetForwardingInterface()->SetInputSourceButtonListener(std::move(event_listener));
}
XRFrameDataProviderAsyncWaiter::XRFrameDataProviderAsyncWaiter(
    XRFrameDataProvider* proxy) : proxy_(proxy) {}

XRFrameDataProviderAsyncWaiter::~XRFrameDataProviderAsyncWaiter() = default;

void XRFrameDataProviderAsyncWaiter::GetFrameData(
    XRFrameDataRequestOptionsPtr options, XRFrameDataPtr* out_frame_data) {
  base::RunLoop loop;
  proxy_->GetFrameData(std::move(options),
      base::BindOnce(
          [](base::RunLoop* loop,
             XRFrameDataPtr* out_frame_data
,
             XRFrameDataPtr frame_data) {*out_frame_data = std::move(frame_data);
            loop->Quit();
          },
          &loop,
          out_frame_data));
  loop.Run();
}



void XRPresentationProviderInterceptorForTesting::UpdateLayerBounds(int16_t frame_id, const ::gfx::RectF& left_bounds, const ::gfx::RectF& right_bounds, const ::gfx::Size& source_size) {
  GetForwardingInterface()->UpdateLayerBounds(std::move(frame_id), std::move(left_bounds), std::move(right_bounds), std::move(source_size));
}
void XRPresentationProviderInterceptorForTesting::SubmitFrameMissing(int16_t frame_id, const ::gpu::SyncToken& sync_token) {
  GetForwardingInterface()->SubmitFrameMissing(std::move(frame_id), std::move(sync_token));
}
void XRPresentationProviderInterceptorForTesting::SubmitFrame(int16_t frame_id, const ::gpu::MailboxHolder& mailbox_holder, ::base::TimeDelta time_waited) {
  GetForwardingInterface()->SubmitFrame(std::move(frame_id), std::move(mailbox_holder), std::move(time_waited));
}
void XRPresentationProviderInterceptorForTesting::SubmitFrameWithTextureHandle(int16_t frameId, mojo::ScopedHandle texture) {
  GetForwardingInterface()->SubmitFrameWithTextureHandle(std::move(frameId), std::move(texture));
}
void XRPresentationProviderInterceptorForTesting::SubmitFrameDrawnIntoTexture(int16_t frameId, const ::gpu::SyncToken& sync_token, ::base::TimeDelta time_waited) {
  GetForwardingInterface()->SubmitFrameDrawnIntoTexture(std::move(frameId), std::move(sync_token), std::move(time_waited));
}
XRPresentationProviderAsyncWaiter::XRPresentationProviderAsyncWaiter(
    XRPresentationProvider* proxy) : proxy_(proxy) {}

XRPresentationProviderAsyncWaiter::~XRPresentationProviderAsyncWaiter() = default;




void XRPresentationClientInterceptorForTesting::OnSubmitFrameTransferred(bool success) {
  GetForwardingInterface()->OnSubmitFrameTransferred(std::move(success));
}
void XRPresentationClientInterceptorForTesting::OnSubmitFrameRendered() {
  GetForwardingInterface()->OnSubmitFrameRendered();
}
void XRPresentationClientInterceptorForTesting::OnSubmitFrameGpuFence(const ::gfx::GpuFenceHandle& gpu_fence_handle) {
  GetForwardingInterface()->OnSubmitFrameGpuFence(std::move(gpu_fence_handle));
}
XRPresentationClientAsyncWaiter::XRPresentationClientAsyncWaiter(
    XRPresentationClient* proxy) : proxy_(proxy) {}

XRPresentationClientAsyncWaiter::~XRPresentationClientAsyncWaiter() = default;




void XRSessionClientInterceptorForTesting::OnChanged(VRDisplayInfoPtr display) {
  GetForwardingInterface()->OnChanged(std::move(display));
}
void XRSessionClientInterceptorForTesting::OnExitPresent() {
  GetForwardingInterface()->OnExitPresent();
}
void XRSessionClientInterceptorForTesting::OnVisibilityStateChanged(XRVisibilityState visibility_state) {
  GetForwardingInterface()->OnVisibilityStateChanged(std::move(visibility_state));
}
XRSessionClientAsyncWaiter::XRSessionClientAsyncWaiter(
    XRSessionClient* proxy) : proxy_(proxy) {}

XRSessionClientAsyncWaiter::~XRSessionClientAsyncWaiter() = default;






}  // namespace mojom
}  // namespace device

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif