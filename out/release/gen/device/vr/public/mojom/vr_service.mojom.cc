// device/vr/public/mojom/vr_service.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif

#include "device/vr/public/mojom/vr_service.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/hash/md5_constexpr.h"
#include "base/logging.h"
#include "base/run_loop.h"
#include "base/task/common/task_annotator.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_context.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"

#include "device/vr/public/mojom/vr_service.mojom-params-data.h"
#include "device/vr/public/mojom/vr_service.mojom-shared-message-ids.h"

#include "device/vr/public/mojom/vr_service.mojom-import-headers.h"


#ifndef DEVICE_VR_PUBLIC_MOJOM_VR_SERVICE_MOJOM_JUMBO_H_
#define DEVICE_VR_PUBLIC_MOJOM_VR_SERVICE_MOJOM_JUMBO_H_
#include "device/gamepad/public/cpp/gamepad_mojom_traits.h"
#include "device/vr/public/mojom/vr_service_mojom_traits.h"
#include "gpu/ipc/common/mailbox_holder_mojom_traits.h"
#include "gpu/ipc/common/mailbox_mojom_traits.h"
#include "gpu/ipc/common/sync_token_mojom_traits.h"
#include "mojo/public/cpp/base/time_mojom_traits.h"
#include "ui/gfx/geometry/mojom/geometry_mojom_traits.h"
#include "ui/gfx/mojom/gpu_fence_handle_mojom_traits.h"
#include "ui/gfx/mojom/transform_mojom_traits.h"
#endif
namespace device {
namespace mojom {
constexpr uint64_t XRCubeMap::kNumComponentsPerPixel;
XRSessionOptions::XRSessionOptions()
    : mode(),
      required_features(),
      optional_features() {}

XRSessionOptions::XRSessionOptions(
    XRSessionMode mode_in,
    std::vector<XRSessionFeature> required_features_in,
    std::vector<XRSessionFeature> optional_features_in)
    : mode(std::move(mode_in)),
      required_features(std::move(required_features_in)),
      optional_features(std::move(optional_features_in)) {}

XRSessionOptions::~XRSessionOptions() = default;

bool XRSessionOptions::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRSession::XRSession()
    : data_provider(),
      client_receiver(),
      display_info(),
      submit_frame_sink(),
      enabled_features(),
      uses_input_eventing() {}

XRSession::XRSession(
    mojo::PendingRemote<XRFrameDataProvider> data_provider_in,
    mojo::PendingReceiver<XRSessionClient> client_receiver_in,
    VRDisplayInfoPtr display_info_in,
    XRPresentationConnectionPtr submit_frame_sink_in,
    std::vector<XRSessionFeature> enabled_features_in,
    bool uses_input_eventing_in)
    : data_provider(std::move(data_provider_in)),
      client_receiver(std::move(client_receiver_in)),
      display_info(std::move(display_info_in)),
      submit_frame_sink(std::move(submit_frame_sink_in)),
      enabled_features(std::move(enabled_features_in)),
      uses_input_eventing(std::move(uses_input_eventing_in)) {}

XRSession::~XRSession() = default;

bool XRSession::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRPresentationConnection::XRPresentationConnection()
    : provider(),
      client_receiver(),
      transport_options() {}

XRPresentationConnection::XRPresentationConnection(
    mojo::PendingRemote<XRPresentationProvider> provider_in,
    mojo::PendingReceiver<XRPresentationClient> client_receiver_in,
    XRPresentationTransportOptionsPtr transport_options_in)
    : provider(std::move(provider_in)),
      client_receiver(std::move(client_receiver_in)),
      transport_options(std::move(transport_options_in)) {}

XRPresentationConnection::~XRPresentationConnection() = default;

bool XRPresentationConnection::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRInputSourceDescription::XRInputSourceDescription()
    : target_ray_mode(),
      handedness(),
      input_from_pointer(),
      profiles() {}

XRInputSourceDescription::XRInputSourceDescription(
    XRTargetRayMode target_ray_mode_in,
    XRHandedness handedness_in,
    const base::Optional<::gfx::Transform>& input_from_pointer_in,
    std::vector<std::string> profiles_in)
    : target_ray_mode(std::move(target_ray_mode_in)),
      handedness(std::move(handedness_in)),
      input_from_pointer(std::move(input_from_pointer_in)),
      profiles(std::move(profiles_in)) {}

XRInputSourceDescription::~XRInputSourceDescription() = default;

bool XRInputSourceDescription::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRInputSourceState::XRInputSourceState()
    : source_id(),
      description(),
      mojo_from_input(),
      emulated_position(),
      primary_input_pressed(),
      primary_input_clicked(),
      gamepad(),
      overlay_pointer_position() {}

XRInputSourceState::XRInputSourceState(
    uint32_t source_id_in,
    XRInputSourceDescriptionPtr description_in,
    const base::Optional<::gfx::Transform>& mojo_from_input_in,
    bool emulated_position_in,
    bool primary_input_pressed_in,
    bool primary_input_clicked_in,
    const base::Optional<::device::Gamepad>& gamepad_in,
    const base::Optional<::gfx::PointF>& overlay_pointer_position_in)
    : source_id(std::move(source_id_in)),
      description(std::move(description_in)),
      mojo_from_input(std::move(mojo_from_input_in)),
      emulated_position(std::move(emulated_position_in)),
      primary_input_pressed(std::move(primary_input_pressed_in)),
      primary_input_clicked(std::move(primary_input_clicked_in)),
      gamepad(std::move(gamepad_in)),
      overlay_pointer_position(std::move(overlay_pointer_position_in)) {}

XRInputSourceState::~XRInputSourceState() = default;

bool XRInputSourceState::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
VRFieldOfView::VRFieldOfView()
    : up_degrees(),
      down_degrees(),
      left_degrees(),
      right_degrees() {}

VRFieldOfView::VRFieldOfView(
    float up_degrees_in,
    float down_degrees_in,
    float left_degrees_in,
    float right_degrees_in)
    : up_degrees(std::move(up_degrees_in)),
      down_degrees(std::move(down_degrees_in)),
      left_degrees(std::move(left_degrees_in)),
      right_degrees(std::move(right_degrees_in)) {}

VRFieldOfView::~VRFieldOfView() = default;
size_t VRFieldOfView::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->up_degrees);
  seed = mojo::internal::Hash(seed, this->down_degrees);
  seed = mojo::internal::Hash(seed, this->left_degrees);
  seed = mojo::internal::Hash(seed, this->right_degrees);
  return seed;
}

bool VRFieldOfView::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
VRPose::VRPose()
    : orientation(),
      position(),
      emulated_position() {}

VRPose::VRPose(
    const base::Optional<::gfx::Quaternion>& orientation_in,
    const base::Optional<::gfx::Point3F>& position_in,
    bool emulated_position_in)
    : orientation(std::move(orientation_in)),
      position(std::move(position_in)),
      emulated_position(std::move(emulated_position_in)) {}

VRPose::~VRPose() = default;

bool VRPose::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
Pose::Pose()
    : orientation(),
      position() {}

Pose::Pose(
    const ::gfx::Quaternion& orientation_in,
    const ::gfx::Point3F& position_in)
    : orientation(std::move(orientation_in)),
      position(std::move(position_in)) {}

Pose::~Pose() = default;

bool Pose::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRRay::XRRay()
    : origin(),
      direction() {}

XRRay::XRRay(
    const ::gfx::Point3F& origin_in,
    const ::gfx::Vector3dF& direction_in)
    : origin(std::move(origin_in)),
      direction(std::move(direction_in)) {}

XRRay::~XRRay() = default;

bool XRRay::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRHitResult::XRHitResult()
    : hit_matrix() {}

XRHitResult::XRHitResult(
    const ::gfx::Transform& hit_matrix_in)
    : hit_matrix(std::move(hit_matrix_in)) {}

XRHitResult::~XRHitResult() = default;

bool XRHitResult::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
VREyeParameters::VREyeParameters()
    : field_of_view(),
      head_from_eye(),
      render_width(),
      render_height() {}

VREyeParameters::VREyeParameters(
    VRFieldOfViewPtr field_of_view_in,
    const ::gfx::Transform& head_from_eye_in,
    uint32_t render_width_in,
    uint32_t render_height_in)
    : field_of_view(std::move(field_of_view_in)),
      head_from_eye(std::move(head_from_eye_in)),
      render_width(std::move(render_width_in)),
      render_height(std::move(render_height_in)) {}

VREyeParameters::~VREyeParameters() = default;

bool VREyeParameters::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
VRStageParameters::VRStageParameters()
    : standing_transform(),
      bounds() {}

VRStageParameters::VRStageParameters(
    const ::gfx::Transform& standing_transform_in,
    base::Optional<std::vector<::gfx::Point3F>> bounds_in)
    : standing_transform(std::move(standing_transform_in)),
      bounds(std::move(bounds_in)) {}

VRStageParameters::~VRStageParameters() = default;

bool VRStageParameters::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
VRDisplayInfo::VRDisplayInfo()
    : id(),
      stage_parameters(),
      left_eye(),
      right_eye(),
      webxr_default_framebuffer_scale(1.0f) {}

VRDisplayInfo::VRDisplayInfo(
    XRDeviceId id_in,
    VRStageParametersPtr stage_parameters_in,
    VREyeParametersPtr left_eye_in,
    VREyeParametersPtr right_eye_in,
    float webxr_default_framebuffer_scale_in)
    : id(std::move(id_in)),
      stage_parameters(std::move(stage_parameters_in)),
      left_eye(std::move(left_eye_in)),
      right_eye(std::move(right_eye_in)),
      webxr_default_framebuffer_scale(std::move(webxr_default_framebuffer_scale_in)) {}

VRDisplayInfo::~VRDisplayInfo() = default;

bool VRDisplayInfo::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRPresentationTransportOptions::XRPresentationTransportOptions()
    : transport_method(),
      wait_for_transfer_notification(),
      wait_for_render_notification(),
      wait_for_gpu_fence() {}

XRPresentationTransportOptions::XRPresentationTransportOptions(
    XRPresentationTransportMethod transport_method_in,
    bool wait_for_transfer_notification_in,
    bool wait_for_render_notification_in,
    bool wait_for_gpu_fence_in)
    : transport_method(std::move(transport_method_in)),
      wait_for_transfer_notification(std::move(wait_for_transfer_notification_in)),
      wait_for_render_notification(std::move(wait_for_render_notification_in)),
      wait_for_gpu_fence(std::move(wait_for_gpu_fence_in)) {}

XRPresentationTransportOptions::~XRPresentationTransportOptions() = default;
size_t XRPresentationTransportOptions::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->transport_method);
  seed = mojo::internal::Hash(seed, this->wait_for_transfer_notification);
  seed = mojo::internal::Hash(seed, this->wait_for_render_notification);
  seed = mojo::internal::Hash(seed, this->wait_for_gpu_fence);
  return seed;
}

bool XRPresentationTransportOptions::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRPlanePointData::XRPlanePointData()
    : x(),
      z() {}

XRPlanePointData::XRPlanePointData(
    float x_in,
    float z_in)
    : x(std::move(x_in)),
      z(std::move(z_in)) {}

XRPlanePointData::~XRPlanePointData() = default;
size_t XRPlanePointData::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->x);
  seed = mojo::internal::Hash(seed, this->z);
  return seed;
}

bool XRPlanePointData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRPlaneData::XRPlaneData()
    : id(),
      orientation(),
      pose(),
      polygon() {}

XRPlaneData::XRPlaneData(
    uint64_t id_in,
    XRPlaneOrientation orientation_in,
    PosePtr pose_in,
    std::vector<XRPlanePointDataPtr> polygon_in)
    : id(std::move(id_in)),
      orientation(std::move(orientation_in)),
      pose(std::move(pose_in)),
      polygon(std::move(polygon_in)) {}

XRPlaneData::~XRPlaneData() = default;

bool XRPlaneData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRPlaneDetectionData::XRPlaneDetectionData()
    : all_planes_ids(),
      updated_planes_data() {}

XRPlaneDetectionData::XRPlaneDetectionData(
    std::vector<uint64_t> all_planes_ids_in,
    std::vector<XRPlaneDataPtr> updated_planes_data_in)
    : all_planes_ids(std::move(all_planes_ids_in)),
      updated_planes_data(std::move(updated_planes_data_in)) {}

XRPlaneDetectionData::~XRPlaneDetectionData() = default;

bool XRPlaneDetectionData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRAnchorData::XRAnchorData()
    : id(),
      pose() {}

XRAnchorData::XRAnchorData(
    uint64_t id_in,
    PosePtr pose_in)
    : id(std::move(id_in)),
      pose(std::move(pose_in)) {}

XRAnchorData::~XRAnchorData() = default;

bool XRAnchorData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRAnchorsData::XRAnchorsData()
    : all_anchors_ids(),
      updated_anchors_data() {}

XRAnchorsData::XRAnchorsData(
    std::vector<uint64_t> all_anchors_ids_in,
    std::vector<XRAnchorDataPtr> updated_anchors_data_in)
    : all_anchors_ids(std::move(all_anchors_ids_in)),
      updated_anchors_data(std::move(updated_anchors_data_in)) {}

XRAnchorsData::~XRAnchorsData() = default;

bool XRAnchorsData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRHitTestSubscriptionResultData::XRHitTestSubscriptionResultData()
    : subscription_id(),
      hit_test_results() {}

XRHitTestSubscriptionResultData::XRHitTestSubscriptionResultData(
    uint64_t subscription_id_in,
    std::vector<XRHitResultPtr> hit_test_results_in)
    : subscription_id(std::move(subscription_id_in)),
      hit_test_results(std::move(hit_test_results_in)) {}

XRHitTestSubscriptionResultData::~XRHitTestSubscriptionResultData() = default;

bool XRHitTestSubscriptionResultData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRHitTestTransientInputSubscriptionResultData::XRHitTestTransientInputSubscriptionResultData()
    : subscription_id(),
      input_source_id_to_hit_test_results() {}

XRHitTestTransientInputSubscriptionResultData::XRHitTestTransientInputSubscriptionResultData(
    uint64_t subscription_id_in,
    base::flat_map<uint32_t, std::vector<XRHitResultPtr>> input_source_id_to_hit_test_results_in)
    : subscription_id(std::move(subscription_id_in)),
      input_source_id_to_hit_test_results(std::move(input_source_id_to_hit_test_results_in)) {}

XRHitTestTransientInputSubscriptionResultData::~XRHitTestTransientInputSubscriptionResultData() = default;

bool XRHitTestTransientInputSubscriptionResultData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRHitTestSubscriptionResultsData::XRHitTestSubscriptionResultsData()
    : results(),
      transient_input_results() {}

XRHitTestSubscriptionResultsData::XRHitTestSubscriptionResultsData(
    std::vector<XRHitTestSubscriptionResultDataPtr> results_in,
    std::vector<XRHitTestTransientInputSubscriptionResultDataPtr> transient_input_results_in)
    : results(std::move(results_in)),
      transient_input_results(std::move(transient_input_results_in)) {}

XRHitTestSubscriptionResultsData::~XRHitTestSubscriptionResultsData() = default;

bool XRHitTestSubscriptionResultsData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
RgbTupleF32::RgbTupleF32()
    : red(),
      green(),
      blue() {}

RgbTupleF32::RgbTupleF32(
    float red_in,
    float green_in,
    float blue_in)
    : red(std::move(red_in)),
      green(std::move(green_in)),
      blue(std::move(blue_in)) {}

RgbTupleF32::~RgbTupleF32() = default;

bool RgbTupleF32::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRSphericalHarmonics::XRSphericalHarmonics()
    : coefficients() {}

XRSphericalHarmonics::XRSphericalHarmonics(
    std::vector<::device::RgbTupleF32> coefficients_in)
    : coefficients(std::move(coefficients_in)) {}

XRSphericalHarmonics::~XRSphericalHarmonics() = default;

bool XRSphericalHarmonics::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
RgbaTupleF16::RgbaTupleF16()
    : red(),
      green(),
      blue(),
      alpha() {}

RgbaTupleF16::RgbaTupleF16(
    uint16_t red_in,
    uint16_t green_in,
    uint16_t blue_in,
    uint16_t alpha_in)
    : red(std::move(red_in)),
      green(std::move(green_in)),
      blue(std::move(blue_in)),
      alpha(std::move(alpha_in)) {}

RgbaTupleF16::~RgbaTupleF16() = default;

bool RgbaTupleF16::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRCubeMap::XRCubeMap()
    : width_and_height(),
      positive_x(),
      negative_x(),
      positive_y(),
      negative_y(),
      positive_z(),
      negative_z() {}

XRCubeMap::XRCubeMap(
    uint32_t width_and_height_in,
    std::vector<::device::RgbaTupleF16> positive_x_in,
    std::vector<::device::RgbaTupleF16> negative_x_in,
    std::vector<::device::RgbaTupleF16> positive_y_in,
    std::vector<::device::RgbaTupleF16> negative_y_in,
    std::vector<::device::RgbaTupleF16> positive_z_in,
    std::vector<::device::RgbaTupleF16> negative_z_in)
    : width_and_height(std::move(width_and_height_in)),
      positive_x(std::move(positive_x_in)),
      negative_x(std::move(negative_x_in)),
      positive_y(std::move(positive_y_in)),
      negative_y(std::move(negative_y_in)),
      positive_z(std::move(positive_z_in)),
      negative_z(std::move(negative_z_in)) {}

XRCubeMap::~XRCubeMap() = default;

bool XRCubeMap::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRLightProbe::XRLightProbe()
    : spherical_harmonics(),
      main_light_direction(),
      main_light_intensity() {}

XRLightProbe::XRLightProbe(
    XRSphericalHarmonicsPtr spherical_harmonics_in,
    const ::gfx::Vector3dF& main_light_direction_in,
    const ::device::RgbTupleF32& main_light_intensity_in)
    : spherical_harmonics(std::move(spherical_harmonics_in)),
      main_light_direction(std::move(main_light_direction_in)),
      main_light_intensity(std::move(main_light_intensity_in)) {}

XRLightProbe::~XRLightProbe() = default;

bool XRLightProbe::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRReflectionProbe::XRReflectionProbe()
    : cube_map() {}

XRReflectionProbe::XRReflectionProbe(
    XRCubeMapPtr cube_map_in)
    : cube_map(std::move(cube_map_in)) {}

XRReflectionProbe::~XRReflectionProbe() = default;

bool XRReflectionProbe::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRLightEstimationData::XRLightEstimationData()
    : light_probe(),
      reflection_probe() {}

XRLightEstimationData::XRLightEstimationData(
    XRLightProbePtr light_probe_in,
    XRReflectionProbePtr reflection_probe_in)
    : light_probe(std::move(light_probe_in)),
      reflection_probe(std::move(reflection_probe_in)) {}

XRLightEstimationData::~XRLightEstimationData() = default;

bool XRLightEstimationData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRFrameData::XRFrameData()
    : pose(),
      time_delta(),
      buffer_holder(),
      mojo_space_reset(),
      frame_id(),
      left_eye(),
      right_eye(),
      input_state(),
      stage_parameters_updated(),
      stage_parameters(),
      detected_planes_data(),
      anchors_data(),
      light_estimation_data(),
      hit_test_subscription_results() {}

XRFrameData::XRFrameData(
    VRPosePtr pose_in,
    ::base::TimeDelta time_delta_in,
    const base::Optional<::gpu::MailboxHolder>& buffer_holder_in,
    bool mojo_space_reset_in,
    int16_t frame_id_in,
    VREyeParametersPtr left_eye_in,
    VREyeParametersPtr right_eye_in,
    base::Optional<std::vector<XRInputSourceStatePtr>> input_state_in,
    bool stage_parameters_updated_in,
    VRStageParametersPtr stage_parameters_in,
    XRPlaneDetectionDataPtr detected_planes_data_in,
    XRAnchorsDataPtr anchors_data_in,
    XRLightEstimationDataPtr light_estimation_data_in,
    XRHitTestSubscriptionResultsDataPtr hit_test_subscription_results_in)
    : pose(std::move(pose_in)),
      time_delta(std::move(time_delta_in)),
      buffer_holder(std::move(buffer_holder_in)),
      mojo_space_reset(std::move(mojo_space_reset_in)),
      frame_id(std::move(frame_id_in)),
      left_eye(std::move(left_eye_in)),
      right_eye(std::move(right_eye_in)),
      input_state(std::move(input_state_in)),
      stage_parameters_updated(std::move(stage_parameters_updated_in)),
      stage_parameters(std::move(stage_parameters_in)),
      detected_planes_data(std::move(detected_planes_data_in)),
      anchors_data(std::move(anchors_data_in)),
      light_estimation_data(std::move(light_estimation_data_in)),
      hit_test_subscription_results(std::move(hit_test_subscription_results_in)) {}

XRFrameData::~XRFrameData() = default;

bool XRFrameData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
RequestSessionSuccess::RequestSessionSuccess()
    : session(),
      metrics_recorder() {}

RequestSessionSuccess::RequestSessionSuccess(
    XRSessionPtr session_in,
    mojo::PendingRemote<XRSessionMetricsRecorder> metrics_recorder_in)
    : session(std::move(session_in)),
      metrics_recorder(std::move(metrics_recorder_in)) {}

RequestSessionSuccess::~RequestSessionSuccess() = default;

bool RequestSessionSuccess::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRFrameDataRequestOptions::XRFrameDataRequestOptions()
    : include_plane_data(),
      include_lighting_estimation_data() {}

XRFrameDataRequestOptions::XRFrameDataRequestOptions(
    bool include_plane_data_in,
    bool include_lighting_estimation_data_in)
    : include_plane_data(std::move(include_plane_data_in)),
      include_lighting_estimation_data(std::move(include_lighting_estimation_data_in)) {}

XRFrameDataRequestOptions::~XRFrameDataRequestOptions() = default;
size_t XRFrameDataRequestOptions::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->include_plane_data);
  seed = mojo::internal::Hash(seed, this->include_lighting_estimation_data);
  return seed;
}

bool XRFrameDataRequestOptions::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
XRNativeOriginInformation::XRNativeOriginInformation() : tag_(Tag::INPUT_SOURCE_ID) {
  data_.input_source_id = uint32_t();
}

XRNativeOriginInformation::~XRNativeOriginInformation() {
  DestroyActive();
}


void XRNativeOriginInformation::set_input_source_id(
    uint32_t input_source_id) {
  if (tag_ != Tag::INPUT_SOURCE_ID) {
    DestroyActive();
    tag_ = Tag::INPUT_SOURCE_ID;
  }
  data_.input_source_id = input_source_id;
}
void XRNativeOriginInformation::set_plane_id(
    uint64_t plane_id) {
  if (tag_ != Tag::PLANE_ID) {
    DestroyActive();
    tag_ = Tag::PLANE_ID;
  }
  data_.plane_id = plane_id;
}
void XRNativeOriginInformation::set_anchor_id(
    uint64_t anchor_id) {
  if (tag_ != Tag::ANCHOR_ID) {
    DestroyActive();
    tag_ = Tag::ANCHOR_ID;
  }
  data_.anchor_id = anchor_id;
}
void XRNativeOriginInformation::set_reference_space_category(
    XRReferenceSpaceCategory reference_space_category) {
  if (tag_ != Tag::REFERENCE_SPACE_CATEGORY) {
    DestroyActive();
    tag_ = Tag::REFERENCE_SPACE_CATEGORY;
  }
  data_.reference_space_category = reference_space_category;
}

void XRNativeOriginInformation::DestroyActive() {
  switch (tag_) {

    case Tag::INPUT_SOURCE_ID:

      break;
    case Tag::PLANE_ID:

      break;
    case Tag::ANCHOR_ID:

      break;
    case Tag::REFERENCE_SPACE_CATEGORY:

      break;
  }
}
size_t XRNativeOriginInformation::Hash(size_t seed) const {
  seed = mojo::internal::HashCombine(seed, static_cast<uint32_t>(tag_));
  switch (tag_) {

    case Tag::INPUT_SOURCE_ID:
      return mojo::internal::Hash(seed, data_.input_source_id);
    case Tag::PLANE_ID:
      return mojo::internal::Hash(seed, data_.plane_id);
    case Tag::ANCHOR_ID:
      return mojo::internal::Hash(seed, data_.anchor_id);
    case Tag::REFERENCE_SPACE_CATEGORY:
      return mojo::internal::Hash(seed, data_.reference_space_category);
    default:
      NOTREACHED();
      return seed;
  }
}

bool XRNativeOriginInformation::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
RequestSessionResult::RequestSessionResult() : tag_(Tag::SUCCESS) {
  data_.success = new RequestSessionSuccessPtr;
}

RequestSessionResult::~RequestSessionResult() {
  DestroyActive();
}


void RequestSessionResult::set_success(
    RequestSessionSuccessPtr success) {
  if (tag_ == Tag::SUCCESS) {
    *(data_.success) = std::move(success);
  } else {
    DestroyActive();
    tag_ = Tag::SUCCESS;
    data_.success = new RequestSessionSuccessPtr(
        std::move(success));
  }
}
void RequestSessionResult::set_failure_reason(
    RequestSessionError failure_reason) {
  if (tag_ != Tag::FAILURE_REASON) {
    DestroyActive();
    tag_ = Tag::FAILURE_REASON;
  }
  data_.failure_reason = failure_reason;
}

void RequestSessionResult::DestroyActive() {
  switch (tag_) {

    case Tag::SUCCESS:

      delete data_.success;
      break;
    case Tag::FAILURE_REASON:

      break;
  }
}

bool RequestSessionResult::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
const char VRService::Name_[] = "device.mojom.VRService";

class VRService_RequestSession_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  VRService_RequestSession_ForwardToCallback(
      VRService::RequestSessionCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  VRService::RequestSessionCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(VRService_RequestSession_ForwardToCallback);
};

class VRService_SupportsSession_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  VRService_SupportsSession_ForwardToCallback(
      VRService::SupportsSessionCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  VRService::SupportsSessionCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(VRService_SupportsSession_ForwardToCallback);
};

class VRService_ExitPresent_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  VRService_ExitPresent_ForwardToCallback(
      VRService::ExitPresentCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  VRService::ExitPresentCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(VRService_ExitPresent_ForwardToCallback);
};

VRServiceProxy::VRServiceProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void VRServiceProxy::SetClient(
    mojo::PendingRemote<VRServiceClient> in_client) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::VRService::SetClient");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kVRService_SetClient_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::VRService_SetClient_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::device::mojom::VRServiceClientInterfaceBase>>(
      in_client, &params->client, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->client),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid client in VRService.SetClient request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VRService::Name_);
  message.set_method_name("SetClient");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void VRServiceProxy::RequestSession(
    XRSessionOptionsPtr in_options, RequestSessionCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::VRService::RequestSession");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kVRService_RequestSession_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::VRService_RequestSession_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->options)::BaseType::BufferWriter
      options_writer;
  mojo::internal::Serialize<::device::mojom::XRSessionOptionsDataView>(
      in_options, buffer, &options_writer, &serialization_context);
  params->options.Set(
      options_writer.is_null() ? nullptr : options_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->options.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null options in VRService.RequestSession request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VRService::Name_);
  message.set_method_name("RequestSession");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new VRService_RequestSession_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void VRServiceProxy::SupportsSession(
    XRSessionOptionsPtr in_options, SupportsSessionCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::VRService::SupportsSession");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kVRService_SupportsSession_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::VRService_SupportsSession_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->options)::BaseType::BufferWriter
      options_writer;
  mojo::internal::Serialize<::device::mojom::XRSessionOptionsDataView>(
      in_options, buffer, &options_writer, &serialization_context);
  params->options.Set(
      options_writer.is_null() ? nullptr : options_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->options.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null options in VRService.SupportsSession request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VRService::Name_);
  message.set_method_name("SupportsSession");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new VRService_SupportsSession_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void VRServiceProxy::ExitPresent(
    ExitPresentCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::VRService::ExitPresent");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kVRService_ExitPresent_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::VRService_ExitPresent_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VRService::Name_);
  message.set_method_name("ExitPresent");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new VRService_ExitPresent_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void VRServiceProxy::SetFramesThrottled(
    bool in_throttled) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::VRService::SetFramesThrottled");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kVRService_SetFramesThrottled_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::VRService_SetFramesThrottled_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->throttled = in_throttled;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VRService::Name_);
  message.set_method_name("SetFramesThrottled");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
class VRService_RequestSession_ProxyToResponder {
 public:
  static VRService::RequestSessionCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<VRService_RequestSession_ProxyToResponder> proxy(
        new VRService_RequestSession_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&VRService_RequestSession_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~VRService_RequestSession_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  VRService_RequestSession_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "VRService::RequestSessionCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      RequestSessionResultPtr in_result);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(VRService_RequestSession_ProxyToResponder);
};

bool VRService_RequestSession_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "device::mojom::VRService::RequestSessionCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::VRService_RequestSession_ResponseParams_Data* params =
      reinterpret_cast<
          internal::VRService_RequestSession_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  RequestSessionResultPtr p_result{};
  VRService_RequestSession_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        VRService::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void VRService_RequestSession_ProxyToResponder::Run(
    RequestSessionResultPtr in_result) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kVRService_RequestSession_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::VRService_RequestSession_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->result)::BufferWriter result_writer;
  result_writer.AllocateInline(buffer, &params->result);
  mojo::internal::Serialize<::device::mojom::RequestSessionResultDataView>(
      in_result, buffer, &result_writer, true, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)device::mojom::VRService::RequestSessionCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VRService::Name_);
  message.set_method_name("RequestSession");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class VRService_SupportsSession_ProxyToResponder {
 public:
  static VRService::SupportsSessionCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<VRService_SupportsSession_ProxyToResponder> proxy(
        new VRService_SupportsSession_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&VRService_SupportsSession_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~VRService_SupportsSession_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  VRService_SupportsSession_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "VRService::SupportsSessionCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_supports_session);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(VRService_SupportsSession_ProxyToResponder);
};

bool VRService_SupportsSession_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "device::mojom::VRService::SupportsSessionCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::VRService_SupportsSession_ResponseParams_Data* params =
      reinterpret_cast<
          internal::VRService_SupportsSession_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  bool p_supports_session{};
  VRService_SupportsSession_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success)
    p_supports_session = input_data_view.supports_session();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        VRService::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_supports_session));
  return true;
}

void VRService_SupportsSession_ProxyToResponder::Run(
    bool in_supports_session) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kVRService_SupportsSession_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::VRService_SupportsSession_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->supports_session = in_supports_session;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)device::mojom::VRService::SupportsSessionCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VRService::Name_);
  message.set_method_name("SupportsSession");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class VRService_ExitPresent_ProxyToResponder {
 public:
  static VRService::ExitPresentCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<VRService_ExitPresent_ProxyToResponder> proxy(
        new VRService_ExitPresent_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&VRService_ExitPresent_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~VRService_ExitPresent_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  VRService_ExitPresent_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "VRService::ExitPresentCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(VRService_ExitPresent_ProxyToResponder);
};

bool VRService_ExitPresent_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "device::mojom::VRService::ExitPresentCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::VRService_ExitPresent_ResponseParams_Data* params =
      reinterpret_cast<
          internal::VRService_ExitPresent_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  VRService_ExitPresent_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        VRService::Name_, 3, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void VRService_ExitPresent_ProxyToResponder::Run(
    ) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kVRService_ExitPresent_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::VRService_ExitPresent_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)device::mojom::VRService::ExitPresentCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VRService::Name_);
  message.set_method_name("ExitPresent");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool VRServiceStubDispatch::Accept(
    VRService* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kVRService_SetClient_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::VRService::SetClient",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::VRService::SetClient");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::VRService_SetClient_Params_Data* params =
          reinterpret_cast<internal::VRService_SetClient_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      mojo::PendingRemote<VRServiceClient> p_client{};
      VRService_SetClient_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success) {
        p_client =
            input_data_view.TakeClient<decltype(p_client)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            VRService::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetClient(
std::move(p_client));
      return true;
    }
    case internal::kVRService_RequestSession_Name: {
      break;
    }
    case internal::kVRService_SupportsSession_Name: {
      break;
    }
    case internal::kVRService_ExitPresent_Name: {
      break;
    }
    case internal::kVRService_SetFramesThrottled_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::VRService::SetFramesThrottled",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::VRService::SetFramesThrottled");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::VRService_SetFramesThrottled_Params_Data* params =
          reinterpret_cast<internal::VRService_SetFramesThrottled_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_throttled{};
      VRService_SetFramesThrottled_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_throttled = input_data_view.throttled();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            VRService::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetFramesThrottled(
std::move(p_throttled));
      return true;
    }
  }
  return false;
}

// static
bool VRServiceStubDispatch::AcceptWithResponder(
    VRService* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kVRService_SetClient_Name: {
      break;
    }
    case internal::kVRService_RequestSession_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::VRService::RequestSession",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::VRService::RequestSession");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::VRService_RequestSession_Params_Data* params =
          reinterpret_cast<
              internal::VRService_RequestSession_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      XRSessionOptionsPtr p_options{};
      VRService_RequestSession_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadOptions(&p_options))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            VRService::Name_, 1, false);
        return false;
      }
      VRService::RequestSessionCallback callback =
          VRService_RequestSession_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RequestSession(
std::move(p_options), std::move(callback));
      return true;
    }
    case internal::kVRService_SupportsSession_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::VRService::SupportsSession",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::VRService::SupportsSession");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::VRService_SupportsSession_Params_Data* params =
          reinterpret_cast<
              internal::VRService_SupportsSession_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      XRSessionOptionsPtr p_options{};
      VRService_SupportsSession_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadOptions(&p_options))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            VRService::Name_, 2, false);
        return false;
      }
      VRService::SupportsSessionCallback callback =
          VRService_SupportsSession_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SupportsSession(
std::move(p_options), std::move(callback));
      return true;
    }
    case internal::kVRService_ExitPresent_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::VRService::ExitPresent",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::VRService::ExitPresent");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::VRService_ExitPresent_Params_Data* params =
          reinterpret_cast<
              internal::VRService_ExitPresent_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      VRService_ExitPresent_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            VRService::Name_, 3, false);
        return false;
      }
      VRService::ExitPresentCallback callback =
          VRService_ExitPresent_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ExitPresent(std::move(callback));
      return true;
    }
    case internal::kVRService_SetFramesThrottled_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kVRServiceValidationInfo[] = {
    {&internal::VRService_SetClient_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::VRService_RequestSession_Params_Data::Validate,
     &internal::VRService_RequestSession_ResponseParams_Data::Validate},
    {&internal::VRService_SupportsSession_Params_Data::Validate,
     &internal::VRService_SupportsSession_ResponseParams_Data::Validate},
    {&internal::VRService_ExitPresent_Params_Data::Validate,
     &internal::VRService_ExitPresent_ResponseParams_Data::Validate},
    {&internal::VRService_SetFramesThrottled_Params_Data::Validate,
     nullptr /* no response */},
};

bool VRServiceRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::device::mojom::VRService::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kVRServiceValidationInfo);
}

bool VRServiceResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::device::mojom::VRService::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kVRServiceValidationInfo);
}
const char XRSessionMetricsRecorder::Name_[] = "device.mojom.XRSessionMetricsRecorder";

XRSessionMetricsRecorderProxy::XRSessionMetricsRecorderProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void XRSessionMetricsRecorderProxy::ReportFeatureUsed(
    XRSessionFeature in_feature) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XRSessionMetricsRecorder::ReportFeatureUsed");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXRSessionMetricsRecorder_ReportFeatureUsed_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XRSessionMetricsRecorder_ReportFeatureUsed_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::device::mojom::XRSessionFeature>(
      in_feature, &params->feature);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XRSessionMetricsRecorder::Name_);
  message.set_method_name("ReportFeatureUsed");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool XRSessionMetricsRecorderStubDispatch::Accept(
    XRSessionMetricsRecorder* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kXRSessionMetricsRecorder_ReportFeatureUsed_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XRSessionMetricsRecorder::ReportFeatureUsed",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XRSessionMetricsRecorder::ReportFeatureUsed");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::XRSessionMetricsRecorder_ReportFeatureUsed_Params_Data* params =
          reinterpret_cast<internal::XRSessionMetricsRecorder_ReportFeatureUsed_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      XRSessionFeature p_feature{};
      XRSessionMetricsRecorder_ReportFeatureUsed_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadFeature(&p_feature))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XRSessionMetricsRecorder::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ReportFeatureUsed(
std::move(p_feature));
      return true;
    }
  }
  return false;
}

// static
bool XRSessionMetricsRecorderStubDispatch::AcceptWithResponder(
    XRSessionMetricsRecorder* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kXRSessionMetricsRecorder_ReportFeatureUsed_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kXRSessionMetricsRecorderValidationInfo[] = {
    {&internal::XRSessionMetricsRecorder_ReportFeatureUsed_Params_Data::Validate,
     nullptr /* no response */},
};

bool XRSessionMetricsRecorderRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::device::mojom::XRSessionMetricsRecorder::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kXRSessionMetricsRecorderValidationInfo);
}

const char VRServiceClient::Name_[] = "device.mojom.VRServiceClient";

VRServiceClientProxy::VRServiceClientProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void VRServiceClientProxy::OnDeviceChanged(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::VRServiceClient::OnDeviceChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kVRServiceClient_OnDeviceChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::VRServiceClient_OnDeviceChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VRServiceClient::Name_);
  message.set_method_name("OnDeviceChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool VRServiceClientStubDispatch::Accept(
    VRServiceClient* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kVRServiceClient_OnDeviceChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::VRServiceClient::OnDeviceChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::VRServiceClient::OnDeviceChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::VRServiceClient_OnDeviceChanged_Params_Data* params =
          reinterpret_cast<internal::VRServiceClient_OnDeviceChanged_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      VRServiceClient_OnDeviceChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            VRServiceClient::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnDeviceChanged();
      return true;
    }
  }
  return false;
}

// static
bool VRServiceClientStubDispatch::AcceptWithResponder(
    VRServiceClient* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kVRServiceClient_OnDeviceChanged_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kVRServiceClientValidationInfo[] = {
    {&internal::VRServiceClient_OnDeviceChanged_Params_Data::Validate,
     nullptr /* no response */},
};

bool VRServiceClientRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::device::mojom::VRServiceClient::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kVRServiceClientValidationInfo);
}

const char XREnvironmentIntegrationProvider::Name_[] = "device.mojom.XREnvironmentIntegrationProvider";

class XREnvironmentIntegrationProvider_RequestHitTest_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  XREnvironmentIntegrationProvider_RequestHitTest_ForwardToCallback(
      XREnvironmentIntegrationProvider::RequestHitTestCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  XREnvironmentIntegrationProvider::RequestHitTestCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(XREnvironmentIntegrationProvider_RequestHitTest_ForwardToCallback);
};

class XREnvironmentIntegrationProvider_SubscribeToHitTest_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  XREnvironmentIntegrationProvider_SubscribeToHitTest_ForwardToCallback(
      XREnvironmentIntegrationProvider::SubscribeToHitTestCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  XREnvironmentIntegrationProvider::SubscribeToHitTestCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(XREnvironmentIntegrationProvider_SubscribeToHitTest_ForwardToCallback);
};

class XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ForwardToCallback(
      XREnvironmentIntegrationProvider::SubscribeToHitTestForTransientInputCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  XREnvironmentIntegrationProvider::SubscribeToHitTestForTransientInputCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ForwardToCallback);
};

class XREnvironmentIntegrationProvider_CreateAnchor_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  XREnvironmentIntegrationProvider_CreateAnchor_ForwardToCallback(
      XREnvironmentIntegrationProvider::CreateAnchorCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  XREnvironmentIntegrationProvider::CreateAnchorCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(XREnvironmentIntegrationProvider_CreateAnchor_ForwardToCallback);
};

class XREnvironmentIntegrationProvider_CreatePlaneAnchor_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  XREnvironmentIntegrationProvider_CreatePlaneAnchor_ForwardToCallback(
      XREnvironmentIntegrationProvider::CreatePlaneAnchorCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  XREnvironmentIntegrationProvider::CreatePlaneAnchorCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(XREnvironmentIntegrationProvider_CreatePlaneAnchor_ForwardToCallback);
};

XREnvironmentIntegrationProviderProxy::XREnvironmentIntegrationProviderProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void XREnvironmentIntegrationProviderProxy::RequestHitTest(
    XRRayPtr in_ray, RequestHitTestCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XREnvironmentIntegrationProvider::RequestHitTest");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXREnvironmentIntegrationProvider_RequestHitTest_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XREnvironmentIntegrationProvider_RequestHitTest_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->ray)::BaseType::BufferWriter
      ray_writer;
  mojo::internal::Serialize<::device::mojom::XRRayDataView>(
      in_ray, buffer, &ray_writer, &serialization_context);
  params->ray.Set(
      ray_writer.is_null() ? nullptr : ray_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->ray.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null ray in XREnvironmentIntegrationProvider.RequestHitTest request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XREnvironmentIntegrationProvider::Name_);
  message.set_method_name("RequestHitTest");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new XREnvironmentIntegrationProvider_RequestHitTest_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void XREnvironmentIntegrationProviderProxy::SubscribeToHitTest(
    XRNativeOriginInformationPtr in_native_origin_information, const std::vector<EntityTypeForHitTest>& in_entity_types, XRRayPtr in_ray, SubscribeToHitTestCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XREnvironmentIntegrationProvider::SubscribeToHitTest");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXREnvironmentIntegrationProvider_SubscribeToHitTest_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XREnvironmentIntegrationProvider_SubscribeToHitTest_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->native_origin_information)::BufferWriter native_origin_information_writer;
  native_origin_information_writer.AllocateInline(buffer, &params->native_origin_information);
  mojo::internal::Serialize<::device::mojom::XRNativeOriginInformationDataView>(
      in_native_origin_information, buffer, &native_origin_information_writer, true, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->native_origin_information.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null native_origin_information in XREnvironmentIntegrationProvider.SubscribeToHitTest request");
  typename decltype(params->entity_types)::BaseType::BufferWriter
      entity_types_writer;
  const mojo::internal::ContainerValidateParams entity_types_validate_params(
      0, ::device::mojom::internal::EntityTypeForHitTest_Data::Validate);
  mojo::internal::Serialize<mojo::ArrayDataView<::device::mojom::EntityTypeForHitTest>>(
      in_entity_types, buffer, &entity_types_writer, &entity_types_validate_params,
      &serialization_context);
  params->entity_types.Set(
      entity_types_writer.is_null() ? nullptr : entity_types_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->entity_types.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null entity_types in XREnvironmentIntegrationProvider.SubscribeToHitTest request");
  typename decltype(params->ray)::BaseType::BufferWriter
      ray_writer;
  mojo::internal::Serialize<::device::mojom::XRRayDataView>(
      in_ray, buffer, &ray_writer, &serialization_context);
  params->ray.Set(
      ray_writer.is_null() ? nullptr : ray_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->ray.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null ray in XREnvironmentIntegrationProvider.SubscribeToHitTest request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XREnvironmentIntegrationProvider::Name_);
  message.set_method_name("SubscribeToHitTest");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new XREnvironmentIntegrationProvider_SubscribeToHitTest_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void XREnvironmentIntegrationProviderProxy::SubscribeToHitTestForTransientInput(
    const std::string& in_profile_name, const std::vector<EntityTypeForHitTest>& in_entity_types, XRRayPtr in_ray, SubscribeToHitTestForTransientInputCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XREnvironmentIntegrationProvider::SubscribeToHitTestForTransientInput");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->profile_name)::BaseType::BufferWriter
      profile_name_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_profile_name, buffer, &profile_name_writer, &serialization_context);
  params->profile_name.Set(
      profile_name_writer.is_null() ? nullptr : profile_name_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->profile_name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null profile_name in XREnvironmentIntegrationProvider.SubscribeToHitTestForTransientInput request");
  typename decltype(params->entity_types)::BaseType::BufferWriter
      entity_types_writer;
  const mojo::internal::ContainerValidateParams entity_types_validate_params(
      0, ::device::mojom::internal::EntityTypeForHitTest_Data::Validate);
  mojo::internal::Serialize<mojo::ArrayDataView<::device::mojom::EntityTypeForHitTest>>(
      in_entity_types, buffer, &entity_types_writer, &entity_types_validate_params,
      &serialization_context);
  params->entity_types.Set(
      entity_types_writer.is_null() ? nullptr : entity_types_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->entity_types.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null entity_types in XREnvironmentIntegrationProvider.SubscribeToHitTestForTransientInput request");
  typename decltype(params->ray)::BaseType::BufferWriter
      ray_writer;
  mojo::internal::Serialize<::device::mojom::XRRayDataView>(
      in_ray, buffer, &ray_writer, &serialization_context);
  params->ray.Set(
      ray_writer.is_null() ? nullptr : ray_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->ray.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null ray in XREnvironmentIntegrationProvider.SubscribeToHitTestForTransientInput request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XREnvironmentIntegrationProvider::Name_);
  message.set_method_name("SubscribeToHitTestForTransientInput");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void XREnvironmentIntegrationProviderProxy::UnsubscribeFromHitTest(
    uint64_t in_subscription_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XREnvironmentIntegrationProvider::UnsubscribeFromHitTest");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->subscription_id = in_subscription_id;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XREnvironmentIntegrationProvider::Name_);
  message.set_method_name("UnsubscribeFromHitTest");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void XREnvironmentIntegrationProviderProxy::CreateAnchor(
    PosePtr in_anchor_pose, CreateAnchorCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XREnvironmentIntegrationProvider::CreateAnchor");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXREnvironmentIntegrationProvider_CreateAnchor_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XREnvironmentIntegrationProvider_CreateAnchor_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->anchor_pose)::BaseType::BufferWriter
      anchor_pose_writer;
  mojo::internal::Serialize<::device::mojom::PoseDataView>(
      in_anchor_pose, buffer, &anchor_pose_writer, &serialization_context);
  params->anchor_pose.Set(
      anchor_pose_writer.is_null() ? nullptr : anchor_pose_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->anchor_pose.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null anchor_pose in XREnvironmentIntegrationProvider.CreateAnchor request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XREnvironmentIntegrationProvider::Name_);
  message.set_method_name("CreateAnchor");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new XREnvironmentIntegrationProvider_CreateAnchor_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void XREnvironmentIntegrationProviderProxy::CreatePlaneAnchor(
    PosePtr in_anchor_pose, uint64_t in_plane_id, CreatePlaneAnchorCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XREnvironmentIntegrationProvider::CreatePlaneAnchor");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXREnvironmentIntegrationProvider_CreatePlaneAnchor_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XREnvironmentIntegrationProvider_CreatePlaneAnchor_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->anchor_pose)::BaseType::BufferWriter
      anchor_pose_writer;
  mojo::internal::Serialize<::device::mojom::PoseDataView>(
      in_anchor_pose, buffer, &anchor_pose_writer, &serialization_context);
  params->anchor_pose.Set(
      anchor_pose_writer.is_null() ? nullptr : anchor_pose_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->anchor_pose.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null anchor_pose in XREnvironmentIntegrationProvider.CreatePlaneAnchor request");
  params->plane_id = in_plane_id;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XREnvironmentIntegrationProvider::Name_);
  message.set_method_name("CreatePlaneAnchor");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new XREnvironmentIntegrationProvider_CreatePlaneAnchor_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void XREnvironmentIntegrationProviderProxy::DetachAnchor(
    uint64_t in_anchor_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XREnvironmentIntegrationProvider::DetachAnchor");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXREnvironmentIntegrationProvider_DetachAnchor_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XREnvironmentIntegrationProvider_DetachAnchor_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->anchor_id = in_anchor_id;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XREnvironmentIntegrationProvider::Name_);
  message.set_method_name("DetachAnchor");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
class XREnvironmentIntegrationProvider_RequestHitTest_ProxyToResponder {
 public:
  static XREnvironmentIntegrationProvider::RequestHitTestCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<XREnvironmentIntegrationProvider_RequestHitTest_ProxyToResponder> proxy(
        new XREnvironmentIntegrationProvider_RequestHitTest_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&XREnvironmentIntegrationProvider_RequestHitTest_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~XREnvironmentIntegrationProvider_RequestHitTest_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  XREnvironmentIntegrationProvider_RequestHitTest_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "XREnvironmentIntegrationProvider::RequestHitTestCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      base::Optional<std::vector<XRHitResultPtr>> in_results);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(XREnvironmentIntegrationProvider_RequestHitTest_ProxyToResponder);
};

bool XREnvironmentIntegrationProvider_RequestHitTest_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "device::mojom::XREnvironmentIntegrationProvider::RequestHitTestCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::XREnvironmentIntegrationProvider_RequestHitTest_ResponseParams_Data* params =
      reinterpret_cast<
          internal::XREnvironmentIntegrationProvider_RequestHitTest_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  base::Optional<std::vector<XRHitResultPtr>> p_results{};
  XREnvironmentIntegrationProvider_RequestHitTest_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadResults(&p_results))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        XREnvironmentIntegrationProvider::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_results));
  return true;
}

void XREnvironmentIntegrationProvider_RequestHitTest_ProxyToResponder::Run(
    base::Optional<std::vector<XRHitResultPtr>> in_results) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXREnvironmentIntegrationProvider_RequestHitTest_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XREnvironmentIntegrationProvider_RequestHitTest_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->results)::BaseType::BufferWriter
      results_writer;
  const mojo::internal::ContainerValidateParams results_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::device::mojom::XRHitResultDataView>>(
      in_results, buffer, &results_writer, &results_validate_params,
      &serialization_context);
  params->results.Set(
      results_writer.is_null() ? nullptr : results_writer.data());
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)device::mojom::XREnvironmentIntegrationProvider::RequestHitTestCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XREnvironmentIntegrationProvider::Name_);
  message.set_method_name("RequestHitTest");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class XREnvironmentIntegrationProvider_SubscribeToHitTest_ProxyToResponder {
 public:
  static XREnvironmentIntegrationProvider::SubscribeToHitTestCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<XREnvironmentIntegrationProvider_SubscribeToHitTest_ProxyToResponder> proxy(
        new XREnvironmentIntegrationProvider_SubscribeToHitTest_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&XREnvironmentIntegrationProvider_SubscribeToHitTest_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~XREnvironmentIntegrationProvider_SubscribeToHitTest_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  XREnvironmentIntegrationProvider_SubscribeToHitTest_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "XREnvironmentIntegrationProvider::SubscribeToHitTestCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      SubscribeToHitTestResult in_result, uint64_t in_subscription_id);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(XREnvironmentIntegrationProvider_SubscribeToHitTest_ProxyToResponder);
};

bool XREnvironmentIntegrationProvider_SubscribeToHitTest_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "device::mojom::XREnvironmentIntegrationProvider::SubscribeToHitTestCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::XREnvironmentIntegrationProvider_SubscribeToHitTest_ResponseParams_Data* params =
      reinterpret_cast<
          internal::XREnvironmentIntegrationProvider_SubscribeToHitTest_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  SubscribeToHitTestResult p_result{};
  uint64_t p_subscription_id{};
  XREnvironmentIntegrationProvider_SubscribeToHitTest_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (success)
    p_subscription_id = input_data_view.subscription_id();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        XREnvironmentIntegrationProvider::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_subscription_id));
  return true;
}

void XREnvironmentIntegrationProvider_SubscribeToHitTest_ProxyToResponder::Run(
    SubscribeToHitTestResult in_result, uint64_t in_subscription_id) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXREnvironmentIntegrationProvider_SubscribeToHitTest_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XREnvironmentIntegrationProvider_SubscribeToHitTest_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::device::mojom::SubscribeToHitTestResult>(
      in_result, &params->result);
  params->subscription_id = in_subscription_id;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)device::mojom::XREnvironmentIntegrationProvider::SubscribeToHitTestCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XREnvironmentIntegrationProvider::Name_);
  message.set_method_name("SubscribeToHitTest");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ProxyToResponder {
 public:
  static XREnvironmentIntegrationProvider::SubscribeToHitTestForTransientInputCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ProxyToResponder> proxy(
        new XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "XREnvironmentIntegrationProvider::SubscribeToHitTestForTransientInputCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      SubscribeToHitTestResult in_result, uint64_t in_subscription_id);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ProxyToResponder);
};

bool XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "device::mojom::XREnvironmentIntegrationProvider::SubscribeToHitTestForTransientInputCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ResponseParams_Data* params =
      reinterpret_cast<
          internal::XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  SubscribeToHitTestResult p_result{};
  uint64_t p_subscription_id{};
  XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (success)
    p_subscription_id = input_data_view.subscription_id();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        XREnvironmentIntegrationProvider::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_subscription_id));
  return true;
}

void XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ProxyToResponder::Run(
    SubscribeToHitTestResult in_result, uint64_t in_subscription_id) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::device::mojom::SubscribeToHitTestResult>(
      in_result, &params->result);
  params->subscription_id = in_subscription_id;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)device::mojom::XREnvironmentIntegrationProvider::SubscribeToHitTestForTransientInputCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XREnvironmentIntegrationProvider::Name_);
  message.set_method_name("SubscribeToHitTestForTransientInput");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class XREnvironmentIntegrationProvider_CreateAnchor_ProxyToResponder {
 public:
  static XREnvironmentIntegrationProvider::CreateAnchorCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<XREnvironmentIntegrationProvider_CreateAnchor_ProxyToResponder> proxy(
        new XREnvironmentIntegrationProvider_CreateAnchor_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&XREnvironmentIntegrationProvider_CreateAnchor_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~XREnvironmentIntegrationProvider_CreateAnchor_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  XREnvironmentIntegrationProvider_CreateAnchor_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "XREnvironmentIntegrationProvider::CreateAnchorCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      CreateAnchorResult in_result, uint64_t in_anchor_id);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(XREnvironmentIntegrationProvider_CreateAnchor_ProxyToResponder);
};

bool XREnvironmentIntegrationProvider_CreateAnchor_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "device::mojom::XREnvironmentIntegrationProvider::CreateAnchorCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::XREnvironmentIntegrationProvider_CreateAnchor_ResponseParams_Data* params =
      reinterpret_cast<
          internal::XREnvironmentIntegrationProvider_CreateAnchor_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  CreateAnchorResult p_result{};
  uint64_t p_anchor_id{};
  XREnvironmentIntegrationProvider_CreateAnchor_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (success)
    p_anchor_id = input_data_view.anchor_id();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        XREnvironmentIntegrationProvider::Name_, 4, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_anchor_id));
  return true;
}

void XREnvironmentIntegrationProvider_CreateAnchor_ProxyToResponder::Run(
    CreateAnchorResult in_result, uint64_t in_anchor_id) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXREnvironmentIntegrationProvider_CreateAnchor_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XREnvironmentIntegrationProvider_CreateAnchor_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::device::mojom::CreateAnchorResult>(
      in_result, &params->result);
  params->anchor_id = in_anchor_id;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)device::mojom::XREnvironmentIntegrationProvider::CreateAnchorCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XREnvironmentIntegrationProvider::Name_);
  message.set_method_name("CreateAnchor");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class XREnvironmentIntegrationProvider_CreatePlaneAnchor_ProxyToResponder {
 public:
  static XREnvironmentIntegrationProvider::CreatePlaneAnchorCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<XREnvironmentIntegrationProvider_CreatePlaneAnchor_ProxyToResponder> proxy(
        new XREnvironmentIntegrationProvider_CreatePlaneAnchor_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&XREnvironmentIntegrationProvider_CreatePlaneAnchor_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~XREnvironmentIntegrationProvider_CreatePlaneAnchor_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  XREnvironmentIntegrationProvider_CreatePlaneAnchor_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "XREnvironmentIntegrationProvider::CreatePlaneAnchorCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      CreateAnchorResult in_result, uint64_t in_anchor_id);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(XREnvironmentIntegrationProvider_CreatePlaneAnchor_ProxyToResponder);
};

bool XREnvironmentIntegrationProvider_CreatePlaneAnchor_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "device::mojom::XREnvironmentIntegrationProvider::CreatePlaneAnchorCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::XREnvironmentIntegrationProvider_CreatePlaneAnchor_ResponseParams_Data* params =
      reinterpret_cast<
          internal::XREnvironmentIntegrationProvider_CreatePlaneAnchor_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  CreateAnchorResult p_result{};
  uint64_t p_anchor_id{};
  XREnvironmentIntegrationProvider_CreatePlaneAnchor_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (success)
    p_anchor_id = input_data_view.anchor_id();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        XREnvironmentIntegrationProvider::Name_, 5, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_anchor_id));
  return true;
}

void XREnvironmentIntegrationProvider_CreatePlaneAnchor_ProxyToResponder::Run(
    CreateAnchorResult in_result, uint64_t in_anchor_id) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXREnvironmentIntegrationProvider_CreatePlaneAnchor_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XREnvironmentIntegrationProvider_CreatePlaneAnchor_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::device::mojom::CreateAnchorResult>(
      in_result, &params->result);
  params->anchor_id = in_anchor_id;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)device::mojom::XREnvironmentIntegrationProvider::CreatePlaneAnchorCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XREnvironmentIntegrationProvider::Name_);
  message.set_method_name("CreatePlaneAnchor");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool XREnvironmentIntegrationProviderStubDispatch::Accept(
    XREnvironmentIntegrationProvider* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kXREnvironmentIntegrationProvider_RequestHitTest_Name: {
      break;
    }
    case internal::kXREnvironmentIntegrationProvider_SubscribeToHitTest_Name: {
      break;
    }
    case internal::kXREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Name: {
      break;
    }
    case internal::kXREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XREnvironmentIntegrationProvider::UnsubscribeFromHitTest",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XREnvironmentIntegrationProvider::UnsubscribeFromHitTest");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::XREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Params_Data* params =
          reinterpret_cast<internal::XREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      uint64_t p_subscription_id{};
      XREnvironmentIntegrationProvider_UnsubscribeFromHitTest_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_subscription_id = input_data_view.subscription_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XREnvironmentIntegrationProvider::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UnsubscribeFromHitTest(
std::move(p_subscription_id));
      return true;
    }
    case internal::kXREnvironmentIntegrationProvider_CreateAnchor_Name: {
      break;
    }
    case internal::kXREnvironmentIntegrationProvider_CreatePlaneAnchor_Name: {
      break;
    }
    case internal::kXREnvironmentIntegrationProvider_DetachAnchor_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XREnvironmentIntegrationProvider::DetachAnchor",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XREnvironmentIntegrationProvider::DetachAnchor");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::XREnvironmentIntegrationProvider_DetachAnchor_Params_Data* params =
          reinterpret_cast<internal::XREnvironmentIntegrationProvider_DetachAnchor_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      uint64_t p_anchor_id{};
      XREnvironmentIntegrationProvider_DetachAnchor_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_anchor_id = input_data_view.anchor_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XREnvironmentIntegrationProvider::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DetachAnchor(
std::move(p_anchor_id));
      return true;
    }
  }
  return false;
}

// static
bool XREnvironmentIntegrationProviderStubDispatch::AcceptWithResponder(
    XREnvironmentIntegrationProvider* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kXREnvironmentIntegrationProvider_RequestHitTest_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XREnvironmentIntegrationProvider::RequestHitTest",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XREnvironmentIntegrationProvider::RequestHitTest");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::XREnvironmentIntegrationProvider_RequestHitTest_Params_Data* params =
          reinterpret_cast<
              internal::XREnvironmentIntegrationProvider_RequestHitTest_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      XRRayPtr p_ray{};
      XREnvironmentIntegrationProvider_RequestHitTest_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadRay(&p_ray))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XREnvironmentIntegrationProvider::Name_, 0, false);
        return false;
      }
      XREnvironmentIntegrationProvider::RequestHitTestCallback callback =
          XREnvironmentIntegrationProvider_RequestHitTest_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RequestHitTest(
std::move(p_ray), std::move(callback));
      return true;
    }
    case internal::kXREnvironmentIntegrationProvider_SubscribeToHitTest_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XREnvironmentIntegrationProvider::SubscribeToHitTest",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XREnvironmentIntegrationProvider::SubscribeToHitTest");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::XREnvironmentIntegrationProvider_SubscribeToHitTest_Params_Data* params =
          reinterpret_cast<
              internal::XREnvironmentIntegrationProvider_SubscribeToHitTest_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      XRNativeOriginInformationPtr p_native_origin_information{};
      std::vector<EntityTypeForHitTest> p_entity_types{};
      XRRayPtr p_ray{};
      XREnvironmentIntegrationProvider_SubscribeToHitTest_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadNativeOriginInformation(&p_native_origin_information))
        success = false;
      if (success && !input_data_view.ReadEntityTypes(&p_entity_types))
        success = false;
      if (success && !input_data_view.ReadRay(&p_ray))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XREnvironmentIntegrationProvider::Name_, 1, false);
        return false;
      }
      XREnvironmentIntegrationProvider::SubscribeToHitTestCallback callback =
          XREnvironmentIntegrationProvider_SubscribeToHitTest_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SubscribeToHitTest(
std::move(p_native_origin_information), 
std::move(p_entity_types), 
std::move(p_ray), std::move(callback));
      return true;
    }
    case internal::kXREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XREnvironmentIntegrationProvider::SubscribeToHitTestForTransientInput",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XREnvironmentIntegrationProvider::SubscribeToHitTestForTransientInput");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Params_Data* params =
          reinterpret_cast<
              internal::XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      std::string p_profile_name{};
      std::vector<EntityTypeForHitTest> p_entity_types{};
      XRRayPtr p_ray{};
      XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadProfileName(&p_profile_name))
        success = false;
      if (success && !input_data_view.ReadEntityTypes(&p_entity_types))
        success = false;
      if (success && !input_data_view.ReadRay(&p_ray))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XREnvironmentIntegrationProvider::Name_, 2, false);
        return false;
      }
      XREnvironmentIntegrationProvider::SubscribeToHitTestForTransientInputCallback callback =
          XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SubscribeToHitTestForTransientInput(
std::move(p_profile_name), 
std::move(p_entity_types), 
std::move(p_ray), std::move(callback));
      return true;
    }
    case internal::kXREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Name: {
      break;
    }
    case internal::kXREnvironmentIntegrationProvider_CreateAnchor_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XREnvironmentIntegrationProvider::CreateAnchor",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XREnvironmentIntegrationProvider::CreateAnchor");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::XREnvironmentIntegrationProvider_CreateAnchor_Params_Data* params =
          reinterpret_cast<
              internal::XREnvironmentIntegrationProvider_CreateAnchor_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      PosePtr p_anchor_pose{};
      XREnvironmentIntegrationProvider_CreateAnchor_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadAnchorPose(&p_anchor_pose))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XREnvironmentIntegrationProvider::Name_, 4, false);
        return false;
      }
      XREnvironmentIntegrationProvider::CreateAnchorCallback callback =
          XREnvironmentIntegrationProvider_CreateAnchor_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateAnchor(
std::move(p_anchor_pose), std::move(callback));
      return true;
    }
    case internal::kXREnvironmentIntegrationProvider_CreatePlaneAnchor_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XREnvironmentIntegrationProvider::CreatePlaneAnchor",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XREnvironmentIntegrationProvider::CreatePlaneAnchor");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::XREnvironmentIntegrationProvider_CreatePlaneAnchor_Params_Data* params =
          reinterpret_cast<
              internal::XREnvironmentIntegrationProvider_CreatePlaneAnchor_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      PosePtr p_anchor_pose{};
      uint64_t p_plane_id{};
      XREnvironmentIntegrationProvider_CreatePlaneAnchor_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadAnchorPose(&p_anchor_pose))
        success = false;
      if (success)
        p_plane_id = input_data_view.plane_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XREnvironmentIntegrationProvider::Name_, 5, false);
        return false;
      }
      XREnvironmentIntegrationProvider::CreatePlaneAnchorCallback callback =
          XREnvironmentIntegrationProvider_CreatePlaneAnchor_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreatePlaneAnchor(
std::move(p_anchor_pose), 
std::move(p_plane_id), std::move(callback));
      return true;
    }
    case internal::kXREnvironmentIntegrationProvider_DetachAnchor_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kXREnvironmentIntegrationProviderValidationInfo[] = {
    {&internal::XREnvironmentIntegrationProvider_RequestHitTest_Params_Data::Validate,
     &internal::XREnvironmentIntegrationProvider_RequestHitTest_ResponseParams_Data::Validate},
    {&internal::XREnvironmentIntegrationProvider_SubscribeToHitTest_Params_Data::Validate,
     &internal::XREnvironmentIntegrationProvider_SubscribeToHitTest_ResponseParams_Data::Validate},
    {&internal::XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Params_Data::Validate,
     &internal::XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ResponseParams_Data::Validate},
    {&internal::XREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::XREnvironmentIntegrationProvider_CreateAnchor_Params_Data::Validate,
     &internal::XREnvironmentIntegrationProvider_CreateAnchor_ResponseParams_Data::Validate},
    {&internal::XREnvironmentIntegrationProvider_CreatePlaneAnchor_Params_Data::Validate,
     &internal::XREnvironmentIntegrationProvider_CreatePlaneAnchor_ResponseParams_Data::Validate},
    {&internal::XREnvironmentIntegrationProvider_DetachAnchor_Params_Data::Validate,
     nullptr /* no response */},
};

bool XREnvironmentIntegrationProviderRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::device::mojom::XREnvironmentIntegrationProvider::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kXREnvironmentIntegrationProviderValidationInfo);
}

bool XREnvironmentIntegrationProviderResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::device::mojom::XREnvironmentIntegrationProvider::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kXREnvironmentIntegrationProviderValidationInfo);
}
const char XRInputSourceButtonListener::Name_[] = "device.mojom.XRInputSourceButtonListener";

XRInputSourceButtonListenerProxy::XRInputSourceButtonListenerProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void XRInputSourceButtonListenerProxy::OnButtonEvent(
    XRInputSourceStatePtr in_input_source) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XRInputSourceButtonListener::OnButtonEvent");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXRInputSourceButtonListener_OnButtonEvent_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XRInputSourceButtonListener_OnButtonEvent_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->input_source)::BaseType::BufferWriter
      input_source_writer;
  mojo::internal::Serialize<::device::mojom::XRInputSourceStateDataView>(
      in_input_source, buffer, &input_source_writer, &serialization_context);
  params->input_source.Set(
      input_source_writer.is_null() ? nullptr : input_source_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->input_source.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null input_source in XRInputSourceButtonListener.OnButtonEvent request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XRInputSourceButtonListener::Name_);
  message.set_method_name("OnButtonEvent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool XRInputSourceButtonListenerStubDispatch::Accept(
    XRInputSourceButtonListener* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kXRInputSourceButtonListener_OnButtonEvent_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XRInputSourceButtonListener::OnButtonEvent",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XRInputSourceButtonListener::OnButtonEvent");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::XRInputSourceButtonListener_OnButtonEvent_Params_Data* params =
          reinterpret_cast<internal::XRInputSourceButtonListener_OnButtonEvent_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      XRInputSourceStatePtr p_input_source{};
      XRInputSourceButtonListener_OnButtonEvent_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadInputSource(&p_input_source))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XRInputSourceButtonListener::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnButtonEvent(
std::move(p_input_source));
      return true;
    }
  }
  return false;
}

// static
bool XRInputSourceButtonListenerStubDispatch::AcceptWithResponder(
    XRInputSourceButtonListener* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kXRInputSourceButtonListener_OnButtonEvent_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kXRInputSourceButtonListenerValidationInfo[] = {
    {&internal::XRInputSourceButtonListener_OnButtonEvent_Params_Data::Validate,
     nullptr /* no response */},
};

bool XRInputSourceButtonListenerRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::device::mojom::XRInputSourceButtonListener::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kXRInputSourceButtonListenerValidationInfo);
}

const char XRFrameDataProvider::Name_[] = "device.mojom.XRFrameDataProvider";

class XRFrameDataProvider_GetFrameData_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  XRFrameDataProvider_GetFrameData_ForwardToCallback(
      XRFrameDataProvider::GetFrameDataCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  XRFrameDataProvider::GetFrameDataCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(XRFrameDataProvider_GetFrameData_ForwardToCallback);
};

XRFrameDataProviderProxy::XRFrameDataProviderProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void XRFrameDataProviderProxy::GetFrameData(
    XRFrameDataRequestOptionsPtr in_options, GetFrameDataCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XRFrameDataProvider::GetFrameData");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXRFrameDataProvider_GetFrameData_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XRFrameDataProvider_GetFrameData_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->options)::BaseType::BufferWriter
      options_writer;
  mojo::internal::Serialize<::device::mojom::XRFrameDataRequestOptionsDataView>(
      in_options, buffer, &options_writer, &serialization_context);
  params->options.Set(
      options_writer.is_null() ? nullptr : options_writer.data());
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XRFrameDataProvider::Name_);
  message.set_method_name("GetFrameData");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new XRFrameDataProvider_GetFrameData_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void XRFrameDataProviderProxy::GetEnvironmentIntegrationProvider(
    mojo::PendingAssociatedReceiver<XREnvironmentIntegrationProvider> in_environment_provider) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XRFrameDataProvider::GetEnvironmentIntegrationProvider");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXRFrameDataProvider_GetEnvironmentIntegrationProvider_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XRFrameDataProvider_GetEnvironmentIntegrationProvider_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::device::mojom::XREnvironmentIntegrationProviderAssociatedRequestDataView>(
      in_environment_provider, &params->environment_provider, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->environment_provider),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid environment_provider in XRFrameDataProvider.GetEnvironmentIntegrationProvider request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XRFrameDataProvider::Name_);
  message.set_method_name("GetEnvironmentIntegrationProvider");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void XRFrameDataProviderProxy::SetInputSourceButtonListener(
    mojo::PendingAssociatedRemote<XRInputSourceButtonListener> in_event_listener) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XRFrameDataProvider::SetInputSourceButtonListener");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXRFrameDataProvider_SetInputSourceButtonListener_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XRFrameDataProvider_SetInputSourceButtonListener_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::device::mojom::XRInputSourceButtonListenerAssociatedPtrInfoDataView>(
      in_event_listener, &params->event_listener, &serialization_context);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XRFrameDataProvider::Name_);
  message.set_method_name("SetInputSourceButtonListener");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
class XRFrameDataProvider_GetFrameData_ProxyToResponder {
 public:
  static XRFrameDataProvider::GetFrameDataCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<XRFrameDataProvider_GetFrameData_ProxyToResponder> proxy(
        new XRFrameDataProvider_GetFrameData_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&XRFrameDataProvider_GetFrameData_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~XRFrameDataProvider_GetFrameData_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  XRFrameDataProvider_GetFrameData_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "XRFrameDataProvider::GetFrameDataCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      XRFrameDataPtr in_frame_data);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(XRFrameDataProvider_GetFrameData_ProxyToResponder);
};

bool XRFrameDataProvider_GetFrameData_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "device::mojom::XRFrameDataProvider::GetFrameDataCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::XRFrameDataProvider_GetFrameData_ResponseParams_Data* params =
      reinterpret_cast<
          internal::XRFrameDataProvider_GetFrameData_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  XRFrameDataPtr p_frame_data{};
  XRFrameDataProvider_GetFrameData_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadFrameData(&p_frame_data))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        XRFrameDataProvider::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_frame_data));
  return true;
}

void XRFrameDataProvider_GetFrameData_ProxyToResponder::Run(
    XRFrameDataPtr in_frame_data) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXRFrameDataProvider_GetFrameData_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XRFrameDataProvider_GetFrameData_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->frame_data)::BaseType::BufferWriter
      frame_data_writer;
  mojo::internal::Serialize<::device::mojom::XRFrameDataDataView>(
      in_frame_data, buffer, &frame_data_writer, &serialization_context);
  params->frame_data.Set(
      frame_data_writer.is_null() ? nullptr : frame_data_writer.data());
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)device::mojom::XRFrameDataProvider::GetFrameDataCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XRFrameDataProvider::Name_);
  message.set_method_name("GetFrameData");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool XRFrameDataProviderStubDispatch::Accept(
    XRFrameDataProvider* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kXRFrameDataProvider_GetFrameData_Name: {
      break;
    }
    case internal::kXRFrameDataProvider_GetEnvironmentIntegrationProvider_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XRFrameDataProvider::GetEnvironmentIntegrationProvider",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XRFrameDataProvider::GetEnvironmentIntegrationProvider");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::XRFrameDataProvider_GetEnvironmentIntegrationProvider_Params_Data* params =
          reinterpret_cast<internal::XRFrameDataProvider_GetEnvironmentIntegrationProvider_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      mojo::PendingAssociatedReceiver<XREnvironmentIntegrationProvider> p_environment_provider{};
      XRFrameDataProvider_GetEnvironmentIntegrationProvider_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success) {
        p_environment_provider =
            input_data_view.TakeEnvironmentProvider<decltype(p_environment_provider)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XRFrameDataProvider::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetEnvironmentIntegrationProvider(
std::move(p_environment_provider));
      return true;
    }
    case internal::kXRFrameDataProvider_SetInputSourceButtonListener_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XRFrameDataProvider::SetInputSourceButtonListener",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XRFrameDataProvider::SetInputSourceButtonListener");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::XRFrameDataProvider_SetInputSourceButtonListener_Params_Data* params =
          reinterpret_cast<internal::XRFrameDataProvider_SetInputSourceButtonListener_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      mojo::PendingAssociatedRemote<XRInputSourceButtonListener> p_event_listener{};
      XRFrameDataProvider_SetInputSourceButtonListener_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success) {
        p_event_listener =
            input_data_view.TakeEventListener<decltype(p_event_listener)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XRFrameDataProvider::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetInputSourceButtonListener(
std::move(p_event_listener));
      return true;
    }
  }
  return false;
}

// static
bool XRFrameDataProviderStubDispatch::AcceptWithResponder(
    XRFrameDataProvider* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kXRFrameDataProvider_GetFrameData_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XRFrameDataProvider::GetFrameData",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XRFrameDataProvider::GetFrameData");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::XRFrameDataProvider_GetFrameData_Params_Data* params =
          reinterpret_cast<
              internal::XRFrameDataProvider_GetFrameData_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      XRFrameDataRequestOptionsPtr p_options{};
      XRFrameDataProvider_GetFrameData_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadOptions(&p_options))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XRFrameDataProvider::Name_, 0, false);
        return false;
      }
      XRFrameDataProvider::GetFrameDataCallback callback =
          XRFrameDataProvider_GetFrameData_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetFrameData(
std::move(p_options), std::move(callback));
      return true;
    }
    case internal::kXRFrameDataProvider_GetEnvironmentIntegrationProvider_Name: {
      break;
    }
    case internal::kXRFrameDataProvider_SetInputSourceButtonListener_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kXRFrameDataProviderValidationInfo[] = {
    {&internal::XRFrameDataProvider_GetFrameData_Params_Data::Validate,
     &internal::XRFrameDataProvider_GetFrameData_ResponseParams_Data::Validate},
    {&internal::XRFrameDataProvider_GetEnvironmentIntegrationProvider_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::XRFrameDataProvider_SetInputSourceButtonListener_Params_Data::Validate,
     nullptr /* no response */},
};

bool XRFrameDataProviderRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::device::mojom::XRFrameDataProvider::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kXRFrameDataProviderValidationInfo);
}

bool XRFrameDataProviderResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::device::mojom::XRFrameDataProvider::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kXRFrameDataProviderValidationInfo);
}
const char XRPresentationProvider::Name_[] = "device.mojom.XRPresentationProvider";

XRPresentationProviderProxy::XRPresentationProviderProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void XRPresentationProviderProxy::UpdateLayerBounds(
    int16_t in_frame_id, const ::gfx::RectF& in_left_bounds, const ::gfx::RectF& in_right_bounds, const ::gfx::Size& in_source_size) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XRPresentationProvider::UpdateLayerBounds");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXRPresentationProvider_UpdateLayerBounds_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XRPresentationProvider_UpdateLayerBounds_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->frame_id = in_frame_id;
  typename decltype(params->left_bounds)::BaseType::BufferWriter
      left_bounds_writer;
  mojo::internal::Serialize<::gfx::mojom::RectFDataView>(
      in_left_bounds, buffer, &left_bounds_writer, &serialization_context);
  params->left_bounds.Set(
      left_bounds_writer.is_null() ? nullptr : left_bounds_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->left_bounds.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null left_bounds in XRPresentationProvider.UpdateLayerBounds request");
  typename decltype(params->right_bounds)::BaseType::BufferWriter
      right_bounds_writer;
  mojo::internal::Serialize<::gfx::mojom::RectFDataView>(
      in_right_bounds, buffer, &right_bounds_writer, &serialization_context);
  params->right_bounds.Set(
      right_bounds_writer.is_null() ? nullptr : right_bounds_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->right_bounds.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null right_bounds in XRPresentationProvider.UpdateLayerBounds request");
  typename decltype(params->source_size)::BaseType::BufferWriter
      source_size_writer;
  mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
      in_source_size, buffer, &source_size_writer, &serialization_context);
  params->source_size.Set(
      source_size_writer.is_null() ? nullptr : source_size_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->source_size.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null source_size in XRPresentationProvider.UpdateLayerBounds request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XRPresentationProvider::Name_);
  message.set_method_name("UpdateLayerBounds");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void XRPresentationProviderProxy::SubmitFrameMissing(
    int16_t in_frame_id, const ::gpu::SyncToken& in_sync_token) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XRPresentationProvider::SubmitFrameMissing");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXRPresentationProvider_SubmitFrameMissing_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XRPresentationProvider_SubmitFrameMissing_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->frame_id = in_frame_id;
  typename decltype(params->sync_token)::BaseType::BufferWriter
      sync_token_writer;
  mojo::internal::Serialize<::gpu::mojom::SyncTokenDataView>(
      in_sync_token, buffer, &sync_token_writer, &serialization_context);
  params->sync_token.Set(
      sync_token_writer.is_null() ? nullptr : sync_token_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->sync_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null sync_token in XRPresentationProvider.SubmitFrameMissing request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XRPresentationProvider::Name_);
  message.set_method_name("SubmitFrameMissing");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void XRPresentationProviderProxy::SubmitFrame(
    int16_t in_frame_id, const ::gpu::MailboxHolder& in_mailbox_holder, ::base::TimeDelta in_time_waited) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XRPresentationProvider::SubmitFrame");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXRPresentationProvider_SubmitFrame_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XRPresentationProvider_SubmitFrame_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->frame_id = in_frame_id;
  typename decltype(params->mailbox_holder)::BaseType::BufferWriter
      mailbox_holder_writer;
  mojo::internal::Serialize<::gpu::mojom::MailboxHolderDataView>(
      in_mailbox_holder, buffer, &mailbox_holder_writer, &serialization_context);
  params->mailbox_holder.Set(
      mailbox_holder_writer.is_null() ? nullptr : mailbox_holder_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->mailbox_holder.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null mailbox_holder in XRPresentationProvider.SubmitFrame request");
  typename decltype(params->time_waited)::BaseType::BufferWriter
      time_waited_writer;
  mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
      in_time_waited, buffer, &time_waited_writer, &serialization_context);
  params->time_waited.Set(
      time_waited_writer.is_null() ? nullptr : time_waited_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->time_waited.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null time_waited in XRPresentationProvider.SubmitFrame request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XRPresentationProvider::Name_);
  message.set_method_name("SubmitFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void XRPresentationProviderProxy::SubmitFrameWithTextureHandle(
    int16_t in_frameId, mojo::ScopedHandle in_texture) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XRPresentationProvider::SubmitFrameWithTextureHandle");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXRPresentationProvider_SubmitFrameWithTextureHandle_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XRPresentationProvider_SubmitFrameWithTextureHandle_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->frameId = in_frameId;
  mojo::internal::Serialize<mojo::ScopedHandle>(
      in_texture, &params->texture, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->texture),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid texture in XRPresentationProvider.SubmitFrameWithTextureHandle request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XRPresentationProvider::Name_);
  message.set_method_name("SubmitFrameWithTextureHandle");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void XRPresentationProviderProxy::SubmitFrameDrawnIntoTexture(
    int16_t in_frameId, const ::gpu::SyncToken& in_sync_token, ::base::TimeDelta in_time_waited) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XRPresentationProvider::SubmitFrameDrawnIntoTexture");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXRPresentationProvider_SubmitFrameDrawnIntoTexture_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XRPresentationProvider_SubmitFrameDrawnIntoTexture_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->frameId = in_frameId;
  typename decltype(params->sync_token)::BaseType::BufferWriter
      sync_token_writer;
  mojo::internal::Serialize<::gpu::mojom::SyncTokenDataView>(
      in_sync_token, buffer, &sync_token_writer, &serialization_context);
  params->sync_token.Set(
      sync_token_writer.is_null() ? nullptr : sync_token_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->sync_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null sync_token in XRPresentationProvider.SubmitFrameDrawnIntoTexture request");
  typename decltype(params->time_waited)::BaseType::BufferWriter
      time_waited_writer;
  mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
      in_time_waited, buffer, &time_waited_writer, &serialization_context);
  params->time_waited.Set(
      time_waited_writer.is_null() ? nullptr : time_waited_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->time_waited.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null time_waited in XRPresentationProvider.SubmitFrameDrawnIntoTexture request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XRPresentationProvider::Name_);
  message.set_method_name("SubmitFrameDrawnIntoTexture");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool XRPresentationProviderStubDispatch::Accept(
    XRPresentationProvider* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kXRPresentationProvider_UpdateLayerBounds_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XRPresentationProvider::UpdateLayerBounds",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XRPresentationProvider::UpdateLayerBounds");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::XRPresentationProvider_UpdateLayerBounds_Params_Data* params =
          reinterpret_cast<internal::XRPresentationProvider_UpdateLayerBounds_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int16_t p_frame_id{};
      ::gfx::RectF p_left_bounds{};
      ::gfx::RectF p_right_bounds{};
      ::gfx::Size p_source_size{};
      XRPresentationProvider_UpdateLayerBounds_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_frame_id = input_data_view.frame_id();
      if (success && !input_data_view.ReadLeftBounds(&p_left_bounds))
        success = false;
      if (success && !input_data_view.ReadRightBounds(&p_right_bounds))
        success = false;
      if (success && !input_data_view.ReadSourceSize(&p_source_size))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XRPresentationProvider::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateLayerBounds(
std::move(p_frame_id), 
std::move(p_left_bounds), 
std::move(p_right_bounds), 
std::move(p_source_size));
      return true;
    }
    case internal::kXRPresentationProvider_SubmitFrameMissing_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XRPresentationProvider::SubmitFrameMissing",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XRPresentationProvider::SubmitFrameMissing");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::XRPresentationProvider_SubmitFrameMissing_Params_Data* params =
          reinterpret_cast<internal::XRPresentationProvider_SubmitFrameMissing_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int16_t p_frame_id{};
      ::gpu::SyncToken p_sync_token{};
      XRPresentationProvider_SubmitFrameMissing_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_frame_id = input_data_view.frame_id();
      if (success && !input_data_view.ReadSyncToken(&p_sync_token))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XRPresentationProvider::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SubmitFrameMissing(
std::move(p_frame_id), 
std::move(p_sync_token));
      return true;
    }
    case internal::kXRPresentationProvider_SubmitFrame_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XRPresentationProvider::SubmitFrame",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XRPresentationProvider::SubmitFrame");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::XRPresentationProvider_SubmitFrame_Params_Data* params =
          reinterpret_cast<internal::XRPresentationProvider_SubmitFrame_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int16_t p_frame_id{};
      ::gpu::MailboxHolder p_mailbox_holder{};
      ::base::TimeDelta p_time_waited{};
      XRPresentationProvider_SubmitFrame_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_frame_id = input_data_view.frame_id();
      if (success && !input_data_view.ReadMailboxHolder(&p_mailbox_holder))
        success = false;
      if (success && !input_data_view.ReadTimeWaited(&p_time_waited))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XRPresentationProvider::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SubmitFrame(
std::move(p_frame_id), 
std::move(p_mailbox_holder), 
std::move(p_time_waited));
      return true;
    }
    case internal::kXRPresentationProvider_SubmitFrameWithTextureHandle_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XRPresentationProvider::SubmitFrameWithTextureHandle",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XRPresentationProvider::SubmitFrameWithTextureHandle");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::XRPresentationProvider_SubmitFrameWithTextureHandle_Params_Data* params =
          reinterpret_cast<internal::XRPresentationProvider_SubmitFrameWithTextureHandle_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int16_t p_frameId{};
      mojo::ScopedHandle p_texture{};
      XRPresentationProvider_SubmitFrameWithTextureHandle_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_frameId = input_data_view.frameId();
      if (success)
        p_texture = input_data_view.TakeTexture();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XRPresentationProvider::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SubmitFrameWithTextureHandle(
std::move(p_frameId), 
std::move(p_texture));
      return true;
    }
    case internal::kXRPresentationProvider_SubmitFrameDrawnIntoTexture_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XRPresentationProvider::SubmitFrameDrawnIntoTexture",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XRPresentationProvider::SubmitFrameDrawnIntoTexture");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::XRPresentationProvider_SubmitFrameDrawnIntoTexture_Params_Data* params =
          reinterpret_cast<internal::XRPresentationProvider_SubmitFrameDrawnIntoTexture_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int16_t p_frameId{};
      ::gpu::SyncToken p_sync_token{};
      ::base::TimeDelta p_time_waited{};
      XRPresentationProvider_SubmitFrameDrawnIntoTexture_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_frameId = input_data_view.frameId();
      if (success && !input_data_view.ReadSyncToken(&p_sync_token))
        success = false;
      if (success && !input_data_view.ReadTimeWaited(&p_time_waited))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XRPresentationProvider::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SubmitFrameDrawnIntoTexture(
std::move(p_frameId), 
std::move(p_sync_token), 
std::move(p_time_waited));
      return true;
    }
  }
  return false;
}

// static
bool XRPresentationProviderStubDispatch::AcceptWithResponder(
    XRPresentationProvider* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kXRPresentationProvider_UpdateLayerBounds_Name: {
      break;
    }
    case internal::kXRPresentationProvider_SubmitFrameMissing_Name: {
      break;
    }
    case internal::kXRPresentationProvider_SubmitFrame_Name: {
      break;
    }
    case internal::kXRPresentationProvider_SubmitFrameWithTextureHandle_Name: {
      break;
    }
    case internal::kXRPresentationProvider_SubmitFrameDrawnIntoTexture_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kXRPresentationProviderValidationInfo[] = {
    {&internal::XRPresentationProvider_UpdateLayerBounds_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::XRPresentationProvider_SubmitFrameMissing_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::XRPresentationProvider_SubmitFrame_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::XRPresentationProvider_SubmitFrameWithTextureHandle_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::XRPresentationProvider_SubmitFrameDrawnIntoTexture_Params_Data::Validate,
     nullptr /* no response */},
};

bool XRPresentationProviderRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::device::mojom::XRPresentationProvider::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kXRPresentationProviderValidationInfo);
}

const char XRPresentationClient::Name_[] = "device.mojom.XRPresentationClient";

XRPresentationClientProxy::XRPresentationClientProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void XRPresentationClientProxy::OnSubmitFrameTransferred(
    bool in_success) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XRPresentationClient::OnSubmitFrameTransferred");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXRPresentationClient_OnSubmitFrameTransferred_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XRPresentationClient_OnSubmitFrameTransferred_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->success = in_success;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XRPresentationClient::Name_);
  message.set_method_name("OnSubmitFrameTransferred");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void XRPresentationClientProxy::OnSubmitFrameRendered(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XRPresentationClient::OnSubmitFrameRendered");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXRPresentationClient_OnSubmitFrameRendered_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XRPresentationClient_OnSubmitFrameRendered_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XRPresentationClient::Name_);
  message.set_method_name("OnSubmitFrameRendered");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void XRPresentationClientProxy::OnSubmitFrameGpuFence(
    const ::gfx::GpuFenceHandle& in_gpu_fence_handle) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XRPresentationClient::OnSubmitFrameGpuFence");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXRPresentationClient_OnSubmitFrameGpuFence_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XRPresentationClient_OnSubmitFrameGpuFence_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->gpu_fence_handle)::BaseType::BufferWriter
      gpu_fence_handle_writer;
  mojo::internal::Serialize<::gfx::mojom::GpuFenceHandleDataView>(
      in_gpu_fence_handle, buffer, &gpu_fence_handle_writer, &serialization_context);
  params->gpu_fence_handle.Set(
      gpu_fence_handle_writer.is_null() ? nullptr : gpu_fence_handle_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->gpu_fence_handle.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null gpu_fence_handle in XRPresentationClient.OnSubmitFrameGpuFence request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XRPresentationClient::Name_);
  message.set_method_name("OnSubmitFrameGpuFence");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool XRPresentationClientStubDispatch::Accept(
    XRPresentationClient* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kXRPresentationClient_OnSubmitFrameTransferred_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XRPresentationClient::OnSubmitFrameTransferred",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XRPresentationClient::OnSubmitFrameTransferred");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::XRPresentationClient_OnSubmitFrameTransferred_Params_Data* params =
          reinterpret_cast<internal::XRPresentationClient_OnSubmitFrameTransferred_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_success{};
      XRPresentationClient_OnSubmitFrameTransferred_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_success = input_data_view.success();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XRPresentationClient::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnSubmitFrameTransferred(
std::move(p_success));
      return true;
    }
    case internal::kXRPresentationClient_OnSubmitFrameRendered_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XRPresentationClient::OnSubmitFrameRendered",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XRPresentationClient::OnSubmitFrameRendered");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::XRPresentationClient_OnSubmitFrameRendered_Params_Data* params =
          reinterpret_cast<internal::XRPresentationClient_OnSubmitFrameRendered_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      XRPresentationClient_OnSubmitFrameRendered_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XRPresentationClient::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnSubmitFrameRendered();
      return true;
    }
    case internal::kXRPresentationClient_OnSubmitFrameGpuFence_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XRPresentationClient::OnSubmitFrameGpuFence",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XRPresentationClient::OnSubmitFrameGpuFence");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::XRPresentationClient_OnSubmitFrameGpuFence_Params_Data* params =
          reinterpret_cast<internal::XRPresentationClient_OnSubmitFrameGpuFence_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::gfx::GpuFenceHandle p_gpu_fence_handle{};
      XRPresentationClient_OnSubmitFrameGpuFence_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadGpuFenceHandle(&p_gpu_fence_handle))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XRPresentationClient::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnSubmitFrameGpuFence(
std::move(p_gpu_fence_handle));
      return true;
    }
  }
  return false;
}

// static
bool XRPresentationClientStubDispatch::AcceptWithResponder(
    XRPresentationClient* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kXRPresentationClient_OnSubmitFrameTransferred_Name: {
      break;
    }
    case internal::kXRPresentationClient_OnSubmitFrameRendered_Name: {
      break;
    }
    case internal::kXRPresentationClient_OnSubmitFrameGpuFence_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kXRPresentationClientValidationInfo[] = {
    {&internal::XRPresentationClient_OnSubmitFrameTransferred_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::XRPresentationClient_OnSubmitFrameRendered_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::XRPresentationClient_OnSubmitFrameGpuFence_Params_Data::Validate,
     nullptr /* no response */},
};

bool XRPresentationClientRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::device::mojom::XRPresentationClient::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kXRPresentationClientValidationInfo);
}

const char XRSessionClient::Name_[] = "device.mojom.XRSessionClient";

XRSessionClientProxy::XRSessionClientProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void XRSessionClientProxy::OnChanged(
    VRDisplayInfoPtr in_display) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XRSessionClient::OnChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXRSessionClient_OnChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XRSessionClient_OnChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->display)::BaseType::BufferWriter
      display_writer;
  mojo::internal::Serialize<::device::mojom::VRDisplayInfoDataView>(
      in_display, buffer, &display_writer, &serialization_context);
  params->display.Set(
      display_writer.is_null() ? nullptr : display_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->display.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null display in XRSessionClient.OnChanged request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XRSessionClient::Name_);
  message.set_method_name("OnChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void XRSessionClientProxy::OnExitPresent(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XRSessionClient::OnExitPresent");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXRSessionClient_OnExitPresent_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XRSessionClient_OnExitPresent_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XRSessionClient::Name_);
  message.set_method_name("OnExitPresent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void XRSessionClientProxy::OnVisibilityStateChanged(
    XRVisibilityState in_visibility_state) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "device::mojom::XRSessionClient::OnVisibilityStateChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kXRSessionClient_OnVisibilityStateChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::device::mojom::internal::XRSessionClient_OnVisibilityStateChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::device::mojom::XRVisibilityState>(
      in_visibility_state, &params->visibility_state);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(XRSessionClient::Name_);
  message.set_method_name("OnVisibilityStateChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool XRSessionClientStubDispatch::Accept(
    XRSessionClient* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kXRSessionClient_OnChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XRSessionClient::OnChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XRSessionClient::OnChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::XRSessionClient_OnChanged_Params_Data* params =
          reinterpret_cast<internal::XRSessionClient_OnChanged_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      VRDisplayInfoPtr p_display{};
      XRSessionClient_OnChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadDisplay(&p_display))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XRSessionClient::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnChanged(
std::move(p_display));
      return true;
    }
    case internal::kXRSessionClient_OnExitPresent_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XRSessionClient::OnExitPresent",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XRSessionClient::OnExitPresent");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::XRSessionClient_OnExitPresent_Params_Data* params =
          reinterpret_cast<internal::XRSessionClient_OnExitPresent_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      XRSessionClient_OnExitPresent_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XRSessionClient::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnExitPresent();
      return true;
    }
    case internal::kXRSessionClient_OnVisibilityStateChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)device::mojom::XRSessionClient::OnVisibilityStateChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)device::mojom::XRSessionClient::OnVisibilityStateChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::XRSessionClient_OnVisibilityStateChanged_Params_Data* params =
          reinterpret_cast<internal::XRSessionClient_OnVisibilityStateChanged_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      XRVisibilityState p_visibility_state{};
      XRSessionClient_OnVisibilityStateChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadVisibilityState(&p_visibility_state))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            XRSessionClient::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnVisibilityStateChanged(
std::move(p_visibility_state));
      return true;
    }
  }
  return false;
}

// static
bool XRSessionClientStubDispatch::AcceptWithResponder(
    XRSessionClient* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kXRSessionClient_OnChanged_Name: {
      break;
    }
    case internal::kXRSessionClient_OnExitPresent_Name: {
      break;
    }
    case internal::kXRSessionClient_OnVisibilityStateChanged_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kXRSessionClientValidationInfo[] = {
    {&internal::XRSessionClient_OnChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::XRSessionClient_OnExitPresent_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::XRSessionClient_OnVisibilityStateChanged_Params_Data::Validate,
     nullptr /* no response */},
};

bool XRSessionClientRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::device::mojom::XRSessionClient::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kXRSessionClientValidationInfo);
}

}  // namespace mojom
}  // namespace device

namespace mojo {


// static
bool StructTraits<::device::mojom::XRSessionOptions::DataView, ::device::mojom::XRSessionOptionsPtr>::Read(
    ::device::mojom::XRSessionOptions::DataView input,
    ::device::mojom::XRSessionOptionsPtr* output) {
  bool success = true;
  ::device::mojom::XRSessionOptionsPtr result(::device::mojom::XRSessionOptions::New());
  
      if (success && !input.ReadMode(&result->mode))
        success = false;
      if (success && !input.ReadRequiredFeatures(&result->required_features))
        success = false;
      if (success && !input.ReadOptionalFeatures(&result->optional_features))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRSession::DataView, ::device::mojom::XRSessionPtr>::Read(
    ::device::mojom::XRSession::DataView input,
    ::device::mojom::XRSessionPtr* output) {
  bool success = true;
  ::device::mojom::XRSessionPtr result(::device::mojom::XRSession::New());
  
      if (success) {
        result->data_provider =
            input.TakeDataProvider<decltype(result->data_provider)>();
      }
      if (success) {
        result->client_receiver =
            input.TakeClientReceiver<decltype(result->client_receiver)>();
      }
      if (success && !input.ReadDisplayInfo(&result->display_info))
        success = false;
      if (success && !input.ReadSubmitFrameSink(&result->submit_frame_sink))
        success = false;
      if (success && !input.ReadEnabledFeatures(&result->enabled_features))
        success = false;
      if (success)
        result->uses_input_eventing = input.uses_input_eventing();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRPresentationConnection::DataView, ::device::mojom::XRPresentationConnectionPtr>::Read(
    ::device::mojom::XRPresentationConnection::DataView input,
    ::device::mojom::XRPresentationConnectionPtr* output) {
  bool success = true;
  ::device::mojom::XRPresentationConnectionPtr result(::device::mojom::XRPresentationConnection::New());
  
      if (success) {
        result->provider =
            input.TakeProvider<decltype(result->provider)>();
      }
      if (success) {
        result->client_receiver =
            input.TakeClientReceiver<decltype(result->client_receiver)>();
      }
      if (success && !input.ReadTransportOptions(&result->transport_options))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRInputSourceDescription::DataView, ::device::mojom::XRInputSourceDescriptionPtr>::Read(
    ::device::mojom::XRInputSourceDescription::DataView input,
    ::device::mojom::XRInputSourceDescriptionPtr* output) {
  bool success = true;
  ::device::mojom::XRInputSourceDescriptionPtr result(::device::mojom::XRInputSourceDescription::New());
  
      if (success && !input.ReadTargetRayMode(&result->target_ray_mode))
        success = false;
      if (success && !input.ReadHandedness(&result->handedness))
        success = false;
      if (success && !input.ReadInputFromPointer(&result->input_from_pointer))
        success = false;
      if (success && !input.ReadProfiles(&result->profiles))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRInputSourceState::DataView, ::device::mojom::XRInputSourceStatePtr>::Read(
    ::device::mojom::XRInputSourceState::DataView input,
    ::device::mojom::XRInputSourceStatePtr* output) {
  bool success = true;
  ::device::mojom::XRInputSourceStatePtr result(::device::mojom::XRInputSourceState::New());
  
      if (success)
        result->source_id = input.source_id();
      if (success && !input.ReadDescription(&result->description))
        success = false;
      if (success && !input.ReadMojoFromInput(&result->mojo_from_input))
        success = false;
      if (success)
        result->emulated_position = input.emulated_position();
      if (success)
        result->primary_input_pressed = input.primary_input_pressed();
      if (success)
        result->primary_input_clicked = input.primary_input_clicked();
      if (success && !input.ReadGamepad(&result->gamepad))
        success = false;
      if (success && !input.ReadOverlayPointerPosition(&result->overlay_pointer_position))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::VRFieldOfView::DataView, ::device::mojom::VRFieldOfViewPtr>::Read(
    ::device::mojom::VRFieldOfView::DataView input,
    ::device::mojom::VRFieldOfViewPtr* output) {
  bool success = true;
  ::device::mojom::VRFieldOfViewPtr result(::device::mojom::VRFieldOfView::New());
  
      if (success)
        result->up_degrees = input.up_degrees();
      if (success)
        result->down_degrees = input.down_degrees();
      if (success)
        result->left_degrees = input.left_degrees();
      if (success)
        result->right_degrees = input.right_degrees();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::VRPose::DataView, ::device::mojom::VRPosePtr>::Read(
    ::device::mojom::VRPose::DataView input,
    ::device::mojom::VRPosePtr* output) {
  bool success = true;
  ::device::mojom::VRPosePtr result(::device::mojom::VRPose::New());
  
      if (success && !input.ReadOrientation(&result->orientation))
        success = false;
      if (success && !input.ReadPosition(&result->position))
        success = false;
      if (success)
        result->emulated_position = input.emulated_position();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::Pose::DataView, ::device::mojom::PosePtr>::Read(
    ::device::mojom::Pose::DataView input,
    ::device::mojom::PosePtr* output) {
  bool success = true;
  ::device::mojom::PosePtr result(::device::mojom::Pose::New());
  
      if (success && !input.ReadOrientation(&result->orientation))
        success = false;
      if (success && !input.ReadPosition(&result->position))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRRay::DataView, ::device::mojom::XRRayPtr>::Read(
    ::device::mojom::XRRay::DataView input,
    ::device::mojom::XRRayPtr* output) {
  bool success = true;
  ::device::mojom::XRRayPtr result(::device::mojom::XRRay::New());
  
      if (success && !input.ReadOrigin(&result->origin))
        success = false;
      if (success && !input.ReadDirection(&result->direction))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRHitResult::DataView, ::device::mojom::XRHitResultPtr>::Read(
    ::device::mojom::XRHitResult::DataView input,
    ::device::mojom::XRHitResultPtr* output) {
  bool success = true;
  ::device::mojom::XRHitResultPtr result(::device::mojom::XRHitResult::New());
  
      if (success && !input.ReadHitMatrix(&result->hit_matrix))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::VREyeParameters::DataView, ::device::mojom::VREyeParametersPtr>::Read(
    ::device::mojom::VREyeParameters::DataView input,
    ::device::mojom::VREyeParametersPtr* output) {
  bool success = true;
  ::device::mojom::VREyeParametersPtr result(::device::mojom::VREyeParameters::New());
  
      if (success && !input.ReadFieldOfView(&result->field_of_view))
        success = false;
      if (success && !input.ReadHeadFromEye(&result->head_from_eye))
        success = false;
      if (success)
        result->render_width = input.render_width();
      if (success)
        result->render_height = input.render_height();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::VRStageParameters::DataView, ::device::mojom::VRStageParametersPtr>::Read(
    ::device::mojom::VRStageParameters::DataView input,
    ::device::mojom::VRStageParametersPtr* output) {
  bool success = true;
  ::device::mojom::VRStageParametersPtr result(::device::mojom::VRStageParameters::New());
  
      if (success && !input.ReadStandingTransform(&result->standing_transform))
        success = false;
      if (success && !input.ReadBounds(&result->bounds))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::VRDisplayInfo::DataView, ::device::mojom::VRDisplayInfoPtr>::Read(
    ::device::mojom::VRDisplayInfo::DataView input,
    ::device::mojom::VRDisplayInfoPtr* output) {
  bool success = true;
  ::device::mojom::VRDisplayInfoPtr result(::device::mojom::VRDisplayInfo::New());
  
      if (success && !input.ReadId(&result->id))
        success = false;
      if (success && !input.ReadStageParameters(&result->stage_parameters))
        success = false;
      if (success && !input.ReadLeftEye(&result->left_eye))
        success = false;
      if (success && !input.ReadRightEye(&result->right_eye))
        success = false;
      if (success)
        result->webxr_default_framebuffer_scale = input.webxr_default_framebuffer_scale();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRPresentationTransportOptions::DataView, ::device::mojom::XRPresentationTransportOptionsPtr>::Read(
    ::device::mojom::XRPresentationTransportOptions::DataView input,
    ::device::mojom::XRPresentationTransportOptionsPtr* output) {
  bool success = true;
  ::device::mojom::XRPresentationTransportOptionsPtr result(::device::mojom::XRPresentationTransportOptions::New());
  
      if (success && !input.ReadTransportMethod(&result->transport_method))
        success = false;
      if (success)
        result->wait_for_transfer_notification = input.wait_for_transfer_notification();
      if (success)
        result->wait_for_render_notification = input.wait_for_render_notification();
      if (success)
        result->wait_for_gpu_fence = input.wait_for_gpu_fence();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRPlanePointData::DataView, ::device::mojom::XRPlanePointDataPtr>::Read(
    ::device::mojom::XRPlanePointData::DataView input,
    ::device::mojom::XRPlanePointDataPtr* output) {
  bool success = true;
  ::device::mojom::XRPlanePointDataPtr result(::device::mojom::XRPlanePointData::New());
  
      if (success)
        result->x = input.x();
      if (success)
        result->z = input.z();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRPlaneData::DataView, ::device::mojom::XRPlaneDataPtr>::Read(
    ::device::mojom::XRPlaneData::DataView input,
    ::device::mojom::XRPlaneDataPtr* output) {
  bool success = true;
  ::device::mojom::XRPlaneDataPtr result(::device::mojom::XRPlaneData::New());
  
      if (success)
        result->id = input.id();
      if (success && !input.ReadOrientation(&result->orientation))
        success = false;
      if (success && !input.ReadPose(&result->pose))
        success = false;
      if (success && !input.ReadPolygon(&result->polygon))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRPlaneDetectionData::DataView, ::device::mojom::XRPlaneDetectionDataPtr>::Read(
    ::device::mojom::XRPlaneDetectionData::DataView input,
    ::device::mojom::XRPlaneDetectionDataPtr* output) {
  bool success = true;
  ::device::mojom::XRPlaneDetectionDataPtr result(::device::mojom::XRPlaneDetectionData::New());
  
      if (success && !input.ReadAllPlanesIds(&result->all_planes_ids))
        success = false;
      if (success && !input.ReadUpdatedPlanesData(&result->updated_planes_data))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRAnchorData::DataView, ::device::mojom::XRAnchorDataPtr>::Read(
    ::device::mojom::XRAnchorData::DataView input,
    ::device::mojom::XRAnchorDataPtr* output) {
  bool success = true;
  ::device::mojom::XRAnchorDataPtr result(::device::mojom::XRAnchorData::New());
  
      if (success)
        result->id = input.id();
      if (success && !input.ReadPose(&result->pose))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRAnchorsData::DataView, ::device::mojom::XRAnchorsDataPtr>::Read(
    ::device::mojom::XRAnchorsData::DataView input,
    ::device::mojom::XRAnchorsDataPtr* output) {
  bool success = true;
  ::device::mojom::XRAnchorsDataPtr result(::device::mojom::XRAnchorsData::New());
  
      if (success && !input.ReadAllAnchorsIds(&result->all_anchors_ids))
        success = false;
      if (success && !input.ReadUpdatedAnchorsData(&result->updated_anchors_data))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRHitTestSubscriptionResultData::DataView, ::device::mojom::XRHitTestSubscriptionResultDataPtr>::Read(
    ::device::mojom::XRHitTestSubscriptionResultData::DataView input,
    ::device::mojom::XRHitTestSubscriptionResultDataPtr* output) {
  bool success = true;
  ::device::mojom::XRHitTestSubscriptionResultDataPtr result(::device::mojom::XRHitTestSubscriptionResultData::New());
  
      if (success)
        result->subscription_id = input.subscription_id();
      if (success && !input.ReadHitTestResults(&result->hit_test_results))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRHitTestTransientInputSubscriptionResultData::DataView, ::device::mojom::XRHitTestTransientInputSubscriptionResultDataPtr>::Read(
    ::device::mojom::XRHitTestTransientInputSubscriptionResultData::DataView input,
    ::device::mojom::XRHitTestTransientInputSubscriptionResultDataPtr* output) {
  bool success = true;
  ::device::mojom::XRHitTestTransientInputSubscriptionResultDataPtr result(::device::mojom::XRHitTestTransientInputSubscriptionResultData::New());
  
      if (success)
        result->subscription_id = input.subscription_id();
      if (success && !input.ReadInputSourceIdToHitTestResults(&result->input_source_id_to_hit_test_results))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRHitTestSubscriptionResultsData::DataView, ::device::mojom::XRHitTestSubscriptionResultsDataPtr>::Read(
    ::device::mojom::XRHitTestSubscriptionResultsData::DataView input,
    ::device::mojom::XRHitTestSubscriptionResultsDataPtr* output) {
  bool success = true;
  ::device::mojom::XRHitTestSubscriptionResultsDataPtr result(::device::mojom::XRHitTestSubscriptionResultsData::New());
  
      if (success && !input.ReadResults(&result->results))
        success = false;
      if (success && !input.ReadTransientInputResults(&result->transient_input_results))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::RgbTupleF32::DataView, ::device::mojom::RgbTupleF32Ptr>::Read(
    ::device::mojom::RgbTupleF32::DataView input,
    ::device::mojom::RgbTupleF32Ptr* output) {
  bool success = true;
  ::device::mojom::RgbTupleF32Ptr result(::device::mojom::RgbTupleF32::New());
  
      if (success)
        result->red = input.red();
      if (success)
        result->green = input.green();
      if (success)
        result->blue = input.blue();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRSphericalHarmonics::DataView, ::device::mojom::XRSphericalHarmonicsPtr>::Read(
    ::device::mojom::XRSphericalHarmonics::DataView input,
    ::device::mojom::XRSphericalHarmonicsPtr* output) {
  bool success = true;
  ::device::mojom::XRSphericalHarmonicsPtr result(::device::mojom::XRSphericalHarmonics::New());
  
      if (success && !input.ReadCoefficients(&result->coefficients))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::RgbaTupleF16::DataView, ::device::mojom::RgbaTupleF16Ptr>::Read(
    ::device::mojom::RgbaTupleF16::DataView input,
    ::device::mojom::RgbaTupleF16Ptr* output) {
  bool success = true;
  ::device::mojom::RgbaTupleF16Ptr result(::device::mojom::RgbaTupleF16::New());
  
      if (success)
        result->red = input.red();
      if (success)
        result->green = input.green();
      if (success)
        result->blue = input.blue();
      if (success)
        result->alpha = input.alpha();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRCubeMap::DataView, ::device::mojom::XRCubeMapPtr>::Read(
    ::device::mojom::XRCubeMap::DataView input,
    ::device::mojom::XRCubeMapPtr* output) {
  bool success = true;
  ::device::mojom::XRCubeMapPtr result(::device::mojom::XRCubeMap::New());
  
      if (success)
        result->width_and_height = input.width_and_height();
      if (success && !input.ReadPositiveX(&result->positive_x))
        success = false;
      if (success && !input.ReadNegativeX(&result->negative_x))
        success = false;
      if (success && !input.ReadPositiveY(&result->positive_y))
        success = false;
      if (success && !input.ReadNegativeY(&result->negative_y))
        success = false;
      if (success && !input.ReadPositiveZ(&result->positive_z))
        success = false;
      if (success && !input.ReadNegativeZ(&result->negative_z))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRLightProbe::DataView, ::device::mojom::XRLightProbePtr>::Read(
    ::device::mojom::XRLightProbe::DataView input,
    ::device::mojom::XRLightProbePtr* output) {
  bool success = true;
  ::device::mojom::XRLightProbePtr result(::device::mojom::XRLightProbe::New());
  
      if (success && !input.ReadSphericalHarmonics(&result->spherical_harmonics))
        success = false;
      if (success && !input.ReadMainLightDirection(&result->main_light_direction))
        success = false;
      if (success && !input.ReadMainLightIntensity(&result->main_light_intensity))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRReflectionProbe::DataView, ::device::mojom::XRReflectionProbePtr>::Read(
    ::device::mojom::XRReflectionProbe::DataView input,
    ::device::mojom::XRReflectionProbePtr* output) {
  bool success = true;
  ::device::mojom::XRReflectionProbePtr result(::device::mojom::XRReflectionProbe::New());
  
      if (success && !input.ReadCubeMap(&result->cube_map))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRLightEstimationData::DataView, ::device::mojom::XRLightEstimationDataPtr>::Read(
    ::device::mojom::XRLightEstimationData::DataView input,
    ::device::mojom::XRLightEstimationDataPtr* output) {
  bool success = true;
  ::device::mojom::XRLightEstimationDataPtr result(::device::mojom::XRLightEstimationData::New());
  
      if (success && !input.ReadLightProbe(&result->light_probe))
        success = false;
      if (success && !input.ReadReflectionProbe(&result->reflection_probe))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRFrameData::DataView, ::device::mojom::XRFrameDataPtr>::Read(
    ::device::mojom::XRFrameData::DataView input,
    ::device::mojom::XRFrameDataPtr* output) {
  bool success = true;
  ::device::mojom::XRFrameDataPtr result(::device::mojom::XRFrameData::New());
  
      if (success && !input.ReadPose(&result->pose))
        success = false;
      if (success && !input.ReadTimeDelta(&result->time_delta))
        success = false;
      if (success && !input.ReadBufferHolder(&result->buffer_holder))
        success = false;
      if (success)
        result->mojo_space_reset = input.mojo_space_reset();
      if (success)
        result->frame_id = input.frame_id();
      if (success && !input.ReadLeftEye(&result->left_eye))
        success = false;
      if (success && !input.ReadRightEye(&result->right_eye))
        success = false;
      if (success && !input.ReadInputState(&result->input_state))
        success = false;
      if (success)
        result->stage_parameters_updated = input.stage_parameters_updated();
      if (success && !input.ReadStageParameters(&result->stage_parameters))
        success = false;
      if (success && !input.ReadDetectedPlanesData(&result->detected_planes_data))
        success = false;
      if (success && !input.ReadAnchorsData(&result->anchors_data))
        success = false;
      if (success && !input.ReadLightEstimationData(&result->light_estimation_data))
        success = false;
      if (success && !input.ReadHitTestSubscriptionResults(&result->hit_test_subscription_results))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::RequestSessionSuccess::DataView, ::device::mojom::RequestSessionSuccessPtr>::Read(
    ::device::mojom::RequestSessionSuccess::DataView input,
    ::device::mojom::RequestSessionSuccessPtr* output) {
  bool success = true;
  ::device::mojom::RequestSessionSuccessPtr result(::device::mojom::RequestSessionSuccess::New());
  
      if (success && !input.ReadSession(&result->session))
        success = false;
      if (success) {
        result->metrics_recorder =
            input.TakeMetricsRecorder<decltype(result->metrics_recorder)>();
      }
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::device::mojom::XRFrameDataRequestOptions::DataView, ::device::mojom::XRFrameDataRequestOptionsPtr>::Read(
    ::device::mojom::XRFrameDataRequestOptions::DataView input,
    ::device::mojom::XRFrameDataRequestOptionsPtr* output) {
  bool success = true;
  ::device::mojom::XRFrameDataRequestOptionsPtr result(::device::mojom::XRFrameDataRequestOptions::New());
  
      if (success)
        result->include_plane_data = input.include_plane_data();
      if (success)
        result->include_lighting_estimation_data = input.include_lighting_estimation_data();
  *output = std::move(result);
  return success;
}

// static
bool UnionTraits<::device::mojom::XRNativeOriginInformation::DataView, ::device::mojom::XRNativeOriginInformationPtr>::Read(
    ::device::mojom::XRNativeOriginInformation::DataView input,
    ::device::mojom::XRNativeOriginInformationPtr* output) {
  using UnionType = ::device::mojom::XRNativeOriginInformation;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::INPUT_SOURCE_ID: {
      *output = UnionType::NewInputSourceId(input.input_source_id());
      break;
    }
    case Tag::PLANE_ID: {
      *output = UnionType::NewPlaneId(input.plane_id());
      break;
    }
    case Tag::ANCHOR_ID: {
      *output = UnionType::NewAnchorId(input.anchor_id());
      break;
    }
    case Tag::REFERENCE_SPACE_CATEGORY: {
      ::device::mojom::XRReferenceSpaceCategory result_reference_space_category;
      if (!input.ReadReferenceSpaceCategory(&result_reference_space_category))
        return false;

      *output = UnionType::NewReferenceSpaceCategory(result_reference_space_category);
      break;
    }
    default:
      return false;
  }
  return true;
}

// static
bool UnionTraits<::device::mojom::RequestSessionResult::DataView, ::device::mojom::RequestSessionResultPtr>::Read(
    ::device::mojom::RequestSessionResult::DataView input,
    ::device::mojom::RequestSessionResultPtr* output) {
  using UnionType = ::device::mojom::RequestSessionResult;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::SUCCESS: {
      ::device::mojom::RequestSessionSuccessPtr result_success;
      if (!input.ReadSuccess(&result_success))
        return false;

      *output = UnionType::NewSuccess(
          std::move(result_success));
      break;
    }
    case Tag::FAILURE_REASON: {
      ::device::mojom::RequestSessionError result_failure_reason;
      if (!input.ReadFailureReason(&result_failure_reason))
        return false;

      *output = UnionType::NewFailureReason(result_failure_reason);
      break;
    }
    default:
      return false;
  }
  return true;
}

}  // namespace mojo

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif