// device/vr/public/mojom/isolated_xr_service.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef DEVICE_VR_PUBLIC_MOJOM_ISOLATED_XR_SERVICE_MOJOM_TEST_UTILS_H_
#define DEVICE_VR_PUBLIC_MOJOM_ISOLATED_XR_SERVICE_MOJOM_TEST_UTILS_H_

#include "device/vr/public/mojom/isolated_xr_service.mojom.h"
#include "base/component_export.h"


namespace device {
namespace mojom {


class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS) XRSessionControllerInterceptorForTesting : public XRSessionController {
  virtual XRSessionController* GetForwardingInterface() = 0;
  void SetFrameDataRestricted(bool restricted) override;
};
class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS) XRSessionControllerAsyncWaiter {
 public:
  explicit XRSessionControllerAsyncWaiter(XRSessionController* proxy);
  ~XRSessionControllerAsyncWaiter();

 private:
  XRSessionController* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(XRSessionControllerAsyncWaiter);
};


class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS) XRRuntimeEventListenerInterceptorForTesting : public XRRuntimeEventListener {
  virtual XRRuntimeEventListener* GetForwardingInterface() = 0;
  void OnDisplayInfoChanged(::device::mojom::VRDisplayInfoPtr display_info) override;
  void OnVisibilityStateChanged(::device::mojom::XRVisibilityState visibility_state) override;
  void OnExitPresent() override;
};
class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS) XRRuntimeEventListenerAsyncWaiter {
 public:
  explicit XRRuntimeEventListenerAsyncWaiter(XRRuntimeEventListener* proxy);
  ~XRRuntimeEventListenerAsyncWaiter();

 private:
  XRRuntimeEventListener* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(XRRuntimeEventListenerAsyncWaiter);
};


class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS) XRRuntimeInterceptorForTesting : public XRRuntime {
  virtual XRRuntime* GetForwardingInterface() = 0;
  void RequestSession(XRRuntimeSessionOptionsPtr options, RequestSessionCallback callback) override;
  void ShutdownSession(ShutdownSessionCallback callback) override;
  void ListenToDeviceChanges(mojo::PendingAssociatedRemote<XRRuntimeEventListener> listener, ListenToDeviceChangesCallback callback) override;
  void SetInlinePosesEnabled(bool enable) override;
};
class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS) XRRuntimeAsyncWaiter {
 public:
  explicit XRRuntimeAsyncWaiter(XRRuntime* proxy);
  ~XRRuntimeAsyncWaiter();
  void RequestSession(
      XRRuntimeSessionOptionsPtr options, ::device::mojom::XRSessionPtr* out_session, mojo::PendingRemote<XRSessionController>* out_controller);
  void ShutdownSession(
      );
  void ListenToDeviceChanges(
      mojo::PendingAssociatedRemote<XRRuntimeEventListener> listener, ::device::mojom::VRDisplayInfoPtr* out_display_info);

 private:
  XRRuntime* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(XRRuntimeAsyncWaiter);
};


class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS) ImmersiveOverlayInterceptorForTesting : public ImmersiveOverlay {
  virtual ImmersiveOverlay* GetForwardingInterface() = 0;
  void RequestNextOverlayPose(RequestNextOverlayPoseCallback callback) override;
  void SubmitOverlayTexture(int16_t frame_id, mojo::ScopedHandle texture, const ::gfx::RectF& left_bounds, const ::gfx::RectF& right_bounds, SubmitOverlayTextureCallback callback) override;
  void SetOverlayAndWebXRVisibility(bool overlay_visible, bool webxr_visible) override;
  void RequestNotificationOnWebXrSubmitted(RequestNotificationOnWebXrSubmittedCallback callback) override;
};
class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS) ImmersiveOverlayAsyncWaiter {
 public:
  explicit ImmersiveOverlayAsyncWaiter(ImmersiveOverlay* proxy);
  ~ImmersiveOverlayAsyncWaiter();
  void RequestNextOverlayPose(
      ::device::mojom::XRFrameDataPtr* out_pose);
  void SubmitOverlayTexture(
      int16_t frame_id, mojo::ScopedHandle texture, const ::gfx::RectF& left_bounds, const ::gfx::RectF& right_bounds, bool* out_success);
  void RequestNotificationOnWebXrSubmitted(
      );

 private:
  ImmersiveOverlay* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(ImmersiveOverlayAsyncWaiter);
};


class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS) XRCompositorHostInterceptorForTesting : public XRCompositorHost {
  virtual XRCompositorHost* GetForwardingInterface() = 0;
  void CreateImmersiveOverlay(mojo::PendingReceiver<ImmersiveOverlay> overlay) override;
};
class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS) XRCompositorHostAsyncWaiter {
 public:
  explicit XRCompositorHostAsyncWaiter(XRCompositorHost* proxy);
  ~XRCompositorHostAsyncWaiter();

 private:
  XRCompositorHost* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(XRCompositorHostAsyncWaiter);
};


class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS) IsolatedXRRuntimeProviderClientInterceptorForTesting : public IsolatedXRRuntimeProviderClient {
  virtual IsolatedXRRuntimeProviderClient* GetForwardingInterface() = 0;
  void OnDeviceAdded(mojo::PendingRemote<XRRuntime> runtime, mojo::PendingRemote<XRCompositorHost> compositor_host, ::device::mojom::XRDeviceId device_id) override;
  void OnDeviceRemoved(::device::mojom::XRDeviceId device_index) override;
  void OnDevicesEnumerated() override;
};
class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS) IsolatedXRRuntimeProviderClientAsyncWaiter {
 public:
  explicit IsolatedXRRuntimeProviderClientAsyncWaiter(IsolatedXRRuntimeProviderClient* proxy);
  ~IsolatedXRRuntimeProviderClientAsyncWaiter();

 private:
  IsolatedXRRuntimeProviderClient* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(IsolatedXRRuntimeProviderClientAsyncWaiter);
};


class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS) IsolatedXRRuntimeProviderInterceptorForTesting : public IsolatedXRRuntimeProvider {
  virtual IsolatedXRRuntimeProvider* GetForwardingInterface() = 0;
  void RequestDevices(mojo::PendingRemote<IsolatedXRRuntimeProviderClient> client) override;
};
class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS) IsolatedXRRuntimeProviderAsyncWaiter {
 public:
  explicit IsolatedXRRuntimeProviderAsyncWaiter(IsolatedXRRuntimeProvider* proxy);
  ~IsolatedXRRuntimeProviderAsyncWaiter();

 private:
  IsolatedXRRuntimeProvider* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(IsolatedXRRuntimeProviderAsyncWaiter);
};


class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS) XRDeviceServiceInterceptorForTesting : public XRDeviceService {
  virtual XRDeviceService* GetForwardingInterface() = 0;
  void BindRuntimeProvider(mojo::PendingReceiver<IsolatedXRRuntimeProvider> receiver) override;
  void BindTestHook(mojo::PendingReceiver<::device_test::mojom::XRServiceTestHook> receiver) override;
};
class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS) XRDeviceServiceAsyncWaiter {
 public:
  explicit XRDeviceServiceAsyncWaiter(XRDeviceService* proxy);
  ~XRDeviceServiceAsyncWaiter();

 private:
  XRDeviceService* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(XRDeviceServiceAsyncWaiter);
};




}  // namespace mojom
}  // namespace device

#endif  // DEVICE_VR_PUBLIC_MOJOM_ISOLATED_XR_SERVICE_MOJOM_TEST_UTILS_H_