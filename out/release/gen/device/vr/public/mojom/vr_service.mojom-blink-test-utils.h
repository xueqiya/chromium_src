// device/vr/public/mojom/vr_service.mojom-blink-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef DEVICE_VR_PUBLIC_MOJOM_VR_SERVICE_MOJOM_BLINK_TEST_UTILS_H_
#define DEVICE_VR_PUBLIC_MOJOM_VR_SERVICE_MOJOM_BLINK_TEST_UTILS_H_

#include "device/vr/public/mojom/vr_service.mojom-blink.h"
#include "base/component_export.h"


namespace device {
namespace mojom {
namespace blink {


class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS_BLINK) VRServiceInterceptorForTesting : public VRService {
  virtual VRService* GetForwardingInterface() = 0;
  void SetClient(mojo::PendingRemote<VRServiceClient> client) override;
  void RequestSession(XRSessionOptionsPtr options, RequestSessionCallback callback) override;
  void SupportsSession(XRSessionOptionsPtr options, SupportsSessionCallback callback) override;
  void ExitPresent(ExitPresentCallback callback) override;
  void SetFramesThrottled(bool throttled) override;
};
class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS_BLINK) VRServiceAsyncWaiter {
 public:
  explicit VRServiceAsyncWaiter(VRService* proxy);
  ~VRServiceAsyncWaiter();
  void RequestSession(
      XRSessionOptionsPtr options, RequestSessionResultPtr* out_result);
  void SupportsSession(
      XRSessionOptionsPtr options, bool* out_supports_session);
  void ExitPresent(
      );

 private:
  VRService* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(VRServiceAsyncWaiter);
};


class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS_BLINK) XRSessionMetricsRecorderInterceptorForTesting : public XRSessionMetricsRecorder {
  virtual XRSessionMetricsRecorder* GetForwardingInterface() = 0;
  void ReportFeatureUsed(XRSessionFeature feature) override;
};
class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS_BLINK) XRSessionMetricsRecorderAsyncWaiter {
 public:
  explicit XRSessionMetricsRecorderAsyncWaiter(XRSessionMetricsRecorder* proxy);
  ~XRSessionMetricsRecorderAsyncWaiter();

 private:
  XRSessionMetricsRecorder* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(XRSessionMetricsRecorderAsyncWaiter);
};


class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS_BLINK) VRServiceClientInterceptorForTesting : public VRServiceClient {
  virtual VRServiceClient* GetForwardingInterface() = 0;
  void OnDeviceChanged() override;
};
class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS_BLINK) VRServiceClientAsyncWaiter {
 public:
  explicit VRServiceClientAsyncWaiter(VRServiceClient* proxy);
  ~VRServiceClientAsyncWaiter();

 private:
  VRServiceClient* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(VRServiceClientAsyncWaiter);
};


class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS_BLINK) XREnvironmentIntegrationProviderInterceptorForTesting : public XREnvironmentIntegrationProvider {
  virtual XREnvironmentIntegrationProvider* GetForwardingInterface() = 0;
  void RequestHitTest(XRRayPtr ray, RequestHitTestCallback callback) override;
  void SubscribeToHitTest(XRNativeOriginInformationPtr native_origin_information, const WTF::Vector<EntityTypeForHitTest>& entity_types, XRRayPtr ray, SubscribeToHitTestCallback callback) override;
  void SubscribeToHitTestForTransientInput(const WTF::String& profile_name, const WTF::Vector<EntityTypeForHitTest>& entity_types, XRRayPtr ray, SubscribeToHitTestForTransientInputCallback callback) override;
  void UnsubscribeFromHitTest(uint64_t subscription_id) override;
  void CreateAnchor(PosePtr anchor_pose, CreateAnchorCallback callback) override;
  void CreatePlaneAnchor(PosePtr anchor_pose, uint64_t plane_id, CreatePlaneAnchorCallback callback) override;
  void DetachAnchor(uint64_t anchor_id) override;
};
class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS_BLINK) XREnvironmentIntegrationProviderAsyncWaiter {
 public:
  explicit XREnvironmentIntegrationProviderAsyncWaiter(XREnvironmentIntegrationProvider* proxy);
  ~XREnvironmentIntegrationProviderAsyncWaiter();
  void RequestHitTest(
      XRRayPtr ray, base::Optional<WTF::Vector<XRHitResultPtr>>* out_results);
  void SubscribeToHitTest(
      XRNativeOriginInformationPtr native_origin_information, const WTF::Vector<EntityTypeForHitTest>& entity_types, XRRayPtr ray, SubscribeToHitTestResult* out_result, uint64_t* out_subscription_id);
  void SubscribeToHitTestForTransientInput(
      const WTF::String& profile_name, const WTF::Vector<EntityTypeForHitTest>& entity_types, XRRayPtr ray, SubscribeToHitTestResult* out_result, uint64_t* out_subscription_id);
  void CreateAnchor(
      PosePtr anchor_pose, CreateAnchorResult* out_result, uint64_t* out_anchor_id);
  void CreatePlaneAnchor(
      PosePtr anchor_pose, uint64_t plane_id, CreateAnchorResult* out_result, uint64_t* out_anchor_id);

 private:
  XREnvironmentIntegrationProvider* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(XREnvironmentIntegrationProviderAsyncWaiter);
};


class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS_BLINK) XRInputSourceButtonListenerInterceptorForTesting : public XRInputSourceButtonListener {
  virtual XRInputSourceButtonListener* GetForwardingInterface() = 0;
  void OnButtonEvent(XRInputSourceStatePtr input_source) override;
};
class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS_BLINK) XRInputSourceButtonListenerAsyncWaiter {
 public:
  explicit XRInputSourceButtonListenerAsyncWaiter(XRInputSourceButtonListener* proxy);
  ~XRInputSourceButtonListenerAsyncWaiter();

 private:
  XRInputSourceButtonListener* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(XRInputSourceButtonListenerAsyncWaiter);
};


class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS_BLINK) XRFrameDataProviderInterceptorForTesting : public XRFrameDataProvider {
  virtual XRFrameDataProvider* GetForwardingInterface() = 0;
  void GetFrameData(XRFrameDataRequestOptionsPtr options, GetFrameDataCallback callback) override;
  void GetEnvironmentIntegrationProvider(mojo::PendingAssociatedReceiver<XREnvironmentIntegrationProvider> environment_provider) override;
  void SetInputSourceButtonListener(mojo::PendingAssociatedRemote<XRInputSourceButtonListener> event_listener) override;
};
class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS_BLINK) XRFrameDataProviderAsyncWaiter {
 public:
  explicit XRFrameDataProviderAsyncWaiter(XRFrameDataProvider* proxy);
  ~XRFrameDataProviderAsyncWaiter();
  void GetFrameData(
      XRFrameDataRequestOptionsPtr options, XRFrameDataPtr* out_frame_data);

 private:
  XRFrameDataProvider* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(XRFrameDataProviderAsyncWaiter);
};


class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS_BLINK) XRPresentationProviderInterceptorForTesting : public XRPresentationProvider {
  virtual XRPresentationProvider* GetForwardingInterface() = 0;
  void UpdateLayerBounds(int16_t frame_id, const ::blink::WebFloatRect& left_bounds, const ::blink::WebFloatRect& right_bounds, const ::blink::WebSize& source_size) override;
  void SubmitFrameMissing(int16_t frame_id, const ::gpu::SyncToken& sync_token) override;
  void SubmitFrame(int16_t frame_id, const ::gpu::MailboxHolder& mailbox_holder, ::base::TimeDelta time_waited) override;
  void SubmitFrameWithTextureHandle(int16_t frameId, mojo::ScopedHandle texture) override;
  void SubmitFrameDrawnIntoTexture(int16_t frameId, const ::gpu::SyncToken& sync_token, ::base::TimeDelta time_waited) override;
};
class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS_BLINK) XRPresentationProviderAsyncWaiter {
 public:
  explicit XRPresentationProviderAsyncWaiter(XRPresentationProvider* proxy);
  ~XRPresentationProviderAsyncWaiter();

 private:
  XRPresentationProvider* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(XRPresentationProviderAsyncWaiter);
};


class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS_BLINK) XRPresentationClientInterceptorForTesting : public XRPresentationClient {
  virtual XRPresentationClient* GetForwardingInterface() = 0;
  void OnSubmitFrameTransferred(bool success) override;
  void OnSubmitFrameRendered() override;
  void OnSubmitFrameGpuFence(const ::gfx::GpuFenceHandle& gpu_fence_handle) override;
};
class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS_BLINK) XRPresentationClientAsyncWaiter {
 public:
  explicit XRPresentationClientAsyncWaiter(XRPresentationClient* proxy);
  ~XRPresentationClientAsyncWaiter();

 private:
  XRPresentationClient* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(XRPresentationClientAsyncWaiter);
};


class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS_BLINK) XRSessionClientInterceptorForTesting : public XRSessionClient {
  virtual XRSessionClient* GetForwardingInterface() = 0;
  void OnChanged(VRDisplayInfoPtr display) override;
  void OnExitPresent() override;
  void OnVisibilityStateChanged(XRVisibilityState visibility_state) override;
};
class COMPONENT_EXPORT(DEVICE_VR_MOJO_BINDINGS_BLINK) XRSessionClientAsyncWaiter {
 public:
  explicit XRSessionClientAsyncWaiter(XRSessionClient* proxy);
  ~XRSessionClientAsyncWaiter();

 private:
  XRSessionClient* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(XRSessionClientAsyncWaiter);
};




}  // namespace blink
}  // namespace mojom
}  // namespace device

#endif  // DEVICE_VR_PUBLIC_MOJOM_VR_SERVICE_MOJOM_BLINK_TEST_UTILS_H_