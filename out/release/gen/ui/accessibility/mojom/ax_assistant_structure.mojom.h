// ui/accessibility/mojom/ax_assistant_structure.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef UI_ACCESSIBILITY_MOJOM_AX_ASSISTANT_STRUCTURE_MOJOM_H_
#define UI_ACCESSIBILITY_MOJOM_AX_ASSISTANT_STRUCTURE_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "base/callback.h"
#include "base/macros.h"
#include "base/optional.h"

#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#if BUILDFLAG(MOJO_TRACE_ENABLED)
#include "base/trace_event/trace_event.h"
#endif
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"
#include "ui/accessibility/mojom/ax_assistant_structure.mojom-shared.h"
#include "ui/accessibility/mojom/ax_assistant_structure.mojom-forward.h"
#include "mojo/public/mojom/base/string16.mojom.h"
#include "ui/gfx/geometry/mojom/geometry.mojom.h"
#include "ui/gfx/range/mojom/range.mojom.h"
#include "url/mojom/url.mojom.h"
#include <string>
#include <vector>




#include "ui/accessibility/ax_assistant_structure.h"




namespace ax {
namespace mojom {










class  AssistantTree {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<AssistantTree, T>::value>;
  using DataView = AssistantTreeDataView;
  using Data_ = internal::AssistantTree_Data;

  template <typename... Args>
  static AssistantTreePtr New(Args&&... args) {
    return AssistantTreePtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static AssistantTreePtr From(const U& u) {
    return mojo::TypeConverter<AssistantTreePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, AssistantTree>::Convert(*this);
  }


  AssistantTree();

  explicit AssistantTree(
      std::vector<::std::unique_ptr<::ui::AssistantNode>> nodes);

  ~AssistantTree();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = AssistantTreePtr>
  AssistantTreePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, AssistantTree::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        AssistantTree::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        AssistantTree::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::AssistantTree_UnserializedMessageContext<
            UserType, AssistantTree::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<AssistantTree::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return AssistantTree::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::AssistantTree_UnserializedMessageContext<
            UserType, AssistantTree::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<AssistantTree::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  std::vector<::std::unique_ptr<::ui::AssistantNode>> nodes;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(AssistantTree);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AssistantTree::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, AssistantTree::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, AssistantTree::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, AssistantTree::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  AssistantNode {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<AssistantNode, T>::value>;
  using DataView = AssistantNodeDataView;
  using Data_ = internal::AssistantNode_Data;

  template <typename... Args>
  static AssistantNodePtr New(Args&&... args) {
    return AssistantNodePtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static AssistantNodePtr From(const U& u) {
    return mojo::TypeConverter<AssistantNodePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, AssistantNode>::Convert(*this);
  }


  AssistantNode();

  AssistantNode(
      std::vector<int32_t> children_indices,
      const ::gfx::Rect& rect,
      const ::base::string16& text,
      float text_size,
      uint32_t color,
      uint32_t bgcolor,
      bool bold,
      bool italic,
      bool underline,
      bool line_through,
      const base::Optional<::gfx::Range>& selection,
      const std::string& class_name,
      const base::Optional<std::string>& role);

  ~AssistantNode();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = AssistantNodePtr>
  AssistantNodePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, AssistantNode::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        AssistantNode::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        AssistantNode::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::AssistantNode_UnserializedMessageContext<
            UserType, AssistantNode::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<AssistantNode::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return AssistantNode::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::AssistantNode_UnserializedMessageContext<
            UserType, AssistantNode::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<AssistantNode::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  std::vector<int32_t> children_indices;
  
  ::gfx::Rect rect;
  
  ::base::string16 text;
  
  float text_size;
  
  uint32_t color;
  
  uint32_t bgcolor;
  
  bool bold;
  
  bool italic;
  
  bool underline;
  
  bool line_through;
  
  base::Optional<::gfx::Range> selection;
  
  std::string class_name;
  
  base::Optional<std::string> role;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AssistantNode::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, AssistantNode::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, AssistantNode::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, AssistantNode::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  AssistantExtra {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<AssistantExtra, T>::value>;
  using DataView = AssistantExtraDataView;
  using Data_ = internal::AssistantExtra_Data;

  template <typename... Args>
  static AssistantExtraPtr New(Args&&... args) {
    return AssistantExtraPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static AssistantExtraPtr From(const U& u) {
    return mojo::TypeConverter<AssistantExtraPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, AssistantExtra>::Convert(*this);
  }


  AssistantExtra();

  AssistantExtra(
      const ::GURL& url,
      const ::gfx::Rect& bounds_pixel,
      const ::base::string16& title);

  ~AssistantExtra();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = AssistantExtraPtr>
  AssistantExtraPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, AssistantExtra::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        AssistantExtra::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        AssistantExtra::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::AssistantExtra_UnserializedMessageContext<
            UserType, AssistantExtra::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<AssistantExtra::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return AssistantExtra::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::AssistantExtra_UnserializedMessageContext<
            UserType, AssistantExtra::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<AssistantExtra::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::GURL url;
  
  ::gfx::Rect bounds_pixel;
  
  ::base::string16 title;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AssistantExtra::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, AssistantExtra::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, AssistantExtra::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, AssistantExtra::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename StructPtrType>
AssistantTreePtr AssistantTree::Clone() const {
  return New(
      mojo::Clone(nodes)
  );
}

template <typename T, AssistantTree::EnableIfSame<T>*>
bool AssistantTree::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->nodes, other_struct.nodes))
    return false;
  return true;
}

template <typename T, AssistantTree::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.nodes < rhs.nodes)
    return true;
  if (rhs.nodes < lhs.nodes)
    return false;
  return false;
}
template <typename StructPtrType>
AssistantNodePtr AssistantNode::Clone() const {
  return New(
      mojo::Clone(children_indices),
      mojo::Clone(rect),
      mojo::Clone(text),
      mojo::Clone(text_size),
      mojo::Clone(color),
      mojo::Clone(bgcolor),
      mojo::Clone(bold),
      mojo::Clone(italic),
      mojo::Clone(underline),
      mojo::Clone(line_through),
      mojo::Clone(selection),
      mojo::Clone(class_name),
      mojo::Clone(role)
  );
}

template <typename T, AssistantNode::EnableIfSame<T>*>
bool AssistantNode::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->children_indices, other_struct.children_indices))
    return false;
  if (!mojo::Equals(this->rect, other_struct.rect))
    return false;
  if (!mojo::Equals(this->text, other_struct.text))
    return false;
  if (!mojo::Equals(this->text_size, other_struct.text_size))
    return false;
  if (!mojo::Equals(this->color, other_struct.color))
    return false;
  if (!mojo::Equals(this->bgcolor, other_struct.bgcolor))
    return false;
  if (!mojo::Equals(this->bold, other_struct.bold))
    return false;
  if (!mojo::Equals(this->italic, other_struct.italic))
    return false;
  if (!mojo::Equals(this->underline, other_struct.underline))
    return false;
  if (!mojo::Equals(this->line_through, other_struct.line_through))
    return false;
  if (!mojo::Equals(this->selection, other_struct.selection))
    return false;
  if (!mojo::Equals(this->class_name, other_struct.class_name))
    return false;
  if (!mojo::Equals(this->role, other_struct.role))
    return false;
  return true;
}

template <typename T, AssistantNode::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.children_indices < rhs.children_indices)
    return true;
  if (rhs.children_indices < lhs.children_indices)
    return false;
  if (lhs.rect < rhs.rect)
    return true;
  if (rhs.rect < lhs.rect)
    return false;
  if (lhs.text < rhs.text)
    return true;
  if (rhs.text < lhs.text)
    return false;
  if (lhs.text_size < rhs.text_size)
    return true;
  if (rhs.text_size < lhs.text_size)
    return false;
  if (lhs.color < rhs.color)
    return true;
  if (rhs.color < lhs.color)
    return false;
  if (lhs.bgcolor < rhs.bgcolor)
    return true;
  if (rhs.bgcolor < lhs.bgcolor)
    return false;
  if (lhs.bold < rhs.bold)
    return true;
  if (rhs.bold < lhs.bold)
    return false;
  if (lhs.italic < rhs.italic)
    return true;
  if (rhs.italic < lhs.italic)
    return false;
  if (lhs.underline < rhs.underline)
    return true;
  if (rhs.underline < lhs.underline)
    return false;
  if (lhs.line_through < rhs.line_through)
    return true;
  if (rhs.line_through < lhs.line_through)
    return false;
  if (lhs.selection < rhs.selection)
    return true;
  if (rhs.selection < lhs.selection)
    return false;
  if (lhs.class_name < rhs.class_name)
    return true;
  if (rhs.class_name < lhs.class_name)
    return false;
  if (lhs.role < rhs.role)
    return true;
  if (rhs.role < lhs.role)
    return false;
  return false;
}
template <typename StructPtrType>
AssistantExtraPtr AssistantExtra::Clone() const {
  return New(
      mojo::Clone(url),
      mojo::Clone(bounds_pixel),
      mojo::Clone(title)
  );
}

template <typename T, AssistantExtra::EnableIfSame<T>*>
bool AssistantExtra::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->url, other_struct.url))
    return false;
  if (!mojo::Equals(this->bounds_pixel, other_struct.bounds_pixel))
    return false;
  if (!mojo::Equals(this->title, other_struct.title))
    return false;
  return true;
}

template <typename T, AssistantExtra::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.url < rhs.url)
    return true;
  if (rhs.url < lhs.url)
    return false;
  if (lhs.bounds_pixel < rhs.bounds_pixel)
    return true;
  if (rhs.bounds_pixel < lhs.bounds_pixel)
    return false;
  if (lhs.title < rhs.title)
    return true;
  if (rhs.title < lhs.title)
    return false;
  return false;
}


}  // namespace mojom
}  // namespace ax

namespace mojo {


template <>
struct  StructTraits<::ax::mojom::AssistantTree::DataView,
                                         ::ax::mojom::AssistantTreePtr> {
  static bool IsNull(const ::ax::mojom::AssistantTreePtr& input) { return !input; }
  static void SetToNull(::ax::mojom::AssistantTreePtr* output) { output->reset(); }

  static const decltype(::ax::mojom::AssistantTree::nodes)& nodes(
      const ::ax::mojom::AssistantTreePtr& input) {
    return input->nodes;
  }

  static bool Read(::ax::mojom::AssistantTree::DataView input, ::ax::mojom::AssistantTreePtr* output);
};


template <>
struct  StructTraits<::ax::mojom::AssistantNode::DataView,
                                         ::ax::mojom::AssistantNodePtr> {
  static bool IsNull(const ::ax::mojom::AssistantNodePtr& input) { return !input; }
  static void SetToNull(::ax::mojom::AssistantNodePtr* output) { output->reset(); }

  static const decltype(::ax::mojom::AssistantNode::children_indices)& children_indices(
      const ::ax::mojom::AssistantNodePtr& input) {
    return input->children_indices;
  }

  static const decltype(::ax::mojom::AssistantNode::rect)& rect(
      const ::ax::mojom::AssistantNodePtr& input) {
    return input->rect;
  }

  static const decltype(::ax::mojom::AssistantNode::text)& text(
      const ::ax::mojom::AssistantNodePtr& input) {
    return input->text;
  }

  static decltype(::ax::mojom::AssistantNode::text_size) text_size(
      const ::ax::mojom::AssistantNodePtr& input) {
    return input->text_size;
  }

  static decltype(::ax::mojom::AssistantNode::color) color(
      const ::ax::mojom::AssistantNodePtr& input) {
    return input->color;
  }

  static decltype(::ax::mojom::AssistantNode::bgcolor) bgcolor(
      const ::ax::mojom::AssistantNodePtr& input) {
    return input->bgcolor;
  }

  static decltype(::ax::mojom::AssistantNode::bold) bold(
      const ::ax::mojom::AssistantNodePtr& input) {
    return input->bold;
  }

  static decltype(::ax::mojom::AssistantNode::italic) italic(
      const ::ax::mojom::AssistantNodePtr& input) {
    return input->italic;
  }

  static decltype(::ax::mojom::AssistantNode::underline) underline(
      const ::ax::mojom::AssistantNodePtr& input) {
    return input->underline;
  }

  static decltype(::ax::mojom::AssistantNode::line_through) line_through(
      const ::ax::mojom::AssistantNodePtr& input) {
    return input->line_through;
  }

  static const decltype(::ax::mojom::AssistantNode::selection)& selection(
      const ::ax::mojom::AssistantNodePtr& input) {
    return input->selection;
  }

  static const decltype(::ax::mojom::AssistantNode::class_name)& class_name(
      const ::ax::mojom::AssistantNodePtr& input) {
    return input->class_name;
  }

  static const decltype(::ax::mojom::AssistantNode::role)& role(
      const ::ax::mojom::AssistantNodePtr& input) {
    return input->role;
  }

  static bool Read(::ax::mojom::AssistantNode::DataView input, ::ax::mojom::AssistantNodePtr* output);
};


template <>
struct  StructTraits<::ax::mojom::AssistantExtra::DataView,
                                         ::ax::mojom::AssistantExtraPtr> {
  static bool IsNull(const ::ax::mojom::AssistantExtraPtr& input) { return !input; }
  static void SetToNull(::ax::mojom::AssistantExtraPtr* output) { output->reset(); }

  static const decltype(::ax::mojom::AssistantExtra::url)& url(
      const ::ax::mojom::AssistantExtraPtr& input) {
    return input->url;
  }

  static const decltype(::ax::mojom::AssistantExtra::bounds_pixel)& bounds_pixel(
      const ::ax::mojom::AssistantExtraPtr& input) {
    return input->bounds_pixel;
  }

  static const decltype(::ax::mojom::AssistantExtra::title)& title(
      const ::ax::mojom::AssistantExtraPtr& input) {
    return input->title;
  }

  static bool Read(::ax::mojom::AssistantExtra::DataView input, ::ax::mojom::AssistantExtraPtr* output);
};

}  // namespace mojo

#endif  // UI_ACCESSIBILITY_MOJOM_AX_ASSISTANT_STRUCTURE_MOJOM_H_