// media/mojo/mojom/interface_factory.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif


#include "media/mojo/mojom/interface_factory.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"
#include "media/mojo/mojom/audio_decoder.mojom.h"
#include "media/mojo/mojom/decryptor.mojom.h"
#include "media/mojo/mojom/content_decryption_module.mojom.h"
#include "media/mojo/mojom/renderer.mojom.h"
#include "media/mojo/mojom/renderer_extensions.mojom.h"
#include "media/mojo/mojom/video_decoder.mojom.h"
#include "mojo/public/mojom/base/token.mojom.h"
#include "mojo/public/mojom/base/unguessable_token.mojom.h"


#ifndef MEDIA_MOJO_MOJOM_INTERFACE_FACTORY_MOJOM_JUMBO_H_
#define MEDIA_MOJO_MOJOM_INTERFACE_FACTORY_MOJOM_JUMBO_H_
#endif


namespace media {
namespace mojom {


void InterfaceFactoryInterceptorForTesting::CreateAudioDecoder(mojo::PendingReceiver<::media::mojom::AudioDecoder> audio_decoder) {
  GetForwardingInterface()->CreateAudioDecoder(std::move(audio_decoder));
}
void InterfaceFactoryInterceptorForTesting::CreateVideoDecoder(mojo::PendingReceiver<::media::mojom::VideoDecoder> video_decoder) {
  GetForwardingInterface()->CreateVideoDecoder(std::move(video_decoder));
}
void InterfaceFactoryInterceptorForTesting::CreateDefaultRenderer(const std::string& audio_device_id, mojo::PendingReceiver<::media::mojom::Renderer> renderer) {
  GetForwardingInterface()->CreateDefaultRenderer(std::move(audio_device_id), std::move(renderer));
}
void InterfaceFactoryInterceptorForTesting::CreateMediaPlayerRenderer(mojo::PendingRemote<::media::mojom::MediaPlayerRendererClientExtension> client_extension, mojo::PendingReceiver<::media::mojom::Renderer> renderer, mojo::PendingReceiver<::media::mojom::MediaPlayerRendererExtension> renderer_extension) {
  GetForwardingInterface()->CreateMediaPlayerRenderer(std::move(client_extension), std::move(renderer), std::move(renderer_extension));
}
void InterfaceFactoryInterceptorForTesting::CreateFlingingRenderer(const std::string& presentation_id, mojo::PendingRemote<::media::mojom::FlingingRendererClientExtension> client_extension, mojo::PendingReceiver<::media::mojom::Renderer> renderer) {
  GetForwardingInterface()->CreateFlingingRenderer(std::move(presentation_id), std::move(client_extension), std::move(renderer));
}
void InterfaceFactoryInterceptorForTesting::CreateCdm(const std::string& key_system, mojo::PendingReceiver<::media::mojom::ContentDecryptionModule> cdm) {
  GetForwardingInterface()->CreateCdm(std::move(key_system), std::move(cdm));
}
void InterfaceFactoryInterceptorForTesting::CreateDecryptor(int32_t cdm_id, mojo::PendingReceiver<::media::mojom::Decryptor> decryptor) {
  GetForwardingInterface()->CreateDecryptor(std::move(cdm_id), std::move(decryptor));
}
InterfaceFactoryAsyncWaiter::InterfaceFactoryAsyncWaiter(
    InterfaceFactory* proxy) : proxy_(proxy) {}

InterfaceFactoryAsyncWaiter::~InterfaceFactoryAsyncWaiter() = default;






}  // namespace mojom
}  // namespace media

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif