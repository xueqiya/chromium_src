// media/mojo/mojom/android_overlay.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif


#include "media/mojo/mojom/android_overlay.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"
#include "media/mojo/mojom/media_types.mojom.h"
#include "mojo/public/mojom/base/unguessable_token.mojom.h"
#include "ui/gfx/geometry/mojom/geometry.mojom.h"


#ifndef MEDIA_MOJO_MOJOM_ANDROID_OVERLAY_MOJOM_JUMBO_H_
#define MEDIA_MOJO_MOJOM_ANDROID_OVERLAY_MOJOM_JUMBO_H_
#include "mojo/public/cpp/base/unguessable_token_mojom_traits.h"
#include "ui/gfx/geometry/mojom/geometry_mojom_traits.h"
#endif


namespace media {
namespace mojom {


void AndroidOverlayProviderInterceptorForTesting::CreateOverlay(mojo::PendingReceiver<AndroidOverlay> overlay, mojo::PendingRemote<AndroidOverlayClient> client, AndroidOverlayConfigPtr config) {
  GetForwardingInterface()->CreateOverlay(std::move(overlay), std::move(client), std::move(config));
}
AndroidOverlayProviderAsyncWaiter::AndroidOverlayProviderAsyncWaiter(
    AndroidOverlayProvider* proxy) : proxy_(proxy) {}

AndroidOverlayProviderAsyncWaiter::~AndroidOverlayProviderAsyncWaiter() = default;




void AndroidOverlayInterceptorForTesting::ScheduleLayout(const ::gfx::Rect& rect) {
  GetForwardingInterface()->ScheduleLayout(std::move(rect));
}
AndroidOverlayAsyncWaiter::AndroidOverlayAsyncWaiter(
    AndroidOverlay* proxy) : proxy_(proxy) {}

AndroidOverlayAsyncWaiter::~AndroidOverlayAsyncWaiter() = default;




void AndroidOverlayClientInterceptorForTesting::OnSurfaceReady(uint64_t surface_key) {
  GetForwardingInterface()->OnSurfaceReady(std::move(surface_key));
}
void AndroidOverlayClientInterceptorForTesting::OnDestroyed() {
  GetForwardingInterface()->OnDestroyed();
}
void AndroidOverlayClientInterceptorForTesting::OnPowerEfficientState(bool is_power_efficient) {
  GetForwardingInterface()->OnPowerEfficientState(std::move(is_power_efficient));
}
AndroidOverlayClientAsyncWaiter::AndroidOverlayClientAsyncWaiter(
    AndroidOverlayClient* proxy) : proxy_(proxy) {}

AndroidOverlayClientAsyncWaiter::~AndroidOverlayClientAsyncWaiter() = default;






}  // namespace mojom
}  // namespace media

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif