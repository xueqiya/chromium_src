// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "content/browser/devtools/protocol/web_authn.h"

#include "content/browser/devtools/protocol/protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/serializer_traits.h"

namespace content {
namespace protocol {
namespace WebAuthn {

// ------------- Enum values from types.

const char Metainfo::domainName[] = "WebAuthn";
const char Metainfo::commandPrefix[] = "WebAuthn.";
const char Metainfo::version[] = "1.3";

namespace AuthenticatorProtocolEnum {
const char U2f[] = "u2f";
const char Ctap2[] = "ctap2";
} // namespace AuthenticatorProtocolEnum

namespace AuthenticatorTransportEnum {
const char Usb[] = "usb";
const char Nfc[] = "nfc";
const char Ble[] = "ble";
const char Cable[] = "cable";
const char Internal[] = "internal";
} // namespace AuthenticatorTransportEnum

std::unique_ptr<VirtualAuthenticatorOptions> VirtualAuthenticatorOptions::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->addError("object expected");
        return nullptr;
    }

    std::unique_ptr<VirtualAuthenticatorOptions> result(new VirtualAuthenticatorOptions());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->push();
    protocol::Value* protocolValue = object->get("protocol");
    errors->setName("protocol");
    result->m_protocol = ValueConversions<String>::fromValue(protocolValue, errors);
    protocol::Value* transportValue = object->get("transport");
    errors->setName("transport");
    result->m_transport = ValueConversions<String>::fromValue(transportValue, errors);
    protocol::Value* hasResidentKeyValue = object->get("hasResidentKey");
    if (hasResidentKeyValue) {
        errors->setName("hasResidentKey");
        result->m_hasResidentKey = ValueConversions<bool>::fromValue(hasResidentKeyValue, errors);
    }
    protocol::Value* hasUserVerificationValue = object->get("hasUserVerification");
    if (hasUserVerificationValue) {
        errors->setName("hasUserVerification");
        result->m_hasUserVerification = ValueConversions<bool>::fromValue(hasUserVerificationValue, errors);
    }
    protocol::Value* automaticPresenceSimulationValue = object->get("automaticPresenceSimulation");
    if (automaticPresenceSimulationValue) {
        errors->setName("automaticPresenceSimulation");
        result->m_automaticPresenceSimulation = ValueConversions<bool>::fromValue(automaticPresenceSimulationValue, errors);
    }
    protocol::Value* isUserVerifiedValue = object->get("isUserVerified");
    if (isUserVerifiedValue) {
        errors->setName("isUserVerified");
        result->m_isUserVerified = ValueConversions<bool>::fromValue(isUserVerifiedValue, errors);
    }
    errors->pop();
    if (errors->hasErrors())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> VirtualAuthenticatorOptions::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("protocol", ValueConversions<String>::toValue(m_protocol));
    result->setValue("transport", ValueConversions<String>::toValue(m_transport));
    if (m_hasResidentKey.isJust())
        result->setValue("hasResidentKey", ValueConversions<bool>::toValue(m_hasResidentKey.fromJust()));
    if (m_hasUserVerification.isJust())
        result->setValue("hasUserVerification", ValueConversions<bool>::toValue(m_hasUserVerification.fromJust()));
    if (m_automaticPresenceSimulation.isJust())
        result->setValue("automaticPresenceSimulation", ValueConversions<bool>::toValue(m_automaticPresenceSimulation.fromJust()));
    if (m_isUserVerified.isJust())
        result->setValue("isUserVerified", ValueConversions<bool>::toValue(m_isUserVerified.fromJust()));
    return result;
}

void VirtualAuthenticatorOptions::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("protocol"), m_protocol, out);
      crdtp::SerializeField(crdtp::SpanFrom("transport"), m_transport, out);
      crdtp::SerializeField(crdtp::SpanFrom("hasResidentKey"), m_hasResidentKey, out);
      crdtp::SerializeField(crdtp::SpanFrom("hasUserVerification"), m_hasUserVerification, out);
      crdtp::SerializeField(crdtp::SpanFrom("automaticPresenceSimulation"), m_automaticPresenceSimulation, out);
      crdtp::SerializeField(crdtp::SpanFrom("isUserVerified"), m_isUserVerified, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<VirtualAuthenticatorOptions> VirtualAuthenticatorOptions::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<Credential> Credential::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->addError("object expected");
        return nullptr;
    }

    std::unique_ptr<Credential> result(new Credential());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->push();
    protocol::Value* credentialIdValue = object->get("credentialId");
    errors->setName("credentialId");
    result->m_credentialId = ValueConversions<Binary>::fromValue(credentialIdValue, errors);
    protocol::Value* isResidentCredentialValue = object->get("isResidentCredential");
    errors->setName("isResidentCredential");
    result->m_isResidentCredential = ValueConversions<bool>::fromValue(isResidentCredentialValue, errors);
    protocol::Value* rpIdValue = object->get("rpId");
    if (rpIdValue) {
        errors->setName("rpId");
        result->m_rpId = ValueConversions<String>::fromValue(rpIdValue, errors);
    }
    protocol::Value* privateKeyValue = object->get("privateKey");
    errors->setName("privateKey");
    result->m_privateKey = ValueConversions<Binary>::fromValue(privateKeyValue, errors);
    protocol::Value* userHandleValue = object->get("userHandle");
    if (userHandleValue) {
        errors->setName("userHandle");
        result->m_userHandle = ValueConversions<Binary>::fromValue(userHandleValue, errors);
    }
    protocol::Value* signCountValue = object->get("signCount");
    errors->setName("signCount");
    result->m_signCount = ValueConversions<int>::fromValue(signCountValue, errors);
    errors->pop();
    if (errors->hasErrors())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> Credential::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("credentialId", ValueConversions<Binary>::toValue(m_credentialId));
    result->setValue("isResidentCredential", ValueConversions<bool>::toValue(m_isResidentCredential));
    if (m_rpId.isJust())
        result->setValue("rpId", ValueConversions<String>::toValue(m_rpId.fromJust()));
    result->setValue("privateKey", ValueConversions<Binary>::toValue(m_privateKey));
    if (m_userHandle.isJust())
        result->setValue("userHandle", ValueConversions<Binary>::toValue(m_userHandle.fromJust()));
    result->setValue("signCount", ValueConversions<int>::toValue(m_signCount));
    return result;
}

void Credential::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("credentialId"), m_credentialId, out);
      crdtp::SerializeField(crdtp::SpanFrom("isResidentCredential"), m_isResidentCredential, out);
      crdtp::SerializeField(crdtp::SpanFrom("rpId"), m_rpId, out);
      crdtp::SerializeField(crdtp::SpanFrom("privateKey"), m_privateKey, out);
      crdtp::SerializeField(crdtp::SpanFrom("userHandle"), m_userHandle, out);
      crdtp::SerializeField(crdtp::SpanFrom("signCount"), m_signCount, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<Credential> Credential::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

// ------------- Enum values from params.


// ------------- Frontend notifications.

void Frontend::flush()
{
    m_frontendChannel->flushProtocolNotifications();
}

void Frontend::sendRawCBORNotification(std::vector<uint8_t> notification)
{
    m_frontendChannel->sendProtocolNotification(InternalRawNotification::fromBinary(std::move(notification)));
}

// --------------------- Dispatcher.

class DispatcherImpl : public protocol::DispatcherBase {
public:
    DispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DispatcherBase(frontendChannel)
        , m_backend(backend) {
        m_dispatchMap["WebAuthn.enable"] = &DispatcherImpl::enable;
        m_dispatchMap["WebAuthn.disable"] = &DispatcherImpl::disable;
        m_dispatchMap["WebAuthn.addVirtualAuthenticator"] = &DispatcherImpl::addVirtualAuthenticator;
        m_dispatchMap["WebAuthn.removeVirtualAuthenticator"] = &DispatcherImpl::removeVirtualAuthenticator;
        m_dispatchMap["WebAuthn.addCredential"] = &DispatcherImpl::addCredential;
        m_dispatchMap["WebAuthn.getCredential"] = &DispatcherImpl::getCredential;
        m_dispatchMap["WebAuthn.getCredentials"] = &DispatcherImpl::getCredentials;
        m_dispatchMap["WebAuthn.removeCredential"] = &DispatcherImpl::removeCredential;
        m_dispatchMap["WebAuthn.clearCredentials"] = &DispatcherImpl::clearCredentials;
        m_dispatchMap["WebAuthn.setUserVerified"] = &DispatcherImpl::setUserVerified;
    }
    ~DispatcherImpl() override { }
    bool canDispatch(const String& method) override;
    void dispatch(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<protocol::DictionaryValue> messageObject) override;
    std::unordered_map<String, String>& redirects() { return m_redirects; }

protected:
    using CallHandler = void (DispatcherImpl::*)(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> messageObject, ErrorSupport* errors);
    using DispatchMap = std::unordered_map<String, CallHandler>;
    DispatchMap m_dispatchMap;
    std::unordered_map<String, String> m_redirects;

    void enable(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport*);
    void disable(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport*);
    void addVirtualAuthenticator(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport*);
    void removeVirtualAuthenticator(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport*);
    void addCredential(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport*);
    void getCredential(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport*);
    void getCredentials(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport*);
    void removeCredential(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport*);
    void clearCredentials(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport*);
    void setUserVerified(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport*);

    Backend* m_backend;
};

bool DispatcherImpl::canDispatch(const String& method) {
    return m_dispatchMap.find(method) != m_dispatchMap.end();
}

void DispatcherImpl::dispatch(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<protocol::DictionaryValue> messageObject)
{
    std::unordered_map<String, CallHandler>::iterator it = m_dispatchMap.find(method);
    DCHECK(it != m_dispatchMap.end());
    protocol::ErrorSupport errors;
    (this->*(it->second))(callId, method, message, std::move(messageObject), &errors);
}


void DispatcherImpl::enable(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport* errors)
{

    std::unique_ptr<DispatcherBase::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->Enable();
    if (response.status() == DispatchResponse::kFallThrough) {
        channel()->fallThrough(callId, method, message);
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(callId, response);
    return;
}

void DispatcherImpl::disable(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport* errors)
{

    std::unique_ptr<DispatcherBase::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->Disable();
    if (response.status() == DispatchResponse::kFallThrough) {
        channel()->fallThrough(callId, method, message);
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(callId, response);
    return;
}

void DispatcherImpl::addVirtualAuthenticator(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::DictionaryValue* object = DictionaryValue::cast(requestMessageObject->get("params"));
    errors->push();
    protocol::Value* optionsValue = object ? object->get("options") : nullptr;
    errors->setName("options");
    std::unique_ptr<protocol::WebAuthn::VirtualAuthenticatorOptions> in_options = ValueConversions<protocol::WebAuthn::VirtualAuthenticatorOptions>::fromValue(optionsValue, errors);
    errors->pop();
    if (errors->hasErrors()) {
        reportProtocolError(callId, DispatchResponse::kInvalidParams, kInvalidParamsString, errors);
        return;
    }
    // Declare output parameters.
    String out_authenticatorId;

    std::unique_ptr<DispatcherBase::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->AddVirtualAuthenticator(std::move(in_options), &out_authenticatorId);
    if (response.status() == DispatchResponse::kFallThrough) {
        channel()->fallThrough(callId, method, message);
        return;
    }
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (response.status() == DispatchResponse::kSuccess) {
        result->setValue("authenticatorId", ValueConversions<String>::toValue(out_authenticatorId));
    }
    if (weak->get())
        weak->get()->sendResponse(callId, response, std::move(result));
    return;
}

void DispatcherImpl::removeVirtualAuthenticator(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::DictionaryValue* object = DictionaryValue::cast(requestMessageObject->get("params"));
    errors->push();
    protocol::Value* authenticatorIdValue = object ? object->get("authenticatorId") : nullptr;
    errors->setName("authenticatorId");
    String in_authenticatorId = ValueConversions<String>::fromValue(authenticatorIdValue, errors);
    errors->pop();
    if (errors->hasErrors()) {
        reportProtocolError(callId, DispatchResponse::kInvalidParams, kInvalidParamsString, errors);
        return;
    }

    std::unique_ptr<DispatcherBase::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->RemoveVirtualAuthenticator(in_authenticatorId);
    if (response.status() == DispatchResponse::kFallThrough) {
        channel()->fallThrough(callId, method, message);
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(callId, response);
    return;
}

void DispatcherImpl::addCredential(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::DictionaryValue* object = DictionaryValue::cast(requestMessageObject->get("params"));
    errors->push();
    protocol::Value* authenticatorIdValue = object ? object->get("authenticatorId") : nullptr;
    errors->setName("authenticatorId");
    String in_authenticatorId = ValueConversions<String>::fromValue(authenticatorIdValue, errors);
    protocol::Value* credentialValue = object ? object->get("credential") : nullptr;
    errors->setName("credential");
    std::unique_ptr<protocol::WebAuthn::Credential> in_credential = ValueConversions<protocol::WebAuthn::Credential>::fromValue(credentialValue, errors);
    errors->pop();
    if (errors->hasErrors()) {
        reportProtocolError(callId, DispatchResponse::kInvalidParams, kInvalidParamsString, errors);
        return;
    }

    std::unique_ptr<DispatcherBase::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->AddCredential(in_authenticatorId, std::move(in_credential));
    if (response.status() == DispatchResponse::kFallThrough) {
        channel()->fallThrough(callId, method, message);
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(callId, response);
    return;
}

void DispatcherImpl::getCredential(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::DictionaryValue* object = DictionaryValue::cast(requestMessageObject->get("params"));
    errors->push();
    protocol::Value* authenticatorIdValue = object ? object->get("authenticatorId") : nullptr;
    errors->setName("authenticatorId");
    String in_authenticatorId = ValueConversions<String>::fromValue(authenticatorIdValue, errors);
    protocol::Value* credentialIdValue = object ? object->get("credentialId") : nullptr;
    errors->setName("credentialId");
    Binary in_credentialId = ValueConversions<Binary>::fromValue(credentialIdValue, errors);
    errors->pop();
    if (errors->hasErrors()) {
        reportProtocolError(callId, DispatchResponse::kInvalidParams, kInvalidParamsString, errors);
        return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::WebAuthn::Credential> out_credential;

    std::unique_ptr<DispatcherBase::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->GetCredential(in_authenticatorId, in_credentialId, &out_credential);
    if (response.status() == DispatchResponse::kFallThrough) {
        channel()->fallThrough(callId, method, message);
        return;
    }
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (response.status() == DispatchResponse::kSuccess) {
        result->setValue("credential", ValueConversions<protocol::WebAuthn::Credential>::toValue(out_credential.get()));
    }
    if (weak->get())
        weak->get()->sendResponse(callId, response, std::move(result));
    return;
}

void DispatcherImpl::getCredentials(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::DictionaryValue* object = DictionaryValue::cast(requestMessageObject->get("params"));
    errors->push();
    protocol::Value* authenticatorIdValue = object ? object->get("authenticatorId") : nullptr;
    errors->setName("authenticatorId");
    String in_authenticatorId = ValueConversions<String>::fromValue(authenticatorIdValue, errors);
    errors->pop();
    if (errors->hasErrors()) {
        reportProtocolError(callId, DispatchResponse::kInvalidParams, kInvalidParamsString, errors);
        return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::WebAuthn::Credential>> out_credentials;

    std::unique_ptr<DispatcherBase::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->GetCredentials(in_authenticatorId, &out_credentials);
    if (response.status() == DispatchResponse::kFallThrough) {
        channel()->fallThrough(callId, method, message);
        return;
    }
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (response.status() == DispatchResponse::kSuccess) {
        result->setValue("credentials", ValueConversions<protocol::Array<protocol::WebAuthn::Credential>>::toValue(out_credentials.get()));
    }
    if (weak->get())
        weak->get()->sendResponse(callId, response, std::move(result));
    return;
}

void DispatcherImpl::removeCredential(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::DictionaryValue* object = DictionaryValue::cast(requestMessageObject->get("params"));
    errors->push();
    protocol::Value* authenticatorIdValue = object ? object->get("authenticatorId") : nullptr;
    errors->setName("authenticatorId");
    String in_authenticatorId = ValueConversions<String>::fromValue(authenticatorIdValue, errors);
    protocol::Value* credentialIdValue = object ? object->get("credentialId") : nullptr;
    errors->setName("credentialId");
    Binary in_credentialId = ValueConversions<Binary>::fromValue(credentialIdValue, errors);
    errors->pop();
    if (errors->hasErrors()) {
        reportProtocolError(callId, DispatchResponse::kInvalidParams, kInvalidParamsString, errors);
        return;
    }

    std::unique_ptr<DispatcherBase::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->RemoveCredential(in_authenticatorId, in_credentialId);
    if (response.status() == DispatchResponse::kFallThrough) {
        channel()->fallThrough(callId, method, message);
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(callId, response);
    return;
}

void DispatcherImpl::clearCredentials(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::DictionaryValue* object = DictionaryValue::cast(requestMessageObject->get("params"));
    errors->push();
    protocol::Value* authenticatorIdValue = object ? object->get("authenticatorId") : nullptr;
    errors->setName("authenticatorId");
    String in_authenticatorId = ValueConversions<String>::fromValue(authenticatorIdValue, errors);
    errors->pop();
    if (errors->hasErrors()) {
        reportProtocolError(callId, DispatchResponse::kInvalidParams, kInvalidParamsString, errors);
        return;
    }

    std::unique_ptr<DispatcherBase::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->ClearCredentials(in_authenticatorId);
    if (response.status() == DispatchResponse::kFallThrough) {
        channel()->fallThrough(callId, method, message);
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(callId, response);
    return;
}

void DispatcherImpl::setUserVerified(int callId, const String& method, crdtp::span<uint8_t> message, std::unique_ptr<DictionaryValue> requestMessageObject, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::DictionaryValue* object = DictionaryValue::cast(requestMessageObject->get("params"));
    errors->push();
    protocol::Value* authenticatorIdValue = object ? object->get("authenticatorId") : nullptr;
    errors->setName("authenticatorId");
    String in_authenticatorId = ValueConversions<String>::fromValue(authenticatorIdValue, errors);
    protocol::Value* isUserVerifiedValue = object ? object->get("isUserVerified") : nullptr;
    errors->setName("isUserVerified");
    bool in_isUserVerified = ValueConversions<bool>::fromValue(isUserVerifiedValue, errors);
    errors->pop();
    if (errors->hasErrors()) {
        reportProtocolError(callId, DispatchResponse::kInvalidParams, kInvalidParamsString, errors);
        return;
    }

    std::unique_ptr<DispatcherBase::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->SetUserVerified(in_authenticatorId, in_isUserVerified);
    if (response.status() == DispatchResponse::kFallThrough) {
        channel()->fallThrough(callId, method, message);
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(callId, response);
    return;
}

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    std::unique_ptr<DispatcherImpl> dispatcher(new DispatcherImpl(uber->channel(), backend));
    uber->setupRedirects(dispatcher->redirects());
    uber->registerBackend("WebAuthn", std::move(dispatcher));
}

} // WebAuthn
} // namespace content
} // namespace protocol
