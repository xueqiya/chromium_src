// content/common/render_message_filter.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif


#include "content/common/render_message_filter.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"
#include "content/common/input/input_handler.mojom.h"
#include "content/common/widget.mojom.h"
#include "mojo/public/mojom/base/thread_priority.mojom.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "url/mojom/url.mojom.h"


#ifndef CONTENT_COMMON_RENDER_MESSAGE_FILTER_MOJOM_JUMBO_H_
#define CONTENT_COMMON_RENDER_MESSAGE_FILTER_MOJOM_JUMBO_H_
#endif


namespace content {
namespace mojom {


void RenderMessageFilterInterceptorForTesting::GenerateRoutingID(GenerateRoutingIDCallback callback) {
  GetForwardingInterface()->GenerateRoutingID(std::move(callback));
}
void RenderMessageFilterInterceptorForTesting::CreateNewWidget(int32_t opener_id, mojo::PendingRemote<::content::mojom::Widget> widget, CreateNewWidgetCallback callback) {
  GetForwardingInterface()->CreateNewWidget(std::move(opener_id), std::move(widget), std::move(callback));
}
void RenderMessageFilterInterceptorForTesting::CreateFullscreenWidget(int32_t opener_id, mojo::PendingRemote<::content::mojom::Widget> widget, CreateFullscreenWidgetCallback callback) {
  GetForwardingInterface()->CreateFullscreenWidget(std::move(opener_id), std::move(widget), std::move(callback));
}
void RenderMessageFilterInterceptorForTesting::HasGpuProcess(HasGpuProcessCallback callback) {
  GetForwardingInterface()->HasGpuProcess(std::move(callback));
}
RenderMessageFilterAsyncWaiter::RenderMessageFilterAsyncWaiter(
    RenderMessageFilter* proxy) : proxy_(proxy) {}

RenderMessageFilterAsyncWaiter::~RenderMessageFilterAsyncWaiter() = default;

void RenderMessageFilterAsyncWaiter::GenerateRoutingID(
    int32_t* out_routing_id) {
  base::RunLoop loop;
  proxy_->GenerateRoutingID(
      base::BindOnce(
          [](base::RunLoop* loop,
             int32_t* out_routing_id
,
             int32_t routing_id) {*out_routing_id = std::move(routing_id);
            loop->Quit();
          },
          &loop,
          out_routing_id));
  loop.Run();
}
void RenderMessageFilterAsyncWaiter::CreateNewWidget(
    int32_t opener_id, mojo::PendingRemote<::content::mojom::Widget> widget, int32_t* out_route_id) {
  base::RunLoop loop;
  proxy_->CreateNewWidget(std::move(opener_id),std::move(widget),
      base::BindOnce(
          [](base::RunLoop* loop,
             int32_t* out_route_id
,
             int32_t route_id) {*out_route_id = std::move(route_id);
            loop->Quit();
          },
          &loop,
          out_route_id));
  loop.Run();
}
void RenderMessageFilterAsyncWaiter::CreateFullscreenWidget(
    int32_t opener_id, mojo::PendingRemote<::content::mojom::Widget> widget, int32_t* out_route_id) {
  base::RunLoop loop;
  proxy_->CreateFullscreenWidget(std::move(opener_id),std::move(widget),
      base::BindOnce(
          [](base::RunLoop* loop,
             int32_t* out_route_id
,
             int32_t route_id) {*out_route_id = std::move(route_id);
            loop->Quit();
          },
          &loop,
          out_route_id));
  loop.Run();
}
void RenderMessageFilterAsyncWaiter::HasGpuProcess(
    bool* out_has_gpu_process) {
  base::RunLoop loop;
  proxy_->HasGpuProcess(
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_has_gpu_process
,
             bool has_gpu_process) {*out_has_gpu_process = std::move(has_gpu_process);
            loop->Quit();
          },
          &loop,
          out_has_gpu_process));
  loop.Run();
}





}  // namespace mojom
}  // namespace content

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif