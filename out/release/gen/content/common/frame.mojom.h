// content/common/frame.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CONTENT_COMMON_FRAME_MOJOM_H_
#define CONTENT_COMMON_FRAME_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "base/callback.h"
#include "base/macros.h"
#include "base/optional.h"

#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#if BUILDFLAG(MOJO_TRACE_ENABLED)
#include "base/trace_event/trace_event.h"
#endif
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"
#include "content/common/frame.mojom-shared.h"
#include "content/common/frame.mojom-forward.h"
#include "content/common/document_scoped_interface_bundle.mojom.h"
#include "content/common/frame_messages.mojom.h"
#include "content/common/native_types.mojom.h"
#include "content/common/navigation_client.mojom.h"
#include "content/common/navigation_params.mojom.h"
#include "content/public/common/browser_controls_state.mojom.h"
#include "content/public/common/resource_type.mojom.h"
#include "content/public/common/resource_load_info.mojom.h"
#include "content/public/common/transferrable_url_loader.mojom.h"
#include "content/public/common/window_container_type.mojom.h"
#include "mojo/public/mojom/base/string16.mojom.h"
#include "mojo/public/mojom/base/unguessable_token.mojom.h"
#include "mojo/public/mojom/base/values.mojom.h"
#include "services/network/public/mojom/content_security_policy.mojom.h"
#include "services/network/public/mojom/url_loader.mojom.h"
#include "services/network/public/mojom/url_loader_factory.mojom.h"
#include "services/network/public/mojom/url_response_head.mojom.h"
#include "services/service_manager/public/mojom/interface_provider.mojom.h"
#include "services/viz/public/mojom/compositing/frame_sink_id.mojom.h"
#include "services/viz/public/mojom/compositing/surface_id.mojom.h"
#include "third_party/blink/public/mojom/blob/blob_url_store.mojom.h"
#include "third_party/blink/public/mojom/commit_result/commit_result.mojom.h"
#include "third_party/blink/public/mojom/devtools/console_message.mojom.h"
#include "third_party/blink/public/mojom/feature_policy/feature_policy.mojom.h"
#include "third_party/blink/public/mojom/feature_policy/feature_policy_feature.mojom.h"
#include "third_party/blink/public/mojom/feature_policy/policy_value.mojom.h"
#include "third_party/blink/public/mojom/frame/lifecycle.mojom.h"
#include "third_party/blink/public/mojom/frame/navigation_initiator.mojom.h"
#include "third_party/blink/public/mojom/messaging/transferable_message.mojom.h"
#include "third_party/blink/public/mojom/loader/url_loader_factory_bundle.mojom.h"
#include "third_party/blink/public/mojom/messaging/transferable_message.mojom.h"
#include "third_party/blink/public/mojom/portal/portal.mojom.h"
#include "third_party/blink/public/mojom/referrer.mojom.h"
#include "third_party/blink/public/mojom/service_worker/controller_service_worker.mojom.h"
#include "third_party/blink/public/mojom/service_worker/service_worker_provider.mojom.h"
#include "third_party/blink/public/mojom/devtools/devtools_agent.mojom.h"
#include "third_party/blink/public/mojom/portal/portal.mojom.h"
#include "third_party/blink/public/mojom/window_features/window_features.mojom.h"
#include "ui/base/mojom/window_open_disposition.mojom.h"
#include "url/mojom/url.mojom.h"
#include "url/mojom/origin.mojom.h"
#include "ui/gfx/geometry/mojom/geometry.mojom.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/associated_interface_ptr.h"
#include "mojo/public/cpp/bindings/associated_interface_ptr_info.h"
#include "mojo/public/cpp/bindings/associated_interface_request.h"
#include "mojo/public/cpp/bindings/interface_ptr.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"
#include "mojo/public/cpp/bindings/thread_safe_interface_ptr.h"


#include "mojo/public/cpp/bindings/lib/native_enum_serialization.h"
#include "mojo/public/cpp/bindings/lib/native_struct_serialization.h"
#include "content/common/content_export.h"




namespace content {
namespace mojom {

class FrameProxy;

template <typename ImplRefTraits>
class FrameStub;

class FrameRequestValidator;
class FrameResponseValidator;


class CONTENT_EXPORT Frame
    : public FrameInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = FrameInterfaceBase;
  using Proxy_ = FrameProxy;

  template <typename ImplRefTraits>
  using Stub_ = FrameStub<ImplRefTraits>;

  using RequestValidator_ = FrameRequestValidator;
  using ResponseValidator_ = FrameResponseValidator;
  enum MethodMinVersions : uint32_t {
    kGetInterfaceProviderMinVersion = 0,
    kGetCanonicalUrlForSharingMinVersion = 0,
    kBlockRequestsMinVersion = 0,
    kResumeBlockedRequestsMinVersion = 0,
    kCancelBlockedRequestsMinVersion = 0,
    kSetLifecycleStateMinVersion = 0,
    kExtractSmartClipDataMinVersion = 0,
    kUpdateBrowserControlsStateMinVersion = 0,
  };
  virtual ~Frame() {}

  
  virtual void GetInterfaceProvider(mojo::PendingReceiver<::service_manager::mojom::InterfaceProvider> interfaces) = 0;


  using GetCanonicalUrlForSharingCallback = base::OnceCallback<void(const base::Optional<::GURL>&)>;
  
  virtual void GetCanonicalUrlForSharing(GetCanonicalUrlForSharingCallback callback) = 0;

  
  virtual void BlockRequests() = 0;

  
  virtual void ResumeBlockedRequests() = 0;

  
  virtual void CancelBlockedRequests() = 0;

  
  virtual void SetLifecycleState(::blink::mojom::FrameLifecycleState state) = 0;


  using ExtractSmartClipDataCallback = base::OnceCallback<void(const ::base::string16&, const ::base::string16&, const ::gfx::Rect&)>;
  
  virtual void ExtractSmartClipData(const ::gfx::Rect& rect, ExtractSmartClipDataCallback callback) = 0;

  
  virtual void UpdateBrowserControlsState(::content::BrowserControlsState constraints, ::content::BrowserControlsState current, bool animate) = 0;
};

class FrameNavigationControlProxy;

template <typename ImplRefTraits>
class FrameNavigationControlStub;

class FrameNavigationControlRequestValidator;
class FrameNavigationControlResponseValidator;


class CONTENT_EXPORT FrameNavigationControl
    : public FrameNavigationControlInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = true;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = FrameNavigationControlInterfaceBase;
  using Proxy_ = FrameNavigationControlProxy;

  template <typename ImplRefTraits>
  using Stub_ = FrameNavigationControlStub<ImplRefTraits>;

  using RequestValidator_ = FrameNavigationControlRequestValidator;
  using ResponseValidator_ = FrameNavigationControlResponseValidator;
  enum MethodMinVersions : uint32_t {
    kCommitNavigationMinVersion = 0,
    kCommitSameDocumentNavigationMinVersion = 0,
    kHandleRendererDebugURLMinVersion = 0,
    kUpdateSubresourceLoaderFactoriesMinVersion = 0,
    kBindDevToolsAgentMinVersion = 0,
    kJavaScriptExecuteRequestMinVersion = 0,
    kJavaScriptExecuteRequestForTestsMinVersion = 0,
    kJavaScriptExecuteRequestInIsolatedWorldMinVersion = 0,
    kPostMessageEventMinVersion = 0,
    kForwardMessageFromHostMinVersion = 0,
    kOnPortalActivatedMinVersion = 0,
    kReportContentSecurityPolicyViolationMinVersion = 0,
  };
  virtual ~FrameNavigationControl() {}


  using CommitNavigationCallback = base::OnceCallback<void(::blink::mojom::CommitResult)>;
  
  virtual void CommitNavigation(::content::mojom::CommonNavigationParamsPtr common_params, ::content::mojom::CommitNavigationParamsPtr request_params, ::network::mojom::URLResponseHeadPtr response_head, mojo::ScopedDataPipeConsumerHandle response_body, ::network::mojom::URLLoaderClientEndpointsPtr url_loader_client_endpoints, ::std::unique_ptr<::blink::PendingURLLoaderFactoryBundle> subresource_loader_factories, base::Optional<std::vector<::content::mojom::TransferrableURLLoaderPtr>> subresource_overrides, ::blink::mojom::ControllerServiceWorkerInfoPtr controller_service_worker_info, ::blink::mojom::ServiceWorkerProviderInfoForClientPtr provider_info, mojo::PendingRemote<::network::mojom::URLLoaderFactory> prefetch_loader_factory, const ::base::UnguessableToken& devtools_navigation_token, CommitNavigationCallback callback) = 0;


  using CommitSameDocumentNavigationCallback = base::OnceCallback<void(::blink::mojom::CommitResult)>;
  
  virtual void CommitSameDocumentNavigation(::content::mojom::CommonNavigationParamsPtr common_params, ::content::mojom::CommitNavigationParamsPtr request_params, CommitSameDocumentNavigationCallback callback) = 0;

  
  virtual void HandleRendererDebugURL(const ::GURL& url) = 0;

  
  virtual void UpdateSubresourceLoaderFactories(::std::unique_ptr<::blink::PendingURLLoaderFactoryBundle> subresource_loader_factories) = 0;

  
  virtual void BindDevToolsAgent(mojo::PendingAssociatedRemote<::blink::mojom::DevToolsAgentHost> agent_host, mojo::PendingAssociatedReceiver<::blink::mojom::DevToolsAgent> agent) = 0;


  using JavaScriptExecuteRequestCallback = base::OnceCallback<void(::base::Value)>;
  
  virtual void JavaScriptExecuteRequest(const ::base::string16& javascript, bool wants_result, JavaScriptExecuteRequestCallback callback) = 0;


  using JavaScriptExecuteRequestForTestsCallback = base::OnceCallback<void(::base::Value)>;
  
  virtual void JavaScriptExecuteRequestForTests(const ::base::string16& javascript, bool wants_result, bool has_user_gesture, int32_t world_id, JavaScriptExecuteRequestForTestsCallback callback) = 0;


  using JavaScriptExecuteRequestInIsolatedWorldCallback = base::OnceCallback<void(::base::Value)>;
  
  virtual void JavaScriptExecuteRequestInIsolatedWorld(const ::base::string16& javascript, bool wants_result, int32_t world_id, JavaScriptExecuteRequestInIsolatedWorldCallback callback) = 0;

  
  virtual void PostMessageEvent(int32_t source_routing_id, const ::base::string16& source_origin, const ::base::string16& target_origin, ::blink::TransferableMessage message) = 0;

  
  virtual void ForwardMessageFromHost(::blink::TransferableMessage message, const ::url::Origin& source_origin, const base::Optional<::url::Origin>& target_origin) = 0;


  using OnPortalActivatedCallback = base::OnceCallback<void(::blink::mojom::PortalActivateResult)>;
  
  virtual void OnPortalActivated(const ::base::UnguessableToken& portal_token, mojo::PendingAssociatedRemote<::blink::mojom::Portal> portal, mojo::PendingAssociatedReceiver<::blink::mojom::PortalClient> portal_client, ::blink::TransferableMessage data, OnPortalActivatedCallback callback) = 0;

  
  virtual void ReportContentSecurityPolicyViolation(const ::content::CSPViolationParams& violation_params) = 0;
};

class FrameBindingsControlProxy;

template <typename ImplRefTraits>
class FrameBindingsControlStub;

class FrameBindingsControlRequestValidator;


class CONTENT_EXPORT FrameBindingsControl
    : public FrameBindingsControlInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = FrameBindingsControlInterfaceBase;
  using Proxy_ = FrameBindingsControlProxy;

  template <typename ImplRefTraits>
  using Stub_ = FrameBindingsControlStub<ImplRefTraits>;

  using RequestValidator_ = FrameBindingsControlRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kAllowBindingsMinVersion = 0,
    kEnableMojoJsBindingsMinVersion = 0,
  };
  virtual ~FrameBindingsControl() {}

  
  virtual void AllowBindings(int32_t enabled_bindings_flags) = 0;

  
  virtual void EnableMojoJsBindings() = 0;
};

class FrameFactoryProxy;

template <typename ImplRefTraits>
class FrameFactoryStub;

class FrameFactoryRequestValidator;


class CONTENT_EXPORT FrameFactory
    : public FrameFactoryInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = FrameFactoryInterfaceBase;
  using Proxy_ = FrameFactoryProxy;

  template <typename ImplRefTraits>
  using Stub_ = FrameFactoryStub<ImplRefTraits>;

  using RequestValidator_ = FrameFactoryRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kCreateFrameMinVersion = 0,
  };
  virtual ~FrameFactory() {}

  
  virtual void CreateFrame(int32_t frame_routing_id, mojo::PendingReceiver<Frame> frame) = 0;
};

class KeepAliveHandleProxy;

template <typename ImplRefTraits>
class KeepAliveHandleStub;

class KeepAliveHandleRequestValidator;


class CONTENT_EXPORT KeepAliveHandle
    : public KeepAliveHandleInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = KeepAliveHandleInterfaceBase;
  using Proxy_ = KeepAliveHandleProxy;

  template <typename ImplRefTraits>
  using Stub_ = KeepAliveHandleStub<ImplRefTraits>;

  using RequestValidator_ = KeepAliveHandleRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
  };
  virtual ~KeepAliveHandle() {}
};

class FrameHostProxy;

template <typename ImplRefTraits>
class FrameHostStub;

class FrameHostRequestValidator;
class FrameHostResponseValidator;


class CONTENT_EXPORT FrameHost
    : public FrameHostInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = true;
  static constexpr bool HasSyncMethods_ = true;

  using Base_ = FrameHostInterfaceBase;
  using Proxy_ = FrameHostProxy;

  template <typename ImplRefTraits>
  using Stub_ = FrameHostStub<ImplRefTraits>;

  using RequestValidator_ = FrameHostRequestValidator;
  using ResponseValidator_ = FrameHostResponseValidator;
  enum MethodMinVersions : uint32_t {
    kCreateNewWindowMinVersion = 0,
    kCreatePortalMinVersion = 0,
    kAdoptPortalMinVersion = 0,
    kIssueKeepAliveHandleMinVersion = 0,
    kDidCommitProvisionalLoadMinVersion = 0,
    kDidCommitSameDocumentNavigationMinVersion = 0,
    kBeginNavigationMinVersion = 0,
    kSubresourceResponseStartedMinVersion = 0,
    kResourceLoadCompleteMinVersion = 0,
    kDidChangeNameMinVersion = 0,
    kDidSetFramePolicyHeadersMinVersion = 0,
    kCancelInitialHistoryLoadMinVersion = 0,
    kUpdateEncodingMinVersion = 0,
    kFrameSizeChangedMinVersion = 0,
    kUpdateUserGestureCarryoverInfoMinVersion = 0,
    kDidAddMessageToConsoleMinVersion = 0,
    kDidFailLoadWithErrorMinVersion = 0,
    kTransferUserActivationFromMinVersion = 0,
    kShowCreatedWindowMinVersion = 0,
    kDidAddContentSecurityPoliciesMinVersion = 0,
  };
  virtual ~FrameHost() {}

  // Sync method. This signature is used by the client side; the service side
  // should implement the signature with callback below.
  
  virtual bool CreateNewWindow(CreateNewWindowParamsPtr params, CreateNewWindowStatus* out_status, CreateNewWindowReplyPtr* out_reply);

  using CreateNewWindowCallback = base::OnceCallback<void(CreateNewWindowStatus, CreateNewWindowReplyPtr)>;
  
  virtual void CreateNewWindow(CreateNewWindowParamsPtr params, CreateNewWindowCallback callback) = 0;

  // Sync method. This signature is used by the client side; the service side
  // should implement the signature with callback below.
  
  virtual bool CreatePortal(mojo::PendingAssociatedReceiver<::blink::mojom::Portal> portal, mojo::PendingAssociatedRemote<::blink::mojom::PortalClient> client, int32_t* out_proxy_routing_id, ::content::FrameReplicationState* out_initial_replicated_state, ::base::UnguessableToken* out_portal_token, ::base::UnguessableToken* out_devtools_frame_token);

  using CreatePortalCallback = base::OnceCallback<void(int32_t, const ::content::FrameReplicationState&, const ::base::UnguessableToken&, const ::base::UnguessableToken&)>;
  
  virtual void CreatePortal(mojo::PendingAssociatedReceiver<::blink::mojom::Portal> portal, mojo::PendingAssociatedRemote<::blink::mojom::PortalClient> client, CreatePortalCallback callback) = 0;

  // Sync method. This signature is used by the client side; the service side
  // should implement the signature with callback below.
  
  virtual bool AdoptPortal(const ::base::UnguessableToken& portal_token, int32_t* out_proxy_routing_id, ::viz::FrameSinkId* out_frame_sink_id, ::content::FrameReplicationState* out_replicated_state, ::base::UnguessableToken* out_devtools_frame_token);

  using AdoptPortalCallback = base::OnceCallback<void(int32_t, const ::viz::FrameSinkId&, const ::content::FrameReplicationState&, const ::base::UnguessableToken&)>;
  
  virtual void AdoptPortal(const ::base::UnguessableToken& portal_token, AdoptPortalCallback callback) = 0;

  
  virtual void IssueKeepAliveHandle(mojo::PendingReceiver<KeepAliveHandle> keep_alive_handle) = 0;

  
  virtual void DidCommitProvisionalLoad(::std::unique_ptr<::FrameHostMsg_DidCommitProvisionalLoad_Params> params, ::content::mojom::DidCommitProvisionalLoadInterfaceParamsPtr interface_params) = 0;

  
  virtual void DidCommitSameDocumentNavigation(::std::unique_ptr<::FrameHostMsg_DidCommitProvisionalLoad_Params> params) = 0;

  
  virtual void BeginNavigation(::content::mojom::CommonNavigationParamsPtr common_params, ::content::mojom::BeginNavigationParamsPtr begin_params, mojo::PendingRemote<::blink::mojom::BlobURLToken> blob_url_token, mojo::PendingAssociatedRemote<::content::mojom::NavigationClient> navigation_client, mojo::PendingRemote<::blink::mojom::NavigationInitiator> navigation_initiator) = 0;

  
  virtual void SubresourceResponseStarted(const ::GURL& url, uint32_t cert_status) = 0;

  
  virtual void ResourceLoadComplete(::content::mojom::ResourceLoadInfoPtr url_load_info) = 0;

  
  virtual void DidChangeName(const std::string& name, const std::string& unique_name) = 0;

  
  virtual void DidSetFramePolicyHeaders(::blink::WebSandboxFlags sandbox_flags, const std::vector<::blink::ParsedFeaturePolicyDeclaration>& feature_policy_header, const base::flat_map<::blink::mojom::FeaturePolicyFeature, ::blink::PolicyValue>& document_policy_header) = 0;

  
  virtual void CancelInitialHistoryLoad() = 0;

  
  virtual void UpdateEncoding(const std::string& encoding_name) = 0;

  
  virtual void FrameSizeChanged(const ::gfx::Size& size) = 0;

  
  virtual void UpdateUserGestureCarryoverInfo() = 0;

  
  virtual void DidAddMessageToConsole(::blink::mojom::ConsoleMessageLevel log_level, const ::base::string16& msg, int32_t line_number, const ::base::string16& source_id) = 0;

  
  virtual void DidFailLoadWithError(const ::GURL& url, int32_t error_code) = 0;

  
  virtual void TransferUserActivationFrom(int32_t source_routing_id) = 0;

  
  virtual void ShowCreatedWindow(int32_t pending_widget_routing_id, ::WindowOpenDisposition disposition, const ::gfx::Rect& rect, bool opened_by_user_gesture) = 0;

  
  virtual void DidAddContentSecurityPolicies(std::vector<::network::mojom::ContentSecurityPolicyPtr> policies) = 0;
};



class CONTENT_EXPORT FrameProxy
    : public Frame {
 public:
  using InterfaceType = Frame;

  explicit FrameProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void GetInterfaceProvider(mojo::PendingReceiver<::service_manager::mojom::InterfaceProvider> interfaces) final;
  
  void GetCanonicalUrlForSharing(GetCanonicalUrlForSharingCallback callback) final;
  
  void BlockRequests() final;
  
  void ResumeBlockedRequests() final;
  
  void CancelBlockedRequests() final;
  
  void SetLifecycleState(::blink::mojom::FrameLifecycleState state) final;
  
  void ExtractSmartClipData(const ::gfx::Rect& rect, ExtractSmartClipDataCallback callback) final;
  
  void UpdateBrowserControlsState(::content::BrowserControlsState constraints, ::content::BrowserControlsState current, bool animate) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class CONTENT_EXPORT FrameNavigationControlProxy
    : public FrameNavigationControl {
 public:
  using InterfaceType = FrameNavigationControl;

  explicit FrameNavigationControlProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void CommitNavigation(::content::mojom::CommonNavigationParamsPtr common_params, ::content::mojom::CommitNavigationParamsPtr request_params, ::network::mojom::URLResponseHeadPtr response_head, mojo::ScopedDataPipeConsumerHandle response_body, ::network::mojom::URLLoaderClientEndpointsPtr url_loader_client_endpoints, ::std::unique_ptr<::blink::PendingURLLoaderFactoryBundle> subresource_loader_factories, base::Optional<std::vector<::content::mojom::TransferrableURLLoaderPtr>> subresource_overrides, ::blink::mojom::ControllerServiceWorkerInfoPtr controller_service_worker_info, ::blink::mojom::ServiceWorkerProviderInfoForClientPtr provider_info, mojo::PendingRemote<::network::mojom::URLLoaderFactory> prefetch_loader_factory, const ::base::UnguessableToken& devtools_navigation_token, CommitNavigationCallback callback) final;
  
  void CommitSameDocumentNavigation(::content::mojom::CommonNavigationParamsPtr common_params, ::content::mojom::CommitNavigationParamsPtr request_params, CommitSameDocumentNavigationCallback callback) final;
  
  void HandleRendererDebugURL(const ::GURL& url) final;
  
  void UpdateSubresourceLoaderFactories(::std::unique_ptr<::blink::PendingURLLoaderFactoryBundle> subresource_loader_factories) final;
  
  void BindDevToolsAgent(mojo::PendingAssociatedRemote<::blink::mojom::DevToolsAgentHost> agent_host, mojo::PendingAssociatedReceiver<::blink::mojom::DevToolsAgent> agent) final;
  
  void JavaScriptExecuteRequest(const ::base::string16& javascript, bool wants_result, JavaScriptExecuteRequestCallback callback) final;
  
  void JavaScriptExecuteRequestForTests(const ::base::string16& javascript, bool wants_result, bool has_user_gesture, int32_t world_id, JavaScriptExecuteRequestForTestsCallback callback) final;
  
  void JavaScriptExecuteRequestInIsolatedWorld(const ::base::string16& javascript, bool wants_result, int32_t world_id, JavaScriptExecuteRequestInIsolatedWorldCallback callback) final;
  
  void PostMessageEvent(int32_t source_routing_id, const ::base::string16& source_origin, const ::base::string16& target_origin, ::blink::TransferableMessage message) final;
  
  void ForwardMessageFromHost(::blink::TransferableMessage message, const ::url::Origin& source_origin, const base::Optional<::url::Origin>& target_origin) final;
  
  void OnPortalActivated(const ::base::UnguessableToken& portal_token, mojo::PendingAssociatedRemote<::blink::mojom::Portal> portal, mojo::PendingAssociatedReceiver<::blink::mojom::PortalClient> portal_client, ::blink::TransferableMessage data, OnPortalActivatedCallback callback) final;
  
  void ReportContentSecurityPolicyViolation(const ::content::CSPViolationParams& violation_params) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class CONTENT_EXPORT FrameBindingsControlProxy
    : public FrameBindingsControl {
 public:
  using InterfaceType = FrameBindingsControl;

  explicit FrameBindingsControlProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void AllowBindings(int32_t enabled_bindings_flags) final;
  
  void EnableMojoJsBindings() final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class CONTENT_EXPORT FrameFactoryProxy
    : public FrameFactory {
 public:
  using InterfaceType = FrameFactory;

  explicit FrameFactoryProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void CreateFrame(int32_t frame_routing_id, mojo::PendingReceiver<Frame> frame) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class CONTENT_EXPORT KeepAliveHandleProxy
    : public KeepAliveHandle {
 public:
  using InterfaceType = KeepAliveHandle;

  explicit KeepAliveHandleProxy(mojo::MessageReceiverWithResponder* receiver);

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class CONTENT_EXPORT FrameHostProxy
    : public FrameHost {
 public:
  using InterfaceType = FrameHost;

  explicit FrameHostProxy(mojo::MessageReceiverWithResponder* receiver);
  
  bool CreateNewWindow(CreateNewWindowParamsPtr params, CreateNewWindowStatus* out_status, CreateNewWindowReplyPtr* out_reply) final;
  
  void CreateNewWindow(CreateNewWindowParamsPtr params, CreateNewWindowCallback callback) final;
  
  bool CreatePortal(mojo::PendingAssociatedReceiver<::blink::mojom::Portal> portal, mojo::PendingAssociatedRemote<::blink::mojom::PortalClient> client, int32_t* out_proxy_routing_id, ::content::FrameReplicationState* out_initial_replicated_state, ::base::UnguessableToken* out_portal_token, ::base::UnguessableToken* out_devtools_frame_token) final;
  
  void CreatePortal(mojo::PendingAssociatedReceiver<::blink::mojom::Portal> portal, mojo::PendingAssociatedRemote<::blink::mojom::PortalClient> client, CreatePortalCallback callback) final;
  
  bool AdoptPortal(const ::base::UnguessableToken& portal_token, int32_t* out_proxy_routing_id, ::viz::FrameSinkId* out_frame_sink_id, ::content::FrameReplicationState* out_replicated_state, ::base::UnguessableToken* out_devtools_frame_token) final;
  
  void AdoptPortal(const ::base::UnguessableToken& portal_token, AdoptPortalCallback callback) final;
  
  void IssueKeepAliveHandle(mojo::PendingReceiver<KeepAliveHandle> keep_alive_handle) final;
  
  void DidCommitProvisionalLoad(::std::unique_ptr<::FrameHostMsg_DidCommitProvisionalLoad_Params> params, ::content::mojom::DidCommitProvisionalLoadInterfaceParamsPtr interface_params) final;
  
  void DidCommitSameDocumentNavigation(::std::unique_ptr<::FrameHostMsg_DidCommitProvisionalLoad_Params> params) final;
  
  void BeginNavigation(::content::mojom::CommonNavigationParamsPtr common_params, ::content::mojom::BeginNavigationParamsPtr begin_params, mojo::PendingRemote<::blink::mojom::BlobURLToken> blob_url_token, mojo::PendingAssociatedRemote<::content::mojom::NavigationClient> navigation_client, mojo::PendingRemote<::blink::mojom::NavigationInitiator> navigation_initiator) final;
  
  void SubresourceResponseStarted(const ::GURL& url, uint32_t cert_status) final;
  
  void ResourceLoadComplete(::content::mojom::ResourceLoadInfoPtr url_load_info) final;
  
  void DidChangeName(const std::string& name, const std::string& unique_name) final;
  
  void DidSetFramePolicyHeaders(::blink::WebSandboxFlags sandbox_flags, const std::vector<::blink::ParsedFeaturePolicyDeclaration>& feature_policy_header, const base::flat_map<::blink::mojom::FeaturePolicyFeature, ::blink::PolicyValue>& document_policy_header) final;
  
  void CancelInitialHistoryLoad() final;
  
  void UpdateEncoding(const std::string& encoding_name) final;
  
  void FrameSizeChanged(const ::gfx::Size& size) final;
  
  void UpdateUserGestureCarryoverInfo() final;
  
  void DidAddMessageToConsole(::blink::mojom::ConsoleMessageLevel log_level, const ::base::string16& msg, int32_t line_number, const ::base::string16& source_id) final;
  
  void DidFailLoadWithError(const ::GURL& url, int32_t error_code) final;
  
  void TransferUserActivationFrom(int32_t source_routing_id) final;
  
  void ShowCreatedWindow(int32_t pending_widget_routing_id, ::WindowOpenDisposition disposition, const ::gfx::Rect& rect, bool opened_by_user_gesture) final;
  
  void DidAddContentSecurityPolicies(std::vector<::network::mojom::ContentSecurityPolicyPtr> policies) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class CONTENT_EXPORT FrameStubDispatch {
 public:
  static bool Accept(Frame* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      Frame* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<Frame>>
class FrameStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  FrameStub() {}
  ~FrameStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return FrameStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return FrameStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class CONTENT_EXPORT FrameNavigationControlStubDispatch {
 public:
  static bool Accept(FrameNavigationControl* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      FrameNavigationControl* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<FrameNavigationControl>>
class FrameNavigationControlStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  FrameNavigationControlStub() {}
  ~FrameNavigationControlStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return FrameNavigationControlStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return FrameNavigationControlStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class CONTENT_EXPORT FrameBindingsControlStubDispatch {
 public:
  static bool Accept(FrameBindingsControl* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      FrameBindingsControl* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<FrameBindingsControl>>
class FrameBindingsControlStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  FrameBindingsControlStub() {}
  ~FrameBindingsControlStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return FrameBindingsControlStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return FrameBindingsControlStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class CONTENT_EXPORT FrameFactoryStubDispatch {
 public:
  static bool Accept(FrameFactory* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      FrameFactory* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<FrameFactory>>
class FrameFactoryStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  FrameFactoryStub() {}
  ~FrameFactoryStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return FrameFactoryStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return FrameFactoryStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class CONTENT_EXPORT KeepAliveHandleStubDispatch {
 public:
  static bool Accept(KeepAliveHandle* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      KeepAliveHandle* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<KeepAliveHandle>>
class KeepAliveHandleStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  KeepAliveHandleStub() {}
  ~KeepAliveHandleStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return KeepAliveHandleStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return KeepAliveHandleStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class CONTENT_EXPORT FrameHostStubDispatch {
 public:
  static bool Accept(FrameHost* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      FrameHost* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<FrameHost>>
class FrameHostStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  FrameHostStub() {}
  ~FrameHostStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return FrameHostStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return FrameHostStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class CONTENT_EXPORT FrameRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class CONTENT_EXPORT FrameNavigationControlRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class CONTENT_EXPORT FrameBindingsControlRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class CONTENT_EXPORT FrameFactoryRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class CONTENT_EXPORT KeepAliveHandleRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class CONTENT_EXPORT FrameHostRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class CONTENT_EXPORT FrameResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class CONTENT_EXPORT FrameNavigationControlResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class CONTENT_EXPORT FrameHostResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};









class CONTENT_EXPORT CreateNewWindowParams {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<CreateNewWindowParams, T>::value>;
  using DataView = CreateNewWindowParamsDataView;
  using Data_ = internal::CreateNewWindowParams_Data;

  template <typename... Args>
  static CreateNewWindowParamsPtr New(Args&&... args) {
    return CreateNewWindowParamsPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static CreateNewWindowParamsPtr From(const U& u) {
    return mojo::TypeConverter<CreateNewWindowParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CreateNewWindowParams>::Convert(*this);
  }


  CreateNewWindowParams();

  CreateNewWindowParams(
      bool mimic_user_gesture,
      ::content::mojom::WindowContainerType window_container_type,
      const std::string& session_storage_namespace_id,
      const std::string& clone_from_session_storage_namespace_id,
      const std::string& frame_name,
      bool opener_suppressed,
      ::WindowOpenDisposition disposition,
      const ::GURL& target_url,
      ::blink::mojom::ReferrerPtr referrer,
      ::blink::mojom::WindowFeaturesPtr features);

  ~CreateNewWindowParams();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = CreateNewWindowParamsPtr>
  CreateNewWindowParamsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, CreateNewWindowParams::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        CreateNewWindowParams::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        CreateNewWindowParams::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::CreateNewWindowParams_UnserializedMessageContext<
            UserType, CreateNewWindowParams::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<CreateNewWindowParams::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return CreateNewWindowParams::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::CreateNewWindowParams_UnserializedMessageContext<
            UserType, CreateNewWindowParams::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<CreateNewWindowParams::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  bool mimic_user_gesture;
  
  ::content::mojom::WindowContainerType window_container_type;
  
  std::string session_storage_namespace_id;
  
  std::string clone_from_session_storage_namespace_id;
  
  std::string frame_name;
  
  bool opener_suppressed;
  
  ::WindowOpenDisposition disposition;
  
  ::GURL target_url;
  
  ::blink::mojom::ReferrerPtr referrer;
  
  ::blink::mojom::WindowFeaturesPtr features;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(CreateNewWindowParams);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CreateNewWindowParams::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, CreateNewWindowParams::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, CreateNewWindowParams::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, CreateNewWindowParams::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class CONTENT_EXPORT CreateNewWindowReply {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<CreateNewWindowReply, T>::value>;
  using DataView = CreateNewWindowReplyDataView;
  using Data_ = internal::CreateNewWindowReply_Data;

  template <typename... Args>
  static CreateNewWindowReplyPtr New(Args&&... args) {
    return CreateNewWindowReplyPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static CreateNewWindowReplyPtr From(const U& u) {
    return mojo::TypeConverter<CreateNewWindowReplyPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CreateNewWindowReply>::Convert(*this);
  }


  CreateNewWindowReply();

  CreateNewWindowReply(
      int32_t route_id,
      int32_t main_frame_route_id,
      int32_t main_frame_widget_route_id,
      const ::content::VisualProperties& visual_properties,
      ::content::mojom::DocumentScopedInterfaceBundlePtr main_frame_interface_bundle,
      const std::string& cloned_session_storage_namespace_id,
      const ::base::UnguessableToken& devtools_main_frame_token);

  ~CreateNewWindowReply();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = CreateNewWindowReplyPtr>
  CreateNewWindowReplyPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, CreateNewWindowReply::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        CreateNewWindowReply::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        CreateNewWindowReply::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::CreateNewWindowReply_UnserializedMessageContext<
            UserType, CreateNewWindowReply::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<CreateNewWindowReply::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return CreateNewWindowReply::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::CreateNewWindowReply_UnserializedMessageContext<
            UserType, CreateNewWindowReply::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<CreateNewWindowReply::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  int32_t route_id;
  
  int32_t main_frame_route_id;
  
  int32_t main_frame_widget_route_id;
  
  ::content::VisualProperties visual_properties;
  
  ::content::mojom::DocumentScopedInterfaceBundlePtr main_frame_interface_bundle;
  
  std::string cloned_session_storage_namespace_id;
  
  ::base::UnguessableToken devtools_main_frame_token;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(CreateNewWindowReply);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CreateNewWindowReply::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, CreateNewWindowReply::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, CreateNewWindowReply::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, CreateNewWindowReply::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename StructPtrType>
CreateNewWindowParamsPtr CreateNewWindowParams::Clone() const {
  return New(
      mojo::Clone(mimic_user_gesture),
      mojo::Clone(window_container_type),
      mojo::Clone(session_storage_namespace_id),
      mojo::Clone(clone_from_session_storage_namespace_id),
      mojo::Clone(frame_name),
      mojo::Clone(opener_suppressed),
      mojo::Clone(disposition),
      mojo::Clone(target_url),
      mojo::Clone(referrer),
      mojo::Clone(features)
  );
}

template <typename T, CreateNewWindowParams::EnableIfSame<T>*>
bool CreateNewWindowParams::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->mimic_user_gesture, other_struct.mimic_user_gesture))
    return false;
  if (!mojo::Equals(this->window_container_type, other_struct.window_container_type))
    return false;
  if (!mojo::Equals(this->session_storage_namespace_id, other_struct.session_storage_namespace_id))
    return false;
  if (!mojo::Equals(this->clone_from_session_storage_namespace_id, other_struct.clone_from_session_storage_namespace_id))
    return false;
  if (!mojo::Equals(this->frame_name, other_struct.frame_name))
    return false;
  if (!mojo::Equals(this->opener_suppressed, other_struct.opener_suppressed))
    return false;
  if (!mojo::Equals(this->disposition, other_struct.disposition))
    return false;
  if (!mojo::Equals(this->target_url, other_struct.target_url))
    return false;
  if (!mojo::Equals(this->referrer, other_struct.referrer))
    return false;
  if (!mojo::Equals(this->features, other_struct.features))
    return false;
  return true;
}

template <typename T, CreateNewWindowParams::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.mimic_user_gesture < rhs.mimic_user_gesture)
    return true;
  if (rhs.mimic_user_gesture < lhs.mimic_user_gesture)
    return false;
  if (lhs.window_container_type < rhs.window_container_type)
    return true;
  if (rhs.window_container_type < lhs.window_container_type)
    return false;
  if (lhs.session_storage_namespace_id < rhs.session_storage_namespace_id)
    return true;
  if (rhs.session_storage_namespace_id < lhs.session_storage_namespace_id)
    return false;
  if (lhs.clone_from_session_storage_namespace_id < rhs.clone_from_session_storage_namespace_id)
    return true;
  if (rhs.clone_from_session_storage_namespace_id < lhs.clone_from_session_storage_namespace_id)
    return false;
  if (lhs.frame_name < rhs.frame_name)
    return true;
  if (rhs.frame_name < lhs.frame_name)
    return false;
  if (lhs.opener_suppressed < rhs.opener_suppressed)
    return true;
  if (rhs.opener_suppressed < lhs.opener_suppressed)
    return false;
  if (lhs.disposition < rhs.disposition)
    return true;
  if (rhs.disposition < lhs.disposition)
    return false;
  if (lhs.target_url < rhs.target_url)
    return true;
  if (rhs.target_url < lhs.target_url)
    return false;
  if (lhs.referrer < rhs.referrer)
    return true;
  if (rhs.referrer < lhs.referrer)
    return false;
  if (lhs.features < rhs.features)
    return true;
  if (rhs.features < lhs.features)
    return false;
  return false;
}
template <typename StructPtrType>
CreateNewWindowReplyPtr CreateNewWindowReply::Clone() const {
  return New(
      mojo::Clone(route_id),
      mojo::Clone(main_frame_route_id),
      mojo::Clone(main_frame_widget_route_id),
      mojo::Clone(visual_properties),
      mojo::Clone(main_frame_interface_bundle),
      mojo::Clone(cloned_session_storage_namespace_id),
      mojo::Clone(devtools_main_frame_token)
  );
}

template <typename T, CreateNewWindowReply::EnableIfSame<T>*>
bool CreateNewWindowReply::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->route_id, other_struct.route_id))
    return false;
  if (!mojo::Equals(this->main_frame_route_id, other_struct.main_frame_route_id))
    return false;
  if (!mojo::Equals(this->main_frame_widget_route_id, other_struct.main_frame_widget_route_id))
    return false;
  if (!mojo::Equals(this->visual_properties, other_struct.visual_properties))
    return false;
  if (!mojo::Equals(this->main_frame_interface_bundle, other_struct.main_frame_interface_bundle))
    return false;
  if (!mojo::Equals(this->cloned_session_storage_namespace_id, other_struct.cloned_session_storage_namespace_id))
    return false;
  if (!mojo::Equals(this->devtools_main_frame_token, other_struct.devtools_main_frame_token))
    return false;
  return true;
}

template <typename T, CreateNewWindowReply::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.route_id < rhs.route_id)
    return true;
  if (rhs.route_id < lhs.route_id)
    return false;
  if (lhs.main_frame_route_id < rhs.main_frame_route_id)
    return true;
  if (rhs.main_frame_route_id < lhs.main_frame_route_id)
    return false;
  if (lhs.main_frame_widget_route_id < rhs.main_frame_widget_route_id)
    return true;
  if (rhs.main_frame_widget_route_id < lhs.main_frame_widget_route_id)
    return false;
  if (lhs.visual_properties < rhs.visual_properties)
    return true;
  if (rhs.visual_properties < lhs.visual_properties)
    return false;
  if (lhs.main_frame_interface_bundle < rhs.main_frame_interface_bundle)
    return true;
  if (rhs.main_frame_interface_bundle < lhs.main_frame_interface_bundle)
    return false;
  if (lhs.cloned_session_storage_namespace_id < rhs.cloned_session_storage_namespace_id)
    return true;
  if (rhs.cloned_session_storage_namespace_id < lhs.cloned_session_storage_namespace_id)
    return false;
  if (lhs.devtools_main_frame_token < rhs.devtools_main_frame_token)
    return true;
  if (rhs.devtools_main_frame_token < lhs.devtools_main_frame_token)
    return false;
  return false;
}


}  // namespace mojom
}  // namespace content

namespace mojo {


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::CreateNewWindowParams::DataView,
                                         ::content::mojom::CreateNewWindowParamsPtr> {
  static bool IsNull(const ::content::mojom::CreateNewWindowParamsPtr& input) { return !input; }
  static void SetToNull(::content::mojom::CreateNewWindowParamsPtr* output) { output->reset(); }

  static decltype(::content::mojom::CreateNewWindowParams::mimic_user_gesture) mimic_user_gesture(
      const ::content::mojom::CreateNewWindowParamsPtr& input) {
    return input->mimic_user_gesture;
  }

  static decltype(::content::mojom::CreateNewWindowParams::window_container_type) window_container_type(
      const ::content::mojom::CreateNewWindowParamsPtr& input) {
    return input->window_container_type;
  }

  static const decltype(::content::mojom::CreateNewWindowParams::session_storage_namespace_id)& session_storage_namespace_id(
      const ::content::mojom::CreateNewWindowParamsPtr& input) {
    return input->session_storage_namespace_id;
  }

  static const decltype(::content::mojom::CreateNewWindowParams::clone_from_session_storage_namespace_id)& clone_from_session_storage_namespace_id(
      const ::content::mojom::CreateNewWindowParamsPtr& input) {
    return input->clone_from_session_storage_namespace_id;
  }

  static const decltype(::content::mojom::CreateNewWindowParams::frame_name)& frame_name(
      const ::content::mojom::CreateNewWindowParamsPtr& input) {
    return input->frame_name;
  }

  static decltype(::content::mojom::CreateNewWindowParams::opener_suppressed) opener_suppressed(
      const ::content::mojom::CreateNewWindowParamsPtr& input) {
    return input->opener_suppressed;
  }

  static decltype(::content::mojom::CreateNewWindowParams::disposition) disposition(
      const ::content::mojom::CreateNewWindowParamsPtr& input) {
    return input->disposition;
  }

  static const decltype(::content::mojom::CreateNewWindowParams::target_url)& target_url(
      const ::content::mojom::CreateNewWindowParamsPtr& input) {
    return input->target_url;
  }

  static const decltype(::content::mojom::CreateNewWindowParams::referrer)& referrer(
      const ::content::mojom::CreateNewWindowParamsPtr& input) {
    return input->referrer;
  }

  static const decltype(::content::mojom::CreateNewWindowParams::features)& features(
      const ::content::mojom::CreateNewWindowParamsPtr& input) {
    return input->features;
  }

  static bool Read(::content::mojom::CreateNewWindowParams::DataView input, ::content::mojom::CreateNewWindowParamsPtr* output);
};


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::CreateNewWindowReply::DataView,
                                         ::content::mojom::CreateNewWindowReplyPtr> {
  static bool IsNull(const ::content::mojom::CreateNewWindowReplyPtr& input) { return !input; }
  static void SetToNull(::content::mojom::CreateNewWindowReplyPtr* output) { output->reset(); }

  static decltype(::content::mojom::CreateNewWindowReply::route_id) route_id(
      const ::content::mojom::CreateNewWindowReplyPtr& input) {
    return input->route_id;
  }

  static decltype(::content::mojom::CreateNewWindowReply::main_frame_route_id) main_frame_route_id(
      const ::content::mojom::CreateNewWindowReplyPtr& input) {
    return input->main_frame_route_id;
  }

  static decltype(::content::mojom::CreateNewWindowReply::main_frame_widget_route_id) main_frame_widget_route_id(
      const ::content::mojom::CreateNewWindowReplyPtr& input) {
    return input->main_frame_widget_route_id;
  }

  static const decltype(::content::mojom::CreateNewWindowReply::visual_properties)& visual_properties(
      const ::content::mojom::CreateNewWindowReplyPtr& input) {
    return input->visual_properties;
  }

  static  decltype(::content::mojom::CreateNewWindowReply::main_frame_interface_bundle)& main_frame_interface_bundle(
       ::content::mojom::CreateNewWindowReplyPtr& input) {
    return input->main_frame_interface_bundle;
  }

  static const decltype(::content::mojom::CreateNewWindowReply::cloned_session_storage_namespace_id)& cloned_session_storage_namespace_id(
      const ::content::mojom::CreateNewWindowReplyPtr& input) {
    return input->cloned_session_storage_namespace_id;
  }

  static const decltype(::content::mojom::CreateNewWindowReply::devtools_main_frame_token)& devtools_main_frame_token(
      const ::content::mojom::CreateNewWindowReplyPtr& input) {
    return input->devtools_main_frame_token;
  }

  static bool Read(::content::mojom::CreateNewWindowReply::DataView input, ::content::mojom::CreateNewWindowReplyPtr* output);
};

}  // namespace mojo

#endif  // CONTENT_COMMON_FRAME_MOJOM_H_