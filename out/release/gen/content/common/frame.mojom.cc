// content/common/frame.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif

#include "content/common/frame.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/hash/md5_constexpr.h"
#include "base/logging.h"
#include "base/run_loop.h"
#include "base/task/common/task_annotator.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_context.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"

#include "content/common/frame.mojom-params-data.h"
#include "content/common/frame.mojom-shared-message-ids.h"

#include "content/common/frame.mojom-import-headers.h"


#ifndef CONTENT_COMMON_FRAME_MOJOM_JUMBO_H_
#define CONTENT_COMMON_FRAME_MOJOM_JUMBO_H_
#include "content/common/frame_messages.h"
#include "content/common/input/input_event_mojom_traits.h"
#include "content/common/input/touch_action_optional_mojom_traits.h"
#include "content/common/input_messages.h"
#include "content/common/resource_messages.h"
#include "content/common/view_messages.h"
#include "content/common/widget_messages.h"
#include "content/public/common/common_param_traits.h"
#include "content/public/common/common_param_traits_macros.h"
#include "content/public/common/resource_type_mojom_traits.h"
#include "mojo/public/cpp/base/big_buffer_mojom_traits.h"
#include "mojo/public/cpp/base/file_mojom_traits.h"
#include "mojo/public/cpp/base/file_path_mojom_traits.h"
#include "mojo/public/cpp/base/string16_mojom_traits.h"
#include "mojo/public/cpp/base/time_mojom_traits.h"
#include "mojo/public/cpp/base/unguessable_token_mojom_traits.h"
#include "mojo/public/cpp/base/values_mojom_traits.h"
#include "services/network/public/cpp/ip_address_mojom_traits.h"
#include "services/network/public/cpp/ip_endpoint_mojom_traits.h"
#include "services/network/public/cpp/load_timing_info_mojom_traits.h"
#include "services/network/public/cpp/net_ipc_param_traits.h"
#include "services/network/public/cpp/network_ipc_param_traits.h"
#include "services/network/public/cpp/network_isolation_key_mojom_traits.h"
#include "services/network/public/cpp/network_param_mojom_traits.h"
#include "services/network/public/cpp/p2p_param_traits.h"
#include "services/network/public/cpp/url_request_mojom_traits.h"
#include "services/proxy_resolver/public/cpp/mojo_host_mojom_traits.h"
#include "services/proxy_resolver/public/cpp/proxy_resolver_mojom_traits.h"
#include "services/viz/public/cpp/compositing/frame_sink_id_mojom_traits.h"
#include "skia/public/mojom/bitmap_skbitmap_mojom_traits.h"
#include "skia/public/mojom/image_info_mojom_traits.h"
#include "third_party/blink/common/feature_policy/feature_policy_mojom_traits.h"
#include "third_party/blink/common/feature_policy/policy_value_mojom_traits.h"
#include "third_party/blink/common/frame/frame_policy_mojom_traits.h"
#include "third_party/blink/public/common/loader/url_loader_factory_bundle_mojom_traits.h"
#include "third_party/blink/public/common/messaging/cloneable_message_mojom_traits.h"
#include "third_party/blink/public/common/messaging/transferable_message_mojom_traits.h"
#include "ui/base/mojom/window_open_disposition_mojom_traits.h"
#include "ui/gfx/geometry/mojom/geometry_mojom_traits.h"
#include "url/mojom/origin_mojom_traits.h"
#include "url/mojom/url_gurl_mojom_traits.h"
#endif
namespace content {
namespace mojom {
const char kNavigation_FrameSpec[] = "navigation:frame";
CreateNewWindowParams::CreateNewWindowParams()
    : mimic_user_gesture(),
      window_container_type(),
      session_storage_namespace_id(),
      clone_from_session_storage_namespace_id(),
      frame_name(),
      opener_suppressed(),
      disposition(),
      target_url(),
      referrer(),
      features() {}

CreateNewWindowParams::CreateNewWindowParams(
    bool mimic_user_gesture_in,
    ::content::mojom::WindowContainerType window_container_type_in,
    const std::string& session_storage_namespace_id_in,
    const std::string& clone_from_session_storage_namespace_id_in,
    const std::string& frame_name_in,
    bool opener_suppressed_in,
    ::WindowOpenDisposition disposition_in,
    const ::GURL& target_url_in,
    ::blink::mojom::ReferrerPtr referrer_in,
    ::blink::mojom::WindowFeaturesPtr features_in)
    : mimic_user_gesture(std::move(mimic_user_gesture_in)),
      window_container_type(std::move(window_container_type_in)),
      session_storage_namespace_id(std::move(session_storage_namespace_id_in)),
      clone_from_session_storage_namespace_id(std::move(clone_from_session_storage_namespace_id_in)),
      frame_name(std::move(frame_name_in)),
      opener_suppressed(std::move(opener_suppressed_in)),
      disposition(std::move(disposition_in)),
      target_url(std::move(target_url_in)),
      referrer(std::move(referrer_in)),
      features(std::move(features_in)) {}

CreateNewWindowParams::~CreateNewWindowParams() = default;

bool CreateNewWindowParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
CreateNewWindowReply::CreateNewWindowReply()
    : route_id(),
      main_frame_route_id(),
      main_frame_widget_route_id(),
      visual_properties(),
      main_frame_interface_bundle(),
      cloned_session_storage_namespace_id(),
      devtools_main_frame_token() {}

CreateNewWindowReply::CreateNewWindowReply(
    int32_t route_id_in,
    int32_t main_frame_route_id_in,
    int32_t main_frame_widget_route_id_in,
    const ::content::VisualProperties& visual_properties_in,
    ::content::mojom::DocumentScopedInterfaceBundlePtr main_frame_interface_bundle_in,
    const std::string& cloned_session_storage_namespace_id_in,
    const ::base::UnguessableToken& devtools_main_frame_token_in)
    : route_id(std::move(route_id_in)),
      main_frame_route_id(std::move(main_frame_route_id_in)),
      main_frame_widget_route_id(std::move(main_frame_widget_route_id_in)),
      visual_properties(std::move(visual_properties_in)),
      main_frame_interface_bundle(std::move(main_frame_interface_bundle_in)),
      cloned_session_storage_namespace_id(std::move(cloned_session_storage_namespace_id_in)),
      devtools_main_frame_token(std::move(devtools_main_frame_token_in)) {}

CreateNewWindowReply::~CreateNewWindowReply() = default;

bool CreateNewWindowReply::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char Frame::Name_[] = "content.mojom.Frame";

class Frame_GetCanonicalUrlForSharing_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Frame_GetCanonicalUrlForSharing_ForwardToCallback(
      Frame::GetCanonicalUrlForSharingCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Frame::GetCanonicalUrlForSharingCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(Frame_GetCanonicalUrlForSharing_ForwardToCallback);
};

class Frame_ExtractSmartClipData_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Frame_ExtractSmartClipData_ForwardToCallback(
      Frame::ExtractSmartClipDataCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Frame::ExtractSmartClipDataCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(Frame_ExtractSmartClipData_ForwardToCallback);
};

FrameProxy::FrameProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void FrameProxy::GetInterfaceProvider(
    mojo::PendingReceiver<::service_manager::mojom::InterfaceProvider> in_interfaces) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::Frame::GetInterfaceProvider");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrame_GetInterfaceProvider_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::Frame_GetInterfaceProvider_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::service_manager::mojom::InterfaceProviderInterfaceBase>>(
      in_interfaces, &params->interfaces, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->interfaces),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid interfaces in Frame.GetInterfaceProvider request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Frame::Name_);
  message.set_method_name("GetInterfaceProvider");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameProxy::GetCanonicalUrlForSharing(
    GetCanonicalUrlForSharingCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::Frame::GetCanonicalUrlForSharing");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrame_GetCanonicalUrlForSharing_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::Frame_GetCanonicalUrlForSharing_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Frame::Name_);
  message.set_method_name("GetCanonicalUrlForSharing");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new Frame_GetCanonicalUrlForSharing_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void FrameProxy::BlockRequests(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::Frame::BlockRequests");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrame_BlockRequests_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::Frame_BlockRequests_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Frame::Name_);
  message.set_method_name("BlockRequests");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameProxy::ResumeBlockedRequests(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::Frame::ResumeBlockedRequests");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrame_ResumeBlockedRequests_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::Frame_ResumeBlockedRequests_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Frame::Name_);
  message.set_method_name("ResumeBlockedRequests");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameProxy::CancelBlockedRequests(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::Frame::CancelBlockedRequests");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrame_CancelBlockedRequests_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::Frame_CancelBlockedRequests_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Frame::Name_);
  message.set_method_name("CancelBlockedRequests");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameProxy::SetLifecycleState(
    ::blink::mojom::FrameLifecycleState in_state) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::Frame::SetLifecycleState");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrame_SetLifecycleState_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::Frame_SetLifecycleState_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::blink::mojom::FrameLifecycleState>(
      in_state, &params->state);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Frame::Name_);
  message.set_method_name("SetLifecycleState");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameProxy::ExtractSmartClipData(
    const ::gfx::Rect& in_rect, ExtractSmartClipDataCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::Frame::ExtractSmartClipData");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrame_ExtractSmartClipData_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::Frame_ExtractSmartClipData_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->rect)::BaseType::BufferWriter
      rect_writer;
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_rect, buffer, &rect_writer, &serialization_context);
  params->rect.Set(
      rect_writer.is_null() ? nullptr : rect_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->rect.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null rect in Frame.ExtractSmartClipData request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Frame::Name_);
  message.set_method_name("ExtractSmartClipData");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new Frame_ExtractSmartClipData_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void FrameProxy::UpdateBrowserControlsState(
    ::content::BrowserControlsState in_constraints, ::content::BrowserControlsState in_current, bool in_animate) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::Frame::UpdateBrowserControlsState");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrame_UpdateBrowserControlsState_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::Frame_UpdateBrowserControlsState_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::content::mojom::BrowserControlsState>(
      in_constraints, &params->constraints);
  mojo::internal::Serialize<::content::mojom::BrowserControlsState>(
      in_current, &params->current);
  params->animate = in_animate;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Frame::Name_);
  message.set_method_name("UpdateBrowserControlsState");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
class Frame_GetCanonicalUrlForSharing_ProxyToResponder {
 public:
  static Frame::GetCanonicalUrlForSharingCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<Frame_GetCanonicalUrlForSharing_ProxyToResponder> proxy(
        new Frame_GetCanonicalUrlForSharing_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&Frame_GetCanonicalUrlForSharing_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~Frame_GetCanonicalUrlForSharing_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  Frame_GetCanonicalUrlForSharing_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "Frame::GetCanonicalUrlForSharingCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const base::Optional<::GURL>& in_canonical_url);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(Frame_GetCanonicalUrlForSharing_ProxyToResponder);
};

bool Frame_GetCanonicalUrlForSharing_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "content::mojom::Frame::GetCanonicalUrlForSharingCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::Frame_GetCanonicalUrlForSharing_ResponseParams_Data* params =
      reinterpret_cast<
          internal::Frame_GetCanonicalUrlForSharing_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  base::Optional<::GURL> p_canonical_url{};
  Frame_GetCanonicalUrlForSharing_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadCanonicalUrl(&p_canonical_url))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        Frame::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_canonical_url));
  return true;
}

void Frame_GetCanonicalUrlForSharing_ProxyToResponder::Run(
    const base::Optional<::GURL>& in_canonical_url) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrame_GetCanonicalUrlForSharing_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::Frame_GetCanonicalUrlForSharing_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->canonical_url)::BaseType::BufferWriter
      canonical_url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_canonical_url, buffer, &canonical_url_writer, &serialization_context);
  params->canonical_url.Set(
      canonical_url_writer.is_null() ? nullptr : canonical_url_writer.data());
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)content::mojom::Frame::GetCanonicalUrlForSharingCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Frame::Name_);
  message.set_method_name("GetCanonicalUrlForSharing");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class Frame_ExtractSmartClipData_ProxyToResponder {
 public:
  static Frame::ExtractSmartClipDataCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<Frame_ExtractSmartClipData_ProxyToResponder> proxy(
        new Frame_ExtractSmartClipData_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&Frame_ExtractSmartClipData_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~Frame_ExtractSmartClipData_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  Frame_ExtractSmartClipData_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "Frame::ExtractSmartClipDataCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const ::base::string16& in_text, const ::base::string16& in_html, const ::gfx::Rect& in_clip_rect);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(Frame_ExtractSmartClipData_ProxyToResponder);
};

bool Frame_ExtractSmartClipData_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "content::mojom::Frame::ExtractSmartClipDataCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::Frame_ExtractSmartClipData_ResponseParams_Data* params =
      reinterpret_cast<
          internal::Frame_ExtractSmartClipData_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  ::base::string16 p_text{};
  ::base::string16 p_html{};
  ::gfx::Rect p_clip_rect{};
  Frame_ExtractSmartClipData_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadText(&p_text))
    success = false;
  if (success && !input_data_view.ReadHtml(&p_html))
    success = false;
  if (success && !input_data_view.ReadClipRect(&p_clip_rect))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        Frame::Name_, 6, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_text), 
std::move(p_html), 
std::move(p_clip_rect));
  return true;
}

void Frame_ExtractSmartClipData_ProxyToResponder::Run(
    const ::base::string16& in_text, const ::base::string16& in_html, const ::gfx::Rect& in_clip_rect) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrame_ExtractSmartClipData_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::Frame_ExtractSmartClipData_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->text)::BaseType::BufferWriter
      text_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_text, buffer, &text_writer, &serialization_context);
  params->text.Set(
      text_writer.is_null() ? nullptr : text_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->text.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null text in ");
  typename decltype(params->html)::BaseType::BufferWriter
      html_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_html, buffer, &html_writer, &serialization_context);
  params->html.Set(
      html_writer.is_null() ? nullptr : html_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->html.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null html in ");
  typename decltype(params->clip_rect)::BaseType::BufferWriter
      clip_rect_writer;
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_clip_rect, buffer, &clip_rect_writer, &serialization_context);
  params->clip_rect.Set(
      clip_rect_writer.is_null() ? nullptr : clip_rect_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->clip_rect.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null clip_rect in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)content::mojom::Frame::ExtractSmartClipDataCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Frame::Name_);
  message.set_method_name("ExtractSmartClipData");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool FrameStubDispatch::Accept(
    Frame* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kFrame_GetInterfaceProvider_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::Frame::GetInterfaceProvider",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::Frame::GetInterfaceProvider");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::Frame_GetInterfaceProvider_Params_Data* params =
          reinterpret_cast<internal::Frame_GetInterfaceProvider_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      mojo::PendingReceiver<::service_manager::mojom::InterfaceProvider> p_interfaces{};
      Frame_GetInterfaceProvider_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success) {
        p_interfaces =
            input_data_view.TakeInterfaces<decltype(p_interfaces)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Frame::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetInterfaceProvider(
std::move(p_interfaces));
      return true;
    }
    case internal::kFrame_GetCanonicalUrlForSharing_Name: {
      break;
    }
    case internal::kFrame_BlockRequests_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::Frame::BlockRequests",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::Frame::BlockRequests");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::Frame_BlockRequests_Params_Data* params =
          reinterpret_cast<internal::Frame_BlockRequests_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      Frame_BlockRequests_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Frame::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BlockRequests();
      return true;
    }
    case internal::kFrame_ResumeBlockedRequests_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::Frame::ResumeBlockedRequests",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::Frame::ResumeBlockedRequests");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::Frame_ResumeBlockedRequests_Params_Data* params =
          reinterpret_cast<internal::Frame_ResumeBlockedRequests_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      Frame_ResumeBlockedRequests_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Frame::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ResumeBlockedRequests();
      return true;
    }
    case internal::kFrame_CancelBlockedRequests_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::Frame::CancelBlockedRequests",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::Frame::CancelBlockedRequests");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::Frame_CancelBlockedRequests_Params_Data* params =
          reinterpret_cast<internal::Frame_CancelBlockedRequests_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      Frame_CancelBlockedRequests_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Frame::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CancelBlockedRequests();
      return true;
    }
    case internal::kFrame_SetLifecycleState_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::Frame::SetLifecycleState",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::Frame::SetLifecycleState");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::Frame_SetLifecycleState_Params_Data* params =
          reinterpret_cast<internal::Frame_SetLifecycleState_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::blink::mojom::FrameLifecycleState p_state{};
      Frame_SetLifecycleState_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadState(&p_state))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Frame::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetLifecycleState(
std::move(p_state));
      return true;
    }
    case internal::kFrame_ExtractSmartClipData_Name: {
      break;
    }
    case internal::kFrame_UpdateBrowserControlsState_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::Frame::UpdateBrowserControlsState",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::Frame::UpdateBrowserControlsState");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::Frame_UpdateBrowserControlsState_Params_Data* params =
          reinterpret_cast<internal::Frame_UpdateBrowserControlsState_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::content::BrowserControlsState p_constraints{};
      ::content::BrowserControlsState p_current{};
      bool p_animate{};
      Frame_UpdateBrowserControlsState_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadConstraints(&p_constraints))
        success = false;
      if (success && !input_data_view.ReadCurrent(&p_current))
        success = false;
      if (success)
        p_animate = input_data_view.animate();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Frame::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateBrowserControlsState(
std::move(p_constraints), 
std::move(p_current), 
std::move(p_animate));
      return true;
    }
  }
  return false;
}

// static
bool FrameStubDispatch::AcceptWithResponder(
    Frame* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kFrame_GetInterfaceProvider_Name: {
      break;
    }
    case internal::kFrame_GetCanonicalUrlForSharing_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::Frame::GetCanonicalUrlForSharing",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::Frame::GetCanonicalUrlForSharing");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::Frame_GetCanonicalUrlForSharing_Params_Data* params =
          reinterpret_cast<
              internal::Frame_GetCanonicalUrlForSharing_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      Frame_GetCanonicalUrlForSharing_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Frame::Name_, 1, false);
        return false;
      }
      Frame::GetCanonicalUrlForSharingCallback callback =
          Frame_GetCanonicalUrlForSharing_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetCanonicalUrlForSharing(std::move(callback));
      return true;
    }
    case internal::kFrame_BlockRequests_Name: {
      break;
    }
    case internal::kFrame_ResumeBlockedRequests_Name: {
      break;
    }
    case internal::kFrame_CancelBlockedRequests_Name: {
      break;
    }
    case internal::kFrame_SetLifecycleState_Name: {
      break;
    }
    case internal::kFrame_ExtractSmartClipData_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::Frame::ExtractSmartClipData",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::Frame::ExtractSmartClipData");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::Frame_ExtractSmartClipData_Params_Data* params =
          reinterpret_cast<
              internal::Frame_ExtractSmartClipData_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::gfx::Rect p_rect{};
      Frame_ExtractSmartClipData_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadRect(&p_rect))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Frame::Name_, 6, false);
        return false;
      }
      Frame::ExtractSmartClipDataCallback callback =
          Frame_ExtractSmartClipData_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ExtractSmartClipData(
std::move(p_rect), std::move(callback));
      return true;
    }
    case internal::kFrame_UpdateBrowserControlsState_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kFrameValidationInfo[] = {
    {&internal::Frame_GetInterfaceProvider_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::Frame_GetCanonicalUrlForSharing_Params_Data::Validate,
     &internal::Frame_GetCanonicalUrlForSharing_ResponseParams_Data::Validate},
    {&internal::Frame_BlockRequests_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::Frame_ResumeBlockedRequests_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::Frame_CancelBlockedRequests_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::Frame_SetLifecycleState_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::Frame_ExtractSmartClipData_Params_Data::Validate,
     &internal::Frame_ExtractSmartClipData_ResponseParams_Data::Validate},
    {&internal::Frame_UpdateBrowserControlsState_Params_Data::Validate,
     nullptr /* no response */},
};

bool FrameRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::content::mojom::Frame::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kFrameValidationInfo);
}

bool FrameResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::content::mojom::Frame::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kFrameValidationInfo);
}
const char FrameNavigationControl::Name_[] = "content.mojom.FrameNavigationControl";

class FrameNavigationControl_CommitNavigation_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FrameNavigationControl_CommitNavigation_ForwardToCallback(
      FrameNavigationControl::CommitNavigationCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  FrameNavigationControl::CommitNavigationCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(FrameNavigationControl_CommitNavigation_ForwardToCallback);
};

class FrameNavigationControl_CommitSameDocumentNavigation_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FrameNavigationControl_CommitSameDocumentNavigation_ForwardToCallback(
      FrameNavigationControl::CommitSameDocumentNavigationCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  FrameNavigationControl::CommitSameDocumentNavigationCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(FrameNavigationControl_CommitSameDocumentNavigation_ForwardToCallback);
};

class FrameNavigationControl_JavaScriptExecuteRequest_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FrameNavigationControl_JavaScriptExecuteRequest_ForwardToCallback(
      FrameNavigationControl::JavaScriptExecuteRequestCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  FrameNavigationControl::JavaScriptExecuteRequestCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(FrameNavigationControl_JavaScriptExecuteRequest_ForwardToCallback);
};

class FrameNavigationControl_JavaScriptExecuteRequestForTests_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FrameNavigationControl_JavaScriptExecuteRequestForTests_ForwardToCallback(
      FrameNavigationControl::JavaScriptExecuteRequestForTestsCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  FrameNavigationControl::JavaScriptExecuteRequestForTestsCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(FrameNavigationControl_JavaScriptExecuteRequestForTests_ForwardToCallback);
};

class FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_ForwardToCallback(
      FrameNavigationControl::JavaScriptExecuteRequestInIsolatedWorldCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  FrameNavigationControl::JavaScriptExecuteRequestInIsolatedWorldCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_ForwardToCallback);
};

class FrameNavigationControl_OnPortalActivated_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FrameNavigationControl_OnPortalActivated_ForwardToCallback(
      FrameNavigationControl::OnPortalActivatedCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  FrameNavigationControl::OnPortalActivatedCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(FrameNavigationControl_OnPortalActivated_ForwardToCallback);
};

FrameNavigationControlProxy::FrameNavigationControlProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void FrameNavigationControlProxy::CommitNavigation(
    ::content::mojom::CommonNavigationParamsPtr in_common_params, ::content::mojom::CommitNavigationParamsPtr in_request_params, ::network::mojom::URLResponseHeadPtr in_response_head, mojo::ScopedDataPipeConsumerHandle in_response_body, ::network::mojom::URLLoaderClientEndpointsPtr in_url_loader_client_endpoints, ::std::unique_ptr<::blink::PendingURLLoaderFactoryBundle> in_subresource_loader_factories, base::Optional<std::vector<::content::mojom::TransferrableURLLoaderPtr>> in_subresource_overrides, ::blink::mojom::ControllerServiceWorkerInfoPtr in_controller_service_worker_info, ::blink::mojom::ServiceWorkerProviderInfoForClientPtr in_provider_info, mojo::PendingRemote<::network::mojom::URLLoaderFactory> in_prefetch_loader_factory, const ::base::UnguessableToken& in_devtools_navigation_token, CommitNavigationCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameNavigationControl::CommitNavigation");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameNavigationControl_CommitNavigation_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameNavigationControl_CommitNavigation_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->common_params)::BaseType::BufferWriter
      common_params_writer;
  mojo::internal::Serialize<::content::mojom::CommonNavigationParamsDataView>(
      in_common_params, buffer, &common_params_writer, &serialization_context);
  params->common_params.Set(
      common_params_writer.is_null() ? nullptr : common_params_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->common_params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null common_params in FrameNavigationControl.CommitNavigation request");
  typename decltype(params->request_params)::BaseType::BufferWriter
      request_params_writer;
  mojo::internal::Serialize<::content::mojom::CommitNavigationParamsDataView>(
      in_request_params, buffer, &request_params_writer, &serialization_context);
  params->request_params.Set(
      request_params_writer.is_null() ? nullptr : request_params_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->request_params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null request_params in FrameNavigationControl.CommitNavigation request");
  typename decltype(params->response_head)::BaseType::BufferWriter
      response_head_writer;
  mojo::internal::Serialize<::network::mojom::URLResponseHeadDataView>(
      in_response_head, buffer, &response_head_writer, &serialization_context);
  params->response_head.Set(
      response_head_writer.is_null() ? nullptr : response_head_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->response_head.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null response_head in FrameNavigationControl.CommitNavigation request");
  mojo::internal::Serialize<mojo::ScopedDataPipeConsumerHandle>(
      in_response_body, &params->response_body, &serialization_context);
  typename decltype(params->url_loader_client_endpoints)::BaseType::BufferWriter
      url_loader_client_endpoints_writer;
  mojo::internal::Serialize<::network::mojom::URLLoaderClientEndpointsDataView>(
      in_url_loader_client_endpoints, buffer, &url_loader_client_endpoints_writer, &serialization_context);
  params->url_loader_client_endpoints.Set(
      url_loader_client_endpoints_writer.is_null() ? nullptr : url_loader_client_endpoints_writer.data());
  typename decltype(params->subresource_loader_factories)::BaseType::BufferWriter
      subresource_loader_factories_writer;
  mojo::internal::Serialize<::blink::mojom::URLLoaderFactoryBundleDataView>(
      in_subresource_loader_factories, buffer, &subresource_loader_factories_writer, &serialization_context);
  params->subresource_loader_factories.Set(
      subresource_loader_factories_writer.is_null() ? nullptr : subresource_loader_factories_writer.data());
  typename decltype(params->subresource_overrides)::BaseType::BufferWriter
      subresource_overrides_writer;
  const mojo::internal::ContainerValidateParams subresource_overrides_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::content::mojom::TransferrableURLLoaderDataView>>(
      in_subresource_overrides, buffer, &subresource_overrides_writer, &subresource_overrides_validate_params,
      &serialization_context);
  params->subresource_overrides.Set(
      subresource_overrides_writer.is_null() ? nullptr : subresource_overrides_writer.data());
  typename decltype(params->controller_service_worker_info)::BaseType::BufferWriter
      controller_service_worker_info_writer;
  mojo::internal::Serialize<::blink::mojom::ControllerServiceWorkerInfoDataView>(
      in_controller_service_worker_info, buffer, &controller_service_worker_info_writer, &serialization_context);
  params->controller_service_worker_info.Set(
      controller_service_worker_info_writer.is_null() ? nullptr : controller_service_worker_info_writer.data());
  typename decltype(params->provider_info)::BaseType::BufferWriter
      provider_info_writer;
  mojo::internal::Serialize<::blink::mojom::ServiceWorkerProviderInfoForClientDataView>(
      in_provider_info, buffer, &provider_info_writer, &serialization_context);
  params->provider_info.Set(
      provider_info_writer.is_null() ? nullptr : provider_info_writer.data());
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::network::mojom::URLLoaderFactoryInterfaceBase>>(
      in_prefetch_loader_factory, &params->prefetch_loader_factory, &serialization_context);
  typename decltype(params->devtools_navigation_token)::BaseType::BufferWriter
      devtools_navigation_token_writer;
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      in_devtools_navigation_token, buffer, &devtools_navigation_token_writer, &serialization_context);
  params->devtools_navigation_token.Set(
      devtools_navigation_token_writer.is_null() ? nullptr : devtools_navigation_token_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->devtools_navigation_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null devtools_navigation_token in FrameNavigationControl.CommitNavigation request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameNavigationControl::Name_);
  message.set_method_name("CommitNavigation");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FrameNavigationControl_CommitNavigation_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void FrameNavigationControlProxy::CommitSameDocumentNavigation(
    ::content::mojom::CommonNavigationParamsPtr in_common_params, ::content::mojom::CommitNavigationParamsPtr in_request_params, CommitSameDocumentNavigationCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameNavigationControl::CommitSameDocumentNavigation");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameNavigationControl_CommitSameDocumentNavigation_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameNavigationControl_CommitSameDocumentNavigation_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->common_params)::BaseType::BufferWriter
      common_params_writer;
  mojo::internal::Serialize<::content::mojom::CommonNavigationParamsDataView>(
      in_common_params, buffer, &common_params_writer, &serialization_context);
  params->common_params.Set(
      common_params_writer.is_null() ? nullptr : common_params_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->common_params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null common_params in FrameNavigationControl.CommitSameDocumentNavigation request");
  typename decltype(params->request_params)::BaseType::BufferWriter
      request_params_writer;
  mojo::internal::Serialize<::content::mojom::CommitNavigationParamsDataView>(
      in_request_params, buffer, &request_params_writer, &serialization_context);
  params->request_params.Set(
      request_params_writer.is_null() ? nullptr : request_params_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->request_params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null request_params in FrameNavigationControl.CommitSameDocumentNavigation request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameNavigationControl::Name_);
  message.set_method_name("CommitSameDocumentNavigation");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FrameNavigationControl_CommitSameDocumentNavigation_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void FrameNavigationControlProxy::HandleRendererDebugURL(
    const ::GURL& in_url) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameNavigationControl::HandleRendererDebugURL");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameNavigationControl_HandleRendererDebugURL_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameNavigationControl_HandleRendererDebugURL_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->url)::BaseType::BufferWriter
      url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, buffer, &url_writer, &serialization_context);
  params->url.Set(
      url_writer.is_null() ? nullptr : url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in FrameNavigationControl.HandleRendererDebugURL request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameNavigationControl::Name_);
  message.set_method_name("HandleRendererDebugURL");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameNavigationControlProxy::UpdateSubresourceLoaderFactories(
    ::std::unique_ptr<::blink::PendingURLLoaderFactoryBundle> in_subresource_loader_factories) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameNavigationControl::UpdateSubresourceLoaderFactories");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameNavigationControl_UpdateSubresourceLoaderFactories_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameNavigationControl_UpdateSubresourceLoaderFactories_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->subresource_loader_factories)::BaseType::BufferWriter
      subresource_loader_factories_writer;
  mojo::internal::Serialize<::blink::mojom::URLLoaderFactoryBundleDataView>(
      in_subresource_loader_factories, buffer, &subresource_loader_factories_writer, &serialization_context);
  params->subresource_loader_factories.Set(
      subresource_loader_factories_writer.is_null() ? nullptr : subresource_loader_factories_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->subresource_loader_factories.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null subresource_loader_factories in FrameNavigationControl.UpdateSubresourceLoaderFactories request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameNavigationControl::Name_);
  message.set_method_name("UpdateSubresourceLoaderFactories");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameNavigationControlProxy::BindDevToolsAgent(
    mojo::PendingAssociatedRemote<::blink::mojom::DevToolsAgentHost> in_agent_host, mojo::PendingAssociatedReceiver<::blink::mojom::DevToolsAgent> in_agent) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameNavigationControl::BindDevToolsAgent");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameNavigationControl_BindDevToolsAgent_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameNavigationControl_BindDevToolsAgent_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::blink::mojom::DevToolsAgentHostAssociatedPtrInfoDataView>(
      in_agent_host, &params->agent_host, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->agent_host),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid agent_host in FrameNavigationControl.BindDevToolsAgent request");
  mojo::internal::Serialize<::blink::mojom::DevToolsAgentAssociatedRequestDataView>(
      in_agent, &params->agent, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->agent),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid agent in FrameNavigationControl.BindDevToolsAgent request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameNavigationControl::Name_);
  message.set_method_name("BindDevToolsAgent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameNavigationControlProxy::JavaScriptExecuteRequest(
    const ::base::string16& in_javascript, bool in_wants_result, JavaScriptExecuteRequestCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameNavigationControl::JavaScriptExecuteRequest");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameNavigationControl_JavaScriptExecuteRequest_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameNavigationControl_JavaScriptExecuteRequest_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->javascript)::BaseType::BufferWriter
      javascript_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_javascript, buffer, &javascript_writer, &serialization_context);
  params->javascript.Set(
      javascript_writer.is_null() ? nullptr : javascript_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->javascript.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null javascript in FrameNavigationControl.JavaScriptExecuteRequest request");
  params->wants_result = in_wants_result;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameNavigationControl::Name_);
  message.set_method_name("JavaScriptExecuteRequest");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FrameNavigationControl_JavaScriptExecuteRequest_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void FrameNavigationControlProxy::JavaScriptExecuteRequestForTests(
    const ::base::string16& in_javascript, bool in_wants_result, bool in_has_user_gesture, int32_t in_world_id, JavaScriptExecuteRequestForTestsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameNavigationControl::JavaScriptExecuteRequestForTests");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameNavigationControl_JavaScriptExecuteRequestForTests_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameNavigationControl_JavaScriptExecuteRequestForTests_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->javascript)::BaseType::BufferWriter
      javascript_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_javascript, buffer, &javascript_writer, &serialization_context);
  params->javascript.Set(
      javascript_writer.is_null() ? nullptr : javascript_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->javascript.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null javascript in FrameNavigationControl.JavaScriptExecuteRequestForTests request");
  params->wants_result = in_wants_result;
  params->has_user_gesture = in_has_user_gesture;
  params->world_id = in_world_id;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameNavigationControl::Name_);
  message.set_method_name("JavaScriptExecuteRequestForTests");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FrameNavigationControl_JavaScriptExecuteRequestForTests_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void FrameNavigationControlProxy::JavaScriptExecuteRequestInIsolatedWorld(
    const ::base::string16& in_javascript, bool in_wants_result, int32_t in_world_id, JavaScriptExecuteRequestInIsolatedWorldCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameNavigationControl::JavaScriptExecuteRequestInIsolatedWorld");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->javascript)::BaseType::BufferWriter
      javascript_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_javascript, buffer, &javascript_writer, &serialization_context);
  params->javascript.Set(
      javascript_writer.is_null() ? nullptr : javascript_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->javascript.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null javascript in FrameNavigationControl.JavaScriptExecuteRequestInIsolatedWorld request");
  params->wants_result = in_wants_result;
  params->world_id = in_world_id;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameNavigationControl::Name_);
  message.set_method_name("JavaScriptExecuteRequestInIsolatedWorld");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void FrameNavigationControlProxy::PostMessageEvent(
    int32_t in_source_routing_id, const ::base::string16& in_source_origin, const ::base::string16& in_target_origin, ::blink::TransferableMessage in_message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameNavigationControl::PostMessageEvent");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameNavigationControl_PostMessageEvent_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameNavigationControl_PostMessageEvent_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->source_routing_id = in_source_routing_id;
  typename decltype(params->source_origin)::BaseType::BufferWriter
      source_origin_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_source_origin, buffer, &source_origin_writer, &serialization_context);
  params->source_origin.Set(
      source_origin_writer.is_null() ? nullptr : source_origin_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->source_origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null source_origin in FrameNavigationControl.PostMessageEvent request");
  typename decltype(params->target_origin)::BaseType::BufferWriter
      target_origin_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_target_origin, buffer, &target_origin_writer, &serialization_context);
  params->target_origin.Set(
      target_origin_writer.is_null() ? nullptr : target_origin_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->target_origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null target_origin in FrameNavigationControl.PostMessageEvent request");
  typename decltype(params->message)::BaseType::BufferWriter
      message_writer;
  mojo::internal::Serialize<::blink::mojom::TransferableMessageDataView>(
      in_message, buffer, &message_writer, &serialization_context);
  params->message.Set(
      message_writer.is_null() ? nullptr : message_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null message in FrameNavigationControl.PostMessageEvent request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameNavigationControl::Name_);
  message.set_method_name("PostMessageEvent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameNavigationControlProxy::ForwardMessageFromHost(
    ::blink::TransferableMessage in_message, const ::url::Origin& in_source_origin, const base::Optional<::url::Origin>& in_target_origin) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameNavigationControl::ForwardMessageFromHost");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameNavigationControl_ForwardMessageFromHost_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameNavigationControl_ForwardMessageFromHost_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->message)::BaseType::BufferWriter
      message_writer;
  mojo::internal::Serialize<::blink::mojom::TransferableMessageDataView>(
      in_message, buffer, &message_writer, &serialization_context);
  params->message.Set(
      message_writer.is_null() ? nullptr : message_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null message in FrameNavigationControl.ForwardMessageFromHost request");
  typename decltype(params->source_origin)::BaseType::BufferWriter
      source_origin_writer;
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      in_source_origin, buffer, &source_origin_writer, &serialization_context);
  params->source_origin.Set(
      source_origin_writer.is_null() ? nullptr : source_origin_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->source_origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null source_origin in FrameNavigationControl.ForwardMessageFromHost request");
  typename decltype(params->target_origin)::BaseType::BufferWriter
      target_origin_writer;
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      in_target_origin, buffer, &target_origin_writer, &serialization_context);
  params->target_origin.Set(
      target_origin_writer.is_null() ? nullptr : target_origin_writer.data());
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameNavigationControl::Name_);
  message.set_method_name("ForwardMessageFromHost");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameNavigationControlProxy::OnPortalActivated(
    const ::base::UnguessableToken& in_portal_token, mojo::PendingAssociatedRemote<::blink::mojom::Portal> in_portal, mojo::PendingAssociatedReceiver<::blink::mojom::PortalClient> in_portal_client, ::blink::TransferableMessage in_data, OnPortalActivatedCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameNavigationControl::OnPortalActivated");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameNavigationControl_OnPortalActivated_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameNavigationControl_OnPortalActivated_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->portal_token)::BaseType::BufferWriter
      portal_token_writer;
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      in_portal_token, buffer, &portal_token_writer, &serialization_context);
  params->portal_token.Set(
      portal_token_writer.is_null() ? nullptr : portal_token_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->portal_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null portal_token in FrameNavigationControl.OnPortalActivated request");
  mojo::internal::Serialize<::blink::mojom::PortalAssociatedPtrInfoDataView>(
      in_portal, &params->portal, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->portal),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid portal in FrameNavigationControl.OnPortalActivated request");
  mojo::internal::Serialize<::blink::mojom::PortalClientAssociatedRequestDataView>(
      in_portal_client, &params->portal_client, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->portal_client),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid portal_client in FrameNavigationControl.OnPortalActivated request");
  typename decltype(params->data)::BaseType::BufferWriter
      data_writer;
  mojo::internal::Serialize<::blink::mojom::TransferableMessageDataView>(
      in_data, buffer, &data_writer, &serialization_context);
  params->data.Set(
      data_writer.is_null() ? nullptr : data_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null data in FrameNavigationControl.OnPortalActivated request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameNavigationControl::Name_);
  message.set_method_name("OnPortalActivated");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FrameNavigationControl_OnPortalActivated_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void FrameNavigationControlProxy::ReportContentSecurityPolicyViolation(
    const ::content::CSPViolationParams& in_violation_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameNavigationControl::ReportContentSecurityPolicyViolation");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameNavigationControl_ReportContentSecurityPolicyViolation_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameNavigationControl_ReportContentSecurityPolicyViolation_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->violation_params)::BaseType::BufferWriter
      violation_params_writer;
  mojo::internal::Serialize<::content::mojom::CSPViolationParamsDataView>(
      in_violation_params, buffer, &violation_params_writer, &serialization_context);
  params->violation_params.Set(
      violation_params_writer.is_null() ? nullptr : violation_params_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->violation_params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null violation_params in FrameNavigationControl.ReportContentSecurityPolicyViolation request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameNavigationControl::Name_);
  message.set_method_name("ReportContentSecurityPolicyViolation");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
class FrameNavigationControl_CommitNavigation_ProxyToResponder {
 public:
  static FrameNavigationControl::CommitNavigationCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FrameNavigationControl_CommitNavigation_ProxyToResponder> proxy(
        new FrameNavigationControl_CommitNavigation_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&FrameNavigationControl_CommitNavigation_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FrameNavigationControl_CommitNavigation_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  FrameNavigationControl_CommitNavigation_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FrameNavigationControl::CommitNavigationCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::CommitResult in_commit_result);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(FrameNavigationControl_CommitNavigation_ProxyToResponder);
};

bool FrameNavigationControl_CommitNavigation_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "content::mojom::FrameNavigationControl::CommitNavigationCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::FrameNavigationControl_CommitNavigation_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FrameNavigationControl_CommitNavigation_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  ::blink::mojom::CommitResult p_commit_result{};
  FrameNavigationControl_CommitNavigation_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadCommitResult(&p_commit_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FrameNavigationControl::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_commit_result));
  return true;
}

void FrameNavigationControl_CommitNavigation_ProxyToResponder::Run(
    ::blink::mojom::CommitResult in_commit_result) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameNavigationControl_CommitNavigation_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameNavigationControl_CommitNavigation_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::blink::mojom::CommitResult>(
      in_commit_result, &params->commit_result);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)content::mojom::FrameNavigationControl::CommitNavigationCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameNavigationControl::Name_);
  message.set_method_name("CommitNavigation");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FrameNavigationControl_CommitSameDocumentNavigation_ProxyToResponder {
 public:
  static FrameNavigationControl::CommitSameDocumentNavigationCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FrameNavigationControl_CommitSameDocumentNavigation_ProxyToResponder> proxy(
        new FrameNavigationControl_CommitSameDocumentNavigation_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&FrameNavigationControl_CommitSameDocumentNavigation_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FrameNavigationControl_CommitSameDocumentNavigation_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  FrameNavigationControl_CommitSameDocumentNavigation_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FrameNavigationControl::CommitSameDocumentNavigationCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::CommitResult in_commit_result);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(FrameNavigationControl_CommitSameDocumentNavigation_ProxyToResponder);
};

bool FrameNavigationControl_CommitSameDocumentNavigation_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "content::mojom::FrameNavigationControl::CommitSameDocumentNavigationCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::FrameNavigationControl_CommitSameDocumentNavigation_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FrameNavigationControl_CommitSameDocumentNavigation_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  ::blink::mojom::CommitResult p_commit_result{};
  FrameNavigationControl_CommitSameDocumentNavigation_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadCommitResult(&p_commit_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FrameNavigationControl::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_commit_result));
  return true;
}

void FrameNavigationControl_CommitSameDocumentNavigation_ProxyToResponder::Run(
    ::blink::mojom::CommitResult in_commit_result) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameNavigationControl_CommitSameDocumentNavigation_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameNavigationControl_CommitSameDocumentNavigation_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::blink::mojom::CommitResult>(
      in_commit_result, &params->commit_result);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)content::mojom::FrameNavigationControl::CommitSameDocumentNavigationCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameNavigationControl::Name_);
  message.set_method_name("CommitSameDocumentNavigation");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FrameNavigationControl_JavaScriptExecuteRequest_ProxyToResponder {
 public:
  static FrameNavigationControl::JavaScriptExecuteRequestCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FrameNavigationControl_JavaScriptExecuteRequest_ProxyToResponder> proxy(
        new FrameNavigationControl_JavaScriptExecuteRequest_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&FrameNavigationControl_JavaScriptExecuteRequest_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FrameNavigationControl_JavaScriptExecuteRequest_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  FrameNavigationControl_JavaScriptExecuteRequest_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FrameNavigationControl::JavaScriptExecuteRequestCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::base::Value in_result);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(FrameNavigationControl_JavaScriptExecuteRequest_ProxyToResponder);
};

bool FrameNavigationControl_JavaScriptExecuteRequest_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "content::mojom::FrameNavigationControl::JavaScriptExecuteRequestCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::FrameNavigationControl_JavaScriptExecuteRequest_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FrameNavigationControl_JavaScriptExecuteRequest_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  ::base::Value p_result{};
  FrameNavigationControl_JavaScriptExecuteRequest_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FrameNavigationControl::Name_, 5, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void FrameNavigationControl_JavaScriptExecuteRequest_ProxyToResponder::Run(
    ::base::Value in_result) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameNavigationControl_JavaScriptExecuteRequest_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameNavigationControl_JavaScriptExecuteRequest_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->result)::BufferWriter result_writer;
  result_writer.AllocateInline(buffer, &params->result);
  mojo::internal::Serialize<::mojo_base::mojom::ValueDataView>(
      in_result, buffer, &result_writer, true, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)content::mojom::FrameNavigationControl::JavaScriptExecuteRequestCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameNavigationControl::Name_);
  message.set_method_name("JavaScriptExecuteRequest");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FrameNavigationControl_JavaScriptExecuteRequestForTests_ProxyToResponder {
 public:
  static FrameNavigationControl::JavaScriptExecuteRequestForTestsCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FrameNavigationControl_JavaScriptExecuteRequestForTests_ProxyToResponder> proxy(
        new FrameNavigationControl_JavaScriptExecuteRequestForTests_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&FrameNavigationControl_JavaScriptExecuteRequestForTests_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FrameNavigationControl_JavaScriptExecuteRequestForTests_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  FrameNavigationControl_JavaScriptExecuteRequestForTests_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FrameNavigationControl::JavaScriptExecuteRequestForTestsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::base::Value in_result);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(FrameNavigationControl_JavaScriptExecuteRequestForTests_ProxyToResponder);
};

bool FrameNavigationControl_JavaScriptExecuteRequestForTests_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "content::mojom::FrameNavigationControl::JavaScriptExecuteRequestForTestsCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::FrameNavigationControl_JavaScriptExecuteRequestForTests_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FrameNavigationControl_JavaScriptExecuteRequestForTests_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  ::base::Value p_result{};
  FrameNavigationControl_JavaScriptExecuteRequestForTests_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FrameNavigationControl::Name_, 6, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void FrameNavigationControl_JavaScriptExecuteRequestForTests_ProxyToResponder::Run(
    ::base::Value in_result) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameNavigationControl_JavaScriptExecuteRequestForTests_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameNavigationControl_JavaScriptExecuteRequestForTests_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->result)::BufferWriter result_writer;
  result_writer.AllocateInline(buffer, &params->result);
  mojo::internal::Serialize<::mojo_base::mojom::ValueDataView>(
      in_result, buffer, &result_writer, true, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)content::mojom::FrameNavigationControl::JavaScriptExecuteRequestForTestsCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameNavigationControl::Name_);
  message.set_method_name("JavaScriptExecuteRequestForTests");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder {
 public:
  static FrameNavigationControl::JavaScriptExecuteRequestInIsolatedWorldCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder> proxy(
        new FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FrameNavigationControl::JavaScriptExecuteRequestInIsolatedWorldCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::base::Value in_result);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder);
};

bool FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "content::mojom::FrameNavigationControl::JavaScriptExecuteRequestInIsolatedWorldCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  ::base::Value p_result{};
  FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FrameNavigationControl::Name_, 7, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder::Run(
    ::base::Value in_result) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->result)::BufferWriter result_writer;
  result_writer.AllocateInline(buffer, &params->result);
  mojo::internal::Serialize<::mojo_base::mojom::ValueDataView>(
      in_result, buffer, &result_writer, true, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)content::mojom::FrameNavigationControl::JavaScriptExecuteRequestInIsolatedWorldCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameNavigationControl::Name_);
  message.set_method_name("JavaScriptExecuteRequestInIsolatedWorld");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FrameNavigationControl_OnPortalActivated_ProxyToResponder {
 public:
  static FrameNavigationControl::OnPortalActivatedCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FrameNavigationControl_OnPortalActivated_ProxyToResponder> proxy(
        new FrameNavigationControl_OnPortalActivated_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&FrameNavigationControl_OnPortalActivated_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FrameNavigationControl_OnPortalActivated_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  FrameNavigationControl_OnPortalActivated_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FrameNavigationControl::OnPortalActivatedCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::PortalActivateResult in_result);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(FrameNavigationControl_OnPortalActivated_ProxyToResponder);
};

bool FrameNavigationControl_OnPortalActivated_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "content::mojom::FrameNavigationControl::OnPortalActivatedCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::FrameNavigationControl_OnPortalActivated_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FrameNavigationControl_OnPortalActivated_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  ::blink::mojom::PortalActivateResult p_result{};
  FrameNavigationControl_OnPortalActivated_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FrameNavigationControl::Name_, 10, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void FrameNavigationControl_OnPortalActivated_ProxyToResponder::Run(
    ::blink::mojom::PortalActivateResult in_result) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameNavigationControl_OnPortalActivated_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameNavigationControl_OnPortalActivated_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::blink::mojom::PortalActivateResult>(
      in_result, &params->result);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)content::mojom::FrameNavigationControl::OnPortalActivatedCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameNavigationControl::Name_);
  message.set_method_name("OnPortalActivated");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool FrameNavigationControlStubDispatch::Accept(
    FrameNavigationControl* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kFrameNavigationControl_CommitNavigation_Name: {
      break;
    }
    case internal::kFrameNavigationControl_CommitSameDocumentNavigation_Name: {
      break;
    }
    case internal::kFrameNavigationControl_HandleRendererDebugURL_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameNavigationControl::HandleRendererDebugURL",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameNavigationControl::HandleRendererDebugURL");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameNavigationControl_HandleRendererDebugURL_Params_Data* params =
          reinterpret_cast<internal::FrameNavigationControl_HandleRendererDebugURL_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::GURL p_url{};
      FrameNavigationControl_HandleRendererDebugURL_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameNavigationControl::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->HandleRendererDebugURL(
std::move(p_url));
      return true;
    }
    case internal::kFrameNavigationControl_UpdateSubresourceLoaderFactories_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameNavigationControl::UpdateSubresourceLoaderFactories",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameNavigationControl::UpdateSubresourceLoaderFactories");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameNavigationControl_UpdateSubresourceLoaderFactories_Params_Data* params =
          reinterpret_cast<internal::FrameNavigationControl_UpdateSubresourceLoaderFactories_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::std::unique_ptr<::blink::PendingURLLoaderFactoryBundle> p_subresource_loader_factories{};
      FrameNavigationControl_UpdateSubresourceLoaderFactories_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadSubresourceLoaderFactories(&p_subresource_loader_factories))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameNavigationControl::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateSubresourceLoaderFactories(
std::move(p_subresource_loader_factories));
      return true;
    }
    case internal::kFrameNavigationControl_BindDevToolsAgent_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameNavigationControl::BindDevToolsAgent",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameNavigationControl::BindDevToolsAgent");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameNavigationControl_BindDevToolsAgent_Params_Data* params =
          reinterpret_cast<internal::FrameNavigationControl_BindDevToolsAgent_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      mojo::PendingAssociatedRemote<::blink::mojom::DevToolsAgentHost> p_agent_host{};
      mojo::PendingAssociatedReceiver<::blink::mojom::DevToolsAgent> p_agent{};
      FrameNavigationControl_BindDevToolsAgent_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success) {
        p_agent_host =
            input_data_view.TakeAgentHost<decltype(p_agent_host)>();
      }
      if (success) {
        p_agent =
            input_data_view.TakeAgent<decltype(p_agent)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameNavigationControl::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BindDevToolsAgent(
std::move(p_agent_host), 
std::move(p_agent));
      return true;
    }
    case internal::kFrameNavigationControl_JavaScriptExecuteRequest_Name: {
      break;
    }
    case internal::kFrameNavigationControl_JavaScriptExecuteRequestForTests_Name: {
      break;
    }
    case internal::kFrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_Name: {
      break;
    }
    case internal::kFrameNavigationControl_PostMessageEvent_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameNavigationControl::PostMessageEvent",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameNavigationControl::PostMessageEvent");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameNavigationControl_PostMessageEvent_Params_Data* params =
          reinterpret_cast<internal::FrameNavigationControl_PostMessageEvent_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int32_t p_source_routing_id{};
      ::base::string16 p_source_origin{};
      ::base::string16 p_target_origin{};
      ::blink::TransferableMessage p_message{};
      FrameNavigationControl_PostMessageEvent_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_source_routing_id = input_data_view.source_routing_id();
      if (success && !input_data_view.ReadSourceOrigin(&p_source_origin))
        success = false;
      if (success && !input_data_view.ReadTargetOrigin(&p_target_origin))
        success = false;
      if (success && !input_data_view.ReadMessage(&p_message))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameNavigationControl::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PostMessageEvent(
std::move(p_source_routing_id), 
std::move(p_source_origin), 
std::move(p_target_origin), 
std::move(p_message));
      return true;
    }
    case internal::kFrameNavigationControl_ForwardMessageFromHost_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameNavigationControl::ForwardMessageFromHost",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameNavigationControl::ForwardMessageFromHost");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameNavigationControl_ForwardMessageFromHost_Params_Data* params =
          reinterpret_cast<internal::FrameNavigationControl_ForwardMessageFromHost_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::blink::TransferableMessage p_message{};
      ::url::Origin p_source_origin{};
      base::Optional<::url::Origin> p_target_origin{};
      FrameNavigationControl_ForwardMessageFromHost_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadMessage(&p_message))
        success = false;
      if (success && !input_data_view.ReadSourceOrigin(&p_source_origin))
        success = false;
      if (success && !input_data_view.ReadTargetOrigin(&p_target_origin))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameNavigationControl::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ForwardMessageFromHost(
std::move(p_message), 
std::move(p_source_origin), 
std::move(p_target_origin));
      return true;
    }
    case internal::kFrameNavigationControl_OnPortalActivated_Name: {
      break;
    }
    case internal::kFrameNavigationControl_ReportContentSecurityPolicyViolation_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameNavigationControl::ReportContentSecurityPolicyViolation",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameNavigationControl::ReportContentSecurityPolicyViolation");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameNavigationControl_ReportContentSecurityPolicyViolation_Params_Data* params =
          reinterpret_cast<internal::FrameNavigationControl_ReportContentSecurityPolicyViolation_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::content::CSPViolationParams p_violation_params{};
      FrameNavigationControl_ReportContentSecurityPolicyViolation_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadViolationParams(&p_violation_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameNavigationControl::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ReportContentSecurityPolicyViolation(
std::move(p_violation_params));
      return true;
    }
  }
  return false;
}

// static
bool FrameNavigationControlStubDispatch::AcceptWithResponder(
    FrameNavigationControl* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kFrameNavigationControl_CommitNavigation_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameNavigationControl::CommitNavigation",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameNavigationControl::CommitNavigation");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::FrameNavigationControl_CommitNavigation_Params_Data* params =
          reinterpret_cast<
              internal::FrameNavigationControl_CommitNavigation_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::content::mojom::CommonNavigationParamsPtr p_common_params{};
      ::content::mojom::CommitNavigationParamsPtr p_request_params{};
      ::network::mojom::URLResponseHeadPtr p_response_head{};
      mojo::ScopedDataPipeConsumerHandle p_response_body{};
      ::network::mojom::URLLoaderClientEndpointsPtr p_url_loader_client_endpoints{};
      ::std::unique_ptr<::blink::PendingURLLoaderFactoryBundle> p_subresource_loader_factories{};
      base::Optional<std::vector<::content::mojom::TransferrableURLLoaderPtr>> p_subresource_overrides{};
      ::blink::mojom::ControllerServiceWorkerInfoPtr p_controller_service_worker_info{};
      ::blink::mojom::ServiceWorkerProviderInfoForClientPtr p_provider_info{};
      mojo::PendingRemote<::network::mojom::URLLoaderFactory> p_prefetch_loader_factory{};
      ::base::UnguessableToken p_devtools_navigation_token{};
      FrameNavigationControl_CommitNavigation_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadCommonParams(&p_common_params))
        success = false;
      if (success && !input_data_view.ReadRequestParams(&p_request_params))
        success = false;
      if (success && !input_data_view.ReadResponseHead(&p_response_head))
        success = false;
      if (success)
        p_response_body = input_data_view.TakeResponseBody();
      if (success && !input_data_view.ReadUrlLoaderClientEndpoints(&p_url_loader_client_endpoints))
        success = false;
      if (success && !input_data_view.ReadSubresourceLoaderFactories(&p_subresource_loader_factories))
        success = false;
      if (success && !input_data_view.ReadSubresourceOverrides(&p_subresource_overrides))
        success = false;
      if (success && !input_data_view.ReadControllerServiceWorkerInfo(&p_controller_service_worker_info))
        success = false;
      if (success && !input_data_view.ReadProviderInfo(&p_provider_info))
        success = false;
      if (success) {
        p_prefetch_loader_factory =
            input_data_view.TakePrefetchLoaderFactory<decltype(p_prefetch_loader_factory)>();
      }
      if (success && !input_data_view.ReadDevtoolsNavigationToken(&p_devtools_navigation_token))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameNavigationControl::Name_, 0, false);
        return false;
      }
      FrameNavigationControl::CommitNavigationCallback callback =
          FrameNavigationControl_CommitNavigation_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CommitNavigation(
std::move(p_common_params), 
std::move(p_request_params), 
std::move(p_response_head), 
std::move(p_response_body), 
std::move(p_url_loader_client_endpoints), 
std::move(p_subresource_loader_factories), 
std::move(p_subresource_overrides), 
std::move(p_controller_service_worker_info), 
std::move(p_provider_info), 
std::move(p_prefetch_loader_factory), 
std::move(p_devtools_navigation_token), std::move(callback));
      return true;
    }
    case internal::kFrameNavigationControl_CommitSameDocumentNavigation_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameNavigationControl::CommitSameDocumentNavigation",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameNavigationControl::CommitSameDocumentNavigation");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::FrameNavigationControl_CommitSameDocumentNavigation_Params_Data* params =
          reinterpret_cast<
              internal::FrameNavigationControl_CommitSameDocumentNavigation_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::content::mojom::CommonNavigationParamsPtr p_common_params{};
      ::content::mojom::CommitNavigationParamsPtr p_request_params{};
      FrameNavigationControl_CommitSameDocumentNavigation_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadCommonParams(&p_common_params))
        success = false;
      if (success && !input_data_view.ReadRequestParams(&p_request_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameNavigationControl::Name_, 1, false);
        return false;
      }
      FrameNavigationControl::CommitSameDocumentNavigationCallback callback =
          FrameNavigationControl_CommitSameDocumentNavigation_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CommitSameDocumentNavigation(
std::move(p_common_params), 
std::move(p_request_params), std::move(callback));
      return true;
    }
    case internal::kFrameNavigationControl_HandleRendererDebugURL_Name: {
      break;
    }
    case internal::kFrameNavigationControl_UpdateSubresourceLoaderFactories_Name: {
      break;
    }
    case internal::kFrameNavigationControl_BindDevToolsAgent_Name: {
      break;
    }
    case internal::kFrameNavigationControl_JavaScriptExecuteRequest_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameNavigationControl::JavaScriptExecuteRequest",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameNavigationControl::JavaScriptExecuteRequest");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::FrameNavigationControl_JavaScriptExecuteRequest_Params_Data* params =
          reinterpret_cast<
              internal::FrameNavigationControl_JavaScriptExecuteRequest_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::base::string16 p_javascript{};
      bool p_wants_result{};
      FrameNavigationControl_JavaScriptExecuteRequest_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadJavascript(&p_javascript))
        success = false;
      if (success)
        p_wants_result = input_data_view.wants_result();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameNavigationControl::Name_, 5, false);
        return false;
      }
      FrameNavigationControl::JavaScriptExecuteRequestCallback callback =
          FrameNavigationControl_JavaScriptExecuteRequest_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->JavaScriptExecuteRequest(
std::move(p_javascript), 
std::move(p_wants_result), std::move(callback));
      return true;
    }
    case internal::kFrameNavigationControl_JavaScriptExecuteRequestForTests_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameNavigationControl::JavaScriptExecuteRequestForTests",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameNavigationControl::JavaScriptExecuteRequestForTests");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::FrameNavigationControl_JavaScriptExecuteRequestForTests_Params_Data* params =
          reinterpret_cast<
              internal::FrameNavigationControl_JavaScriptExecuteRequestForTests_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::base::string16 p_javascript{};
      bool p_wants_result{};
      bool p_has_user_gesture{};
      int32_t p_world_id{};
      FrameNavigationControl_JavaScriptExecuteRequestForTests_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadJavascript(&p_javascript))
        success = false;
      if (success)
        p_wants_result = input_data_view.wants_result();
      if (success)
        p_has_user_gesture = input_data_view.has_user_gesture();
      if (success)
        p_world_id = input_data_view.world_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameNavigationControl::Name_, 6, false);
        return false;
      }
      FrameNavigationControl::JavaScriptExecuteRequestForTestsCallback callback =
          FrameNavigationControl_JavaScriptExecuteRequestForTests_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->JavaScriptExecuteRequestForTests(
std::move(p_javascript), 
std::move(p_wants_result), 
std::move(p_has_user_gesture), 
std::move(p_world_id), std::move(callback));
      return true;
    }
    case internal::kFrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameNavigationControl::JavaScriptExecuteRequestInIsolatedWorld",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameNavigationControl::JavaScriptExecuteRequestInIsolatedWorld");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_Params_Data* params =
          reinterpret_cast<
              internal::FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::base::string16 p_javascript{};
      bool p_wants_result{};
      int32_t p_world_id{};
      FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadJavascript(&p_javascript))
        success = false;
      if (success)
        p_wants_result = input_data_view.wants_result();
      if (success)
        p_world_id = input_data_view.world_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameNavigationControl::Name_, 7, false);
        return false;
      }
      FrameNavigationControl::JavaScriptExecuteRequestInIsolatedWorldCallback callback =
          FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->JavaScriptExecuteRequestInIsolatedWorld(
std::move(p_javascript), 
std::move(p_wants_result), 
std::move(p_world_id), std::move(callback));
      return true;
    }
    case internal::kFrameNavigationControl_PostMessageEvent_Name: {
      break;
    }
    case internal::kFrameNavigationControl_ForwardMessageFromHost_Name: {
      break;
    }
    case internal::kFrameNavigationControl_OnPortalActivated_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameNavigationControl::OnPortalActivated",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameNavigationControl::OnPortalActivated");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::FrameNavigationControl_OnPortalActivated_Params_Data* params =
          reinterpret_cast<
              internal::FrameNavigationControl_OnPortalActivated_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::base::UnguessableToken p_portal_token{};
      mojo::PendingAssociatedRemote<::blink::mojom::Portal> p_portal{};
      mojo::PendingAssociatedReceiver<::blink::mojom::PortalClient> p_portal_client{};
      ::blink::TransferableMessage p_data{};
      FrameNavigationControl_OnPortalActivated_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadPortalToken(&p_portal_token))
        success = false;
      if (success) {
        p_portal =
            input_data_view.TakePortal<decltype(p_portal)>();
      }
      if (success) {
        p_portal_client =
            input_data_view.TakePortalClient<decltype(p_portal_client)>();
      }
      if (success && !input_data_view.ReadData(&p_data))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameNavigationControl::Name_, 10, false);
        return false;
      }
      FrameNavigationControl::OnPortalActivatedCallback callback =
          FrameNavigationControl_OnPortalActivated_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnPortalActivated(
std::move(p_portal_token), 
std::move(p_portal), 
std::move(p_portal_client), 
std::move(p_data), std::move(callback));
      return true;
    }
    case internal::kFrameNavigationControl_ReportContentSecurityPolicyViolation_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kFrameNavigationControlValidationInfo[] = {
    {&internal::FrameNavigationControl_CommitNavigation_Params_Data::Validate,
     &internal::FrameNavigationControl_CommitNavigation_ResponseParams_Data::Validate},
    {&internal::FrameNavigationControl_CommitSameDocumentNavigation_Params_Data::Validate,
     &internal::FrameNavigationControl_CommitSameDocumentNavigation_ResponseParams_Data::Validate},
    {&internal::FrameNavigationControl_HandleRendererDebugURL_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameNavigationControl_UpdateSubresourceLoaderFactories_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameNavigationControl_BindDevToolsAgent_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameNavigationControl_JavaScriptExecuteRequest_Params_Data::Validate,
     &internal::FrameNavigationControl_JavaScriptExecuteRequest_ResponseParams_Data::Validate},
    {&internal::FrameNavigationControl_JavaScriptExecuteRequestForTests_Params_Data::Validate,
     &internal::FrameNavigationControl_JavaScriptExecuteRequestForTests_ResponseParams_Data::Validate},
    {&internal::FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_Params_Data::Validate,
     &internal::FrameNavigationControl_JavaScriptExecuteRequestInIsolatedWorld_ResponseParams_Data::Validate},
    {&internal::FrameNavigationControl_PostMessageEvent_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameNavigationControl_ForwardMessageFromHost_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameNavigationControl_OnPortalActivated_Params_Data::Validate,
     &internal::FrameNavigationControl_OnPortalActivated_ResponseParams_Data::Validate},
    {&internal::FrameNavigationControl_ReportContentSecurityPolicyViolation_Params_Data::Validate,
     nullptr /* no response */},
};

bool FrameNavigationControlRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::content::mojom::FrameNavigationControl::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kFrameNavigationControlValidationInfo);
}

bool FrameNavigationControlResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::content::mojom::FrameNavigationControl::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kFrameNavigationControlValidationInfo);
}
const char FrameBindingsControl::Name_[] = "content.mojom.FrameBindingsControl";

FrameBindingsControlProxy::FrameBindingsControlProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void FrameBindingsControlProxy::AllowBindings(
    int32_t in_enabled_bindings_flags) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameBindingsControl::AllowBindings");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameBindingsControl_AllowBindings_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameBindingsControl_AllowBindings_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->enabled_bindings_flags = in_enabled_bindings_flags;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameBindingsControl::Name_);
  message.set_method_name("AllowBindings");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameBindingsControlProxy::EnableMojoJsBindings(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameBindingsControl::EnableMojoJsBindings");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameBindingsControl_EnableMojoJsBindings_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameBindingsControl_EnableMojoJsBindings_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameBindingsControl::Name_);
  message.set_method_name("EnableMojoJsBindings");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool FrameBindingsControlStubDispatch::Accept(
    FrameBindingsControl* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kFrameBindingsControl_AllowBindings_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameBindingsControl::AllowBindings",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameBindingsControl::AllowBindings");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameBindingsControl_AllowBindings_Params_Data* params =
          reinterpret_cast<internal::FrameBindingsControl_AllowBindings_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int32_t p_enabled_bindings_flags{};
      FrameBindingsControl_AllowBindings_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_enabled_bindings_flags = input_data_view.enabled_bindings_flags();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameBindingsControl::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AllowBindings(
std::move(p_enabled_bindings_flags));
      return true;
    }
    case internal::kFrameBindingsControl_EnableMojoJsBindings_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameBindingsControl::EnableMojoJsBindings",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameBindingsControl::EnableMojoJsBindings");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameBindingsControl_EnableMojoJsBindings_Params_Data* params =
          reinterpret_cast<internal::FrameBindingsControl_EnableMojoJsBindings_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      FrameBindingsControl_EnableMojoJsBindings_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameBindingsControl::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EnableMojoJsBindings();
      return true;
    }
  }
  return false;
}

// static
bool FrameBindingsControlStubDispatch::AcceptWithResponder(
    FrameBindingsControl* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kFrameBindingsControl_AllowBindings_Name: {
      break;
    }
    case internal::kFrameBindingsControl_EnableMojoJsBindings_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kFrameBindingsControlValidationInfo[] = {
    {&internal::FrameBindingsControl_AllowBindings_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameBindingsControl_EnableMojoJsBindings_Params_Data::Validate,
     nullptr /* no response */},
};

bool FrameBindingsControlRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::content::mojom::FrameBindingsControl::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kFrameBindingsControlValidationInfo);
}

const char FrameFactory::Name_[] = "content.mojom.FrameFactory";

FrameFactoryProxy::FrameFactoryProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void FrameFactoryProxy::CreateFrame(
    int32_t in_frame_routing_id, mojo::PendingReceiver<Frame> in_frame) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameFactory::CreateFrame");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameFactory_CreateFrame_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameFactory_CreateFrame_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->frame_routing_id = in_frame_routing_id;
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::content::mojom::FrameInterfaceBase>>(
      in_frame, &params->frame, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->frame),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid frame in FrameFactory.CreateFrame request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameFactory::Name_);
  message.set_method_name("CreateFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool FrameFactoryStubDispatch::Accept(
    FrameFactory* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kFrameFactory_CreateFrame_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameFactory::CreateFrame",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameFactory::CreateFrame");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameFactory_CreateFrame_Params_Data* params =
          reinterpret_cast<internal::FrameFactory_CreateFrame_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int32_t p_frame_routing_id{};
      mojo::PendingReceiver<Frame> p_frame{};
      FrameFactory_CreateFrame_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_frame_routing_id = input_data_view.frame_routing_id();
      if (success) {
        p_frame =
            input_data_view.TakeFrame<decltype(p_frame)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameFactory::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateFrame(
std::move(p_frame_routing_id), 
std::move(p_frame));
      return true;
    }
  }
  return false;
}

// static
bool FrameFactoryStubDispatch::AcceptWithResponder(
    FrameFactory* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kFrameFactory_CreateFrame_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kFrameFactoryValidationInfo[] = {
    {&internal::FrameFactory_CreateFrame_Params_Data::Validate,
     nullptr /* no response */},
};

bool FrameFactoryRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::content::mojom::FrameFactory::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kFrameFactoryValidationInfo);
}

const char KeepAliveHandle::Name_[] = "content.mojom.KeepAliveHandle";

KeepAliveHandleProxy::KeepAliveHandleProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

// static
bool KeepAliveHandleStubDispatch::Accept(
    KeepAliveHandle* impl,
    mojo::Message* message) {
  return false;
}

// static
bool KeepAliveHandleStubDispatch::AcceptWithResponder(
    KeepAliveHandle* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  return false;
}



bool KeepAliveHandleRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::content::mojom::KeepAliveHandle::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, {});
}

const char FrameHost::Name_[] = "content.mojom.FrameHost";
bool FrameHost::CreateNewWindow(CreateNewWindowParamsPtr params, CreateNewWindowStatus* out_status, CreateNewWindowReplyPtr* out_reply) {
  NOTREACHED();
  return false;
}
bool FrameHost::CreatePortal(mojo::PendingAssociatedReceiver<::blink::mojom::Portal> portal, mojo::PendingAssociatedRemote<::blink::mojom::PortalClient> client, int32_t* out_proxy_routing_id, ::content::FrameReplicationState* out_initial_replicated_state, ::base::UnguessableToken* out_portal_token, ::base::UnguessableToken* out_devtools_frame_token) {
  NOTREACHED();
  return false;
}
bool FrameHost::AdoptPortal(const ::base::UnguessableToken& portal_token, int32_t* out_proxy_routing_id, ::viz::FrameSinkId* out_frame_sink_id, ::content::FrameReplicationState* out_replicated_state, ::base::UnguessableToken* out_devtools_frame_token) {
  NOTREACHED();
  return false;
}
class FrameHost_CreateNewWindow_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  FrameHost_CreateNewWindow_HandleSyncResponse(
      bool* result, CreateNewWindowStatus* out_status, CreateNewWindowReplyPtr* out_reply)
      : result_(result), out_status_(out_status), out_reply_(out_reply) {
    DCHECK(!*result_);
  }
  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  CreateNewWindowStatus* out_status_;
  CreateNewWindowReplyPtr* out_reply_;DISALLOW_COPY_AND_ASSIGN(FrameHost_CreateNewWindow_HandleSyncResponse);
};

class FrameHost_CreateNewWindow_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FrameHost_CreateNewWindow_ForwardToCallback(
      FrameHost::CreateNewWindowCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  FrameHost::CreateNewWindowCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(FrameHost_CreateNewWindow_ForwardToCallback);
};
class FrameHost_CreatePortal_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  FrameHost_CreatePortal_HandleSyncResponse(
      bool* result, int32_t* out_proxy_routing_id, ::content::FrameReplicationState* out_initial_replicated_state, ::base::UnguessableToken* out_portal_token, ::base::UnguessableToken* out_devtools_frame_token)
      : result_(result), out_proxy_routing_id_(out_proxy_routing_id), out_initial_replicated_state_(out_initial_replicated_state), out_portal_token_(out_portal_token), out_devtools_frame_token_(out_devtools_frame_token) {
    DCHECK(!*result_);
  }
  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  int32_t* out_proxy_routing_id_;
  ::content::FrameReplicationState* out_initial_replicated_state_;
  ::base::UnguessableToken* out_portal_token_;
  ::base::UnguessableToken* out_devtools_frame_token_;DISALLOW_COPY_AND_ASSIGN(FrameHost_CreatePortal_HandleSyncResponse);
};

class FrameHost_CreatePortal_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FrameHost_CreatePortal_ForwardToCallback(
      FrameHost::CreatePortalCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  FrameHost::CreatePortalCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(FrameHost_CreatePortal_ForwardToCallback);
};
class FrameHost_AdoptPortal_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  FrameHost_AdoptPortal_HandleSyncResponse(
      bool* result, int32_t* out_proxy_routing_id, ::viz::FrameSinkId* out_frame_sink_id, ::content::FrameReplicationState* out_replicated_state, ::base::UnguessableToken* out_devtools_frame_token)
      : result_(result), out_proxy_routing_id_(out_proxy_routing_id), out_frame_sink_id_(out_frame_sink_id), out_replicated_state_(out_replicated_state), out_devtools_frame_token_(out_devtools_frame_token) {
    DCHECK(!*result_);
  }
  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  int32_t* out_proxy_routing_id_;
  ::viz::FrameSinkId* out_frame_sink_id_;
  ::content::FrameReplicationState* out_replicated_state_;
  ::base::UnguessableToken* out_devtools_frame_token_;DISALLOW_COPY_AND_ASSIGN(FrameHost_AdoptPortal_HandleSyncResponse);
};

class FrameHost_AdoptPortal_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FrameHost_AdoptPortal_ForwardToCallback(
      FrameHost::AdoptPortalCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  FrameHost::AdoptPortalCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(FrameHost_AdoptPortal_ForwardToCallback);
};

FrameHostProxy::FrameHostProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}
bool FrameHostProxy::CreateNewWindow(
    CreateNewWindowParamsPtr param_params, CreateNewWindowStatus* out_param_status, CreateNewWindowReplyPtr* out_param_reply) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::CreateNewWindow");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_CreateNewWindow_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_CreateNewWindow_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->params)::BaseType::BufferWriter
      params_writer;
  mojo::internal::Serialize<::content::mojom::CreateNewWindowParamsDataView>(
      param_params, buffer, &params_writer, &serialization_context);
  params->params.Set(
      params_writer.is_null() ? nullptr : params_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in FrameHost.CreateNewWindow request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("CreateNewWindow");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FrameHost_CreateNewWindow_HandleSyncResponse(
          &result, out_param_status, out_param_reply));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
  return result;
}

void FrameHostProxy::CreateNewWindow(
    CreateNewWindowParamsPtr in_params, CreateNewWindowCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::CreateNewWindow");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_CreateNewWindow_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_CreateNewWindow_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->params)::BaseType::BufferWriter
      params_writer;
  mojo::internal::Serialize<::content::mojom::CreateNewWindowParamsDataView>(
      in_params, buffer, &params_writer, &serialization_context);
  params->params.Set(
      params_writer.is_null() ? nullptr : params_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in FrameHost.CreateNewWindow request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("CreateNewWindow");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FrameHost_CreateNewWindow_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
bool FrameHostProxy::CreatePortal(
    mojo::PendingAssociatedReceiver<::blink::mojom::Portal> param_portal, mojo::PendingAssociatedRemote<::blink::mojom::PortalClient> param_client, int32_t* out_param_proxy_routing_id, ::content::FrameReplicationState* out_param_initial_replicated_state, ::base::UnguessableToken* out_param_portal_token, ::base::UnguessableToken* out_param_devtools_frame_token) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::CreatePortal");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_CreatePortal_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_CreatePortal_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::blink::mojom::PortalAssociatedRequestDataView>(
      param_portal, &params->portal, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->portal),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid portal in FrameHost.CreatePortal request");
  mojo::internal::Serialize<::blink::mojom::PortalClientAssociatedPtrInfoDataView>(
      param_client, &params->client, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->client),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid client in FrameHost.CreatePortal request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("CreatePortal");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FrameHost_CreatePortal_HandleSyncResponse(
          &result, out_param_proxy_routing_id, out_param_initial_replicated_state, out_param_portal_token, out_param_devtools_frame_token));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
  return result;
}

void FrameHostProxy::CreatePortal(
    mojo::PendingAssociatedReceiver<::blink::mojom::Portal> in_portal, mojo::PendingAssociatedRemote<::blink::mojom::PortalClient> in_client, CreatePortalCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::CreatePortal");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_CreatePortal_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_CreatePortal_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::blink::mojom::PortalAssociatedRequestDataView>(
      in_portal, &params->portal, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->portal),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid portal in FrameHost.CreatePortal request");
  mojo::internal::Serialize<::blink::mojom::PortalClientAssociatedPtrInfoDataView>(
      in_client, &params->client, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->client),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid client in FrameHost.CreatePortal request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("CreatePortal");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FrameHost_CreatePortal_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
bool FrameHostProxy::AdoptPortal(
    const ::base::UnguessableToken& param_portal_token, int32_t* out_param_proxy_routing_id, ::viz::FrameSinkId* out_param_frame_sink_id, ::content::FrameReplicationState* out_param_replicated_state, ::base::UnguessableToken* out_param_devtools_frame_token) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::AdoptPortal");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_AdoptPortal_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_AdoptPortal_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->portal_token)::BaseType::BufferWriter
      portal_token_writer;
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      param_portal_token, buffer, &portal_token_writer, &serialization_context);
  params->portal_token.Set(
      portal_token_writer.is_null() ? nullptr : portal_token_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->portal_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null portal_token in FrameHost.AdoptPortal request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("AdoptPortal");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FrameHost_AdoptPortal_HandleSyncResponse(
          &result, out_param_proxy_routing_id, out_param_frame_sink_id, out_param_replicated_state, out_param_devtools_frame_token));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
  return result;
}

void FrameHostProxy::AdoptPortal(
    const ::base::UnguessableToken& in_portal_token, AdoptPortalCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::AdoptPortal");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_AdoptPortal_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_AdoptPortal_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->portal_token)::BaseType::BufferWriter
      portal_token_writer;
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      in_portal_token, buffer, &portal_token_writer, &serialization_context);
  params->portal_token.Set(
      portal_token_writer.is_null() ? nullptr : portal_token_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->portal_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null portal_token in FrameHost.AdoptPortal request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("AdoptPortal");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FrameHost_AdoptPortal_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void FrameHostProxy::IssueKeepAliveHandle(
    mojo::PendingReceiver<KeepAliveHandle> in_keep_alive_handle) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::IssueKeepAliveHandle");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_IssueKeepAliveHandle_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_IssueKeepAliveHandle_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::content::mojom::KeepAliveHandleInterfaceBase>>(
      in_keep_alive_handle, &params->keep_alive_handle, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->keep_alive_handle),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid keep_alive_handle in FrameHost.IssueKeepAliveHandle request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("IssueKeepAliveHandle");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameHostProxy::DidCommitProvisionalLoad(
    ::std::unique_ptr<::FrameHostMsg_DidCommitProvisionalLoad_Params> in_params, ::content::mojom::DidCommitProvisionalLoadInterfaceParamsPtr in_interface_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::DidCommitProvisionalLoad");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_DidCommitProvisionalLoad_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_DidCommitProvisionalLoad_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->params)::BaseType::BufferWriter
      params_writer;
  mojo::internal::Serialize<::content::mojom::DidCommitProvisionalLoadParamsDataView>(
      in_params, buffer, &params_writer, &serialization_context);
  params->params.Set(
      params_writer.is_null() ? nullptr : params_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in FrameHost.DidCommitProvisionalLoad request");
  typename decltype(params->interface_params)::BaseType::BufferWriter
      interface_params_writer;
  mojo::internal::Serialize<::content::mojom::DidCommitProvisionalLoadInterfaceParamsDataView>(
      in_interface_params, buffer, &interface_params_writer, &serialization_context);
  params->interface_params.Set(
      interface_params_writer.is_null() ? nullptr : interface_params_writer.data());
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("DidCommitProvisionalLoad");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameHostProxy::DidCommitSameDocumentNavigation(
    ::std::unique_ptr<::FrameHostMsg_DidCommitProvisionalLoad_Params> in_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::DidCommitSameDocumentNavigation");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_DidCommitSameDocumentNavigation_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_DidCommitSameDocumentNavigation_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->params)::BaseType::BufferWriter
      params_writer;
  mojo::internal::Serialize<::content::mojom::DidCommitProvisionalLoadParamsDataView>(
      in_params, buffer, &params_writer, &serialization_context);
  params->params.Set(
      params_writer.is_null() ? nullptr : params_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in FrameHost.DidCommitSameDocumentNavigation request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("DidCommitSameDocumentNavigation");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameHostProxy::BeginNavigation(
    ::content::mojom::CommonNavigationParamsPtr in_common_params, ::content::mojom::BeginNavigationParamsPtr in_begin_params, mojo::PendingRemote<::blink::mojom::BlobURLToken> in_blob_url_token, mojo::PendingAssociatedRemote<::content::mojom::NavigationClient> in_navigation_client, mojo::PendingRemote<::blink::mojom::NavigationInitiator> in_navigation_initiator) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::BeginNavigation");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_BeginNavigation_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_BeginNavigation_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->common_params)::BaseType::BufferWriter
      common_params_writer;
  mojo::internal::Serialize<::content::mojom::CommonNavigationParamsDataView>(
      in_common_params, buffer, &common_params_writer, &serialization_context);
  params->common_params.Set(
      common_params_writer.is_null() ? nullptr : common_params_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->common_params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null common_params in FrameHost.BeginNavigation request");
  typename decltype(params->begin_params)::BaseType::BufferWriter
      begin_params_writer;
  mojo::internal::Serialize<::content::mojom::BeginNavigationParamsDataView>(
      in_begin_params, buffer, &begin_params_writer, &serialization_context);
  params->begin_params.Set(
      begin_params_writer.is_null() ? nullptr : begin_params_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->begin_params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null begin_params in FrameHost.BeginNavigation request");
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::mojom::BlobURLTokenInterfaceBase>>(
      in_blob_url_token, &params->blob_url_token, &serialization_context);
  mojo::internal::Serialize<::content::mojom::NavigationClientAssociatedPtrInfoDataView>(
      in_navigation_client, &params->navigation_client, &serialization_context);
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::mojom::NavigationInitiatorInterfaceBase>>(
      in_navigation_initiator, &params->navigation_initiator, &serialization_context);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("BeginNavigation");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameHostProxy::SubresourceResponseStarted(
    const ::GURL& in_url, uint32_t in_cert_status) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::SubresourceResponseStarted");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_SubresourceResponseStarted_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_SubresourceResponseStarted_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->url)::BaseType::BufferWriter
      url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, buffer, &url_writer, &serialization_context);
  params->url.Set(
      url_writer.is_null() ? nullptr : url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in FrameHost.SubresourceResponseStarted request");
  params->cert_status = in_cert_status;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("SubresourceResponseStarted");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameHostProxy::ResourceLoadComplete(
    ::content::mojom::ResourceLoadInfoPtr in_url_load_info) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::ResourceLoadComplete");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_ResourceLoadComplete_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_ResourceLoadComplete_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->url_load_info)::BaseType::BufferWriter
      url_load_info_writer;
  mojo::internal::Serialize<::content::mojom::ResourceLoadInfoDataView>(
      in_url_load_info, buffer, &url_load_info_writer, &serialization_context);
  params->url_load_info.Set(
      url_load_info_writer.is_null() ? nullptr : url_load_info_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url_load_info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url_load_info in FrameHost.ResourceLoadComplete request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("ResourceLoadComplete");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameHostProxy::DidChangeName(
    const std::string& in_name, const std::string& in_unique_name) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::DidChangeName");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_DidChangeName_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_DidChangeName_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->name)::BaseType::BufferWriter
      name_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_name, buffer, &name_writer, &serialization_context);
  params->name.Set(
      name_writer.is_null() ? nullptr : name_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null name in FrameHost.DidChangeName request");
  typename decltype(params->unique_name)::BaseType::BufferWriter
      unique_name_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_unique_name, buffer, &unique_name_writer, &serialization_context);
  params->unique_name.Set(
      unique_name_writer.is_null() ? nullptr : unique_name_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->unique_name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null unique_name in FrameHost.DidChangeName request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("DidChangeName");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameHostProxy::DidSetFramePolicyHeaders(
    ::blink::WebSandboxFlags in_sandbox_flags, const std::vector<::blink::ParsedFeaturePolicyDeclaration>& in_feature_policy_header, const base::flat_map<::blink::mojom::FeaturePolicyFeature, ::blink::PolicyValue>& in_document_policy_header) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::DidSetFramePolicyHeaders");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_DidSetFramePolicyHeaders_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_DidSetFramePolicyHeaders_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::blink::mojom::WebSandboxFlags>(
      in_sandbox_flags, &params->sandbox_flags);
  typename decltype(params->feature_policy_header)::BaseType::BufferWriter
      feature_policy_header_writer;
  const mojo::internal::ContainerValidateParams feature_policy_header_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::ParsedFeaturePolicyDeclarationDataView>>(
      in_feature_policy_header, buffer, &feature_policy_header_writer, &feature_policy_header_validate_params,
      &serialization_context);
  params->feature_policy_header.Set(
      feature_policy_header_writer.is_null() ? nullptr : feature_policy_header_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->feature_policy_header.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null feature_policy_header in FrameHost.DidSetFramePolicyHeaders request");
  typename decltype(params->document_policy_header)::BaseType::BufferWriter
      document_policy_header_writer;
  const mojo::internal::ContainerValidateParams document_policy_header_validate_params(
      new mojo::internal::ContainerValidateParams(0, ::blink::mojom::internal::FeaturePolicyFeature_Data::Validate), new mojo::internal::ContainerValidateParams(0, false, nullptr));
  mojo::internal::Serialize<mojo::MapDataView<::blink::mojom::FeaturePolicyFeature, ::blink::mojom::PolicyValueDataView>>(
      in_document_policy_header, buffer, &document_policy_header_writer, &document_policy_header_validate_params,
      &serialization_context);
  params->document_policy_header.Set(
      document_policy_header_writer.is_null() ? nullptr : document_policy_header_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->document_policy_header.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null document_policy_header in FrameHost.DidSetFramePolicyHeaders request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("DidSetFramePolicyHeaders");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameHostProxy::CancelInitialHistoryLoad(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::CancelInitialHistoryLoad");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_CancelInitialHistoryLoad_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_CancelInitialHistoryLoad_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("CancelInitialHistoryLoad");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameHostProxy::UpdateEncoding(
    const std::string& in_encoding_name) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::UpdateEncoding");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_UpdateEncoding_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_UpdateEncoding_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->encoding_name)::BaseType::BufferWriter
      encoding_name_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_encoding_name, buffer, &encoding_name_writer, &serialization_context);
  params->encoding_name.Set(
      encoding_name_writer.is_null() ? nullptr : encoding_name_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->encoding_name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null encoding_name in FrameHost.UpdateEncoding request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("UpdateEncoding");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameHostProxy::FrameSizeChanged(
    const ::gfx::Size& in_size) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::FrameSizeChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_FrameSizeChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_FrameSizeChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->size)::BaseType::BufferWriter
      size_writer;
  mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
      in_size, buffer, &size_writer, &serialization_context);
  params->size.Set(
      size_writer.is_null() ? nullptr : size_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->size.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null size in FrameHost.FrameSizeChanged request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("FrameSizeChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameHostProxy::UpdateUserGestureCarryoverInfo(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::UpdateUserGestureCarryoverInfo");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_UpdateUserGestureCarryoverInfo_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_UpdateUserGestureCarryoverInfo_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("UpdateUserGestureCarryoverInfo");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameHostProxy::DidAddMessageToConsole(
    ::blink::mojom::ConsoleMessageLevel in_log_level, const ::base::string16& in_msg, int32_t in_line_number, const ::base::string16& in_source_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::DidAddMessageToConsole");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_DidAddMessageToConsole_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_DidAddMessageToConsole_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::blink::mojom::ConsoleMessageLevel>(
      in_log_level, &params->log_level);
  typename decltype(params->msg)::BaseType::BufferWriter
      msg_writer;
  mojo::internal::Serialize<::mojo_base::mojom::BigString16DataView>(
      in_msg, buffer, &msg_writer, &serialization_context);
  params->msg.Set(
      msg_writer.is_null() ? nullptr : msg_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->msg.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null msg in FrameHost.DidAddMessageToConsole request");
  params->line_number = in_line_number;
  typename decltype(params->source_id)::BaseType::BufferWriter
      source_id_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_source_id, buffer, &source_id_writer, &serialization_context);
  params->source_id.Set(
      source_id_writer.is_null() ? nullptr : source_id_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->source_id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null source_id in FrameHost.DidAddMessageToConsole request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("DidAddMessageToConsole");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameHostProxy::DidFailLoadWithError(
    const ::GURL& in_url, int32_t in_error_code) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::DidFailLoadWithError");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_DidFailLoadWithError_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_DidFailLoadWithError_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->url)::BaseType::BufferWriter
      url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, buffer, &url_writer, &serialization_context);
  params->url.Set(
      url_writer.is_null() ? nullptr : url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in FrameHost.DidFailLoadWithError request");
  params->error_code = in_error_code;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("DidFailLoadWithError");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameHostProxy::TransferUserActivationFrom(
    int32_t in_source_routing_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::TransferUserActivationFrom");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_TransferUserActivationFrom_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_TransferUserActivationFrom_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->source_routing_id = in_source_routing_id;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("TransferUserActivationFrom");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameHostProxy::ShowCreatedWindow(
    int32_t in_pending_widget_routing_id, ::WindowOpenDisposition in_disposition, const ::gfx::Rect& in_rect, bool in_opened_by_user_gesture) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::ShowCreatedWindow");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_ShowCreatedWindow_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_ShowCreatedWindow_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->pending_widget_routing_id = in_pending_widget_routing_id;
  mojo::internal::Serialize<::ui::mojom::WindowOpenDisposition>(
      in_disposition, &params->disposition);
  typename decltype(params->rect)::BaseType::BufferWriter
      rect_writer;
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_rect, buffer, &rect_writer, &serialization_context);
  params->rect.Set(
      rect_writer.is_null() ? nullptr : rect_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->rect.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null rect in FrameHost.ShowCreatedWindow request");
  params->opened_by_user_gesture = in_opened_by_user_gesture;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("ShowCreatedWindow");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameHostProxy::DidAddContentSecurityPolicies(
    std::vector<::network::mojom::ContentSecurityPolicyPtr> in_policies) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameHost::DidAddContentSecurityPolicies");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_DidAddContentSecurityPolicies_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_DidAddContentSecurityPolicies_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->policies)::BaseType::BufferWriter
      policies_writer;
  const mojo::internal::ContainerValidateParams policies_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::ContentSecurityPolicyDataView>>(
      in_policies, buffer, &policies_writer, &policies_validate_params,
      &serialization_context);
  params->policies.Set(
      policies_writer.is_null() ? nullptr : policies_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->policies.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null policies in FrameHost.DidAddContentSecurityPolicies request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("DidAddContentSecurityPolicies");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
class FrameHost_CreateNewWindow_ProxyToResponder {
 public:
  static FrameHost::CreateNewWindowCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FrameHost_CreateNewWindow_ProxyToResponder> proxy(
        new FrameHost_CreateNewWindow_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&FrameHost_CreateNewWindow_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FrameHost_CreateNewWindow_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  FrameHost_CreateNewWindow_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FrameHost::CreateNewWindowCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      CreateNewWindowStatus in_status, CreateNewWindowReplyPtr in_reply);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(FrameHost_CreateNewWindow_ProxyToResponder);
};

bool FrameHost_CreateNewWindow_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "content::mojom::FrameHost::CreateNewWindowCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::FrameHost_CreateNewWindow_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FrameHost_CreateNewWindow_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  CreateNewWindowStatus p_status{};
  CreateNewWindowReplyPtr p_reply{};
  FrameHost_CreateNewWindow_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadStatus(&p_status))
    success = false;
  if (success && !input_data_view.ReadReply(&p_reply))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FrameHost::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_status), 
std::move(p_reply));
  return true;
}

void FrameHost_CreateNewWindow_ProxyToResponder::Run(
    CreateNewWindowStatus in_status, CreateNewWindowReplyPtr in_reply) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_CreateNewWindow_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_CreateNewWindow_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::content::mojom::CreateNewWindowStatus>(
      in_status, &params->status);
  typename decltype(params->reply)::BaseType::BufferWriter
      reply_writer;
  mojo::internal::Serialize<::content::mojom::CreateNewWindowReplyDataView>(
      in_reply, buffer, &reply_writer, &serialization_context);
  params->reply.Set(
      reply_writer.is_null() ? nullptr : reply_writer.data());
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)content::mojom::FrameHost::CreateNewWindowCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("CreateNewWindow");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool FrameHost_CreateNewWindow_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FrameHost_CreateNewWindow_ResponseParams_Data* params =
      reinterpret_cast<internal::FrameHost_CreateNewWindow_ResponseParams_Data*>(
          message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  CreateNewWindowStatus p_status{};
  CreateNewWindowReplyPtr p_reply{};
  FrameHost_CreateNewWindow_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadStatus(&p_status))
    success = false;
  if (success && !input_data_view.ReadReply(&p_reply))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FrameHost::Name_, 0, true);
    return false;
  }
  *out_status_ = std::move(p_status);
  *out_reply_ = std::move(p_reply);
  mojo::internal::SyncMessageResponseSetup::SetCurrentSyncResponseMessage(
      message);
  *result_ = true;
  return true;
}
class FrameHost_CreatePortal_ProxyToResponder {
 public:
  static FrameHost::CreatePortalCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FrameHost_CreatePortal_ProxyToResponder> proxy(
        new FrameHost_CreatePortal_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&FrameHost_CreatePortal_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FrameHost_CreatePortal_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  FrameHost_CreatePortal_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FrameHost::CreatePortalCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      int32_t in_proxy_routing_id, const ::content::FrameReplicationState& in_initial_replicated_state, const ::base::UnguessableToken& in_portal_token, const ::base::UnguessableToken& in_devtools_frame_token);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(FrameHost_CreatePortal_ProxyToResponder);
};

bool FrameHost_CreatePortal_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "content::mojom::FrameHost::CreatePortalCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::FrameHost_CreatePortal_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FrameHost_CreatePortal_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  int32_t p_proxy_routing_id{};
  ::content::FrameReplicationState p_initial_replicated_state{};
  ::base::UnguessableToken p_portal_token{};
  ::base::UnguessableToken p_devtools_frame_token{};
  FrameHost_CreatePortal_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success)
    p_proxy_routing_id = input_data_view.proxy_routing_id();
  if (success && !input_data_view.ReadInitialReplicatedState(&p_initial_replicated_state))
    success = false;
  if (success && !input_data_view.ReadPortalToken(&p_portal_token))
    success = false;
  if (success && !input_data_view.ReadDevtoolsFrameToken(&p_devtools_frame_token))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FrameHost::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_proxy_routing_id), 
std::move(p_initial_replicated_state), 
std::move(p_portal_token), 
std::move(p_devtools_frame_token));
  return true;
}

void FrameHost_CreatePortal_ProxyToResponder::Run(
    int32_t in_proxy_routing_id, const ::content::FrameReplicationState& in_initial_replicated_state, const ::base::UnguessableToken& in_portal_token, const ::base::UnguessableToken& in_devtools_frame_token) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_CreatePortal_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_CreatePortal_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->proxy_routing_id = in_proxy_routing_id;
  typename decltype(params->initial_replicated_state)::BaseType::BufferWriter
      initial_replicated_state_writer;
  mojo::internal::Serialize<::content::mojom::FrameReplicationStateDataView>(
      in_initial_replicated_state, buffer, &initial_replicated_state_writer, &serialization_context);
  params->initial_replicated_state.Set(
      initial_replicated_state_writer.is_null() ? nullptr : initial_replicated_state_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->initial_replicated_state.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null initial_replicated_state in ");
  typename decltype(params->portal_token)::BaseType::BufferWriter
      portal_token_writer;
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      in_portal_token, buffer, &portal_token_writer, &serialization_context);
  params->portal_token.Set(
      portal_token_writer.is_null() ? nullptr : portal_token_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->portal_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null portal_token in ");
  typename decltype(params->devtools_frame_token)::BaseType::BufferWriter
      devtools_frame_token_writer;
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      in_devtools_frame_token, buffer, &devtools_frame_token_writer, &serialization_context);
  params->devtools_frame_token.Set(
      devtools_frame_token_writer.is_null() ? nullptr : devtools_frame_token_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->devtools_frame_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null devtools_frame_token in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)content::mojom::FrameHost::CreatePortalCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("CreatePortal");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool FrameHost_CreatePortal_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FrameHost_CreatePortal_ResponseParams_Data* params =
      reinterpret_cast<internal::FrameHost_CreatePortal_ResponseParams_Data*>(
          message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  int32_t p_proxy_routing_id{};
  ::content::FrameReplicationState p_initial_replicated_state{};
  ::base::UnguessableToken p_portal_token{};
  ::base::UnguessableToken p_devtools_frame_token{};
  FrameHost_CreatePortal_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success)
    p_proxy_routing_id = input_data_view.proxy_routing_id();
  if (success && !input_data_view.ReadInitialReplicatedState(&p_initial_replicated_state))
    success = false;
  if (success && !input_data_view.ReadPortalToken(&p_portal_token))
    success = false;
  if (success && !input_data_view.ReadDevtoolsFrameToken(&p_devtools_frame_token))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FrameHost::Name_, 1, true);
    return false;
  }
  *out_proxy_routing_id_ = std::move(p_proxy_routing_id);
  *out_initial_replicated_state_ = std::move(p_initial_replicated_state);
  *out_portal_token_ = std::move(p_portal_token);
  *out_devtools_frame_token_ = std::move(p_devtools_frame_token);
  mojo::internal::SyncMessageResponseSetup::SetCurrentSyncResponseMessage(
      message);
  *result_ = true;
  return true;
}
class FrameHost_AdoptPortal_ProxyToResponder {
 public:
  static FrameHost::AdoptPortalCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FrameHost_AdoptPortal_ProxyToResponder> proxy(
        new FrameHost_AdoptPortal_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&FrameHost_AdoptPortal_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FrameHost_AdoptPortal_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  FrameHost_AdoptPortal_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FrameHost::AdoptPortalCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      int32_t in_proxy_routing_id, const ::viz::FrameSinkId& in_frame_sink_id, const ::content::FrameReplicationState& in_replicated_state, const ::base::UnguessableToken& in_devtools_frame_token);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(FrameHost_AdoptPortal_ProxyToResponder);
};

bool FrameHost_AdoptPortal_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "content::mojom::FrameHost::AdoptPortalCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::FrameHost_AdoptPortal_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FrameHost_AdoptPortal_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  int32_t p_proxy_routing_id{};
  ::viz::FrameSinkId p_frame_sink_id{};
  ::content::FrameReplicationState p_replicated_state{};
  ::base::UnguessableToken p_devtools_frame_token{};
  FrameHost_AdoptPortal_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success)
    p_proxy_routing_id = input_data_view.proxy_routing_id();
  if (success && !input_data_view.ReadFrameSinkId(&p_frame_sink_id))
    success = false;
  if (success && !input_data_view.ReadReplicatedState(&p_replicated_state))
    success = false;
  if (success && !input_data_view.ReadDevtoolsFrameToken(&p_devtools_frame_token))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FrameHost::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_proxy_routing_id), 
std::move(p_frame_sink_id), 
std::move(p_replicated_state), 
std::move(p_devtools_frame_token));
  return true;
}

void FrameHost_AdoptPortal_ProxyToResponder::Run(
    int32_t in_proxy_routing_id, const ::viz::FrameSinkId& in_frame_sink_id, const ::content::FrameReplicationState& in_replicated_state, const ::base::UnguessableToken& in_devtools_frame_token) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameHost_AdoptPortal_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameHost_AdoptPortal_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->proxy_routing_id = in_proxy_routing_id;
  typename decltype(params->frame_sink_id)::BaseType::BufferWriter
      frame_sink_id_writer;
  mojo::internal::Serialize<::viz::mojom::FrameSinkIdDataView>(
      in_frame_sink_id, buffer, &frame_sink_id_writer, &serialization_context);
  params->frame_sink_id.Set(
      frame_sink_id_writer.is_null() ? nullptr : frame_sink_id_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->frame_sink_id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null frame_sink_id in ");
  typename decltype(params->replicated_state)::BaseType::BufferWriter
      replicated_state_writer;
  mojo::internal::Serialize<::content::mojom::FrameReplicationStateDataView>(
      in_replicated_state, buffer, &replicated_state_writer, &serialization_context);
  params->replicated_state.Set(
      replicated_state_writer.is_null() ? nullptr : replicated_state_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->replicated_state.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null replicated_state in ");
  typename decltype(params->devtools_frame_token)::BaseType::BufferWriter
      devtools_frame_token_writer;
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      in_devtools_frame_token, buffer, &devtools_frame_token_writer, &serialization_context);
  params->devtools_frame_token.Set(
      devtools_frame_token_writer.is_null() ? nullptr : devtools_frame_token_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->devtools_frame_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null devtools_frame_token in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)content::mojom::FrameHost::AdoptPortalCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameHost::Name_);
  message.set_method_name("AdoptPortal");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool FrameHost_AdoptPortal_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FrameHost_AdoptPortal_ResponseParams_Data* params =
      reinterpret_cast<internal::FrameHost_AdoptPortal_ResponseParams_Data*>(
          message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  int32_t p_proxy_routing_id{};
  ::viz::FrameSinkId p_frame_sink_id{};
  ::content::FrameReplicationState p_replicated_state{};
  ::base::UnguessableToken p_devtools_frame_token{};
  FrameHost_AdoptPortal_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success)
    p_proxy_routing_id = input_data_view.proxy_routing_id();
  if (success && !input_data_view.ReadFrameSinkId(&p_frame_sink_id))
    success = false;
  if (success && !input_data_view.ReadReplicatedState(&p_replicated_state))
    success = false;
  if (success && !input_data_view.ReadDevtoolsFrameToken(&p_devtools_frame_token))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FrameHost::Name_, 2, true);
    return false;
  }
  *out_proxy_routing_id_ = std::move(p_proxy_routing_id);
  *out_frame_sink_id_ = std::move(p_frame_sink_id);
  *out_replicated_state_ = std::move(p_replicated_state);
  *out_devtools_frame_token_ = std::move(p_devtools_frame_token);
  mojo::internal::SyncMessageResponseSetup::SetCurrentSyncResponseMessage(
      message);
  *result_ = true;
  return true;
}

// static
bool FrameHostStubDispatch::Accept(
    FrameHost* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kFrameHost_CreateNewWindow_Name: {
      break;
    }
    case internal::kFrameHost_CreatePortal_Name: {
      break;
    }
    case internal::kFrameHost_AdoptPortal_Name: {
      break;
    }
    case internal::kFrameHost_IssueKeepAliveHandle_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameHost::IssueKeepAliveHandle",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameHost::IssueKeepAliveHandle");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameHost_IssueKeepAliveHandle_Params_Data* params =
          reinterpret_cast<internal::FrameHost_IssueKeepAliveHandle_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      mojo::PendingReceiver<KeepAliveHandle> p_keep_alive_handle{};
      FrameHost_IssueKeepAliveHandle_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success) {
        p_keep_alive_handle =
            input_data_view.TakeKeepAliveHandle<decltype(p_keep_alive_handle)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameHost::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->IssueKeepAliveHandle(
std::move(p_keep_alive_handle));
      return true;
    }
    case internal::kFrameHost_DidCommitProvisionalLoad_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameHost::DidCommitProvisionalLoad",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameHost::DidCommitProvisionalLoad");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameHost_DidCommitProvisionalLoad_Params_Data* params =
          reinterpret_cast<internal::FrameHost_DidCommitProvisionalLoad_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::std::unique_ptr<::FrameHostMsg_DidCommitProvisionalLoad_Params> p_params{};
      ::content::mojom::DidCommitProvisionalLoadInterfaceParamsPtr p_interface_params{};
      FrameHost_DidCommitProvisionalLoad_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (success && !input_data_view.ReadInterfaceParams(&p_interface_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameHost::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidCommitProvisionalLoad(
std::move(p_params), 
std::move(p_interface_params));
      return true;
    }
    case internal::kFrameHost_DidCommitSameDocumentNavigation_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameHost::DidCommitSameDocumentNavigation",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameHost::DidCommitSameDocumentNavigation");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameHost_DidCommitSameDocumentNavigation_Params_Data* params =
          reinterpret_cast<internal::FrameHost_DidCommitSameDocumentNavigation_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::std::unique_ptr<::FrameHostMsg_DidCommitProvisionalLoad_Params> p_params{};
      FrameHost_DidCommitSameDocumentNavigation_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameHost::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidCommitSameDocumentNavigation(
std::move(p_params));
      return true;
    }
    case internal::kFrameHost_BeginNavigation_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameHost::BeginNavigation",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameHost::BeginNavigation");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameHost_BeginNavigation_Params_Data* params =
          reinterpret_cast<internal::FrameHost_BeginNavigation_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::content::mojom::CommonNavigationParamsPtr p_common_params{};
      ::content::mojom::BeginNavigationParamsPtr p_begin_params{};
      mojo::PendingRemote<::blink::mojom::BlobURLToken> p_blob_url_token{};
      mojo::PendingAssociatedRemote<::content::mojom::NavigationClient> p_navigation_client{};
      mojo::PendingRemote<::blink::mojom::NavigationInitiator> p_navigation_initiator{};
      FrameHost_BeginNavigation_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadCommonParams(&p_common_params))
        success = false;
      if (success && !input_data_view.ReadBeginParams(&p_begin_params))
        success = false;
      if (success) {
        p_blob_url_token =
            input_data_view.TakeBlobUrlToken<decltype(p_blob_url_token)>();
      }
      if (success) {
        p_navigation_client =
            input_data_view.TakeNavigationClient<decltype(p_navigation_client)>();
      }
      if (success) {
        p_navigation_initiator =
            input_data_view.TakeNavigationInitiator<decltype(p_navigation_initiator)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameHost::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BeginNavigation(
std::move(p_common_params), 
std::move(p_begin_params), 
std::move(p_blob_url_token), 
std::move(p_navigation_client), 
std::move(p_navigation_initiator));
      return true;
    }
    case internal::kFrameHost_SubresourceResponseStarted_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameHost::SubresourceResponseStarted",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameHost::SubresourceResponseStarted");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameHost_SubresourceResponseStarted_Params_Data* params =
          reinterpret_cast<internal::FrameHost_SubresourceResponseStarted_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::GURL p_url{};
      uint32_t p_cert_status{};
      FrameHost_SubresourceResponseStarted_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success)
        p_cert_status = input_data_view.cert_status();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameHost::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SubresourceResponseStarted(
std::move(p_url), 
std::move(p_cert_status));
      return true;
    }
    case internal::kFrameHost_ResourceLoadComplete_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameHost::ResourceLoadComplete",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameHost::ResourceLoadComplete");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameHost_ResourceLoadComplete_Params_Data* params =
          reinterpret_cast<internal::FrameHost_ResourceLoadComplete_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::content::mojom::ResourceLoadInfoPtr p_url_load_info{};
      FrameHost_ResourceLoadComplete_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadUrlLoadInfo(&p_url_load_info))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameHost::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ResourceLoadComplete(
std::move(p_url_load_info));
      return true;
    }
    case internal::kFrameHost_DidChangeName_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameHost::DidChangeName",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameHost::DidChangeName");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameHost_DidChangeName_Params_Data* params =
          reinterpret_cast<internal::FrameHost_DidChangeName_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      std::string p_name{};
      std::string p_unique_name{};
      FrameHost_DidChangeName_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadName(&p_name))
        success = false;
      if (success && !input_data_view.ReadUniqueName(&p_unique_name))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameHost::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidChangeName(
std::move(p_name), 
std::move(p_unique_name));
      return true;
    }
    case internal::kFrameHost_DidSetFramePolicyHeaders_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameHost::DidSetFramePolicyHeaders",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameHost::DidSetFramePolicyHeaders");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameHost_DidSetFramePolicyHeaders_Params_Data* params =
          reinterpret_cast<internal::FrameHost_DidSetFramePolicyHeaders_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::blink::WebSandboxFlags p_sandbox_flags{};
      std::vector<::blink::ParsedFeaturePolicyDeclaration> p_feature_policy_header{};
      base::flat_map<::blink::mojom::FeaturePolicyFeature, ::blink::PolicyValue> p_document_policy_header{};
      FrameHost_DidSetFramePolicyHeaders_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadSandboxFlags(&p_sandbox_flags))
        success = false;
      if (success && !input_data_view.ReadFeaturePolicyHeader(&p_feature_policy_header))
        success = false;
      if (success && !input_data_view.ReadDocumentPolicyHeader(&p_document_policy_header))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameHost::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidSetFramePolicyHeaders(
std::move(p_sandbox_flags), 
std::move(p_feature_policy_header), 
std::move(p_document_policy_header));
      return true;
    }
    case internal::kFrameHost_CancelInitialHistoryLoad_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameHost::CancelInitialHistoryLoad",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameHost::CancelInitialHistoryLoad");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameHost_CancelInitialHistoryLoad_Params_Data* params =
          reinterpret_cast<internal::FrameHost_CancelInitialHistoryLoad_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      FrameHost_CancelInitialHistoryLoad_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameHost::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CancelInitialHistoryLoad();
      return true;
    }
    case internal::kFrameHost_UpdateEncoding_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameHost::UpdateEncoding",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameHost::UpdateEncoding");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameHost_UpdateEncoding_Params_Data* params =
          reinterpret_cast<internal::FrameHost_UpdateEncoding_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      std::string p_encoding_name{};
      FrameHost_UpdateEncoding_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadEncodingName(&p_encoding_name))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameHost::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateEncoding(
std::move(p_encoding_name));
      return true;
    }
    case internal::kFrameHost_FrameSizeChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameHost::FrameSizeChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameHost::FrameSizeChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameHost_FrameSizeChanged_Params_Data* params =
          reinterpret_cast<internal::FrameHost_FrameSizeChanged_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::gfx::Size p_size{};
      FrameHost_FrameSizeChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadSize(&p_size))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameHost::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FrameSizeChanged(
std::move(p_size));
      return true;
    }
    case internal::kFrameHost_UpdateUserGestureCarryoverInfo_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameHost::UpdateUserGestureCarryoverInfo",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameHost::UpdateUserGestureCarryoverInfo");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameHost_UpdateUserGestureCarryoverInfo_Params_Data* params =
          reinterpret_cast<internal::FrameHost_UpdateUserGestureCarryoverInfo_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      FrameHost_UpdateUserGestureCarryoverInfo_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameHost::Name_, 14, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateUserGestureCarryoverInfo();
      return true;
    }
    case internal::kFrameHost_DidAddMessageToConsole_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameHost::DidAddMessageToConsole",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameHost::DidAddMessageToConsole");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameHost_DidAddMessageToConsole_Params_Data* params =
          reinterpret_cast<internal::FrameHost_DidAddMessageToConsole_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::blink::mojom::ConsoleMessageLevel p_log_level{};
      ::base::string16 p_msg{};
      int32_t p_line_number{};
      ::base::string16 p_source_id{};
      FrameHost_DidAddMessageToConsole_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadLogLevel(&p_log_level))
        success = false;
      if (success && !input_data_view.ReadMsg(&p_msg))
        success = false;
      if (success)
        p_line_number = input_data_view.line_number();
      if (success && !input_data_view.ReadSourceId(&p_source_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameHost::Name_, 15, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidAddMessageToConsole(
std::move(p_log_level), 
std::move(p_msg), 
std::move(p_line_number), 
std::move(p_source_id));
      return true;
    }
    case internal::kFrameHost_DidFailLoadWithError_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameHost::DidFailLoadWithError",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameHost::DidFailLoadWithError");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameHost_DidFailLoadWithError_Params_Data* params =
          reinterpret_cast<internal::FrameHost_DidFailLoadWithError_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::GURL p_url{};
      int32_t p_error_code{};
      FrameHost_DidFailLoadWithError_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success)
        p_error_code = input_data_view.error_code();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameHost::Name_, 16, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidFailLoadWithError(
std::move(p_url), 
std::move(p_error_code));
      return true;
    }
    case internal::kFrameHost_TransferUserActivationFrom_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameHost::TransferUserActivationFrom",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameHost::TransferUserActivationFrom");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameHost_TransferUserActivationFrom_Params_Data* params =
          reinterpret_cast<internal::FrameHost_TransferUserActivationFrom_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int32_t p_source_routing_id{};
      FrameHost_TransferUserActivationFrom_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_source_routing_id = input_data_view.source_routing_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameHost::Name_, 17, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->TransferUserActivationFrom(
std::move(p_source_routing_id));
      return true;
    }
    case internal::kFrameHost_ShowCreatedWindow_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameHost::ShowCreatedWindow",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameHost::ShowCreatedWindow");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameHost_ShowCreatedWindow_Params_Data* params =
          reinterpret_cast<internal::FrameHost_ShowCreatedWindow_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int32_t p_pending_widget_routing_id{};
      ::WindowOpenDisposition p_disposition{};
      ::gfx::Rect p_rect{};
      bool p_opened_by_user_gesture{};
      FrameHost_ShowCreatedWindow_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_pending_widget_routing_id = input_data_view.pending_widget_routing_id();
      if (success && !input_data_view.ReadDisposition(&p_disposition))
        success = false;
      if (success && !input_data_view.ReadRect(&p_rect))
        success = false;
      if (success)
        p_opened_by_user_gesture = input_data_view.opened_by_user_gesture();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameHost::Name_, 18, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ShowCreatedWindow(
std::move(p_pending_widget_routing_id), 
std::move(p_disposition), 
std::move(p_rect), 
std::move(p_opened_by_user_gesture));
      return true;
    }
    case internal::kFrameHost_DidAddContentSecurityPolicies_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameHost::DidAddContentSecurityPolicies",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameHost::DidAddContentSecurityPolicies");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameHost_DidAddContentSecurityPolicies_Params_Data* params =
          reinterpret_cast<internal::FrameHost_DidAddContentSecurityPolicies_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      std::vector<::network::mojom::ContentSecurityPolicyPtr> p_policies{};
      FrameHost_DidAddContentSecurityPolicies_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadPolicies(&p_policies))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameHost::Name_, 19, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidAddContentSecurityPolicies(
std::move(p_policies));
      return true;
    }
  }
  return false;
}

// static
bool FrameHostStubDispatch::AcceptWithResponder(
    FrameHost* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kFrameHost_CreateNewWindow_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameHost::CreateNewWindow",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameHost::CreateNewWindow");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::FrameHost_CreateNewWindow_Params_Data* params =
          reinterpret_cast<
              internal::FrameHost_CreateNewWindow_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      CreateNewWindowParamsPtr p_params{};
      FrameHost_CreateNewWindow_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameHost::Name_, 0, false);
        return false;
      }
      FrameHost::CreateNewWindowCallback callback =
          FrameHost_CreateNewWindow_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateNewWindow(
std::move(p_params), std::move(callback));
      return true;
    }
    case internal::kFrameHost_CreatePortal_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameHost::CreatePortal",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameHost::CreatePortal");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::FrameHost_CreatePortal_Params_Data* params =
          reinterpret_cast<
              internal::FrameHost_CreatePortal_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      mojo::PendingAssociatedReceiver<::blink::mojom::Portal> p_portal{};
      mojo::PendingAssociatedRemote<::blink::mojom::PortalClient> p_client{};
      FrameHost_CreatePortal_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success) {
        p_portal =
            input_data_view.TakePortal<decltype(p_portal)>();
      }
      if (success) {
        p_client =
            input_data_view.TakeClient<decltype(p_client)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameHost::Name_, 1, false);
        return false;
      }
      FrameHost::CreatePortalCallback callback =
          FrameHost_CreatePortal_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreatePortal(
std::move(p_portal), 
std::move(p_client), std::move(callback));
      return true;
    }
    case internal::kFrameHost_AdoptPortal_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameHost::AdoptPortal",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameHost::AdoptPortal");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::FrameHost_AdoptPortal_Params_Data* params =
          reinterpret_cast<
              internal::FrameHost_AdoptPortal_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::base::UnguessableToken p_portal_token{};
      FrameHost_AdoptPortal_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadPortalToken(&p_portal_token))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameHost::Name_, 2, false);
        return false;
      }
      FrameHost::AdoptPortalCallback callback =
          FrameHost_AdoptPortal_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AdoptPortal(
std::move(p_portal_token), std::move(callback));
      return true;
    }
    case internal::kFrameHost_IssueKeepAliveHandle_Name: {
      break;
    }
    case internal::kFrameHost_DidCommitProvisionalLoad_Name: {
      break;
    }
    case internal::kFrameHost_DidCommitSameDocumentNavigation_Name: {
      break;
    }
    case internal::kFrameHost_BeginNavigation_Name: {
      break;
    }
    case internal::kFrameHost_SubresourceResponseStarted_Name: {
      break;
    }
    case internal::kFrameHost_ResourceLoadComplete_Name: {
      break;
    }
    case internal::kFrameHost_DidChangeName_Name: {
      break;
    }
    case internal::kFrameHost_DidSetFramePolicyHeaders_Name: {
      break;
    }
    case internal::kFrameHost_CancelInitialHistoryLoad_Name: {
      break;
    }
    case internal::kFrameHost_UpdateEncoding_Name: {
      break;
    }
    case internal::kFrameHost_FrameSizeChanged_Name: {
      break;
    }
    case internal::kFrameHost_UpdateUserGestureCarryoverInfo_Name: {
      break;
    }
    case internal::kFrameHost_DidAddMessageToConsole_Name: {
      break;
    }
    case internal::kFrameHost_DidFailLoadWithError_Name: {
      break;
    }
    case internal::kFrameHost_TransferUserActivationFrom_Name: {
      break;
    }
    case internal::kFrameHost_ShowCreatedWindow_Name: {
      break;
    }
    case internal::kFrameHost_DidAddContentSecurityPolicies_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kFrameHostValidationInfo[] = {
    {&internal::FrameHost_CreateNewWindow_Params_Data::Validate,
     &internal::FrameHost_CreateNewWindow_ResponseParams_Data::Validate},
    {&internal::FrameHost_CreatePortal_Params_Data::Validate,
     &internal::FrameHost_CreatePortal_ResponseParams_Data::Validate},
    {&internal::FrameHost_AdoptPortal_Params_Data::Validate,
     &internal::FrameHost_AdoptPortal_ResponseParams_Data::Validate},
    {&internal::FrameHost_IssueKeepAliveHandle_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameHost_DidCommitProvisionalLoad_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameHost_DidCommitSameDocumentNavigation_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameHost_BeginNavigation_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameHost_SubresourceResponseStarted_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameHost_ResourceLoadComplete_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameHost_DidChangeName_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameHost_DidSetFramePolicyHeaders_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameHost_CancelInitialHistoryLoad_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameHost_UpdateEncoding_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameHost_FrameSizeChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameHost_UpdateUserGestureCarryoverInfo_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameHost_DidAddMessageToConsole_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameHost_DidFailLoadWithError_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameHost_TransferUserActivationFrom_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameHost_ShowCreatedWindow_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameHost_DidAddContentSecurityPolicies_Params_Data::Validate,
     nullptr /* no response */},
};

bool FrameHostRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::content::mojom::FrameHost::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kFrameHostValidationInfo);
}

bool FrameHostResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::content::mojom::FrameHost::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kFrameHostValidationInfo);
}
}  // namespace mojom
}  // namespace content

namespace mojo {


// static
bool StructTraits<::content::mojom::CreateNewWindowParams::DataView, ::content::mojom::CreateNewWindowParamsPtr>::Read(
    ::content::mojom::CreateNewWindowParams::DataView input,
    ::content::mojom::CreateNewWindowParamsPtr* output) {
  bool success = true;
  ::content::mojom::CreateNewWindowParamsPtr result(::content::mojom::CreateNewWindowParams::New());
  
      if (success)
        result->mimic_user_gesture = input.mimic_user_gesture();
      if (success && !input.ReadWindowContainerType(&result->window_container_type))
        success = false;
      if (success && !input.ReadSessionStorageNamespaceId(&result->session_storage_namespace_id))
        success = false;
      if (success && !input.ReadCloneFromSessionStorageNamespaceId(&result->clone_from_session_storage_namespace_id))
        success = false;
      if (success && !input.ReadFrameName(&result->frame_name))
        success = false;
      if (success)
        result->opener_suppressed = input.opener_suppressed();
      if (success && !input.ReadDisposition(&result->disposition))
        success = false;
      if (success && !input.ReadTargetUrl(&result->target_url))
        success = false;
      if (success && !input.ReadReferrer(&result->referrer))
        success = false;
      if (success && !input.ReadFeatures(&result->features))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::content::mojom::CreateNewWindowReply::DataView, ::content::mojom::CreateNewWindowReplyPtr>::Read(
    ::content::mojom::CreateNewWindowReply::DataView input,
    ::content::mojom::CreateNewWindowReplyPtr* output) {
  bool success = true;
  ::content::mojom::CreateNewWindowReplyPtr result(::content::mojom::CreateNewWindowReply::New());
  
      if (success)
        result->route_id = input.route_id();
      if (success)
        result->main_frame_route_id = input.main_frame_route_id();
      if (success)
        result->main_frame_widget_route_id = input.main_frame_widget_route_id();
      if (success && !input.ReadVisualProperties(&result->visual_properties))
        success = false;
      if (success && !input.ReadMainFrameInterfaceBundle(&result->main_frame_interface_bundle))
        success = false;
      if (success && !input.ReadClonedSessionStorageNamespaceId(&result->cloned_session_storage_namespace_id))
        success = false;
      if (success && !input.ReadDevtoolsMainFrameToken(&result->devtools_main_frame_token))
        success = false;
  *output = std::move(result);
  return success;
}

}  // namespace mojo

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif