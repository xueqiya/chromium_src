// content/common/navigation_params.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CONTENT_COMMON_NAVIGATION_PARAMS_MOJOM_H_
#define CONTENT_COMMON_NAVIGATION_PARAMS_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "base/callback.h"
#include "base/macros.h"
#include "base/optional.h"

#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#if BUILDFLAG(MOJO_TRACE_ENABLED)
#include "base/trace_event/trace_event.h"
#endif
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"
#include "content/common/navigation_params.mojom-shared.h"
#include "content/common/navigation_params.mojom-forward.h"
#include "content/common/prefetched_signed_exchange_info.mojom.h"
#include "content/public/common/was_activated_option.mojom.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "mojo/public/mojom/base/unguessable_token.mojom.h"
#include "mojo/public/mojom/base/values.mojom.h"
#include "services/network/public/mojom/content_security_policy.mojom.h"
#include "services/network/public/mojom/ip_address_space.mojom.h"
#include "services/network/public/mojom/url_loader.mojom.h"
#include "services/network/public/mojom/url_response_head.mojom.h"
#include "third_party/blink/public/mojom/fetch/fetch_api_request.mojom.h"
#include "third_party/blink/public/mojom/referrer.mojom.h"
#include "third_party/blink/public/mojom/feature_policy/feature_policy.mojom.h"
#include "third_party/blink/public/mojom/frame/frame_policy.mojom.h"
#include "url/mojom/origin.mojom.h"
#include "url/mojom/url.mojom.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/associated_interface_ptr.h"
#include "mojo/public/cpp/bindings/associated_interface_ptr_info.h"
#include "mojo/public/cpp/bindings/associated_interface_request.h"
#include "mojo/public/cpp/bindings/interface_ptr.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"
#include "mojo/public/cpp/bindings/thread_safe_interface_ptr.h"


#include "mojo/public/cpp/bindings/lib/native_enum_serialization.h"
#include "mojo/public/cpp/bindings/lib/native_struct_serialization.h"
#include "content/common/content_param_traits.h"
#include "content/common/navigation_params.h"
#include "content/public/common/navigation_policy.h"
#include "content/public/common/page_state.h"
#include "third_party/blink/public/platform/web_mixed_content_context_type.h"
#include "ui/base/page_transition_types.h"
#include "content/common/content_export.h"




namespace content {
namespace mojom {


















class CONTENT_EXPORT InitiatorCSPInfo {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<InitiatorCSPInfo, T>::value>;
  using DataView = InitiatorCSPInfoDataView;
  using Data_ = internal::InitiatorCSPInfo_Data;

  template <typename... Args>
  static InitiatorCSPInfoPtr New(Args&&... args) {
    return InitiatorCSPInfoPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static InitiatorCSPInfoPtr From(const U& u) {
    return mojo::TypeConverter<InitiatorCSPInfoPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, InitiatorCSPInfo>::Convert(*this);
  }


  InitiatorCSPInfo();

  InitiatorCSPInfo(
      ::network::mojom::CSPDisposition should_check_main_world_csp,
      std::vector<::network::mojom::ContentSecurityPolicyPtr> initiator_csp,
      ::network::mojom::CSPSourcePtr initiator_self_source);

  ~InitiatorCSPInfo();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = InitiatorCSPInfoPtr>
  InitiatorCSPInfoPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, InitiatorCSPInfo::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        InitiatorCSPInfo::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        InitiatorCSPInfo::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::InitiatorCSPInfo_UnserializedMessageContext<
            UserType, InitiatorCSPInfo::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<InitiatorCSPInfo::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return InitiatorCSPInfo::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::InitiatorCSPInfo_UnserializedMessageContext<
            UserType, InitiatorCSPInfo::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<InitiatorCSPInfo::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::network::mojom::CSPDisposition should_check_main_world_csp;
  
  std::vector<::network::mojom::ContentSecurityPolicyPtr> initiator_csp;
  
  ::network::mojom::CSPSourcePtr initiator_self_source;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(InitiatorCSPInfo);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, InitiatorCSPInfo::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, InitiatorCSPInfo::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, InitiatorCSPInfo::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, InitiatorCSPInfo::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class CONTENT_EXPORT BeginNavigationParams {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<BeginNavigationParams, T>::value>;
  using DataView = BeginNavigationParamsDataView;
  using Data_ = internal::BeginNavigationParams_Data;

  template <typename... Args>
  static BeginNavigationParamsPtr New(Args&&... args) {
    return BeginNavigationParamsPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static BeginNavigationParamsPtr From(const U& u) {
    return mojo::TypeConverter<BeginNavigationParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BeginNavigationParams>::Convert(*this);
  }


  BeginNavigationParams();

  BeginNavigationParams(
      const std::string& headers,
      int32_t load_flags,
      bool skip_service_worker,
      ::blink::mojom::RequestContextType request_context_type,
      ::blink::WebMixedContentContextType mixed_content_context_type,
      bool is_form_submission,
      bool was_initiated_by_link_click,
      const ::GURL& searchable_form_url,
      const std::string& searchable_form_encoding,
      const ::GURL& client_side_redirect_url,
      base::Optional<::base::Value> devtools_initiator,
      bool attach_same_site_cookies);

  ~BeginNavigationParams();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = BeginNavigationParamsPtr>
  BeginNavigationParamsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, BeginNavigationParams::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        BeginNavigationParams::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        BeginNavigationParams::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::BeginNavigationParams_UnserializedMessageContext<
            UserType, BeginNavigationParams::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<BeginNavigationParams::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return BeginNavigationParams::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::BeginNavigationParams_UnserializedMessageContext<
            UserType, BeginNavigationParams::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<BeginNavigationParams::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  std::string headers;
  
  int32_t load_flags;
  
  bool skip_service_worker;
  
  ::blink::mojom::RequestContextType request_context_type;
  
  ::blink::WebMixedContentContextType mixed_content_context_type;
  
  bool is_form_submission;
  
  bool was_initiated_by_link_click;
  
  ::GURL searchable_form_url;
  
  std::string searchable_form_encoding;
  
  ::GURL client_side_redirect_url;
  
  base::Optional<::base::Value> devtools_initiator;
  
  bool attach_same_site_cookies;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(BeginNavigationParams);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, BeginNavigationParams::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, BeginNavigationParams::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, BeginNavigationParams::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, BeginNavigationParams::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class CONTENT_EXPORT CommonNavigationParams {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<CommonNavigationParams, T>::value>;
  using DataView = CommonNavigationParamsDataView;
  using Data_ = internal::CommonNavigationParams_Data;

  template <typename... Args>
  static CommonNavigationParamsPtr New(Args&&... args) {
    return CommonNavigationParamsPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static CommonNavigationParamsPtr From(const U& u) {
    return mojo::TypeConverter<CommonNavigationParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CommonNavigationParams>::Convert(*this);
  }


  CommonNavigationParams();

  CommonNavigationParams(
      const ::GURL& url,
      const base::Optional<::url::Origin>& initiator_origin,
      ::blink::mojom::ReferrerPtr referrer,
      ::ui::PageTransition transition,
      NavigationType navigation_type,
      const ::content::NavigationDownloadPolicy& download_policy,
      bool should_replace_current_entry,
      const ::GURL& base_url_for_data_url,
      const ::GURL& history_url_for_data_url,
      int32_t previews_state,
      ::base::TimeTicks navigation_start,
      const std::string& method,
      ::scoped_refptr<::network::ResourceRequestBody> post_data,
      const base::Optional<::content::SourceLocation>& source_location,
      bool started_from_context_menu,
      bool has_user_gesture,
      InitiatorCSPInfoPtr initiator_csp_info,
      std::vector<int32_t> initiator_origin_trial_features,
      const std::string& href_translate,
      bool is_history_navigation_in_new_child_frame,
      ::base::TimeTicks input_start);

  ~CommonNavigationParams();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = CommonNavigationParamsPtr>
  CommonNavigationParamsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, CommonNavigationParams::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        CommonNavigationParams::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        CommonNavigationParams::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::CommonNavigationParams_UnserializedMessageContext<
            UserType, CommonNavigationParams::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<CommonNavigationParams::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return CommonNavigationParams::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::CommonNavigationParams_UnserializedMessageContext<
            UserType, CommonNavigationParams::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<CommonNavigationParams::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::GURL url;
  
  base::Optional<::url::Origin> initiator_origin;
  
  ::blink::mojom::ReferrerPtr referrer;
  
  ::ui::PageTransition transition;
  
  NavigationType navigation_type;
  
  ::content::NavigationDownloadPolicy download_policy;
  
  bool should_replace_current_entry;
  
  ::GURL base_url_for_data_url;
  
  ::GURL history_url_for_data_url;
  
  int32_t previews_state;
  
  ::base::TimeTicks navigation_start;
  
  std::string method;
  
  ::scoped_refptr<::network::ResourceRequestBody> post_data;
  
  base::Optional<::content::SourceLocation> source_location;
  
  bool started_from_context_menu;
  
  bool has_user_gesture;
  
  InitiatorCSPInfoPtr initiator_csp_info;
  
  std::vector<int32_t> initiator_origin_trial_features;
  
  std::string href_translate;
  
  bool is_history_navigation_in_new_child_frame;
  
  ::base::TimeTicks input_start;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(CommonNavigationParams);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CommonNavigationParams::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, CommonNavigationParams::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, CommonNavigationParams::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, CommonNavigationParams::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class CONTENT_EXPORT NavigationTiming {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<NavigationTiming, T>::value>;
  using DataView = NavigationTimingDataView;
  using Data_ = internal::NavigationTiming_Data;

  template <typename... Args>
  static NavigationTimingPtr New(Args&&... args) {
    return NavigationTimingPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static NavigationTimingPtr From(const U& u) {
    return mojo::TypeConverter<NavigationTimingPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NavigationTiming>::Convert(*this);
  }


  NavigationTiming();

  NavigationTiming(
      ::base::TimeTicks redirect_start,
      ::base::TimeTicks redirect_end,
      ::base::TimeTicks fetch_start);

  ~NavigationTiming();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = NavigationTimingPtr>
  NavigationTimingPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, NavigationTiming::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        NavigationTiming::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        NavigationTiming::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::NavigationTiming_UnserializedMessageContext<
            UserType, NavigationTiming::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<NavigationTiming::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return NavigationTiming::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::NavigationTiming_UnserializedMessageContext<
            UserType, NavigationTiming::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<NavigationTiming::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::base::TimeTicks redirect_start;
  
  ::base::TimeTicks redirect_end;
  
  ::base::TimeTicks fetch_start;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, NavigationTiming::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, NavigationTiming::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, NavigationTiming::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, NavigationTiming::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class CONTENT_EXPORT CommitNavigationParams {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<CommitNavigationParams, T>::value>;
  using DataView = CommitNavigationParamsDataView;
  using Data_ = internal::CommitNavigationParams_Data;

  template <typename... Args>
  static CommitNavigationParamsPtr New(Args&&... args) {
    return CommitNavigationParamsPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static CommitNavigationParamsPtr From(const U& u) {
    return mojo::TypeConverter<CommitNavigationParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CommitNavigationParams>::Convert(*this);
  }


  CommitNavigationParams();

  CommitNavigationParams(
      const base::Optional<::url::Origin>& origin_to_commit,
      bool is_overriding_user_agent,
      std::vector<::GURL> redirects,
      std::vector<::network::mojom::URLResponseHeadPtr> redirect_response,
      std::vector<::net::RedirectInfo> redirect_infos,
      const std::string& post_content_type,
      const ::GURL& original_url,
      const std::string& original_method,
      bool can_load_local_resources,
      const ::content::PageState& page_state,
      int32_t nav_entry_id,
      const base::flat_map<std::string, bool>& subframe_unique_names,
      bool intended_as_new_entry,
      int32_t pending_history_list_offset,
      int32_t current_history_list_offset,
      int32_t current_history_list_length,
      bool was_discarded,
      bool is_view_source,
      bool should_clear_history_list,
      NavigationTimingPtr navigation_timing,
      const base::Optional<::base::UnguessableToken>& appcache_host_id,
      ::content::mojom::WasActivatedOption was_activated,
      const ::base::UnguessableToken& navigation_token,
      std::vector<::content::mojom::PrefetchedSignedExchangeInfoPtr> prefetched_signed_exchanges,
      const std::string& data_url_as_string,
      bool is_browser_initiated,
      ::network::mojom::IPAddressSpace ip_address_space,
      const ::GURL& web_bundle_physical_url,
      const ::GURL& base_url_override_for_web_bundle,
      const base::Optional<::blink::FramePolicy>& frame_policy);

  ~CommitNavigationParams();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = CommitNavigationParamsPtr>
  CommitNavigationParamsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, CommitNavigationParams::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        CommitNavigationParams::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        CommitNavigationParams::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::CommitNavigationParams_UnserializedMessageContext<
            UserType, CommitNavigationParams::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<CommitNavigationParams::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return CommitNavigationParams::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::CommitNavigationParams_UnserializedMessageContext<
            UserType, CommitNavigationParams::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<CommitNavigationParams::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  base::Optional<::url::Origin> origin_to_commit;
  
  bool is_overriding_user_agent;
  
  std::vector<::GURL> redirects;
  
  std::vector<::network::mojom::URLResponseHeadPtr> redirect_response;
  
  std::vector<::net::RedirectInfo> redirect_infos;
  
  std::string post_content_type;
  
  ::GURL original_url;
  
  std::string original_method;
  
  bool can_load_local_resources;
  
  ::content::PageState page_state;
  
  int32_t nav_entry_id;
  
  base::flat_map<std::string, bool> subframe_unique_names;
  
  bool intended_as_new_entry;
  
  int32_t pending_history_list_offset;
  
  int32_t current_history_list_offset;
  
  int32_t current_history_list_length;
  
  bool was_discarded;
  
  bool is_view_source;
  
  bool should_clear_history_list;
  
  NavigationTimingPtr navigation_timing;
  
  base::Optional<::base::UnguessableToken> appcache_host_id;
  
  ::content::mojom::WasActivatedOption was_activated;
  
  ::base::UnguessableToken navigation_token;
  
  std::vector<::content::mojom::PrefetchedSignedExchangeInfoPtr> prefetched_signed_exchanges;
  
  std::string data_url_as_string;
  
  bool is_browser_initiated;
  
  ::network::mojom::IPAddressSpace ip_address_space;
  
  ::GURL web_bundle_physical_url;
  
  ::GURL base_url_override_for_web_bundle;
  
  base::Optional<::blink::FramePolicy> frame_policy;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(CommitNavigationParams);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CommitNavigationParams::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, CommitNavigationParams::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, CommitNavigationParams::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, CommitNavigationParams::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename StructPtrType>
InitiatorCSPInfoPtr InitiatorCSPInfo::Clone() const {
  return New(
      mojo::Clone(should_check_main_world_csp),
      mojo::Clone(initiator_csp),
      mojo::Clone(initiator_self_source)
  );
}

template <typename T, InitiatorCSPInfo::EnableIfSame<T>*>
bool InitiatorCSPInfo::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->should_check_main_world_csp, other_struct.should_check_main_world_csp))
    return false;
  if (!mojo::Equals(this->initiator_csp, other_struct.initiator_csp))
    return false;
  if (!mojo::Equals(this->initiator_self_source, other_struct.initiator_self_source))
    return false;
  return true;
}

template <typename T, InitiatorCSPInfo::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.should_check_main_world_csp < rhs.should_check_main_world_csp)
    return true;
  if (rhs.should_check_main_world_csp < lhs.should_check_main_world_csp)
    return false;
  if (lhs.initiator_csp < rhs.initiator_csp)
    return true;
  if (rhs.initiator_csp < lhs.initiator_csp)
    return false;
  if (lhs.initiator_self_source < rhs.initiator_self_source)
    return true;
  if (rhs.initiator_self_source < lhs.initiator_self_source)
    return false;
  return false;
}
template <typename StructPtrType>
BeginNavigationParamsPtr BeginNavigationParams::Clone() const {
  return New(
      mojo::Clone(headers),
      mojo::Clone(load_flags),
      mojo::Clone(skip_service_worker),
      mojo::Clone(request_context_type),
      mojo::Clone(mixed_content_context_type),
      mojo::Clone(is_form_submission),
      mojo::Clone(was_initiated_by_link_click),
      mojo::Clone(searchable_form_url),
      mojo::Clone(searchable_form_encoding),
      mojo::Clone(client_side_redirect_url),
      mojo::Clone(devtools_initiator),
      mojo::Clone(attach_same_site_cookies)
  );
}

template <typename T, BeginNavigationParams::EnableIfSame<T>*>
bool BeginNavigationParams::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->headers, other_struct.headers))
    return false;
  if (!mojo::Equals(this->load_flags, other_struct.load_flags))
    return false;
  if (!mojo::Equals(this->skip_service_worker, other_struct.skip_service_worker))
    return false;
  if (!mojo::Equals(this->request_context_type, other_struct.request_context_type))
    return false;
  if (!mojo::Equals(this->mixed_content_context_type, other_struct.mixed_content_context_type))
    return false;
  if (!mojo::Equals(this->is_form_submission, other_struct.is_form_submission))
    return false;
  if (!mojo::Equals(this->was_initiated_by_link_click, other_struct.was_initiated_by_link_click))
    return false;
  if (!mojo::Equals(this->searchable_form_url, other_struct.searchable_form_url))
    return false;
  if (!mojo::Equals(this->searchable_form_encoding, other_struct.searchable_form_encoding))
    return false;
  if (!mojo::Equals(this->client_side_redirect_url, other_struct.client_side_redirect_url))
    return false;
  if (!mojo::Equals(this->devtools_initiator, other_struct.devtools_initiator))
    return false;
  if (!mojo::Equals(this->attach_same_site_cookies, other_struct.attach_same_site_cookies))
    return false;
  return true;
}

template <typename T, BeginNavigationParams::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.headers < rhs.headers)
    return true;
  if (rhs.headers < lhs.headers)
    return false;
  if (lhs.load_flags < rhs.load_flags)
    return true;
  if (rhs.load_flags < lhs.load_flags)
    return false;
  if (lhs.skip_service_worker < rhs.skip_service_worker)
    return true;
  if (rhs.skip_service_worker < lhs.skip_service_worker)
    return false;
  if (lhs.request_context_type < rhs.request_context_type)
    return true;
  if (rhs.request_context_type < lhs.request_context_type)
    return false;
  if (lhs.mixed_content_context_type < rhs.mixed_content_context_type)
    return true;
  if (rhs.mixed_content_context_type < lhs.mixed_content_context_type)
    return false;
  if (lhs.is_form_submission < rhs.is_form_submission)
    return true;
  if (rhs.is_form_submission < lhs.is_form_submission)
    return false;
  if (lhs.was_initiated_by_link_click < rhs.was_initiated_by_link_click)
    return true;
  if (rhs.was_initiated_by_link_click < lhs.was_initiated_by_link_click)
    return false;
  if (lhs.searchable_form_url < rhs.searchable_form_url)
    return true;
  if (rhs.searchable_form_url < lhs.searchable_form_url)
    return false;
  if (lhs.searchable_form_encoding < rhs.searchable_form_encoding)
    return true;
  if (rhs.searchable_form_encoding < lhs.searchable_form_encoding)
    return false;
  if (lhs.client_side_redirect_url < rhs.client_side_redirect_url)
    return true;
  if (rhs.client_side_redirect_url < lhs.client_side_redirect_url)
    return false;
  if (lhs.devtools_initiator < rhs.devtools_initiator)
    return true;
  if (rhs.devtools_initiator < lhs.devtools_initiator)
    return false;
  if (lhs.attach_same_site_cookies < rhs.attach_same_site_cookies)
    return true;
  if (rhs.attach_same_site_cookies < lhs.attach_same_site_cookies)
    return false;
  return false;
}
template <typename StructPtrType>
CommonNavigationParamsPtr CommonNavigationParams::Clone() const {
  return New(
      mojo::Clone(url),
      mojo::Clone(initiator_origin),
      mojo::Clone(referrer),
      mojo::Clone(transition),
      mojo::Clone(navigation_type),
      mojo::Clone(download_policy),
      mojo::Clone(should_replace_current_entry),
      mojo::Clone(base_url_for_data_url),
      mojo::Clone(history_url_for_data_url),
      mojo::Clone(previews_state),
      mojo::Clone(navigation_start),
      mojo::Clone(method),
      mojo::Clone(post_data),
      mojo::Clone(source_location),
      mojo::Clone(started_from_context_menu),
      mojo::Clone(has_user_gesture),
      mojo::Clone(initiator_csp_info),
      mojo::Clone(initiator_origin_trial_features),
      mojo::Clone(href_translate),
      mojo::Clone(is_history_navigation_in_new_child_frame),
      mojo::Clone(input_start)
  );
}

template <typename T, CommonNavigationParams::EnableIfSame<T>*>
bool CommonNavigationParams::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->url, other_struct.url))
    return false;
  if (!mojo::Equals(this->initiator_origin, other_struct.initiator_origin))
    return false;
  if (!mojo::Equals(this->referrer, other_struct.referrer))
    return false;
  if (!mojo::Equals(this->transition, other_struct.transition))
    return false;
  if (!mojo::Equals(this->navigation_type, other_struct.navigation_type))
    return false;
  if (!mojo::Equals(this->download_policy, other_struct.download_policy))
    return false;
  if (!mojo::Equals(this->should_replace_current_entry, other_struct.should_replace_current_entry))
    return false;
  if (!mojo::Equals(this->base_url_for_data_url, other_struct.base_url_for_data_url))
    return false;
  if (!mojo::Equals(this->history_url_for_data_url, other_struct.history_url_for_data_url))
    return false;
  if (!mojo::Equals(this->previews_state, other_struct.previews_state))
    return false;
  if (!mojo::Equals(this->navigation_start, other_struct.navigation_start))
    return false;
  if (!mojo::Equals(this->method, other_struct.method))
    return false;
  if (!mojo::Equals(this->post_data, other_struct.post_data))
    return false;
  if (!mojo::Equals(this->source_location, other_struct.source_location))
    return false;
  if (!mojo::Equals(this->started_from_context_menu, other_struct.started_from_context_menu))
    return false;
  if (!mojo::Equals(this->has_user_gesture, other_struct.has_user_gesture))
    return false;
  if (!mojo::Equals(this->initiator_csp_info, other_struct.initiator_csp_info))
    return false;
  if (!mojo::Equals(this->initiator_origin_trial_features, other_struct.initiator_origin_trial_features))
    return false;
  if (!mojo::Equals(this->href_translate, other_struct.href_translate))
    return false;
  if (!mojo::Equals(this->is_history_navigation_in_new_child_frame, other_struct.is_history_navigation_in_new_child_frame))
    return false;
  if (!mojo::Equals(this->input_start, other_struct.input_start))
    return false;
  return true;
}

template <typename T, CommonNavigationParams::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.url < rhs.url)
    return true;
  if (rhs.url < lhs.url)
    return false;
  if (lhs.initiator_origin < rhs.initiator_origin)
    return true;
  if (rhs.initiator_origin < lhs.initiator_origin)
    return false;
  if (lhs.referrer < rhs.referrer)
    return true;
  if (rhs.referrer < lhs.referrer)
    return false;
  if (lhs.transition < rhs.transition)
    return true;
  if (rhs.transition < lhs.transition)
    return false;
  if (lhs.navigation_type < rhs.navigation_type)
    return true;
  if (rhs.navigation_type < lhs.navigation_type)
    return false;
  if (lhs.download_policy < rhs.download_policy)
    return true;
  if (rhs.download_policy < lhs.download_policy)
    return false;
  if (lhs.should_replace_current_entry < rhs.should_replace_current_entry)
    return true;
  if (rhs.should_replace_current_entry < lhs.should_replace_current_entry)
    return false;
  if (lhs.base_url_for_data_url < rhs.base_url_for_data_url)
    return true;
  if (rhs.base_url_for_data_url < lhs.base_url_for_data_url)
    return false;
  if (lhs.history_url_for_data_url < rhs.history_url_for_data_url)
    return true;
  if (rhs.history_url_for_data_url < lhs.history_url_for_data_url)
    return false;
  if (lhs.previews_state < rhs.previews_state)
    return true;
  if (rhs.previews_state < lhs.previews_state)
    return false;
  if (lhs.navigation_start < rhs.navigation_start)
    return true;
  if (rhs.navigation_start < lhs.navigation_start)
    return false;
  if (lhs.method < rhs.method)
    return true;
  if (rhs.method < lhs.method)
    return false;
  if (lhs.post_data < rhs.post_data)
    return true;
  if (rhs.post_data < lhs.post_data)
    return false;
  if (lhs.source_location < rhs.source_location)
    return true;
  if (rhs.source_location < lhs.source_location)
    return false;
  if (lhs.started_from_context_menu < rhs.started_from_context_menu)
    return true;
  if (rhs.started_from_context_menu < lhs.started_from_context_menu)
    return false;
  if (lhs.has_user_gesture < rhs.has_user_gesture)
    return true;
  if (rhs.has_user_gesture < lhs.has_user_gesture)
    return false;
  if (lhs.initiator_csp_info < rhs.initiator_csp_info)
    return true;
  if (rhs.initiator_csp_info < lhs.initiator_csp_info)
    return false;
  if (lhs.initiator_origin_trial_features < rhs.initiator_origin_trial_features)
    return true;
  if (rhs.initiator_origin_trial_features < lhs.initiator_origin_trial_features)
    return false;
  if (lhs.href_translate < rhs.href_translate)
    return true;
  if (rhs.href_translate < lhs.href_translate)
    return false;
  if (lhs.is_history_navigation_in_new_child_frame < rhs.is_history_navigation_in_new_child_frame)
    return true;
  if (rhs.is_history_navigation_in_new_child_frame < lhs.is_history_navigation_in_new_child_frame)
    return false;
  if (lhs.input_start < rhs.input_start)
    return true;
  if (rhs.input_start < lhs.input_start)
    return false;
  return false;
}
template <typename StructPtrType>
NavigationTimingPtr NavigationTiming::Clone() const {
  return New(
      mojo::Clone(redirect_start),
      mojo::Clone(redirect_end),
      mojo::Clone(fetch_start)
  );
}

template <typename T, NavigationTiming::EnableIfSame<T>*>
bool NavigationTiming::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->redirect_start, other_struct.redirect_start))
    return false;
  if (!mojo::Equals(this->redirect_end, other_struct.redirect_end))
    return false;
  if (!mojo::Equals(this->fetch_start, other_struct.fetch_start))
    return false;
  return true;
}

template <typename T, NavigationTiming::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.redirect_start < rhs.redirect_start)
    return true;
  if (rhs.redirect_start < lhs.redirect_start)
    return false;
  if (lhs.redirect_end < rhs.redirect_end)
    return true;
  if (rhs.redirect_end < lhs.redirect_end)
    return false;
  if (lhs.fetch_start < rhs.fetch_start)
    return true;
  if (rhs.fetch_start < lhs.fetch_start)
    return false;
  return false;
}
template <typename StructPtrType>
CommitNavigationParamsPtr CommitNavigationParams::Clone() const {
  return New(
      mojo::Clone(origin_to_commit),
      mojo::Clone(is_overriding_user_agent),
      mojo::Clone(redirects),
      mojo::Clone(redirect_response),
      mojo::Clone(redirect_infos),
      mojo::Clone(post_content_type),
      mojo::Clone(original_url),
      mojo::Clone(original_method),
      mojo::Clone(can_load_local_resources),
      mojo::Clone(page_state),
      mojo::Clone(nav_entry_id),
      mojo::Clone(subframe_unique_names),
      mojo::Clone(intended_as_new_entry),
      mojo::Clone(pending_history_list_offset),
      mojo::Clone(current_history_list_offset),
      mojo::Clone(current_history_list_length),
      mojo::Clone(was_discarded),
      mojo::Clone(is_view_source),
      mojo::Clone(should_clear_history_list),
      mojo::Clone(navigation_timing),
      mojo::Clone(appcache_host_id),
      mojo::Clone(was_activated),
      mojo::Clone(navigation_token),
      mojo::Clone(prefetched_signed_exchanges),
      mojo::Clone(data_url_as_string),
      mojo::Clone(is_browser_initiated),
      mojo::Clone(ip_address_space),
      mojo::Clone(web_bundle_physical_url),
      mojo::Clone(base_url_override_for_web_bundle),
      mojo::Clone(frame_policy)
  );
}

template <typename T, CommitNavigationParams::EnableIfSame<T>*>
bool CommitNavigationParams::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->origin_to_commit, other_struct.origin_to_commit))
    return false;
  if (!mojo::Equals(this->is_overriding_user_agent, other_struct.is_overriding_user_agent))
    return false;
  if (!mojo::Equals(this->redirects, other_struct.redirects))
    return false;
  if (!mojo::Equals(this->redirect_response, other_struct.redirect_response))
    return false;
  if (!mojo::Equals(this->redirect_infos, other_struct.redirect_infos))
    return false;
  if (!mojo::Equals(this->post_content_type, other_struct.post_content_type))
    return false;
  if (!mojo::Equals(this->original_url, other_struct.original_url))
    return false;
  if (!mojo::Equals(this->original_method, other_struct.original_method))
    return false;
  if (!mojo::Equals(this->can_load_local_resources, other_struct.can_load_local_resources))
    return false;
  if (!mojo::Equals(this->page_state, other_struct.page_state))
    return false;
  if (!mojo::Equals(this->nav_entry_id, other_struct.nav_entry_id))
    return false;
  if (!mojo::Equals(this->subframe_unique_names, other_struct.subframe_unique_names))
    return false;
  if (!mojo::Equals(this->intended_as_new_entry, other_struct.intended_as_new_entry))
    return false;
  if (!mojo::Equals(this->pending_history_list_offset, other_struct.pending_history_list_offset))
    return false;
  if (!mojo::Equals(this->current_history_list_offset, other_struct.current_history_list_offset))
    return false;
  if (!mojo::Equals(this->current_history_list_length, other_struct.current_history_list_length))
    return false;
  if (!mojo::Equals(this->was_discarded, other_struct.was_discarded))
    return false;
  if (!mojo::Equals(this->is_view_source, other_struct.is_view_source))
    return false;
  if (!mojo::Equals(this->should_clear_history_list, other_struct.should_clear_history_list))
    return false;
  if (!mojo::Equals(this->navigation_timing, other_struct.navigation_timing))
    return false;
  if (!mojo::Equals(this->appcache_host_id, other_struct.appcache_host_id))
    return false;
  if (!mojo::Equals(this->was_activated, other_struct.was_activated))
    return false;
  if (!mojo::Equals(this->navigation_token, other_struct.navigation_token))
    return false;
  if (!mojo::Equals(this->prefetched_signed_exchanges, other_struct.prefetched_signed_exchanges))
    return false;
  if (!mojo::Equals(this->data_url_as_string, other_struct.data_url_as_string))
    return false;
  if (!mojo::Equals(this->is_browser_initiated, other_struct.is_browser_initiated))
    return false;
  if (!mojo::Equals(this->ip_address_space, other_struct.ip_address_space))
    return false;
  if (!mojo::Equals(this->web_bundle_physical_url, other_struct.web_bundle_physical_url))
    return false;
  if (!mojo::Equals(this->base_url_override_for_web_bundle, other_struct.base_url_override_for_web_bundle))
    return false;
  if (!mojo::Equals(this->frame_policy, other_struct.frame_policy))
    return false;
  return true;
}

template <typename T, CommitNavigationParams::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.origin_to_commit < rhs.origin_to_commit)
    return true;
  if (rhs.origin_to_commit < lhs.origin_to_commit)
    return false;
  if (lhs.is_overriding_user_agent < rhs.is_overriding_user_agent)
    return true;
  if (rhs.is_overriding_user_agent < lhs.is_overriding_user_agent)
    return false;
  if (lhs.redirects < rhs.redirects)
    return true;
  if (rhs.redirects < lhs.redirects)
    return false;
  if (lhs.redirect_response < rhs.redirect_response)
    return true;
  if (rhs.redirect_response < lhs.redirect_response)
    return false;
  if (lhs.redirect_infos < rhs.redirect_infos)
    return true;
  if (rhs.redirect_infos < lhs.redirect_infos)
    return false;
  if (lhs.post_content_type < rhs.post_content_type)
    return true;
  if (rhs.post_content_type < lhs.post_content_type)
    return false;
  if (lhs.original_url < rhs.original_url)
    return true;
  if (rhs.original_url < lhs.original_url)
    return false;
  if (lhs.original_method < rhs.original_method)
    return true;
  if (rhs.original_method < lhs.original_method)
    return false;
  if (lhs.can_load_local_resources < rhs.can_load_local_resources)
    return true;
  if (rhs.can_load_local_resources < lhs.can_load_local_resources)
    return false;
  if (lhs.page_state < rhs.page_state)
    return true;
  if (rhs.page_state < lhs.page_state)
    return false;
  if (lhs.nav_entry_id < rhs.nav_entry_id)
    return true;
  if (rhs.nav_entry_id < lhs.nav_entry_id)
    return false;
  if (lhs.subframe_unique_names < rhs.subframe_unique_names)
    return true;
  if (rhs.subframe_unique_names < lhs.subframe_unique_names)
    return false;
  if (lhs.intended_as_new_entry < rhs.intended_as_new_entry)
    return true;
  if (rhs.intended_as_new_entry < lhs.intended_as_new_entry)
    return false;
  if (lhs.pending_history_list_offset < rhs.pending_history_list_offset)
    return true;
  if (rhs.pending_history_list_offset < lhs.pending_history_list_offset)
    return false;
  if (lhs.current_history_list_offset < rhs.current_history_list_offset)
    return true;
  if (rhs.current_history_list_offset < lhs.current_history_list_offset)
    return false;
  if (lhs.current_history_list_length < rhs.current_history_list_length)
    return true;
  if (rhs.current_history_list_length < lhs.current_history_list_length)
    return false;
  if (lhs.was_discarded < rhs.was_discarded)
    return true;
  if (rhs.was_discarded < lhs.was_discarded)
    return false;
  if (lhs.is_view_source < rhs.is_view_source)
    return true;
  if (rhs.is_view_source < lhs.is_view_source)
    return false;
  if (lhs.should_clear_history_list < rhs.should_clear_history_list)
    return true;
  if (rhs.should_clear_history_list < lhs.should_clear_history_list)
    return false;
  if (lhs.navigation_timing < rhs.navigation_timing)
    return true;
  if (rhs.navigation_timing < lhs.navigation_timing)
    return false;
  if (lhs.appcache_host_id < rhs.appcache_host_id)
    return true;
  if (rhs.appcache_host_id < lhs.appcache_host_id)
    return false;
  if (lhs.was_activated < rhs.was_activated)
    return true;
  if (rhs.was_activated < lhs.was_activated)
    return false;
  if (lhs.navigation_token < rhs.navigation_token)
    return true;
  if (rhs.navigation_token < lhs.navigation_token)
    return false;
  if (lhs.prefetched_signed_exchanges < rhs.prefetched_signed_exchanges)
    return true;
  if (rhs.prefetched_signed_exchanges < lhs.prefetched_signed_exchanges)
    return false;
  if (lhs.data_url_as_string < rhs.data_url_as_string)
    return true;
  if (rhs.data_url_as_string < lhs.data_url_as_string)
    return false;
  if (lhs.is_browser_initiated < rhs.is_browser_initiated)
    return true;
  if (rhs.is_browser_initiated < lhs.is_browser_initiated)
    return false;
  if (lhs.ip_address_space < rhs.ip_address_space)
    return true;
  if (rhs.ip_address_space < lhs.ip_address_space)
    return false;
  if (lhs.web_bundle_physical_url < rhs.web_bundle_physical_url)
    return true;
  if (rhs.web_bundle_physical_url < lhs.web_bundle_physical_url)
    return false;
  if (lhs.base_url_override_for_web_bundle < rhs.base_url_override_for_web_bundle)
    return true;
  if (rhs.base_url_override_for_web_bundle < lhs.base_url_override_for_web_bundle)
    return false;
  if (lhs.frame_policy < rhs.frame_policy)
    return true;
  if (rhs.frame_policy < lhs.frame_policy)
    return false;
  return false;
}


}  // namespace mojom
}  // namespace content

namespace mojo {


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::InitiatorCSPInfo::DataView,
                                         ::content::mojom::InitiatorCSPInfoPtr> {
  static bool IsNull(const ::content::mojom::InitiatorCSPInfoPtr& input) { return !input; }
  static void SetToNull(::content::mojom::InitiatorCSPInfoPtr* output) { output->reset(); }

  static decltype(::content::mojom::InitiatorCSPInfo::should_check_main_world_csp) should_check_main_world_csp(
      const ::content::mojom::InitiatorCSPInfoPtr& input) {
    return input->should_check_main_world_csp;
  }

  static const decltype(::content::mojom::InitiatorCSPInfo::initiator_csp)& initiator_csp(
      const ::content::mojom::InitiatorCSPInfoPtr& input) {
    return input->initiator_csp;
  }

  static const decltype(::content::mojom::InitiatorCSPInfo::initiator_self_source)& initiator_self_source(
      const ::content::mojom::InitiatorCSPInfoPtr& input) {
    return input->initiator_self_source;
  }

  static bool Read(::content::mojom::InitiatorCSPInfo::DataView input, ::content::mojom::InitiatorCSPInfoPtr* output);
};


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::BeginNavigationParams::DataView,
                                         ::content::mojom::BeginNavigationParamsPtr> {
  static bool IsNull(const ::content::mojom::BeginNavigationParamsPtr& input) { return !input; }
  static void SetToNull(::content::mojom::BeginNavigationParamsPtr* output) { output->reset(); }

  static const decltype(::content::mojom::BeginNavigationParams::headers)& headers(
      const ::content::mojom::BeginNavigationParamsPtr& input) {
    return input->headers;
  }

  static decltype(::content::mojom::BeginNavigationParams::load_flags) load_flags(
      const ::content::mojom::BeginNavigationParamsPtr& input) {
    return input->load_flags;
  }

  static decltype(::content::mojom::BeginNavigationParams::skip_service_worker) skip_service_worker(
      const ::content::mojom::BeginNavigationParamsPtr& input) {
    return input->skip_service_worker;
  }

  static decltype(::content::mojom::BeginNavigationParams::request_context_type) request_context_type(
      const ::content::mojom::BeginNavigationParamsPtr& input) {
    return input->request_context_type;
  }

  static decltype(::content::mojom::BeginNavigationParams::mixed_content_context_type) mixed_content_context_type(
      const ::content::mojom::BeginNavigationParamsPtr& input) {
    return input->mixed_content_context_type;
  }

  static decltype(::content::mojom::BeginNavigationParams::is_form_submission) is_form_submission(
      const ::content::mojom::BeginNavigationParamsPtr& input) {
    return input->is_form_submission;
  }

  static decltype(::content::mojom::BeginNavigationParams::was_initiated_by_link_click) was_initiated_by_link_click(
      const ::content::mojom::BeginNavigationParamsPtr& input) {
    return input->was_initiated_by_link_click;
  }

  static const decltype(::content::mojom::BeginNavigationParams::searchable_form_url)& searchable_form_url(
      const ::content::mojom::BeginNavigationParamsPtr& input) {
    return input->searchable_form_url;
  }

  static const decltype(::content::mojom::BeginNavigationParams::searchable_form_encoding)& searchable_form_encoding(
      const ::content::mojom::BeginNavigationParamsPtr& input) {
    return input->searchable_form_encoding;
  }

  static const decltype(::content::mojom::BeginNavigationParams::client_side_redirect_url)& client_side_redirect_url(
      const ::content::mojom::BeginNavigationParamsPtr& input) {
    return input->client_side_redirect_url;
  }

  static const decltype(::content::mojom::BeginNavigationParams::devtools_initiator)& devtools_initiator(
      const ::content::mojom::BeginNavigationParamsPtr& input) {
    return input->devtools_initiator;
  }

  static decltype(::content::mojom::BeginNavigationParams::attach_same_site_cookies) attach_same_site_cookies(
      const ::content::mojom::BeginNavigationParamsPtr& input) {
    return input->attach_same_site_cookies;
  }

  static bool Read(::content::mojom::BeginNavigationParams::DataView input, ::content::mojom::BeginNavigationParamsPtr* output);
};


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::CommonNavigationParams::DataView,
                                         ::content::mojom::CommonNavigationParamsPtr> {
  static bool IsNull(const ::content::mojom::CommonNavigationParamsPtr& input) { return !input; }
  static void SetToNull(::content::mojom::CommonNavigationParamsPtr* output) { output->reset(); }

  static const decltype(::content::mojom::CommonNavigationParams::url)& url(
      const ::content::mojom::CommonNavigationParamsPtr& input) {
    return input->url;
  }

  static const decltype(::content::mojom::CommonNavigationParams::initiator_origin)& initiator_origin(
      const ::content::mojom::CommonNavigationParamsPtr& input) {
    return input->initiator_origin;
  }

  static const decltype(::content::mojom::CommonNavigationParams::referrer)& referrer(
      const ::content::mojom::CommonNavigationParamsPtr& input) {
    return input->referrer;
  }

  static decltype(::content::mojom::CommonNavigationParams::transition) transition(
      const ::content::mojom::CommonNavigationParamsPtr& input) {
    return input->transition;
  }

  static decltype(::content::mojom::CommonNavigationParams::navigation_type) navigation_type(
      const ::content::mojom::CommonNavigationParamsPtr& input) {
    return input->navigation_type;
  }

  static const decltype(::content::mojom::CommonNavigationParams::download_policy)& download_policy(
      const ::content::mojom::CommonNavigationParamsPtr& input) {
    return input->download_policy;
  }

  static decltype(::content::mojom::CommonNavigationParams::should_replace_current_entry) should_replace_current_entry(
      const ::content::mojom::CommonNavigationParamsPtr& input) {
    return input->should_replace_current_entry;
  }

  static const decltype(::content::mojom::CommonNavigationParams::base_url_for_data_url)& base_url_for_data_url(
      const ::content::mojom::CommonNavigationParamsPtr& input) {
    return input->base_url_for_data_url;
  }

  static const decltype(::content::mojom::CommonNavigationParams::history_url_for_data_url)& history_url_for_data_url(
      const ::content::mojom::CommonNavigationParamsPtr& input) {
    return input->history_url_for_data_url;
  }

  static decltype(::content::mojom::CommonNavigationParams::previews_state) previews_state(
      const ::content::mojom::CommonNavigationParamsPtr& input) {
    return input->previews_state;
  }

  static const decltype(::content::mojom::CommonNavigationParams::navigation_start)& navigation_start(
      const ::content::mojom::CommonNavigationParamsPtr& input) {
    return input->navigation_start;
  }

  static const decltype(::content::mojom::CommonNavigationParams::method)& method(
      const ::content::mojom::CommonNavigationParamsPtr& input) {
    return input->method;
  }

  static  decltype(::content::mojom::CommonNavigationParams::post_data)& post_data(
       ::content::mojom::CommonNavigationParamsPtr& input) {
    return input->post_data;
  }

  static const decltype(::content::mojom::CommonNavigationParams::source_location)& source_location(
      const ::content::mojom::CommonNavigationParamsPtr& input) {
    return input->source_location;
  }

  static decltype(::content::mojom::CommonNavigationParams::started_from_context_menu) started_from_context_menu(
      const ::content::mojom::CommonNavigationParamsPtr& input) {
    return input->started_from_context_menu;
  }

  static decltype(::content::mojom::CommonNavigationParams::has_user_gesture) has_user_gesture(
      const ::content::mojom::CommonNavigationParamsPtr& input) {
    return input->has_user_gesture;
  }

  static const decltype(::content::mojom::CommonNavigationParams::initiator_csp_info)& initiator_csp_info(
      const ::content::mojom::CommonNavigationParamsPtr& input) {
    return input->initiator_csp_info;
  }

  static const decltype(::content::mojom::CommonNavigationParams::initiator_origin_trial_features)& initiator_origin_trial_features(
      const ::content::mojom::CommonNavigationParamsPtr& input) {
    return input->initiator_origin_trial_features;
  }

  static const decltype(::content::mojom::CommonNavigationParams::href_translate)& href_translate(
      const ::content::mojom::CommonNavigationParamsPtr& input) {
    return input->href_translate;
  }

  static decltype(::content::mojom::CommonNavigationParams::is_history_navigation_in_new_child_frame) is_history_navigation_in_new_child_frame(
      const ::content::mojom::CommonNavigationParamsPtr& input) {
    return input->is_history_navigation_in_new_child_frame;
  }

  static const decltype(::content::mojom::CommonNavigationParams::input_start)& input_start(
      const ::content::mojom::CommonNavigationParamsPtr& input) {
    return input->input_start;
  }

  static bool Read(::content::mojom::CommonNavigationParams::DataView input, ::content::mojom::CommonNavigationParamsPtr* output);
};


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::NavigationTiming::DataView,
                                         ::content::mojom::NavigationTimingPtr> {
  static bool IsNull(const ::content::mojom::NavigationTimingPtr& input) { return !input; }
  static void SetToNull(::content::mojom::NavigationTimingPtr* output) { output->reset(); }

  static const decltype(::content::mojom::NavigationTiming::redirect_start)& redirect_start(
      const ::content::mojom::NavigationTimingPtr& input) {
    return input->redirect_start;
  }

  static const decltype(::content::mojom::NavigationTiming::redirect_end)& redirect_end(
      const ::content::mojom::NavigationTimingPtr& input) {
    return input->redirect_end;
  }

  static const decltype(::content::mojom::NavigationTiming::fetch_start)& fetch_start(
      const ::content::mojom::NavigationTimingPtr& input) {
    return input->fetch_start;
  }

  static bool Read(::content::mojom::NavigationTiming::DataView input, ::content::mojom::NavigationTimingPtr* output);
};


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::CommitNavigationParams::DataView,
                                         ::content::mojom::CommitNavigationParamsPtr> {
  static bool IsNull(const ::content::mojom::CommitNavigationParamsPtr& input) { return !input; }
  static void SetToNull(::content::mojom::CommitNavigationParamsPtr* output) { output->reset(); }

  static const decltype(::content::mojom::CommitNavigationParams::origin_to_commit)& origin_to_commit(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->origin_to_commit;
  }

  static decltype(::content::mojom::CommitNavigationParams::is_overriding_user_agent) is_overriding_user_agent(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->is_overriding_user_agent;
  }

  static const decltype(::content::mojom::CommitNavigationParams::redirects)& redirects(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->redirects;
  }

  static const decltype(::content::mojom::CommitNavigationParams::redirect_response)& redirect_response(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->redirect_response;
  }

  static const decltype(::content::mojom::CommitNavigationParams::redirect_infos)& redirect_infos(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->redirect_infos;
  }

  static const decltype(::content::mojom::CommitNavigationParams::post_content_type)& post_content_type(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->post_content_type;
  }

  static const decltype(::content::mojom::CommitNavigationParams::original_url)& original_url(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->original_url;
  }

  static const decltype(::content::mojom::CommitNavigationParams::original_method)& original_method(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->original_method;
  }

  static decltype(::content::mojom::CommitNavigationParams::can_load_local_resources) can_load_local_resources(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->can_load_local_resources;
  }

  static const decltype(::content::mojom::CommitNavigationParams::page_state)& page_state(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->page_state;
  }

  static decltype(::content::mojom::CommitNavigationParams::nav_entry_id) nav_entry_id(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->nav_entry_id;
  }

  static const decltype(::content::mojom::CommitNavigationParams::subframe_unique_names)& subframe_unique_names(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->subframe_unique_names;
  }

  static decltype(::content::mojom::CommitNavigationParams::intended_as_new_entry) intended_as_new_entry(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->intended_as_new_entry;
  }

  static decltype(::content::mojom::CommitNavigationParams::pending_history_list_offset) pending_history_list_offset(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->pending_history_list_offset;
  }

  static decltype(::content::mojom::CommitNavigationParams::current_history_list_offset) current_history_list_offset(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->current_history_list_offset;
  }

  static decltype(::content::mojom::CommitNavigationParams::current_history_list_length) current_history_list_length(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->current_history_list_length;
  }

  static decltype(::content::mojom::CommitNavigationParams::was_discarded) was_discarded(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->was_discarded;
  }

  static decltype(::content::mojom::CommitNavigationParams::is_view_source) is_view_source(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->is_view_source;
  }

  static decltype(::content::mojom::CommitNavigationParams::should_clear_history_list) should_clear_history_list(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->should_clear_history_list;
  }

  static const decltype(::content::mojom::CommitNavigationParams::navigation_timing)& navigation_timing(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->navigation_timing;
  }

  static const decltype(::content::mojom::CommitNavigationParams::appcache_host_id)& appcache_host_id(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->appcache_host_id;
  }

  static decltype(::content::mojom::CommitNavigationParams::was_activated) was_activated(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->was_activated;
  }

  static const decltype(::content::mojom::CommitNavigationParams::navigation_token)& navigation_token(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->navigation_token;
  }

  static  decltype(::content::mojom::CommitNavigationParams::prefetched_signed_exchanges)& prefetched_signed_exchanges(
       ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->prefetched_signed_exchanges;
  }

  static const decltype(::content::mojom::CommitNavigationParams::data_url_as_string)& data_url_as_string(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->data_url_as_string;
  }

  static decltype(::content::mojom::CommitNavigationParams::is_browser_initiated) is_browser_initiated(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->is_browser_initiated;
  }

  static decltype(::content::mojom::CommitNavigationParams::ip_address_space) ip_address_space(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->ip_address_space;
  }

  static const decltype(::content::mojom::CommitNavigationParams::web_bundle_physical_url)& web_bundle_physical_url(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->web_bundle_physical_url;
  }

  static const decltype(::content::mojom::CommitNavigationParams::base_url_override_for_web_bundle)& base_url_override_for_web_bundle(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->base_url_override_for_web_bundle;
  }

  static const decltype(::content::mojom::CommitNavigationParams::frame_policy)& frame_policy(
      const ::content::mojom::CommitNavigationParamsPtr& input) {
    return input->frame_policy;
  }

  static bool Read(::content::mojom::CommitNavigationParams::DataView input, ::content::mojom::CommitNavigationParamsPtr* output);
};

}  // namespace mojo

#endif  // CONTENT_COMMON_NAVIGATION_PARAMS_MOJOM_H_