// content/common/input/input_handler.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CONTENT_COMMON_INPUT_INPUT_HANDLER_MOJOM_TEST_UTILS_H_
#define CONTENT_COMMON_INPUT_INPUT_HANDLER_MOJOM_TEST_UTILS_H_

#include "content/common/input/input_handler.mojom.h"
#include "content/common/content_export.h"


namespace content {
namespace mojom {


class CONTENT_EXPORT WidgetInputHandlerHostInterceptorForTesting : public WidgetInputHandlerHost {
  virtual WidgetInputHandlerHost* GetForwardingInterface() = 0;
  void FallbackCursorModeLockCursor(bool left, bool right, bool up, bool down) override;
  void FallbackCursorModeSetCursorVisibility(bool visible) override;
  void SetTouchActionFromMain(::cc::TouchAction touch_action) override;
  void SetWhiteListedTouchAction(::cc::TouchAction touch_action, uint32_t unique_touch_event_id, ::content::InputEventAckState state) override;
  void DidOverscroll(const ::ui::DidOverscrollParams& params) override;
  void DidStartScrollingViewport() override;
  void ImeCancelComposition() override;
  void ImeCompositionRangeChanged(const ::gfx::Range& range, const std::vector<::gfx::Rect>& bounds) override;
  void SetMouseCapture(bool capture) override;
};
class CONTENT_EXPORT WidgetInputHandlerHostAsyncWaiter {
 public:
  explicit WidgetInputHandlerHostAsyncWaiter(WidgetInputHandlerHost* proxy);
  ~WidgetInputHandlerHostAsyncWaiter();

 private:
  WidgetInputHandlerHost* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(WidgetInputHandlerHostAsyncWaiter);
};


class CONTENT_EXPORT WidgetInputHandlerInterceptorForTesting : public WidgetInputHandler {
  virtual WidgetInputHandler* GetForwardingInterface() = 0;
  void SetFocus(bool focused) override;
  void MouseCaptureLost() override;
  void SetEditCommandsForNextKeyEvent(const std::vector<::content::EditCommand>& commands) override;
  void CursorVisibilityChanged(bool visible) override;
  void FallbackCursorModeToggled(bool is_on) override;
  void ImeSetComposition(const ::base::string16& text, const std::vector<::ui::ImeTextSpan>& ime_text_spans, const ::gfx::Range& range, int32_t start, int32_t end) override;
  void ImeCommitText(const ::base::string16& text, const std::vector<::ui::ImeTextSpan>& ime_text_spans, const ::gfx::Range& range, int32_t relative_cursor_position, ImeCommitTextCallback callback) override;
  void ImeFinishComposingText(bool keep_selection) override;
  void RequestTextInputStateUpdate() override;
  void RequestCompositionUpdates(bool immediate_request, bool monitor_request) override;
  void DispatchEvent(::std::unique_ptr<::content::InputEvent> event, DispatchEventCallback callback) override;
  void DispatchNonBlockingEvent(::std::unique_ptr<::content::InputEvent> event) override;
  void WaitForInputProcessed(WaitForInputProcessedCallback callback) override;
  void AttachSynchronousCompositor(mojo::PendingRemote<::content::mojom::SynchronousCompositorControlHost> control_host, mojo::PendingAssociatedRemote<::content::mojom::SynchronousCompositorHost> host, mojo::PendingAssociatedReceiver<::content::mojom::SynchronousCompositor> compositor_request) override;
};
class CONTENT_EXPORT WidgetInputHandlerAsyncWaiter {
 public:
  explicit WidgetInputHandlerAsyncWaiter(WidgetInputHandler* proxy);
  ~WidgetInputHandlerAsyncWaiter();
  void ImeCommitText(
      const ::base::string16& text, const std::vector<::ui::ImeTextSpan>& ime_text_spans, const ::gfx::Range& range, int32_t relative_cursor_position);
  void DispatchEvent(
      ::std::unique_ptr<::content::InputEvent> event, ::content::InputEventAckSource* out_source, ::ui::LatencyInfo* out_updated_latency, ::content::InputEventAckState* out_state, base::Optional<::ui::DidOverscrollParams>* out_overscroll, base::Optional<::cc::TouchAction>* out_touch_action);
  void WaitForInputProcessed(
      );

 private:
  WidgetInputHandler* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(WidgetInputHandlerAsyncWaiter);
};


class CONTENT_EXPORT FrameInputHandlerInterceptorForTesting : public FrameInputHandler {
  virtual FrameInputHandler* GetForwardingInterface() = 0;
  void SetCompositionFromExistingText(int32_t start, int32_t end, const std::vector<::ui::ImeTextSpan>& ime_text_spans) override;
  void ExtendSelectionAndDelete(int32_t before, int32_t after) override;
  void DeleteSurroundingText(int32_t before, int32_t after) override;
  void DeleteSurroundingTextInCodePoints(int32_t before, int32_t after) override;
  void SetEditableSelectionOffsets(int32_t start, int32_t end) override;
  void ExecuteEditCommand(const std::string& command, const base::Optional<::base::string16>& value) override;
  void Undo() override;
  void Redo() override;
  void Cut() override;
  void Copy() override;
  void CopyToFindPboard() override;
  void Paste() override;
  void PasteAndMatchStyle() override;
  void Delete() override;
  void SelectAll() override;
  void CollapseSelection() override;
  void Replace(const ::base::string16& word) override;
  void ReplaceMisspelling(const ::base::string16& word) override;
  void SelectRange(const ::gfx::Point& base, const ::gfx::Point& extent) override;
  void AdjustSelectionByCharacterOffset(int32_t start, int32_t end, ::blink::mojom::SelectionMenuBehavior behavior) override;
  void SelectWordAroundCaret(SelectWordAroundCaretCallback callback) override;
  void MoveRangeSelectionExtent(const ::gfx::Point& extent) override;
  void ScrollFocusedEditableNodeIntoRect(const ::gfx::Rect& rect) override;
  void MoveCaret(const ::gfx::Point& point) override;
  void GetWidgetInputHandler(mojo::PendingAssociatedReceiver<WidgetInputHandler> interface_request, mojo::PendingRemote<WidgetInputHandlerHost> host) override;
};
class CONTENT_EXPORT FrameInputHandlerAsyncWaiter {
 public:
  explicit FrameInputHandlerAsyncWaiter(FrameInputHandler* proxy);
  ~FrameInputHandlerAsyncWaiter();
  void SelectWordAroundCaret(
      bool* out_did_select, int32_t* out_start_adjust, int32_t* out_end_adjust);

 private:
  FrameInputHandler* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(FrameInputHandlerAsyncWaiter);
};




}  // namespace mojom
}  // namespace content

#endif  // CONTENT_COMMON_INPUT_INPUT_HANDLER_MOJOM_TEST_UTILS_H_