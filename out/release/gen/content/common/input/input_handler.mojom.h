// content/common/input/input_handler.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CONTENT_COMMON_INPUT_INPUT_HANDLER_MOJOM_H_
#define CONTENT_COMMON_INPUT_INPUT_HANDLER_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "base/callback.h"
#include "base/macros.h"
#include "base/optional.h"

#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#if BUILDFLAG(MOJO_TRACE_ENABLED)
#include "base/trace_event/trace_event.h"
#endif
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"
#include "content/common/input/input_handler.mojom-shared.h"
#include "content/common/input/input_handler.mojom-forward.h"
#include "cc/mojom/touch_action.mojom.h"
#include "content/common/input/synchronous_compositor.mojom.h"
#include "content/common/native_types.mojom.h"
#include "mojo/public/mojom/base/string16.mojom.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "third_party/blink/public/mojom/selection_menu/selection_menu_behavior.mojom.h"
#include "ui/base/ime/mojom/ime_types.mojom.h"
#include "ui/events/mojom/event.mojom.h"
#include "ui/events/mojom/event_constants.mojom.h"
#include "ui/events/mojom/scroll_granularity.mojom.h"
#include "ui/gfx/geometry/mojom/geometry.mojom.h"
#include "ui/gfx/range/mojom/range.mojom.h"
#include "ui/latency/mojom/latency_info.mojom.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/associated_interface_ptr.h"
#include "mojo/public/cpp/bindings/associated_interface_ptr_info.h"
#include "mojo/public/cpp/bindings/associated_interface_request.h"
#include "mojo/public/cpp/bindings/interface_ptr.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"
#include "mojo/public/cpp/bindings/thread_safe_interface_ptr.h"


#include "mojo/public/cpp/bindings/lib/native_enum_serialization.h"
#include "mojo/public/cpp/bindings/lib/native_struct_serialization.h"
#include "cc/input/touch_action.h"
#include "content/common/content_security_policy/csp_context.h"
#include "content/common/cursors/webcursor.h"
#include "content/common/edit_command.h"
#include "content/common/frame_owner_properties.h"
#include "content/common/frame_replication_state.h"
#include "content/common/input/input_event.h"
#include "content/common/input/synthetic_pinch_gesture_params.h"
#include "content/common/input/synthetic_pointer_action_list_params.h"
#include "content/common/input/synthetic_smooth_drag_gesture_params.h"
#include "content/common/input/synthetic_smooth_scroll_gesture_params.h"
#include "content/common/input/synthetic_tap_gesture_params.h"
#include "content/common/visual_properties.h"
#include "content/public/common/input_event_ack_source.h"
#include "content/public/common/input_event_ack_state.h"
#include "content/public/common/web_preferences.h"
#include "net/base/network_change_notifier.h"
#include "third_party/blink/public/common/input/web_gesture_device.h"
#include "third_party/blink/public/common/input/web_gesture_event.h"
#include "third_party/blink/public/common/input/web_input_event.h"
#include "third_party/blink/public/common/input/web_mouse_wheel_event.h"
#include "third_party/blink/public/common/input/web_pointer_properties.h"
#include "third_party/blink/public/common/input/web_touch_point.h"
#include "ui/events/blink/did_overscroll_params.h"
#include "ui/events/blink/web_input_event_traits.h"
#include "ui/latency/ipc/latency_info_param_traits.h"
#include "ui/native_theme/native_theme.h"
#include "content/common/content_export.h"




namespace content {
namespace mojom {

class WidgetInputHandlerHostProxy;

template <typename ImplRefTraits>
class WidgetInputHandlerHostStub;

class WidgetInputHandlerHostRequestValidator;


class CONTENT_EXPORT WidgetInputHandlerHost
    : public WidgetInputHandlerHostInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = WidgetInputHandlerHostInterfaceBase;
  using Proxy_ = WidgetInputHandlerHostProxy;

  template <typename ImplRefTraits>
  using Stub_ = WidgetInputHandlerHostStub<ImplRefTraits>;

  using RequestValidator_ = WidgetInputHandlerHostRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kFallbackCursorModeLockCursorMinVersion = 0,
    kFallbackCursorModeSetCursorVisibilityMinVersion = 0,
    kSetTouchActionFromMainMinVersion = 0,
    kSetWhiteListedTouchActionMinVersion = 0,
    kDidOverscrollMinVersion = 0,
    kDidStartScrollingViewportMinVersion = 0,
    kImeCancelCompositionMinVersion = 0,
    kImeCompositionRangeChangedMinVersion = 0,
    kSetMouseCaptureMinVersion = 0,
  };
  virtual ~WidgetInputHandlerHost() {}

  
  virtual void FallbackCursorModeLockCursor(bool left, bool right, bool up, bool down) = 0;

  
  virtual void FallbackCursorModeSetCursorVisibility(bool visible) = 0;

  
  virtual void SetTouchActionFromMain(::cc::TouchAction touch_action) = 0;

  
  virtual void SetWhiteListedTouchAction(::cc::TouchAction touch_action, uint32_t unique_touch_event_id, ::content::InputEventAckState state) = 0;

  
  virtual void DidOverscroll(const ::ui::DidOverscrollParams& params) = 0;

  
  virtual void DidStartScrollingViewport() = 0;

  
  virtual void ImeCancelComposition() = 0;

  
  virtual void ImeCompositionRangeChanged(const ::gfx::Range& range, const std::vector<::gfx::Rect>& bounds) = 0;

  
  virtual void SetMouseCapture(bool capture) = 0;
};

class WidgetInputHandlerProxy;

template <typename ImplRefTraits>
class WidgetInputHandlerStub;

class WidgetInputHandlerRequestValidator;
class WidgetInputHandlerResponseValidator;


class CONTENT_EXPORT WidgetInputHandler
    : public WidgetInputHandlerInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = true;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = WidgetInputHandlerInterfaceBase;
  using Proxy_ = WidgetInputHandlerProxy;

  template <typename ImplRefTraits>
  using Stub_ = WidgetInputHandlerStub<ImplRefTraits>;

  using RequestValidator_ = WidgetInputHandlerRequestValidator;
  using ResponseValidator_ = WidgetInputHandlerResponseValidator;
  enum MethodMinVersions : uint32_t {
    kSetFocusMinVersion = 0,
    kMouseCaptureLostMinVersion = 0,
    kSetEditCommandsForNextKeyEventMinVersion = 0,
    kCursorVisibilityChangedMinVersion = 0,
    kFallbackCursorModeToggledMinVersion = 0,
    kImeSetCompositionMinVersion = 0,
    kImeCommitTextMinVersion = 0,
    kImeFinishComposingTextMinVersion = 0,
    kRequestTextInputStateUpdateMinVersion = 0,
    kRequestCompositionUpdatesMinVersion = 0,
    kDispatchEventMinVersion = 0,
    kDispatchNonBlockingEventMinVersion = 0,
    kWaitForInputProcessedMinVersion = 0,
    kAttachSynchronousCompositorMinVersion = 0,
  };
  virtual ~WidgetInputHandler() {}

  
  virtual void SetFocus(bool focused) = 0;

  
  virtual void MouseCaptureLost() = 0;

  
  virtual void SetEditCommandsForNextKeyEvent(const std::vector<::content::EditCommand>& commands) = 0;

  
  virtual void CursorVisibilityChanged(bool visible) = 0;

  
  virtual void FallbackCursorModeToggled(bool is_on) = 0;

  
  virtual void ImeSetComposition(const ::base::string16& text, const std::vector<::ui::ImeTextSpan>& ime_text_spans, const ::gfx::Range& range, int32_t start, int32_t end) = 0;


  using ImeCommitTextCallback = base::OnceCallback<void()>;
  
  virtual void ImeCommitText(const ::base::string16& text, const std::vector<::ui::ImeTextSpan>& ime_text_spans, const ::gfx::Range& range, int32_t relative_cursor_position, ImeCommitTextCallback callback) = 0;

  
  virtual void ImeFinishComposingText(bool keep_selection) = 0;

  
  virtual void RequestTextInputStateUpdate() = 0;

  
  virtual void RequestCompositionUpdates(bool immediate_request, bool monitor_request) = 0;


  using DispatchEventCallback = base::OnceCallback<void(::content::InputEventAckSource, const ::ui::LatencyInfo&, ::content::InputEventAckState, const base::Optional<::ui::DidOverscrollParams>&, const base::Optional<::cc::TouchAction>&)>;
  
  virtual void DispatchEvent(::std::unique_ptr<::content::InputEvent> event, DispatchEventCallback callback) = 0;

  
  virtual void DispatchNonBlockingEvent(::std::unique_ptr<::content::InputEvent> event) = 0;


  using WaitForInputProcessedCallback = base::OnceCallback<void()>;
  
  virtual void WaitForInputProcessed(WaitForInputProcessedCallback callback) = 0;

  
  virtual void AttachSynchronousCompositor(mojo::PendingRemote<::content::mojom::SynchronousCompositorControlHost> control_host, mojo::PendingAssociatedRemote<::content::mojom::SynchronousCompositorHost> host, mojo::PendingAssociatedReceiver<::content::mojom::SynchronousCompositor> compositor_request) = 0;
};

class FrameInputHandlerProxy;

template <typename ImplRefTraits>
class FrameInputHandlerStub;

class FrameInputHandlerRequestValidator;
class FrameInputHandlerResponseValidator;


class CONTENT_EXPORT FrameInputHandler
    : public FrameInputHandlerInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = true;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = FrameInputHandlerInterfaceBase;
  using Proxy_ = FrameInputHandlerProxy;

  template <typename ImplRefTraits>
  using Stub_ = FrameInputHandlerStub<ImplRefTraits>;

  using RequestValidator_ = FrameInputHandlerRequestValidator;
  using ResponseValidator_ = FrameInputHandlerResponseValidator;
  enum MethodMinVersions : uint32_t {
    kSetCompositionFromExistingTextMinVersion = 0,
    kExtendSelectionAndDeleteMinVersion = 0,
    kDeleteSurroundingTextMinVersion = 0,
    kDeleteSurroundingTextInCodePointsMinVersion = 0,
    kSetEditableSelectionOffsetsMinVersion = 0,
    kExecuteEditCommandMinVersion = 0,
    kUndoMinVersion = 0,
    kRedoMinVersion = 0,
    kCutMinVersion = 0,
    kCopyMinVersion = 0,
    kCopyToFindPboardMinVersion = 0,
    kPasteMinVersion = 0,
    kPasteAndMatchStyleMinVersion = 0,
    kDeleteMinVersion = 0,
    kSelectAllMinVersion = 0,
    kCollapseSelectionMinVersion = 0,
    kReplaceMinVersion = 0,
    kReplaceMisspellingMinVersion = 0,
    kSelectRangeMinVersion = 0,
    kAdjustSelectionByCharacterOffsetMinVersion = 0,
    kSelectWordAroundCaretMinVersion = 0,
    kMoveRangeSelectionExtentMinVersion = 0,
    kScrollFocusedEditableNodeIntoRectMinVersion = 0,
    kMoveCaretMinVersion = 0,
    kGetWidgetInputHandlerMinVersion = 0,
  };
  virtual ~FrameInputHandler() {}

  
  virtual void SetCompositionFromExistingText(int32_t start, int32_t end, const std::vector<::ui::ImeTextSpan>& ime_text_spans) = 0;

  
  virtual void ExtendSelectionAndDelete(int32_t before, int32_t after) = 0;

  
  virtual void DeleteSurroundingText(int32_t before, int32_t after) = 0;

  
  virtual void DeleteSurroundingTextInCodePoints(int32_t before, int32_t after) = 0;

  
  virtual void SetEditableSelectionOffsets(int32_t start, int32_t end) = 0;

  
  virtual void ExecuteEditCommand(const std::string& command, const base::Optional<::base::string16>& value) = 0;

  
  virtual void Undo() = 0;

  
  virtual void Redo() = 0;

  
  virtual void Cut() = 0;

  
  virtual void Copy() = 0;

  
  virtual void CopyToFindPboard() = 0;

  
  virtual void Paste() = 0;

  
  virtual void PasteAndMatchStyle() = 0;

  
  virtual void Delete() = 0;

  
  virtual void SelectAll() = 0;

  
  virtual void CollapseSelection() = 0;

  
  virtual void Replace(const ::base::string16& word) = 0;

  
  virtual void ReplaceMisspelling(const ::base::string16& word) = 0;

  
  virtual void SelectRange(const ::gfx::Point& base, const ::gfx::Point& extent) = 0;

  
  virtual void AdjustSelectionByCharacterOffset(int32_t start, int32_t end, ::blink::mojom::SelectionMenuBehavior behavior) = 0;


  using SelectWordAroundCaretCallback = base::OnceCallback<void(bool, int32_t, int32_t)>;
  
  virtual void SelectWordAroundCaret(SelectWordAroundCaretCallback callback) = 0;

  
  virtual void MoveRangeSelectionExtent(const ::gfx::Point& extent) = 0;

  
  virtual void ScrollFocusedEditableNodeIntoRect(const ::gfx::Rect& rect) = 0;

  
  virtual void MoveCaret(const ::gfx::Point& point) = 0;

  
  virtual void GetWidgetInputHandler(mojo::PendingAssociatedReceiver<WidgetInputHandler> interface_request, mojo::PendingRemote<WidgetInputHandlerHost> host) = 0;
};



class CONTENT_EXPORT WidgetInputHandlerHostProxy
    : public WidgetInputHandlerHost {
 public:
  using InterfaceType = WidgetInputHandlerHost;

  explicit WidgetInputHandlerHostProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void FallbackCursorModeLockCursor(bool left, bool right, bool up, bool down) final;
  
  void FallbackCursorModeSetCursorVisibility(bool visible) final;
  
  void SetTouchActionFromMain(::cc::TouchAction touch_action) final;
  
  void SetWhiteListedTouchAction(::cc::TouchAction touch_action, uint32_t unique_touch_event_id, ::content::InputEventAckState state) final;
  
  void DidOverscroll(const ::ui::DidOverscrollParams& params) final;
  
  void DidStartScrollingViewport() final;
  
  void ImeCancelComposition() final;
  
  void ImeCompositionRangeChanged(const ::gfx::Range& range, const std::vector<::gfx::Rect>& bounds) final;
  
  void SetMouseCapture(bool capture) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class CONTENT_EXPORT WidgetInputHandlerProxy
    : public WidgetInputHandler {
 public:
  using InterfaceType = WidgetInputHandler;

  explicit WidgetInputHandlerProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void SetFocus(bool focused) final;
  
  void MouseCaptureLost() final;
  
  void SetEditCommandsForNextKeyEvent(const std::vector<::content::EditCommand>& commands) final;
  
  void CursorVisibilityChanged(bool visible) final;
  
  void FallbackCursorModeToggled(bool is_on) final;
  
  void ImeSetComposition(const ::base::string16& text, const std::vector<::ui::ImeTextSpan>& ime_text_spans, const ::gfx::Range& range, int32_t start, int32_t end) final;
  
  void ImeCommitText(const ::base::string16& text, const std::vector<::ui::ImeTextSpan>& ime_text_spans, const ::gfx::Range& range, int32_t relative_cursor_position, ImeCommitTextCallback callback) final;
  
  void ImeFinishComposingText(bool keep_selection) final;
  
  void RequestTextInputStateUpdate() final;
  
  void RequestCompositionUpdates(bool immediate_request, bool monitor_request) final;
  
  void DispatchEvent(::std::unique_ptr<::content::InputEvent> event, DispatchEventCallback callback) final;
  
  void DispatchNonBlockingEvent(::std::unique_ptr<::content::InputEvent> event) final;
  
  void WaitForInputProcessed(WaitForInputProcessedCallback callback) final;
  
  void AttachSynchronousCompositor(mojo::PendingRemote<::content::mojom::SynchronousCompositorControlHost> control_host, mojo::PendingAssociatedRemote<::content::mojom::SynchronousCompositorHost> host, mojo::PendingAssociatedReceiver<::content::mojom::SynchronousCompositor> compositor_request) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class CONTENT_EXPORT FrameInputHandlerProxy
    : public FrameInputHandler {
 public:
  using InterfaceType = FrameInputHandler;

  explicit FrameInputHandlerProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void SetCompositionFromExistingText(int32_t start, int32_t end, const std::vector<::ui::ImeTextSpan>& ime_text_spans) final;
  
  void ExtendSelectionAndDelete(int32_t before, int32_t after) final;
  
  void DeleteSurroundingText(int32_t before, int32_t after) final;
  
  void DeleteSurroundingTextInCodePoints(int32_t before, int32_t after) final;
  
  void SetEditableSelectionOffsets(int32_t start, int32_t end) final;
  
  void ExecuteEditCommand(const std::string& command, const base::Optional<::base::string16>& value) final;
  
  void Undo() final;
  
  void Redo() final;
  
  void Cut() final;
  
  void Copy() final;
  
  void CopyToFindPboard() final;
  
  void Paste() final;
  
  void PasteAndMatchStyle() final;
  
  void Delete() final;
  
  void SelectAll() final;
  
  void CollapseSelection() final;
  
  void Replace(const ::base::string16& word) final;
  
  void ReplaceMisspelling(const ::base::string16& word) final;
  
  void SelectRange(const ::gfx::Point& base, const ::gfx::Point& extent) final;
  
  void AdjustSelectionByCharacterOffset(int32_t start, int32_t end, ::blink::mojom::SelectionMenuBehavior behavior) final;
  
  void SelectWordAroundCaret(SelectWordAroundCaretCallback callback) final;
  
  void MoveRangeSelectionExtent(const ::gfx::Point& extent) final;
  
  void ScrollFocusedEditableNodeIntoRect(const ::gfx::Rect& rect) final;
  
  void MoveCaret(const ::gfx::Point& point) final;
  
  void GetWidgetInputHandler(mojo::PendingAssociatedReceiver<WidgetInputHandler> interface_request, mojo::PendingRemote<WidgetInputHandlerHost> host) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class CONTENT_EXPORT WidgetInputHandlerHostStubDispatch {
 public:
  static bool Accept(WidgetInputHandlerHost* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      WidgetInputHandlerHost* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<WidgetInputHandlerHost>>
class WidgetInputHandlerHostStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  WidgetInputHandlerHostStub() {}
  ~WidgetInputHandlerHostStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return WidgetInputHandlerHostStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return WidgetInputHandlerHostStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class CONTENT_EXPORT WidgetInputHandlerStubDispatch {
 public:
  static bool Accept(WidgetInputHandler* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      WidgetInputHandler* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<WidgetInputHandler>>
class WidgetInputHandlerStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  WidgetInputHandlerStub() {}
  ~WidgetInputHandlerStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return WidgetInputHandlerStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return WidgetInputHandlerStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class CONTENT_EXPORT FrameInputHandlerStubDispatch {
 public:
  static bool Accept(FrameInputHandler* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      FrameInputHandler* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<FrameInputHandler>>
class FrameInputHandlerStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  FrameInputHandlerStub() {}
  ~FrameInputHandlerStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return FrameInputHandlerStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return FrameInputHandlerStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class CONTENT_EXPORT WidgetInputHandlerHostRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class CONTENT_EXPORT WidgetInputHandlerRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class CONTENT_EXPORT FrameInputHandlerRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class CONTENT_EXPORT WidgetInputHandlerResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class CONTENT_EXPORT FrameInputHandlerResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};









class CONTENT_EXPORT ScrollUpdate {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ScrollUpdate, T>::value>;
  using DataView = ScrollUpdateDataView;
  using Data_ = internal::ScrollUpdate_Data;

  template <typename... Args>
  static ScrollUpdatePtr New(Args&&... args) {
    return ScrollUpdatePtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ScrollUpdatePtr From(const U& u) {
    return mojo::TypeConverter<ScrollUpdatePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ScrollUpdate>::Convert(*this);
  }


  ScrollUpdate();

  ScrollUpdate(
      float velocity_x,
      float velocity_y);

  ~ScrollUpdate();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ScrollUpdatePtr>
  ScrollUpdatePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ScrollUpdate::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;
  size_t Hash(size_t seed) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ScrollUpdate::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ScrollUpdate::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ScrollUpdate_UnserializedMessageContext<
            UserType, ScrollUpdate::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<ScrollUpdate::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ScrollUpdate::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ScrollUpdate_UnserializedMessageContext<
            UserType, ScrollUpdate::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ScrollUpdate::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  float velocity_x;
  
  float velocity_y;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ScrollUpdate::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ScrollUpdate::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ScrollUpdate::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ScrollUpdate::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class CONTENT_EXPORT PinchBeginData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PinchBeginData, T>::value>;
  using DataView = PinchBeginDataDataView;
  using Data_ = internal::PinchBeginData_Data;

  template <typename... Args>
  static PinchBeginDataPtr New(Args&&... args) {
    return PinchBeginDataPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PinchBeginDataPtr From(const U& u) {
    return mojo::TypeConverter<PinchBeginDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PinchBeginData>::Convert(*this);
  }


  PinchBeginData();

  explicit PinchBeginData(
      bool needs_wheel_event);

  ~PinchBeginData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PinchBeginDataPtr>
  PinchBeginDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PinchBeginData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;
  size_t Hash(size_t seed) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PinchBeginData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PinchBeginData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PinchBeginData_UnserializedMessageContext<
            UserType, PinchBeginData::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<PinchBeginData::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return PinchBeginData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PinchBeginData_UnserializedMessageContext<
            UserType, PinchBeginData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PinchBeginData::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  bool needs_wheel_event;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PinchBeginData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PinchBeginData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PinchBeginData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PinchBeginData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class CONTENT_EXPORT PinchUpdateData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PinchUpdateData, T>::value>;
  using DataView = PinchUpdateDataDataView;
  using Data_ = internal::PinchUpdateData_Data;

  template <typename... Args>
  static PinchUpdateDataPtr New(Args&&... args) {
    return PinchUpdateDataPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PinchUpdateDataPtr From(const U& u) {
    return mojo::TypeConverter<PinchUpdateDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PinchUpdateData>::Convert(*this);
  }


  PinchUpdateData();

  PinchUpdateData(
      float scale,
      bool zoom_disabled,
      bool needs_wheel_event);

  ~PinchUpdateData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PinchUpdateDataPtr>
  PinchUpdateDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PinchUpdateData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;
  size_t Hash(size_t seed) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PinchUpdateData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PinchUpdateData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PinchUpdateData_UnserializedMessageContext<
            UserType, PinchUpdateData::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<PinchUpdateData::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return PinchUpdateData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PinchUpdateData_UnserializedMessageContext<
            UserType, PinchUpdateData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PinchUpdateData::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  float scale;
  
  bool zoom_disabled;
  
  bool needs_wheel_event;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PinchUpdateData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PinchUpdateData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PinchUpdateData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PinchUpdateData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class CONTENT_EXPORT PinchEndData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PinchEndData, T>::value>;
  using DataView = PinchEndDataDataView;
  using Data_ = internal::PinchEndData_Data;

  template <typename... Args>
  static PinchEndDataPtr New(Args&&... args) {
    return PinchEndDataPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PinchEndDataPtr From(const U& u) {
    return mojo::TypeConverter<PinchEndDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PinchEndData>::Convert(*this);
  }


  PinchEndData();

  explicit PinchEndData(
      bool needs_wheel_event);

  ~PinchEndData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PinchEndDataPtr>
  PinchEndDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PinchEndData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;
  size_t Hash(size_t seed) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PinchEndData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PinchEndData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PinchEndData_UnserializedMessageContext<
            UserType, PinchEndData::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<PinchEndData::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return PinchEndData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PinchEndData_UnserializedMessageContext<
            UserType, PinchEndData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PinchEndData::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  bool needs_wheel_event;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PinchEndData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PinchEndData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PinchEndData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PinchEndData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class CONTENT_EXPORT FlingData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<FlingData, T>::value>;
  using DataView = FlingDataDataView;
  using Data_ = internal::FlingData_Data;

  template <typename... Args>
  static FlingDataPtr New(Args&&... args) {
    return FlingDataPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static FlingDataPtr From(const U& u) {
    return mojo::TypeConverter<FlingDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, FlingData>::Convert(*this);
  }


  FlingData();

  FlingData(
      float velocity_x,
      float velocity_y,
      bool target_viewport,
      bool prevent_boosting);

  ~FlingData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = FlingDataPtr>
  FlingDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, FlingData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;
  size_t Hash(size_t seed) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        FlingData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        FlingData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::FlingData_UnserializedMessageContext<
            UserType, FlingData::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<FlingData::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return FlingData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::FlingData_UnserializedMessageContext<
            UserType, FlingData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<FlingData::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  float velocity_x;
  
  float velocity_y;
  
  bool target_viewport;
  
  bool prevent_boosting;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FlingData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, FlingData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, FlingData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, FlingData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class CONTENT_EXPORT TapData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<TapData, T>::value>;
  using DataView = TapDataDataView;
  using Data_ = internal::TapData_Data;

  template <typename... Args>
  static TapDataPtr New(Args&&... args) {
    return TapDataPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static TapDataPtr From(const U& u) {
    return mojo::TypeConverter<TapDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, TapData>::Convert(*this);
  }


  TapData();

  TapData(
      int32_t tap_count,
      bool needs_wheel_event);

  ~TapData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = TapDataPtr>
  TapDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, TapData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;
  size_t Hash(size_t seed) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        TapData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        TapData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::TapData_UnserializedMessageContext<
            UserType, TapData::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<TapData::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return TapData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::TapData_UnserializedMessageContext<
            UserType, TapData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<TapData::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  int32_t tap_count;
  
  bool needs_wheel_event;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, TapData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, TapData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, TapData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, TapData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}









class CONTENT_EXPORT TouchActionOptional {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<TouchActionOptional, T>::value>;
  using DataView = TouchActionOptionalDataView;
  using Data_ = internal::TouchActionOptional_Data;

  template <typename... Args>
  static TouchActionOptionalPtr New(Args&&... args) {
    return TouchActionOptionalPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static TouchActionOptionalPtr From(const U& u) {
    return mojo::TypeConverter<TouchActionOptionalPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, TouchActionOptional>::Convert(*this);
  }


  TouchActionOptional();

  explicit TouchActionOptional(
      ::cc::TouchAction touch_action);

  ~TouchActionOptional();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = TouchActionOptionalPtr>
  TouchActionOptionalPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, TouchActionOptional::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        TouchActionOptional::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        TouchActionOptional::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::TouchActionOptional_UnserializedMessageContext<
            UserType, TouchActionOptional::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<TouchActionOptional::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return TouchActionOptional::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::TouchActionOptional_UnserializedMessageContext<
            UserType, TouchActionOptional::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<TouchActionOptional::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::cc::TouchAction touch_action;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, TouchActionOptional::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, TouchActionOptional::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, TouchActionOptional::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, TouchActionOptional::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}







class CONTENT_EXPORT KeyData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<KeyData, T>::value>;
  using DataView = KeyDataDataView;
  using Data_ = internal::KeyData_Data;

  template <typename... Args>
  static KeyDataPtr New(Args&&... args) {
    return KeyDataPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static KeyDataPtr From(const U& u) {
    return mojo::TypeConverter<KeyDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, KeyData>::Convert(*this);
  }


  KeyData();

  KeyData(
      int32_t dom_key,
      int32_t dom_code,
      int32_t windows_key_code,
      int32_t native_key_code,
      bool is_system_key,
      bool is_browser_shortcut,
      const ::base::string16& text,
      const ::base::string16& unmodified_text);

  ~KeyData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = KeyDataPtr>
  KeyDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, KeyData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        KeyData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        KeyData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::KeyData_UnserializedMessageContext<
            UserType, KeyData::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<KeyData::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return KeyData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::KeyData_UnserializedMessageContext<
            UserType, KeyData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<KeyData::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  int32_t dom_key;
  
  int32_t dom_code;
  
  int32_t windows_key_code;
  
  int32_t native_key_code;
  
  bool is_system_key;
  
  bool is_browser_shortcut;
  
  ::base::string16 text;
  
  ::base::string16 unmodified_text;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, KeyData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, KeyData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, KeyData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, KeyData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class CONTENT_EXPORT PointerData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PointerData, T>::value>;
  using DataView = PointerDataDataView;
  using Data_ = internal::PointerData_Data;

  template <typename... Args>
  static PointerDataPtr New(Args&&... args) {
    return PointerDataPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PointerDataPtr From(const U& u) {
    return mojo::TypeConverter<PointerDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PointerData>::Convert(*this);
  }


  PointerData();

  PointerData(
      int32_t pointer_id,
      float force,
      int32_t tilt_x,
      int32_t tilt_y,
      float tangential_pressure,
      int32_t twist,
      ::blink::WebPointerProperties::Button button,
      ::blink::WebPointerProperties::PointerType pointer_type,
      int32_t movement_x,
      int32_t movement_y,
      bool is_raw_movement_event,
      const ::gfx::PointF& widget_position,
      const ::gfx::PointF& screen_position,
      MouseDataPtr mouse_data);

  ~PointerData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PointerDataPtr>
  PointerDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PointerData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PointerData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PointerData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PointerData_UnserializedMessageContext<
            UserType, PointerData::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<PointerData::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return PointerData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PointerData_UnserializedMessageContext<
            UserType, PointerData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PointerData::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  int32_t pointer_id;
  
  float force;
  
  int32_t tilt_x;
  
  int32_t tilt_y;
  
  float tangential_pressure;
  
  int32_t twist;
  
  ::blink::WebPointerProperties::Button button;
  
  ::blink::WebPointerProperties::PointerType pointer_type;
  
  int32_t movement_x;
  
  int32_t movement_y;
  
  bool is_raw_movement_event;
  
  ::gfx::PointF widget_position;
  
  ::gfx::PointF screen_position;
  
  MouseDataPtr mouse_data;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(PointerData);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PointerData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PointerData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PointerData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PointerData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class CONTENT_EXPORT WheelData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<WheelData, T>::value>;
  using DataView = WheelDataDataView;
  using Data_ = internal::WheelData_Data;

  template <typename... Args>
  static WheelDataPtr New(Args&&... args) {
    return WheelDataPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static WheelDataPtr From(const U& u) {
    return mojo::TypeConverter<WheelDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, WheelData>::Convert(*this);
  }


  WheelData();

  WheelData(
      float delta_x,
      float delta_y,
      float wheel_ticks_x,
      float wheel_ticks_y,
      float acceleration_ratio_x,
      float acceleration_ratio_y,
      uint8_t phase,
      uint8_t momentum_phase,
      ::blink::WebInputEvent::DispatchType cancelable,
      uint8_t event_action,
      uint8_t delta_units);

  ~WheelData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = WheelDataPtr>
  WheelDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, WheelData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        WheelData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        WheelData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::WheelData_UnserializedMessageContext<
            UserType, WheelData::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<WheelData::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return WheelData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::WheelData_UnserializedMessageContext<
            UserType, WheelData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<WheelData::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  float delta_x;
  
  float delta_y;
  
  float wheel_ticks_x;
  
  float wheel_ticks_y;
  
  float acceleration_ratio_x;
  
  float acceleration_ratio_y;
  
  uint8_t phase;
  
  uint8_t momentum_phase;
  
  ::blink::WebInputEvent::DispatchType cancelable;
  
  uint8_t event_action;
  
  uint8_t delta_units;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WheelData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, WheelData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, WheelData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, WheelData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class CONTENT_EXPORT MouseData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MouseData, T>::value>;
  using DataView = MouseDataDataView;
  using Data_ = internal::MouseData_Data;

  template <typename... Args>
  static MouseDataPtr New(Args&&... args) {
    return MouseDataPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MouseDataPtr From(const U& u) {
    return mojo::TypeConverter<MouseDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MouseData>::Convert(*this);
  }


  MouseData();

  MouseData(
      int32_t click_count,
      WheelDataPtr wheel_data);

  ~MouseData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MouseDataPtr>
  MouseDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MouseData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        MouseData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MouseData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MouseData_UnserializedMessageContext<
            UserType, MouseData::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<MouseData::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return MouseData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MouseData_UnserializedMessageContext<
            UserType, MouseData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MouseData::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  int32_t click_count;
  
  WheelDataPtr wheel_data;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(MouseData);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MouseData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MouseData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MouseData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MouseData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class CONTENT_EXPORT ScrollData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ScrollData, T>::value>;
  using DataView = ScrollDataDataView;
  using Data_ = internal::ScrollData_Data;

  template <typename... Args>
  static ScrollDataPtr New(Args&&... args) {
    return ScrollDataPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ScrollDataPtr From(const U& u) {
    return mojo::TypeConverter<ScrollDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ScrollData>::Convert(*this);
  }


  ScrollData();

  ScrollData(
      float delta_x,
      float delta_y,
      ::ui::input_types::ScrollGranularity delta_units,
      bool target_viewport,
      ::blink::WebGestureEvent::InertialPhaseState inertial_phase,
      bool synthetic,
      int32_t pointer_count,
      ScrollUpdatePtr update_details);

  ~ScrollData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ScrollDataPtr>
  ScrollDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ScrollData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ScrollData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ScrollData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ScrollData_UnserializedMessageContext<
            UserType, ScrollData::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<ScrollData::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ScrollData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ScrollData_UnserializedMessageContext<
            UserType, ScrollData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ScrollData::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  float delta_x;
  
  float delta_y;
  
  ::ui::input_types::ScrollGranularity delta_units;
  
  bool target_viewport;
  
  ::blink::WebGestureEvent::InertialPhaseState inertial_phase;
  
  bool synthetic;
  
  int32_t pointer_count;
  
  ScrollUpdatePtr update_details;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(ScrollData);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ScrollData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ScrollData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ScrollData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ScrollData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}










class CONTENT_EXPORT GestureData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<GestureData, T>::value>;
  using DataView = GestureDataDataView;
  using Data_ = internal::GestureData_Data;

  template <typename... Args>
  static GestureDataPtr New(Args&&... args) {
    return GestureDataPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static GestureDataPtr From(const U& u) {
    return mojo::TypeConverter<GestureDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, GestureData>::Convert(*this);
  }


  GestureData();

  GestureData(
      const ::gfx::PointF& screen_position,
      const ::gfx::PointF& widget_position,
      ::blink::WebGestureDevice source_device,
      bool is_source_touch_event_set_non_blocking,
      ::blink::WebPointerProperties::PointerType primary_pointer_type,
      int32_t unique_touch_event_id,
      const base::Optional<::gfx::Size>& contact_size,
      ScrollDataPtr scroll_data,
      PinchBeginDataPtr pinch_begin_data,
      PinchUpdateDataPtr pinch_update_data,
      PinchEndDataPtr pinch_end_data,
      TapDataPtr tap_data,
      FlingDataPtr fling_data);

  ~GestureData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = GestureDataPtr>
  GestureDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, GestureData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        GestureData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        GestureData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::GestureData_UnserializedMessageContext<
            UserType, GestureData::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<GestureData::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return GestureData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::GestureData_UnserializedMessageContext<
            UserType, GestureData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<GestureData::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::gfx::PointF screen_position;
  
  ::gfx::PointF widget_position;
  
  ::blink::WebGestureDevice source_device;
  
  bool is_source_touch_event_set_non_blocking;
  
  ::blink::WebPointerProperties::PointerType primary_pointer_type;
  
  int32_t unique_touch_event_id;
  
  base::Optional<::gfx::Size> contact_size;
  
  ScrollDataPtr scroll_data;
  
  PinchBeginDataPtr pinch_begin_data;
  
  PinchUpdateDataPtr pinch_update_data;
  
  PinchEndDataPtr pinch_end_data;
  
  TapDataPtr tap_data;
  
  FlingDataPtr fling_data;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(GestureData);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, GestureData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, GestureData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, GestureData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, GestureData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class CONTENT_EXPORT TouchPoint {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<TouchPoint, T>::value>;
  using DataView = TouchPointDataView;
  using Data_ = internal::TouchPoint_Data;

  template <typename... Args>
  static TouchPointPtr New(Args&&... args) {
    return TouchPointPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static TouchPointPtr From(const U& u) {
    return mojo::TypeConverter<TouchPointPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, TouchPoint>::Convert(*this);
  }


  TouchPoint();

  TouchPoint(
      ::blink::WebTouchPoint::State state,
      float radius_x,
      float radius_y,
      float rotation_angle,
      PointerDataPtr pointer_data);

  ~TouchPoint();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = TouchPointPtr>
  TouchPointPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, TouchPoint::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        TouchPoint::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        TouchPoint::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::TouchPoint_UnserializedMessageContext<
            UserType, TouchPoint::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<TouchPoint::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return TouchPoint::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::TouchPoint_UnserializedMessageContext<
            UserType, TouchPoint::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<TouchPoint::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::blink::WebTouchPoint::State state;
  
  float radius_x;
  
  float radius_y;
  
  float rotation_angle;
  
  PointerDataPtr pointer_data;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(TouchPoint);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, TouchPoint::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, TouchPoint::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, TouchPoint::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, TouchPoint::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class CONTENT_EXPORT TouchData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<TouchData, T>::value>;
  using DataView = TouchDataDataView;
  using Data_ = internal::TouchData_Data;

  template <typename... Args>
  static TouchDataPtr New(Args&&... args) {
    return TouchDataPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static TouchDataPtr From(const U& u) {
    return mojo::TypeConverter<TouchDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, TouchData>::Convert(*this);
  }


  TouchData();

  TouchData(
      ::blink::WebInputEvent::DispatchType cancelable,
      bool moved_beyond_slop_region,
      bool touch_start_or_first_move,
      bool hovering,
      uint32_t unique_touch_event_id,
      std::vector<TouchPointPtr> touches);

  ~TouchData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = TouchDataPtr>
  TouchDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, TouchData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        TouchData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        TouchData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::TouchData_UnserializedMessageContext<
            UserType, TouchData::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<TouchData::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return TouchData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::TouchData_UnserializedMessageContext<
            UserType, TouchData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<TouchData::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::blink::WebInputEvent::DispatchType cancelable;
  
  bool moved_beyond_slop_region;
  
  bool touch_start_or_first_move;
  
  bool hovering;
  
  uint32_t unique_touch_event_id;
  
  std::vector<TouchPointPtr> touches;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(TouchData);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, TouchData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, TouchData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, TouchData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, TouchData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class CONTENT_EXPORT Event {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<Event, T>::value>;
  using DataView = EventDataView;
  using Data_ = internal::Event_Data;

  template <typename... Args>
  static EventPtr New(Args&&... args) {
    return EventPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static EventPtr From(const U& u) {
    return mojo::TypeConverter<EventPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Event>::Convert(*this);
  }


  Event();

  Event(
      ::blink::WebInputEvent::Type type,
      int32_t modifiers,
      ::base::TimeTicks timestamp,
      const ::ui::LatencyInfo& latency,
      KeyDataPtr key_data,
      PointerDataPtr pointer_data,
      GestureDataPtr gesture_data,
      TouchDataPtr touch_data);

  ~Event();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = EventPtr>
  EventPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, Event::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        Event::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        Event::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::Event_UnserializedMessageContext<
            UserType, Event::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<Event::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return Event::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::Event_UnserializedMessageContext<
            UserType, Event::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<Event::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::blink::WebInputEvent::Type type;
  
  int32_t modifiers;
  
  ::base::TimeTicks timestamp;
  
  ::ui::LatencyInfo latency;
  
  KeyDataPtr key_data;
  
  PointerDataPtr pointer_data;
  
  GestureDataPtr gesture_data;
  
  TouchDataPtr touch_data;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(Event);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Event::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, Event::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, Event::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, Event::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}


template <typename StructPtrType>
KeyDataPtr KeyData::Clone() const {
  return New(
      mojo::Clone(dom_key),
      mojo::Clone(dom_code),
      mojo::Clone(windows_key_code),
      mojo::Clone(native_key_code),
      mojo::Clone(is_system_key),
      mojo::Clone(is_browser_shortcut),
      mojo::Clone(text),
      mojo::Clone(unmodified_text)
  );
}

template <typename T, KeyData::EnableIfSame<T>*>
bool KeyData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->dom_key, other_struct.dom_key))
    return false;
  if (!mojo::Equals(this->dom_code, other_struct.dom_code))
    return false;
  if (!mojo::Equals(this->windows_key_code, other_struct.windows_key_code))
    return false;
  if (!mojo::Equals(this->native_key_code, other_struct.native_key_code))
    return false;
  if (!mojo::Equals(this->is_system_key, other_struct.is_system_key))
    return false;
  if (!mojo::Equals(this->is_browser_shortcut, other_struct.is_browser_shortcut))
    return false;
  if (!mojo::Equals(this->text, other_struct.text))
    return false;
  if (!mojo::Equals(this->unmodified_text, other_struct.unmodified_text))
    return false;
  return true;
}

template <typename T, KeyData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.dom_key < rhs.dom_key)
    return true;
  if (rhs.dom_key < lhs.dom_key)
    return false;
  if (lhs.dom_code < rhs.dom_code)
    return true;
  if (rhs.dom_code < lhs.dom_code)
    return false;
  if (lhs.windows_key_code < rhs.windows_key_code)
    return true;
  if (rhs.windows_key_code < lhs.windows_key_code)
    return false;
  if (lhs.native_key_code < rhs.native_key_code)
    return true;
  if (rhs.native_key_code < lhs.native_key_code)
    return false;
  if (lhs.is_system_key < rhs.is_system_key)
    return true;
  if (rhs.is_system_key < lhs.is_system_key)
    return false;
  if (lhs.is_browser_shortcut < rhs.is_browser_shortcut)
    return true;
  if (rhs.is_browser_shortcut < lhs.is_browser_shortcut)
    return false;
  if (lhs.text < rhs.text)
    return true;
  if (rhs.text < lhs.text)
    return false;
  if (lhs.unmodified_text < rhs.unmodified_text)
    return true;
  if (rhs.unmodified_text < lhs.unmodified_text)
    return false;
  return false;
}
template <typename StructPtrType>
PointerDataPtr PointerData::Clone() const {
  return New(
      mojo::Clone(pointer_id),
      mojo::Clone(force),
      mojo::Clone(tilt_x),
      mojo::Clone(tilt_y),
      mojo::Clone(tangential_pressure),
      mojo::Clone(twist),
      mojo::Clone(button),
      mojo::Clone(pointer_type),
      mojo::Clone(movement_x),
      mojo::Clone(movement_y),
      mojo::Clone(is_raw_movement_event),
      mojo::Clone(widget_position),
      mojo::Clone(screen_position),
      mojo::Clone(mouse_data)
  );
}

template <typename T, PointerData::EnableIfSame<T>*>
bool PointerData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->pointer_id, other_struct.pointer_id))
    return false;
  if (!mojo::Equals(this->force, other_struct.force))
    return false;
  if (!mojo::Equals(this->tilt_x, other_struct.tilt_x))
    return false;
  if (!mojo::Equals(this->tilt_y, other_struct.tilt_y))
    return false;
  if (!mojo::Equals(this->tangential_pressure, other_struct.tangential_pressure))
    return false;
  if (!mojo::Equals(this->twist, other_struct.twist))
    return false;
  if (!mojo::Equals(this->button, other_struct.button))
    return false;
  if (!mojo::Equals(this->pointer_type, other_struct.pointer_type))
    return false;
  if (!mojo::Equals(this->movement_x, other_struct.movement_x))
    return false;
  if (!mojo::Equals(this->movement_y, other_struct.movement_y))
    return false;
  if (!mojo::Equals(this->is_raw_movement_event, other_struct.is_raw_movement_event))
    return false;
  if (!mojo::Equals(this->widget_position, other_struct.widget_position))
    return false;
  if (!mojo::Equals(this->screen_position, other_struct.screen_position))
    return false;
  if (!mojo::Equals(this->mouse_data, other_struct.mouse_data))
    return false;
  return true;
}

template <typename T, PointerData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.pointer_id < rhs.pointer_id)
    return true;
  if (rhs.pointer_id < lhs.pointer_id)
    return false;
  if (lhs.force < rhs.force)
    return true;
  if (rhs.force < lhs.force)
    return false;
  if (lhs.tilt_x < rhs.tilt_x)
    return true;
  if (rhs.tilt_x < lhs.tilt_x)
    return false;
  if (lhs.tilt_y < rhs.tilt_y)
    return true;
  if (rhs.tilt_y < lhs.tilt_y)
    return false;
  if (lhs.tangential_pressure < rhs.tangential_pressure)
    return true;
  if (rhs.tangential_pressure < lhs.tangential_pressure)
    return false;
  if (lhs.twist < rhs.twist)
    return true;
  if (rhs.twist < lhs.twist)
    return false;
  if (lhs.button < rhs.button)
    return true;
  if (rhs.button < lhs.button)
    return false;
  if (lhs.pointer_type < rhs.pointer_type)
    return true;
  if (rhs.pointer_type < lhs.pointer_type)
    return false;
  if (lhs.movement_x < rhs.movement_x)
    return true;
  if (rhs.movement_x < lhs.movement_x)
    return false;
  if (lhs.movement_y < rhs.movement_y)
    return true;
  if (rhs.movement_y < lhs.movement_y)
    return false;
  if (lhs.is_raw_movement_event < rhs.is_raw_movement_event)
    return true;
  if (rhs.is_raw_movement_event < lhs.is_raw_movement_event)
    return false;
  if (lhs.widget_position < rhs.widget_position)
    return true;
  if (rhs.widget_position < lhs.widget_position)
    return false;
  if (lhs.screen_position < rhs.screen_position)
    return true;
  if (rhs.screen_position < lhs.screen_position)
    return false;
  if (lhs.mouse_data < rhs.mouse_data)
    return true;
  if (rhs.mouse_data < lhs.mouse_data)
    return false;
  return false;
}
template <typename StructPtrType>
WheelDataPtr WheelData::Clone() const {
  return New(
      mojo::Clone(delta_x),
      mojo::Clone(delta_y),
      mojo::Clone(wheel_ticks_x),
      mojo::Clone(wheel_ticks_y),
      mojo::Clone(acceleration_ratio_x),
      mojo::Clone(acceleration_ratio_y),
      mojo::Clone(phase),
      mojo::Clone(momentum_phase),
      mojo::Clone(cancelable),
      mojo::Clone(event_action),
      mojo::Clone(delta_units)
  );
}

template <typename T, WheelData::EnableIfSame<T>*>
bool WheelData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->delta_x, other_struct.delta_x))
    return false;
  if (!mojo::Equals(this->delta_y, other_struct.delta_y))
    return false;
  if (!mojo::Equals(this->wheel_ticks_x, other_struct.wheel_ticks_x))
    return false;
  if (!mojo::Equals(this->wheel_ticks_y, other_struct.wheel_ticks_y))
    return false;
  if (!mojo::Equals(this->acceleration_ratio_x, other_struct.acceleration_ratio_x))
    return false;
  if (!mojo::Equals(this->acceleration_ratio_y, other_struct.acceleration_ratio_y))
    return false;
  if (!mojo::Equals(this->phase, other_struct.phase))
    return false;
  if (!mojo::Equals(this->momentum_phase, other_struct.momentum_phase))
    return false;
  if (!mojo::Equals(this->cancelable, other_struct.cancelable))
    return false;
  if (!mojo::Equals(this->event_action, other_struct.event_action))
    return false;
  if (!mojo::Equals(this->delta_units, other_struct.delta_units))
    return false;
  return true;
}

template <typename T, WheelData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.delta_x < rhs.delta_x)
    return true;
  if (rhs.delta_x < lhs.delta_x)
    return false;
  if (lhs.delta_y < rhs.delta_y)
    return true;
  if (rhs.delta_y < lhs.delta_y)
    return false;
  if (lhs.wheel_ticks_x < rhs.wheel_ticks_x)
    return true;
  if (rhs.wheel_ticks_x < lhs.wheel_ticks_x)
    return false;
  if (lhs.wheel_ticks_y < rhs.wheel_ticks_y)
    return true;
  if (rhs.wheel_ticks_y < lhs.wheel_ticks_y)
    return false;
  if (lhs.acceleration_ratio_x < rhs.acceleration_ratio_x)
    return true;
  if (rhs.acceleration_ratio_x < lhs.acceleration_ratio_x)
    return false;
  if (lhs.acceleration_ratio_y < rhs.acceleration_ratio_y)
    return true;
  if (rhs.acceleration_ratio_y < lhs.acceleration_ratio_y)
    return false;
  if (lhs.phase < rhs.phase)
    return true;
  if (rhs.phase < lhs.phase)
    return false;
  if (lhs.momentum_phase < rhs.momentum_phase)
    return true;
  if (rhs.momentum_phase < lhs.momentum_phase)
    return false;
  if (lhs.cancelable < rhs.cancelable)
    return true;
  if (rhs.cancelable < lhs.cancelable)
    return false;
  if (lhs.event_action < rhs.event_action)
    return true;
  if (rhs.event_action < lhs.event_action)
    return false;
  if (lhs.delta_units < rhs.delta_units)
    return true;
  if (rhs.delta_units < lhs.delta_units)
    return false;
  return false;
}
template <typename StructPtrType>
MouseDataPtr MouseData::Clone() const {
  return New(
      mojo::Clone(click_count),
      mojo::Clone(wheel_data)
  );
}

template <typename T, MouseData::EnableIfSame<T>*>
bool MouseData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->click_count, other_struct.click_count))
    return false;
  if (!mojo::Equals(this->wheel_data, other_struct.wheel_data))
    return false;
  return true;
}

template <typename T, MouseData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.click_count < rhs.click_count)
    return true;
  if (rhs.click_count < lhs.click_count)
    return false;
  if (lhs.wheel_data < rhs.wheel_data)
    return true;
  if (rhs.wheel_data < lhs.wheel_data)
    return false;
  return false;
}
template <typename StructPtrType>
ScrollUpdatePtr ScrollUpdate::Clone() const {
  return New(
      mojo::Clone(velocity_x),
      mojo::Clone(velocity_y)
  );
}

template <typename T, ScrollUpdate::EnableIfSame<T>*>
bool ScrollUpdate::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->velocity_x, other_struct.velocity_x))
    return false;
  if (!mojo::Equals(this->velocity_y, other_struct.velocity_y))
    return false;
  return true;
}

template <typename T, ScrollUpdate::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.velocity_x < rhs.velocity_x)
    return true;
  if (rhs.velocity_x < lhs.velocity_x)
    return false;
  if (lhs.velocity_y < rhs.velocity_y)
    return true;
  if (rhs.velocity_y < lhs.velocity_y)
    return false;
  return false;
}
template <typename StructPtrType>
ScrollDataPtr ScrollData::Clone() const {
  return New(
      mojo::Clone(delta_x),
      mojo::Clone(delta_y),
      mojo::Clone(delta_units),
      mojo::Clone(target_viewport),
      mojo::Clone(inertial_phase),
      mojo::Clone(synthetic),
      mojo::Clone(pointer_count),
      mojo::Clone(update_details)
  );
}

template <typename T, ScrollData::EnableIfSame<T>*>
bool ScrollData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->delta_x, other_struct.delta_x))
    return false;
  if (!mojo::Equals(this->delta_y, other_struct.delta_y))
    return false;
  if (!mojo::Equals(this->delta_units, other_struct.delta_units))
    return false;
  if (!mojo::Equals(this->target_viewport, other_struct.target_viewport))
    return false;
  if (!mojo::Equals(this->inertial_phase, other_struct.inertial_phase))
    return false;
  if (!mojo::Equals(this->synthetic, other_struct.synthetic))
    return false;
  if (!mojo::Equals(this->pointer_count, other_struct.pointer_count))
    return false;
  if (!mojo::Equals(this->update_details, other_struct.update_details))
    return false;
  return true;
}

template <typename T, ScrollData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.delta_x < rhs.delta_x)
    return true;
  if (rhs.delta_x < lhs.delta_x)
    return false;
  if (lhs.delta_y < rhs.delta_y)
    return true;
  if (rhs.delta_y < lhs.delta_y)
    return false;
  if (lhs.delta_units < rhs.delta_units)
    return true;
  if (rhs.delta_units < lhs.delta_units)
    return false;
  if (lhs.target_viewport < rhs.target_viewport)
    return true;
  if (rhs.target_viewport < lhs.target_viewport)
    return false;
  if (lhs.inertial_phase < rhs.inertial_phase)
    return true;
  if (rhs.inertial_phase < lhs.inertial_phase)
    return false;
  if (lhs.synthetic < rhs.synthetic)
    return true;
  if (rhs.synthetic < lhs.synthetic)
    return false;
  if (lhs.pointer_count < rhs.pointer_count)
    return true;
  if (rhs.pointer_count < lhs.pointer_count)
    return false;
  if (lhs.update_details < rhs.update_details)
    return true;
  if (rhs.update_details < lhs.update_details)
    return false;
  return false;
}
template <typename StructPtrType>
PinchBeginDataPtr PinchBeginData::Clone() const {
  return New(
      mojo::Clone(needs_wheel_event)
  );
}

template <typename T, PinchBeginData::EnableIfSame<T>*>
bool PinchBeginData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->needs_wheel_event, other_struct.needs_wheel_event))
    return false;
  return true;
}

template <typename T, PinchBeginData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.needs_wheel_event < rhs.needs_wheel_event)
    return true;
  if (rhs.needs_wheel_event < lhs.needs_wheel_event)
    return false;
  return false;
}
template <typename StructPtrType>
PinchUpdateDataPtr PinchUpdateData::Clone() const {
  return New(
      mojo::Clone(scale),
      mojo::Clone(zoom_disabled),
      mojo::Clone(needs_wheel_event)
  );
}

template <typename T, PinchUpdateData::EnableIfSame<T>*>
bool PinchUpdateData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->scale, other_struct.scale))
    return false;
  if (!mojo::Equals(this->zoom_disabled, other_struct.zoom_disabled))
    return false;
  if (!mojo::Equals(this->needs_wheel_event, other_struct.needs_wheel_event))
    return false;
  return true;
}

template <typename T, PinchUpdateData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.scale < rhs.scale)
    return true;
  if (rhs.scale < lhs.scale)
    return false;
  if (lhs.zoom_disabled < rhs.zoom_disabled)
    return true;
  if (rhs.zoom_disabled < lhs.zoom_disabled)
    return false;
  if (lhs.needs_wheel_event < rhs.needs_wheel_event)
    return true;
  if (rhs.needs_wheel_event < lhs.needs_wheel_event)
    return false;
  return false;
}
template <typename StructPtrType>
PinchEndDataPtr PinchEndData::Clone() const {
  return New(
      mojo::Clone(needs_wheel_event)
  );
}

template <typename T, PinchEndData::EnableIfSame<T>*>
bool PinchEndData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->needs_wheel_event, other_struct.needs_wheel_event))
    return false;
  return true;
}

template <typename T, PinchEndData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.needs_wheel_event < rhs.needs_wheel_event)
    return true;
  if (rhs.needs_wheel_event < lhs.needs_wheel_event)
    return false;
  return false;
}
template <typename StructPtrType>
FlingDataPtr FlingData::Clone() const {
  return New(
      mojo::Clone(velocity_x),
      mojo::Clone(velocity_y),
      mojo::Clone(target_viewport),
      mojo::Clone(prevent_boosting)
  );
}

template <typename T, FlingData::EnableIfSame<T>*>
bool FlingData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->velocity_x, other_struct.velocity_x))
    return false;
  if (!mojo::Equals(this->velocity_y, other_struct.velocity_y))
    return false;
  if (!mojo::Equals(this->target_viewport, other_struct.target_viewport))
    return false;
  if (!mojo::Equals(this->prevent_boosting, other_struct.prevent_boosting))
    return false;
  return true;
}

template <typename T, FlingData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.velocity_x < rhs.velocity_x)
    return true;
  if (rhs.velocity_x < lhs.velocity_x)
    return false;
  if (lhs.velocity_y < rhs.velocity_y)
    return true;
  if (rhs.velocity_y < lhs.velocity_y)
    return false;
  if (lhs.target_viewport < rhs.target_viewport)
    return true;
  if (rhs.target_viewport < lhs.target_viewport)
    return false;
  if (lhs.prevent_boosting < rhs.prevent_boosting)
    return true;
  if (rhs.prevent_boosting < lhs.prevent_boosting)
    return false;
  return false;
}
template <typename StructPtrType>
TapDataPtr TapData::Clone() const {
  return New(
      mojo::Clone(tap_count),
      mojo::Clone(needs_wheel_event)
  );
}

template <typename T, TapData::EnableIfSame<T>*>
bool TapData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->tap_count, other_struct.tap_count))
    return false;
  if (!mojo::Equals(this->needs_wheel_event, other_struct.needs_wheel_event))
    return false;
  return true;
}

template <typename T, TapData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.tap_count < rhs.tap_count)
    return true;
  if (rhs.tap_count < lhs.tap_count)
    return false;
  if (lhs.needs_wheel_event < rhs.needs_wheel_event)
    return true;
  if (rhs.needs_wheel_event < lhs.needs_wheel_event)
    return false;
  return false;
}
template <typename StructPtrType>
GestureDataPtr GestureData::Clone() const {
  return New(
      mojo::Clone(screen_position),
      mojo::Clone(widget_position),
      mojo::Clone(source_device),
      mojo::Clone(is_source_touch_event_set_non_blocking),
      mojo::Clone(primary_pointer_type),
      mojo::Clone(unique_touch_event_id),
      mojo::Clone(contact_size),
      mojo::Clone(scroll_data),
      mojo::Clone(pinch_begin_data),
      mojo::Clone(pinch_update_data),
      mojo::Clone(pinch_end_data),
      mojo::Clone(tap_data),
      mojo::Clone(fling_data)
  );
}

template <typename T, GestureData::EnableIfSame<T>*>
bool GestureData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->screen_position, other_struct.screen_position))
    return false;
  if (!mojo::Equals(this->widget_position, other_struct.widget_position))
    return false;
  if (!mojo::Equals(this->source_device, other_struct.source_device))
    return false;
  if (!mojo::Equals(this->is_source_touch_event_set_non_blocking, other_struct.is_source_touch_event_set_non_blocking))
    return false;
  if (!mojo::Equals(this->primary_pointer_type, other_struct.primary_pointer_type))
    return false;
  if (!mojo::Equals(this->unique_touch_event_id, other_struct.unique_touch_event_id))
    return false;
  if (!mojo::Equals(this->contact_size, other_struct.contact_size))
    return false;
  if (!mojo::Equals(this->scroll_data, other_struct.scroll_data))
    return false;
  if (!mojo::Equals(this->pinch_begin_data, other_struct.pinch_begin_data))
    return false;
  if (!mojo::Equals(this->pinch_update_data, other_struct.pinch_update_data))
    return false;
  if (!mojo::Equals(this->pinch_end_data, other_struct.pinch_end_data))
    return false;
  if (!mojo::Equals(this->tap_data, other_struct.tap_data))
    return false;
  if (!mojo::Equals(this->fling_data, other_struct.fling_data))
    return false;
  return true;
}

template <typename T, GestureData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.screen_position < rhs.screen_position)
    return true;
  if (rhs.screen_position < lhs.screen_position)
    return false;
  if (lhs.widget_position < rhs.widget_position)
    return true;
  if (rhs.widget_position < lhs.widget_position)
    return false;
  if (lhs.source_device < rhs.source_device)
    return true;
  if (rhs.source_device < lhs.source_device)
    return false;
  if (lhs.is_source_touch_event_set_non_blocking < rhs.is_source_touch_event_set_non_blocking)
    return true;
  if (rhs.is_source_touch_event_set_non_blocking < lhs.is_source_touch_event_set_non_blocking)
    return false;
  if (lhs.primary_pointer_type < rhs.primary_pointer_type)
    return true;
  if (rhs.primary_pointer_type < lhs.primary_pointer_type)
    return false;
  if (lhs.unique_touch_event_id < rhs.unique_touch_event_id)
    return true;
  if (rhs.unique_touch_event_id < lhs.unique_touch_event_id)
    return false;
  if (lhs.contact_size < rhs.contact_size)
    return true;
  if (rhs.contact_size < lhs.contact_size)
    return false;
  if (lhs.scroll_data < rhs.scroll_data)
    return true;
  if (rhs.scroll_data < lhs.scroll_data)
    return false;
  if (lhs.pinch_begin_data < rhs.pinch_begin_data)
    return true;
  if (rhs.pinch_begin_data < lhs.pinch_begin_data)
    return false;
  if (lhs.pinch_update_data < rhs.pinch_update_data)
    return true;
  if (rhs.pinch_update_data < lhs.pinch_update_data)
    return false;
  if (lhs.pinch_end_data < rhs.pinch_end_data)
    return true;
  if (rhs.pinch_end_data < lhs.pinch_end_data)
    return false;
  if (lhs.tap_data < rhs.tap_data)
    return true;
  if (rhs.tap_data < lhs.tap_data)
    return false;
  if (lhs.fling_data < rhs.fling_data)
    return true;
  if (rhs.fling_data < lhs.fling_data)
    return false;
  return false;
}
template <typename StructPtrType>
TouchPointPtr TouchPoint::Clone() const {
  return New(
      mojo::Clone(state),
      mojo::Clone(radius_x),
      mojo::Clone(radius_y),
      mojo::Clone(rotation_angle),
      mojo::Clone(pointer_data)
  );
}

template <typename T, TouchPoint::EnableIfSame<T>*>
bool TouchPoint::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->state, other_struct.state))
    return false;
  if (!mojo::Equals(this->radius_x, other_struct.radius_x))
    return false;
  if (!mojo::Equals(this->radius_y, other_struct.radius_y))
    return false;
  if (!mojo::Equals(this->rotation_angle, other_struct.rotation_angle))
    return false;
  if (!mojo::Equals(this->pointer_data, other_struct.pointer_data))
    return false;
  return true;
}

template <typename T, TouchPoint::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.state < rhs.state)
    return true;
  if (rhs.state < lhs.state)
    return false;
  if (lhs.radius_x < rhs.radius_x)
    return true;
  if (rhs.radius_x < lhs.radius_x)
    return false;
  if (lhs.radius_y < rhs.radius_y)
    return true;
  if (rhs.radius_y < lhs.radius_y)
    return false;
  if (lhs.rotation_angle < rhs.rotation_angle)
    return true;
  if (rhs.rotation_angle < lhs.rotation_angle)
    return false;
  if (lhs.pointer_data < rhs.pointer_data)
    return true;
  if (rhs.pointer_data < lhs.pointer_data)
    return false;
  return false;
}
template <typename StructPtrType>
TouchDataPtr TouchData::Clone() const {
  return New(
      mojo::Clone(cancelable),
      mojo::Clone(moved_beyond_slop_region),
      mojo::Clone(touch_start_or_first_move),
      mojo::Clone(hovering),
      mojo::Clone(unique_touch_event_id),
      mojo::Clone(touches)
  );
}

template <typename T, TouchData::EnableIfSame<T>*>
bool TouchData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->cancelable, other_struct.cancelable))
    return false;
  if (!mojo::Equals(this->moved_beyond_slop_region, other_struct.moved_beyond_slop_region))
    return false;
  if (!mojo::Equals(this->touch_start_or_first_move, other_struct.touch_start_or_first_move))
    return false;
  if (!mojo::Equals(this->hovering, other_struct.hovering))
    return false;
  if (!mojo::Equals(this->unique_touch_event_id, other_struct.unique_touch_event_id))
    return false;
  if (!mojo::Equals(this->touches, other_struct.touches))
    return false;
  return true;
}

template <typename T, TouchData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.cancelable < rhs.cancelable)
    return true;
  if (rhs.cancelable < lhs.cancelable)
    return false;
  if (lhs.moved_beyond_slop_region < rhs.moved_beyond_slop_region)
    return true;
  if (rhs.moved_beyond_slop_region < lhs.moved_beyond_slop_region)
    return false;
  if (lhs.touch_start_or_first_move < rhs.touch_start_or_first_move)
    return true;
  if (rhs.touch_start_or_first_move < lhs.touch_start_or_first_move)
    return false;
  if (lhs.hovering < rhs.hovering)
    return true;
  if (rhs.hovering < lhs.hovering)
    return false;
  if (lhs.unique_touch_event_id < rhs.unique_touch_event_id)
    return true;
  if (rhs.unique_touch_event_id < lhs.unique_touch_event_id)
    return false;
  if (lhs.touches < rhs.touches)
    return true;
  if (rhs.touches < lhs.touches)
    return false;
  return false;
}
template <typename StructPtrType>
EventPtr Event::Clone() const {
  return New(
      mojo::Clone(type),
      mojo::Clone(modifiers),
      mojo::Clone(timestamp),
      mojo::Clone(latency),
      mojo::Clone(key_data),
      mojo::Clone(pointer_data),
      mojo::Clone(gesture_data),
      mojo::Clone(touch_data)
  );
}

template <typename T, Event::EnableIfSame<T>*>
bool Event::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->type, other_struct.type))
    return false;
  if (!mojo::Equals(this->modifiers, other_struct.modifiers))
    return false;
  if (!mojo::Equals(this->timestamp, other_struct.timestamp))
    return false;
  if (!mojo::Equals(this->latency, other_struct.latency))
    return false;
  if (!mojo::Equals(this->key_data, other_struct.key_data))
    return false;
  if (!mojo::Equals(this->pointer_data, other_struct.pointer_data))
    return false;
  if (!mojo::Equals(this->gesture_data, other_struct.gesture_data))
    return false;
  if (!mojo::Equals(this->touch_data, other_struct.touch_data))
    return false;
  return true;
}

template <typename T, Event::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.type < rhs.type)
    return true;
  if (rhs.type < lhs.type)
    return false;
  if (lhs.modifiers < rhs.modifiers)
    return true;
  if (rhs.modifiers < lhs.modifiers)
    return false;
  if (lhs.timestamp < rhs.timestamp)
    return true;
  if (rhs.timestamp < lhs.timestamp)
    return false;
  if (lhs.latency < rhs.latency)
    return true;
  if (rhs.latency < lhs.latency)
    return false;
  if (lhs.key_data < rhs.key_data)
    return true;
  if (rhs.key_data < lhs.key_data)
    return false;
  if (lhs.pointer_data < rhs.pointer_data)
    return true;
  if (rhs.pointer_data < lhs.pointer_data)
    return false;
  if (lhs.gesture_data < rhs.gesture_data)
    return true;
  if (rhs.gesture_data < lhs.gesture_data)
    return false;
  if (lhs.touch_data < rhs.touch_data)
    return true;
  if (rhs.touch_data < lhs.touch_data)
    return false;
  return false;
}
template <typename StructPtrType>
TouchActionOptionalPtr TouchActionOptional::Clone() const {
  return New(
      mojo::Clone(touch_action)
  );
}

template <typename T, TouchActionOptional::EnableIfSame<T>*>
bool TouchActionOptional::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->touch_action, other_struct.touch_action))
    return false;
  return true;
}

template <typename T, TouchActionOptional::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.touch_action < rhs.touch_action)
    return true;
  if (rhs.touch_action < lhs.touch_action)
    return false;
  return false;
}


}  // namespace mojom
}  // namespace content

namespace mojo {


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::KeyData::DataView,
                                         ::content::mojom::KeyDataPtr> {
  static bool IsNull(const ::content::mojom::KeyDataPtr& input) { return !input; }
  static void SetToNull(::content::mojom::KeyDataPtr* output) { output->reset(); }

  static decltype(::content::mojom::KeyData::dom_key) dom_key(
      const ::content::mojom::KeyDataPtr& input) {
    return input->dom_key;
  }

  static decltype(::content::mojom::KeyData::dom_code) dom_code(
      const ::content::mojom::KeyDataPtr& input) {
    return input->dom_code;
  }

  static decltype(::content::mojom::KeyData::windows_key_code) windows_key_code(
      const ::content::mojom::KeyDataPtr& input) {
    return input->windows_key_code;
  }

  static decltype(::content::mojom::KeyData::native_key_code) native_key_code(
      const ::content::mojom::KeyDataPtr& input) {
    return input->native_key_code;
  }

  static decltype(::content::mojom::KeyData::is_system_key) is_system_key(
      const ::content::mojom::KeyDataPtr& input) {
    return input->is_system_key;
  }

  static decltype(::content::mojom::KeyData::is_browser_shortcut) is_browser_shortcut(
      const ::content::mojom::KeyDataPtr& input) {
    return input->is_browser_shortcut;
  }

  static const decltype(::content::mojom::KeyData::text)& text(
      const ::content::mojom::KeyDataPtr& input) {
    return input->text;
  }

  static const decltype(::content::mojom::KeyData::unmodified_text)& unmodified_text(
      const ::content::mojom::KeyDataPtr& input) {
    return input->unmodified_text;
  }

  static bool Read(::content::mojom::KeyData::DataView input, ::content::mojom::KeyDataPtr* output);
};


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::PointerData::DataView,
                                         ::content::mojom::PointerDataPtr> {
  static bool IsNull(const ::content::mojom::PointerDataPtr& input) { return !input; }
  static void SetToNull(::content::mojom::PointerDataPtr* output) { output->reset(); }

  static decltype(::content::mojom::PointerData::pointer_id) pointer_id(
      const ::content::mojom::PointerDataPtr& input) {
    return input->pointer_id;
  }

  static decltype(::content::mojom::PointerData::force) force(
      const ::content::mojom::PointerDataPtr& input) {
    return input->force;
  }

  static decltype(::content::mojom::PointerData::tilt_x) tilt_x(
      const ::content::mojom::PointerDataPtr& input) {
    return input->tilt_x;
  }

  static decltype(::content::mojom::PointerData::tilt_y) tilt_y(
      const ::content::mojom::PointerDataPtr& input) {
    return input->tilt_y;
  }

  static decltype(::content::mojom::PointerData::tangential_pressure) tangential_pressure(
      const ::content::mojom::PointerDataPtr& input) {
    return input->tangential_pressure;
  }

  static decltype(::content::mojom::PointerData::twist) twist(
      const ::content::mojom::PointerDataPtr& input) {
    return input->twist;
  }

  static decltype(::content::mojom::PointerData::button) button(
      const ::content::mojom::PointerDataPtr& input) {
    return input->button;
  }

  static decltype(::content::mojom::PointerData::pointer_type) pointer_type(
      const ::content::mojom::PointerDataPtr& input) {
    return input->pointer_type;
  }

  static decltype(::content::mojom::PointerData::movement_x) movement_x(
      const ::content::mojom::PointerDataPtr& input) {
    return input->movement_x;
  }

  static decltype(::content::mojom::PointerData::movement_y) movement_y(
      const ::content::mojom::PointerDataPtr& input) {
    return input->movement_y;
  }

  static decltype(::content::mojom::PointerData::is_raw_movement_event) is_raw_movement_event(
      const ::content::mojom::PointerDataPtr& input) {
    return input->is_raw_movement_event;
  }

  static const decltype(::content::mojom::PointerData::widget_position)& widget_position(
      const ::content::mojom::PointerDataPtr& input) {
    return input->widget_position;
  }

  static const decltype(::content::mojom::PointerData::screen_position)& screen_position(
      const ::content::mojom::PointerDataPtr& input) {
    return input->screen_position;
  }

  static const decltype(::content::mojom::PointerData::mouse_data)& mouse_data(
      const ::content::mojom::PointerDataPtr& input) {
    return input->mouse_data;
  }

  static bool Read(::content::mojom::PointerData::DataView input, ::content::mojom::PointerDataPtr* output);
};


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::WheelData::DataView,
                                         ::content::mojom::WheelDataPtr> {
  static bool IsNull(const ::content::mojom::WheelDataPtr& input) { return !input; }
  static void SetToNull(::content::mojom::WheelDataPtr* output) { output->reset(); }

  static decltype(::content::mojom::WheelData::delta_x) delta_x(
      const ::content::mojom::WheelDataPtr& input) {
    return input->delta_x;
  }

  static decltype(::content::mojom::WheelData::delta_y) delta_y(
      const ::content::mojom::WheelDataPtr& input) {
    return input->delta_y;
  }

  static decltype(::content::mojom::WheelData::wheel_ticks_x) wheel_ticks_x(
      const ::content::mojom::WheelDataPtr& input) {
    return input->wheel_ticks_x;
  }

  static decltype(::content::mojom::WheelData::wheel_ticks_y) wheel_ticks_y(
      const ::content::mojom::WheelDataPtr& input) {
    return input->wheel_ticks_y;
  }

  static decltype(::content::mojom::WheelData::acceleration_ratio_x) acceleration_ratio_x(
      const ::content::mojom::WheelDataPtr& input) {
    return input->acceleration_ratio_x;
  }

  static decltype(::content::mojom::WheelData::acceleration_ratio_y) acceleration_ratio_y(
      const ::content::mojom::WheelDataPtr& input) {
    return input->acceleration_ratio_y;
  }

  static decltype(::content::mojom::WheelData::phase) phase(
      const ::content::mojom::WheelDataPtr& input) {
    return input->phase;
  }

  static decltype(::content::mojom::WheelData::momentum_phase) momentum_phase(
      const ::content::mojom::WheelDataPtr& input) {
    return input->momentum_phase;
  }

  static decltype(::content::mojom::WheelData::cancelable) cancelable(
      const ::content::mojom::WheelDataPtr& input) {
    return input->cancelable;
  }

  static decltype(::content::mojom::WheelData::event_action) event_action(
      const ::content::mojom::WheelDataPtr& input) {
    return input->event_action;
  }

  static decltype(::content::mojom::WheelData::delta_units) delta_units(
      const ::content::mojom::WheelDataPtr& input) {
    return input->delta_units;
  }

  static bool Read(::content::mojom::WheelData::DataView input, ::content::mojom::WheelDataPtr* output);
};


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::MouseData::DataView,
                                         ::content::mojom::MouseDataPtr> {
  static bool IsNull(const ::content::mojom::MouseDataPtr& input) { return !input; }
  static void SetToNull(::content::mojom::MouseDataPtr* output) { output->reset(); }

  static decltype(::content::mojom::MouseData::click_count) click_count(
      const ::content::mojom::MouseDataPtr& input) {
    return input->click_count;
  }

  static const decltype(::content::mojom::MouseData::wheel_data)& wheel_data(
      const ::content::mojom::MouseDataPtr& input) {
    return input->wheel_data;
  }

  static bool Read(::content::mojom::MouseData::DataView input, ::content::mojom::MouseDataPtr* output);
};


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::ScrollUpdate::DataView,
                                         ::content::mojom::ScrollUpdatePtr> {
  static bool IsNull(const ::content::mojom::ScrollUpdatePtr& input) { return !input; }
  static void SetToNull(::content::mojom::ScrollUpdatePtr* output) { output->reset(); }

  static decltype(::content::mojom::ScrollUpdate::velocity_x) velocity_x(
      const ::content::mojom::ScrollUpdatePtr& input) {
    return input->velocity_x;
  }

  static decltype(::content::mojom::ScrollUpdate::velocity_y) velocity_y(
      const ::content::mojom::ScrollUpdatePtr& input) {
    return input->velocity_y;
  }

  static bool Read(::content::mojom::ScrollUpdate::DataView input, ::content::mojom::ScrollUpdatePtr* output);
};


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::ScrollData::DataView,
                                         ::content::mojom::ScrollDataPtr> {
  static bool IsNull(const ::content::mojom::ScrollDataPtr& input) { return !input; }
  static void SetToNull(::content::mojom::ScrollDataPtr* output) { output->reset(); }

  static decltype(::content::mojom::ScrollData::delta_x) delta_x(
      const ::content::mojom::ScrollDataPtr& input) {
    return input->delta_x;
  }

  static decltype(::content::mojom::ScrollData::delta_y) delta_y(
      const ::content::mojom::ScrollDataPtr& input) {
    return input->delta_y;
  }

  static decltype(::content::mojom::ScrollData::delta_units) delta_units(
      const ::content::mojom::ScrollDataPtr& input) {
    return input->delta_units;
  }

  static decltype(::content::mojom::ScrollData::target_viewport) target_viewport(
      const ::content::mojom::ScrollDataPtr& input) {
    return input->target_viewport;
  }

  static decltype(::content::mojom::ScrollData::inertial_phase) inertial_phase(
      const ::content::mojom::ScrollDataPtr& input) {
    return input->inertial_phase;
  }

  static decltype(::content::mojom::ScrollData::synthetic) synthetic(
      const ::content::mojom::ScrollDataPtr& input) {
    return input->synthetic;
  }

  static decltype(::content::mojom::ScrollData::pointer_count) pointer_count(
      const ::content::mojom::ScrollDataPtr& input) {
    return input->pointer_count;
  }

  static const decltype(::content::mojom::ScrollData::update_details)& update_details(
      const ::content::mojom::ScrollDataPtr& input) {
    return input->update_details;
  }

  static bool Read(::content::mojom::ScrollData::DataView input, ::content::mojom::ScrollDataPtr* output);
};


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::PinchBeginData::DataView,
                                         ::content::mojom::PinchBeginDataPtr> {
  static bool IsNull(const ::content::mojom::PinchBeginDataPtr& input) { return !input; }
  static void SetToNull(::content::mojom::PinchBeginDataPtr* output) { output->reset(); }

  static decltype(::content::mojom::PinchBeginData::needs_wheel_event) needs_wheel_event(
      const ::content::mojom::PinchBeginDataPtr& input) {
    return input->needs_wheel_event;
  }

  static bool Read(::content::mojom::PinchBeginData::DataView input, ::content::mojom::PinchBeginDataPtr* output);
};


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::PinchUpdateData::DataView,
                                         ::content::mojom::PinchUpdateDataPtr> {
  static bool IsNull(const ::content::mojom::PinchUpdateDataPtr& input) { return !input; }
  static void SetToNull(::content::mojom::PinchUpdateDataPtr* output) { output->reset(); }

  static decltype(::content::mojom::PinchUpdateData::scale) scale(
      const ::content::mojom::PinchUpdateDataPtr& input) {
    return input->scale;
  }

  static decltype(::content::mojom::PinchUpdateData::zoom_disabled) zoom_disabled(
      const ::content::mojom::PinchUpdateDataPtr& input) {
    return input->zoom_disabled;
  }

  static decltype(::content::mojom::PinchUpdateData::needs_wheel_event) needs_wheel_event(
      const ::content::mojom::PinchUpdateDataPtr& input) {
    return input->needs_wheel_event;
  }

  static bool Read(::content::mojom::PinchUpdateData::DataView input, ::content::mojom::PinchUpdateDataPtr* output);
};


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::PinchEndData::DataView,
                                         ::content::mojom::PinchEndDataPtr> {
  static bool IsNull(const ::content::mojom::PinchEndDataPtr& input) { return !input; }
  static void SetToNull(::content::mojom::PinchEndDataPtr* output) { output->reset(); }

  static decltype(::content::mojom::PinchEndData::needs_wheel_event) needs_wheel_event(
      const ::content::mojom::PinchEndDataPtr& input) {
    return input->needs_wheel_event;
  }

  static bool Read(::content::mojom::PinchEndData::DataView input, ::content::mojom::PinchEndDataPtr* output);
};


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::FlingData::DataView,
                                         ::content::mojom::FlingDataPtr> {
  static bool IsNull(const ::content::mojom::FlingDataPtr& input) { return !input; }
  static void SetToNull(::content::mojom::FlingDataPtr* output) { output->reset(); }

  static decltype(::content::mojom::FlingData::velocity_x) velocity_x(
      const ::content::mojom::FlingDataPtr& input) {
    return input->velocity_x;
  }

  static decltype(::content::mojom::FlingData::velocity_y) velocity_y(
      const ::content::mojom::FlingDataPtr& input) {
    return input->velocity_y;
  }

  static decltype(::content::mojom::FlingData::target_viewport) target_viewport(
      const ::content::mojom::FlingDataPtr& input) {
    return input->target_viewport;
  }

  static decltype(::content::mojom::FlingData::prevent_boosting) prevent_boosting(
      const ::content::mojom::FlingDataPtr& input) {
    return input->prevent_boosting;
  }

  static bool Read(::content::mojom::FlingData::DataView input, ::content::mojom::FlingDataPtr* output);
};


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::TapData::DataView,
                                         ::content::mojom::TapDataPtr> {
  static bool IsNull(const ::content::mojom::TapDataPtr& input) { return !input; }
  static void SetToNull(::content::mojom::TapDataPtr* output) { output->reset(); }

  static decltype(::content::mojom::TapData::tap_count) tap_count(
      const ::content::mojom::TapDataPtr& input) {
    return input->tap_count;
  }

  static decltype(::content::mojom::TapData::needs_wheel_event) needs_wheel_event(
      const ::content::mojom::TapDataPtr& input) {
    return input->needs_wheel_event;
  }

  static bool Read(::content::mojom::TapData::DataView input, ::content::mojom::TapDataPtr* output);
};


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::GestureData::DataView,
                                         ::content::mojom::GestureDataPtr> {
  static bool IsNull(const ::content::mojom::GestureDataPtr& input) { return !input; }
  static void SetToNull(::content::mojom::GestureDataPtr* output) { output->reset(); }

  static const decltype(::content::mojom::GestureData::screen_position)& screen_position(
      const ::content::mojom::GestureDataPtr& input) {
    return input->screen_position;
  }

  static const decltype(::content::mojom::GestureData::widget_position)& widget_position(
      const ::content::mojom::GestureDataPtr& input) {
    return input->widget_position;
  }

  static decltype(::content::mojom::GestureData::source_device) source_device(
      const ::content::mojom::GestureDataPtr& input) {
    return input->source_device;
  }

  static decltype(::content::mojom::GestureData::is_source_touch_event_set_non_blocking) is_source_touch_event_set_non_blocking(
      const ::content::mojom::GestureDataPtr& input) {
    return input->is_source_touch_event_set_non_blocking;
  }

  static decltype(::content::mojom::GestureData::primary_pointer_type) primary_pointer_type(
      const ::content::mojom::GestureDataPtr& input) {
    return input->primary_pointer_type;
  }

  static decltype(::content::mojom::GestureData::unique_touch_event_id) unique_touch_event_id(
      const ::content::mojom::GestureDataPtr& input) {
    return input->unique_touch_event_id;
  }

  static const decltype(::content::mojom::GestureData::contact_size)& contact_size(
      const ::content::mojom::GestureDataPtr& input) {
    return input->contact_size;
  }

  static const decltype(::content::mojom::GestureData::scroll_data)& scroll_data(
      const ::content::mojom::GestureDataPtr& input) {
    return input->scroll_data;
  }

  static const decltype(::content::mojom::GestureData::pinch_begin_data)& pinch_begin_data(
      const ::content::mojom::GestureDataPtr& input) {
    return input->pinch_begin_data;
  }

  static const decltype(::content::mojom::GestureData::pinch_update_data)& pinch_update_data(
      const ::content::mojom::GestureDataPtr& input) {
    return input->pinch_update_data;
  }

  static const decltype(::content::mojom::GestureData::pinch_end_data)& pinch_end_data(
      const ::content::mojom::GestureDataPtr& input) {
    return input->pinch_end_data;
  }

  static const decltype(::content::mojom::GestureData::tap_data)& tap_data(
      const ::content::mojom::GestureDataPtr& input) {
    return input->tap_data;
  }

  static const decltype(::content::mojom::GestureData::fling_data)& fling_data(
      const ::content::mojom::GestureDataPtr& input) {
    return input->fling_data;
  }

  static bool Read(::content::mojom::GestureData::DataView input, ::content::mojom::GestureDataPtr* output);
};


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::TouchPoint::DataView,
                                         ::content::mojom::TouchPointPtr> {
  static bool IsNull(const ::content::mojom::TouchPointPtr& input) { return !input; }
  static void SetToNull(::content::mojom::TouchPointPtr* output) { output->reset(); }

  static decltype(::content::mojom::TouchPoint::state) state(
      const ::content::mojom::TouchPointPtr& input) {
    return input->state;
  }

  static decltype(::content::mojom::TouchPoint::radius_x) radius_x(
      const ::content::mojom::TouchPointPtr& input) {
    return input->radius_x;
  }

  static decltype(::content::mojom::TouchPoint::radius_y) radius_y(
      const ::content::mojom::TouchPointPtr& input) {
    return input->radius_y;
  }

  static decltype(::content::mojom::TouchPoint::rotation_angle) rotation_angle(
      const ::content::mojom::TouchPointPtr& input) {
    return input->rotation_angle;
  }

  static const decltype(::content::mojom::TouchPoint::pointer_data)& pointer_data(
      const ::content::mojom::TouchPointPtr& input) {
    return input->pointer_data;
  }

  static bool Read(::content::mojom::TouchPoint::DataView input, ::content::mojom::TouchPointPtr* output);
};


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::TouchData::DataView,
                                         ::content::mojom::TouchDataPtr> {
  static bool IsNull(const ::content::mojom::TouchDataPtr& input) { return !input; }
  static void SetToNull(::content::mojom::TouchDataPtr* output) { output->reset(); }

  static decltype(::content::mojom::TouchData::cancelable) cancelable(
      const ::content::mojom::TouchDataPtr& input) {
    return input->cancelable;
  }

  static decltype(::content::mojom::TouchData::moved_beyond_slop_region) moved_beyond_slop_region(
      const ::content::mojom::TouchDataPtr& input) {
    return input->moved_beyond_slop_region;
  }

  static decltype(::content::mojom::TouchData::touch_start_or_first_move) touch_start_or_first_move(
      const ::content::mojom::TouchDataPtr& input) {
    return input->touch_start_or_first_move;
  }

  static decltype(::content::mojom::TouchData::hovering) hovering(
      const ::content::mojom::TouchDataPtr& input) {
    return input->hovering;
  }

  static decltype(::content::mojom::TouchData::unique_touch_event_id) unique_touch_event_id(
      const ::content::mojom::TouchDataPtr& input) {
    return input->unique_touch_event_id;
  }

  static const decltype(::content::mojom::TouchData::touches)& touches(
      const ::content::mojom::TouchDataPtr& input) {
    return input->touches;
  }

  static bool Read(::content::mojom::TouchData::DataView input, ::content::mojom::TouchDataPtr* output);
};


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::Event::DataView,
                                         ::content::mojom::EventPtr> {
  static bool IsNull(const ::content::mojom::EventPtr& input) { return !input; }
  static void SetToNull(::content::mojom::EventPtr* output) { output->reset(); }

  static decltype(::content::mojom::Event::type) type(
      const ::content::mojom::EventPtr& input) {
    return input->type;
  }

  static decltype(::content::mojom::Event::modifiers) modifiers(
      const ::content::mojom::EventPtr& input) {
    return input->modifiers;
  }

  static const decltype(::content::mojom::Event::timestamp)& timestamp(
      const ::content::mojom::EventPtr& input) {
    return input->timestamp;
  }

  static const decltype(::content::mojom::Event::latency)& latency(
      const ::content::mojom::EventPtr& input) {
    return input->latency;
  }

  static const decltype(::content::mojom::Event::key_data)& key_data(
      const ::content::mojom::EventPtr& input) {
    return input->key_data;
  }

  static const decltype(::content::mojom::Event::pointer_data)& pointer_data(
      const ::content::mojom::EventPtr& input) {
    return input->pointer_data;
  }

  static const decltype(::content::mojom::Event::gesture_data)& gesture_data(
      const ::content::mojom::EventPtr& input) {
    return input->gesture_data;
  }

  static const decltype(::content::mojom::Event::touch_data)& touch_data(
      const ::content::mojom::EventPtr& input) {
    return input->touch_data;
  }

  static bool Read(::content::mojom::Event::DataView input, ::content::mojom::EventPtr* output);
};


template <>
struct CONTENT_EXPORT StructTraits<::content::mojom::TouchActionOptional::DataView,
                                         ::content::mojom::TouchActionOptionalPtr> {
  static bool IsNull(const ::content::mojom::TouchActionOptionalPtr& input) { return !input; }
  static void SetToNull(::content::mojom::TouchActionOptionalPtr* output) { output->reset(); }

  static decltype(::content::mojom::TouchActionOptional::touch_action) touch_action(
      const ::content::mojom::TouchActionOptionalPtr& input) {
    return input->touch_action;
  }

  static bool Read(::content::mojom::TouchActionOptional::DataView input, ::content::mojom::TouchActionOptionalPtr* output);
};

}  // namespace mojo

#endif  // CONTENT_COMMON_INPUT_INPUT_HANDLER_MOJOM_H_