// content/common/input/input_handler.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif

#include "content/common/input/input_handler.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/hash/md5_constexpr.h"
#include "base/logging.h"
#include "base/run_loop.h"
#include "base/task/common/task_annotator.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_context.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"

#include "content/common/input/input_handler.mojom-params-data.h"
#include "content/common/input/input_handler.mojom-shared-message-ids.h"

#include "content/common/input/input_handler.mojom-import-headers.h"


#ifndef CONTENT_COMMON_INPUT_INPUT_HANDLER_MOJOM_JUMBO_H_
#define CONTENT_COMMON_INPUT_INPUT_HANDLER_MOJOM_JUMBO_H_
#include "cc/ipc/cc_param_traits_macros.h"
#include "content/common/frame_messages.h"
#include "content/common/input/input_event_mojom_traits.h"
#include "content/common/input/touch_action_optional_mojom_traits.h"
#include "content/common/input_messages.h"
#include "content/common/view_messages.h"
#include "content/common/widget_messages.h"
#include "content/public/common/common_param_traits.h"
#include "mojo/public/cpp/base/string16_mojom_traits.h"
#include "mojo/public/cpp/base/time_mojom_traits.h"
#include "services/network/public/cpp/p2p_param_traits.h"
#include "ui/base/ime/mojom/ime_types_mojom_traits.h"
#include "ui/events/ipc/ui_events_param_traits_macros.h"
#include "ui/gfx/geometry/mojom/geometry_mojom_traits.h"
#include "ui/gfx/range/mojom/range_mojom_traits.h"
#include "ui/latency/mojom/latency_info_mojom_traits.h"
#endif
namespace content {
namespace mojom {
KeyData::KeyData()
    : dom_key(),
      dom_code(),
      windows_key_code(),
      native_key_code(),
      is_system_key(),
      is_browser_shortcut(),
      text(),
      unmodified_text() {}

KeyData::KeyData(
    int32_t dom_key_in,
    int32_t dom_code_in,
    int32_t windows_key_code_in,
    int32_t native_key_code_in,
    bool is_system_key_in,
    bool is_browser_shortcut_in,
    const ::base::string16& text_in,
    const ::base::string16& unmodified_text_in)
    : dom_key(std::move(dom_key_in)),
      dom_code(std::move(dom_code_in)),
      windows_key_code(std::move(windows_key_code_in)),
      native_key_code(std::move(native_key_code_in)),
      is_system_key(std::move(is_system_key_in)),
      is_browser_shortcut(std::move(is_browser_shortcut_in)),
      text(std::move(text_in)),
      unmodified_text(std::move(unmodified_text_in)) {}

KeyData::~KeyData() = default;

bool KeyData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
PointerData::PointerData()
    : pointer_id(),
      force(),
      tilt_x(),
      tilt_y(),
      tangential_pressure(),
      twist(),
      button(),
      pointer_type(),
      movement_x(),
      movement_y(),
      is_raw_movement_event(),
      widget_position(),
      screen_position(),
      mouse_data() {}

PointerData::PointerData(
    int32_t pointer_id_in,
    float force_in,
    int32_t tilt_x_in,
    int32_t tilt_y_in,
    float tangential_pressure_in,
    int32_t twist_in,
    ::blink::WebPointerProperties::Button button_in,
    ::blink::WebPointerProperties::PointerType pointer_type_in,
    int32_t movement_x_in,
    int32_t movement_y_in,
    bool is_raw_movement_event_in,
    const ::gfx::PointF& widget_position_in,
    const ::gfx::PointF& screen_position_in,
    MouseDataPtr mouse_data_in)
    : pointer_id(std::move(pointer_id_in)),
      force(std::move(force_in)),
      tilt_x(std::move(tilt_x_in)),
      tilt_y(std::move(tilt_y_in)),
      tangential_pressure(std::move(tangential_pressure_in)),
      twist(std::move(twist_in)),
      button(std::move(button_in)),
      pointer_type(std::move(pointer_type_in)),
      movement_x(std::move(movement_x_in)),
      movement_y(std::move(movement_y_in)),
      is_raw_movement_event(std::move(is_raw_movement_event_in)),
      widget_position(std::move(widget_position_in)),
      screen_position(std::move(screen_position_in)),
      mouse_data(std::move(mouse_data_in)) {}

PointerData::~PointerData() = default;

bool PointerData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
WheelData::WheelData()
    : delta_x(),
      delta_y(),
      wheel_ticks_x(),
      wheel_ticks_y(),
      acceleration_ratio_x(),
      acceleration_ratio_y(),
      phase(),
      momentum_phase(),
      cancelable(),
      event_action(),
      delta_units() {}

WheelData::WheelData(
    float delta_x_in,
    float delta_y_in,
    float wheel_ticks_x_in,
    float wheel_ticks_y_in,
    float acceleration_ratio_x_in,
    float acceleration_ratio_y_in,
    uint8_t phase_in,
    uint8_t momentum_phase_in,
    ::blink::WebInputEvent::DispatchType cancelable_in,
    uint8_t event_action_in,
    uint8_t delta_units_in)
    : delta_x(std::move(delta_x_in)),
      delta_y(std::move(delta_y_in)),
      wheel_ticks_x(std::move(wheel_ticks_x_in)),
      wheel_ticks_y(std::move(wheel_ticks_y_in)),
      acceleration_ratio_x(std::move(acceleration_ratio_x_in)),
      acceleration_ratio_y(std::move(acceleration_ratio_y_in)),
      phase(std::move(phase_in)),
      momentum_phase(std::move(momentum_phase_in)),
      cancelable(std::move(cancelable_in)),
      event_action(std::move(event_action_in)),
      delta_units(std::move(delta_units_in)) {}

WheelData::~WheelData() = default;

bool WheelData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
MouseData::MouseData()
    : click_count(),
      wheel_data() {}

MouseData::MouseData(
    int32_t click_count_in,
    WheelDataPtr wheel_data_in)
    : click_count(std::move(click_count_in)),
      wheel_data(std::move(wheel_data_in)) {}

MouseData::~MouseData() = default;

bool MouseData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ScrollUpdate::ScrollUpdate()
    : velocity_x(),
      velocity_y() {}

ScrollUpdate::ScrollUpdate(
    float velocity_x_in,
    float velocity_y_in)
    : velocity_x(std::move(velocity_x_in)),
      velocity_y(std::move(velocity_y_in)) {}

ScrollUpdate::~ScrollUpdate() = default;
size_t ScrollUpdate::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->velocity_x);
  seed = mojo::internal::Hash(seed, this->velocity_y);
  return seed;
}

bool ScrollUpdate::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ScrollData::ScrollData()
    : delta_x(),
      delta_y(),
      delta_units(),
      target_viewport(),
      inertial_phase(),
      synthetic(),
      pointer_count(),
      update_details() {}

ScrollData::ScrollData(
    float delta_x_in,
    float delta_y_in,
    ::ui::input_types::ScrollGranularity delta_units_in,
    bool target_viewport_in,
    ::blink::WebGestureEvent::InertialPhaseState inertial_phase_in,
    bool synthetic_in,
    int32_t pointer_count_in,
    ScrollUpdatePtr update_details_in)
    : delta_x(std::move(delta_x_in)),
      delta_y(std::move(delta_y_in)),
      delta_units(std::move(delta_units_in)),
      target_viewport(std::move(target_viewport_in)),
      inertial_phase(std::move(inertial_phase_in)),
      synthetic(std::move(synthetic_in)),
      pointer_count(std::move(pointer_count_in)),
      update_details(std::move(update_details_in)) {}

ScrollData::~ScrollData() = default;

bool ScrollData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
PinchBeginData::PinchBeginData()
    : needs_wheel_event() {}

PinchBeginData::PinchBeginData(
    bool needs_wheel_event_in)
    : needs_wheel_event(std::move(needs_wheel_event_in)) {}

PinchBeginData::~PinchBeginData() = default;
size_t PinchBeginData::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->needs_wheel_event);
  return seed;
}

bool PinchBeginData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
PinchUpdateData::PinchUpdateData()
    : scale(),
      zoom_disabled(),
      needs_wheel_event() {}

PinchUpdateData::PinchUpdateData(
    float scale_in,
    bool zoom_disabled_in,
    bool needs_wheel_event_in)
    : scale(std::move(scale_in)),
      zoom_disabled(std::move(zoom_disabled_in)),
      needs_wheel_event(std::move(needs_wheel_event_in)) {}

PinchUpdateData::~PinchUpdateData() = default;
size_t PinchUpdateData::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->scale);
  seed = mojo::internal::Hash(seed, this->zoom_disabled);
  seed = mojo::internal::Hash(seed, this->needs_wheel_event);
  return seed;
}

bool PinchUpdateData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
PinchEndData::PinchEndData()
    : needs_wheel_event() {}

PinchEndData::PinchEndData(
    bool needs_wheel_event_in)
    : needs_wheel_event(std::move(needs_wheel_event_in)) {}

PinchEndData::~PinchEndData() = default;
size_t PinchEndData::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->needs_wheel_event);
  return seed;
}

bool PinchEndData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
FlingData::FlingData()
    : velocity_x(),
      velocity_y(),
      target_viewport(),
      prevent_boosting() {}

FlingData::FlingData(
    float velocity_x_in,
    float velocity_y_in,
    bool target_viewport_in,
    bool prevent_boosting_in)
    : velocity_x(std::move(velocity_x_in)),
      velocity_y(std::move(velocity_y_in)),
      target_viewport(std::move(target_viewport_in)),
      prevent_boosting(std::move(prevent_boosting_in)) {}

FlingData::~FlingData() = default;
size_t FlingData::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->velocity_x);
  seed = mojo::internal::Hash(seed, this->velocity_y);
  seed = mojo::internal::Hash(seed, this->target_viewport);
  seed = mojo::internal::Hash(seed, this->prevent_boosting);
  return seed;
}

bool FlingData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
TapData::TapData()
    : tap_count(),
      needs_wheel_event() {}

TapData::TapData(
    int32_t tap_count_in,
    bool needs_wheel_event_in)
    : tap_count(std::move(tap_count_in)),
      needs_wheel_event(std::move(needs_wheel_event_in)) {}

TapData::~TapData() = default;
size_t TapData::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->tap_count);
  seed = mojo::internal::Hash(seed, this->needs_wheel_event);
  return seed;
}

bool TapData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
GestureData::GestureData()
    : screen_position(),
      widget_position(),
      source_device(),
      is_source_touch_event_set_non_blocking(),
      primary_pointer_type(),
      unique_touch_event_id(),
      contact_size(),
      scroll_data(),
      pinch_begin_data(),
      pinch_update_data(),
      pinch_end_data(),
      tap_data(),
      fling_data() {}

GestureData::GestureData(
    const ::gfx::PointF& screen_position_in,
    const ::gfx::PointF& widget_position_in,
    ::blink::WebGestureDevice source_device_in,
    bool is_source_touch_event_set_non_blocking_in,
    ::blink::WebPointerProperties::PointerType primary_pointer_type_in,
    int32_t unique_touch_event_id_in,
    const base::Optional<::gfx::Size>& contact_size_in,
    ScrollDataPtr scroll_data_in,
    PinchBeginDataPtr pinch_begin_data_in,
    PinchUpdateDataPtr pinch_update_data_in,
    PinchEndDataPtr pinch_end_data_in,
    TapDataPtr tap_data_in,
    FlingDataPtr fling_data_in)
    : screen_position(std::move(screen_position_in)),
      widget_position(std::move(widget_position_in)),
      source_device(std::move(source_device_in)),
      is_source_touch_event_set_non_blocking(std::move(is_source_touch_event_set_non_blocking_in)),
      primary_pointer_type(std::move(primary_pointer_type_in)),
      unique_touch_event_id(std::move(unique_touch_event_id_in)),
      contact_size(std::move(contact_size_in)),
      scroll_data(std::move(scroll_data_in)),
      pinch_begin_data(std::move(pinch_begin_data_in)),
      pinch_update_data(std::move(pinch_update_data_in)),
      pinch_end_data(std::move(pinch_end_data_in)),
      tap_data(std::move(tap_data_in)),
      fling_data(std::move(fling_data_in)) {}

GestureData::~GestureData() = default;

bool GestureData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
TouchPoint::TouchPoint()
    : state(),
      radius_x(),
      radius_y(),
      rotation_angle(),
      pointer_data() {}

TouchPoint::TouchPoint(
    ::blink::WebTouchPoint::State state_in,
    float radius_x_in,
    float radius_y_in,
    float rotation_angle_in,
    PointerDataPtr pointer_data_in)
    : state(std::move(state_in)),
      radius_x(std::move(radius_x_in)),
      radius_y(std::move(radius_y_in)),
      rotation_angle(std::move(rotation_angle_in)),
      pointer_data(std::move(pointer_data_in)) {}

TouchPoint::~TouchPoint() = default;

bool TouchPoint::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
TouchData::TouchData()
    : cancelable(),
      moved_beyond_slop_region(),
      touch_start_or_first_move(),
      hovering(),
      unique_touch_event_id(),
      touches() {}

TouchData::TouchData(
    ::blink::WebInputEvent::DispatchType cancelable_in,
    bool moved_beyond_slop_region_in,
    bool touch_start_or_first_move_in,
    bool hovering_in,
    uint32_t unique_touch_event_id_in,
    std::vector<TouchPointPtr> touches_in)
    : cancelable(std::move(cancelable_in)),
      moved_beyond_slop_region(std::move(moved_beyond_slop_region_in)),
      touch_start_or_first_move(std::move(touch_start_or_first_move_in)),
      hovering(std::move(hovering_in)),
      unique_touch_event_id(std::move(unique_touch_event_id_in)),
      touches(std::move(touches_in)) {}

TouchData::~TouchData() = default;

bool TouchData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
Event::Event()
    : type(),
      modifiers(),
      timestamp(),
      latency(),
      key_data(),
      pointer_data(),
      gesture_data(),
      touch_data() {}

Event::Event(
    ::blink::WebInputEvent::Type type_in,
    int32_t modifiers_in,
    ::base::TimeTicks timestamp_in,
    const ::ui::LatencyInfo& latency_in,
    KeyDataPtr key_data_in,
    PointerDataPtr pointer_data_in,
    GestureDataPtr gesture_data_in,
    TouchDataPtr touch_data_in)
    : type(std::move(type_in)),
      modifiers(std::move(modifiers_in)),
      timestamp(std::move(timestamp_in)),
      latency(std::move(latency_in)),
      key_data(std::move(key_data_in)),
      pointer_data(std::move(pointer_data_in)),
      gesture_data(std::move(gesture_data_in)),
      touch_data(std::move(touch_data_in)) {}

Event::~Event() = default;

bool Event::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
TouchActionOptional::TouchActionOptional()
    : touch_action() {}

TouchActionOptional::TouchActionOptional(
    ::cc::TouchAction touch_action_in)
    : touch_action(std::move(touch_action_in)) {}

TouchActionOptional::~TouchActionOptional() = default;

bool TouchActionOptional::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char WidgetInputHandlerHost::Name_[] = "content.mojom.WidgetInputHandlerHost";

WidgetInputHandlerHostProxy::WidgetInputHandlerHostProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void WidgetInputHandlerHostProxy::FallbackCursorModeLockCursor(
    bool in_left, bool in_right, bool in_up, bool in_down) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandlerHost::FallbackCursorModeLockCursor");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandlerHost_FallbackCursorModeLockCursor_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandlerHost_FallbackCursorModeLockCursor_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->left = in_left;
  params->right = in_right;
  params->up = in_up;
  params->down = in_down;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandlerHost::Name_);
  message.set_method_name("FallbackCursorModeLockCursor");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void WidgetInputHandlerHostProxy::FallbackCursorModeSetCursorVisibility(
    bool in_visible) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandlerHost::FallbackCursorModeSetCursorVisibility");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandlerHost_FallbackCursorModeSetCursorVisibility_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandlerHost_FallbackCursorModeSetCursorVisibility_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->visible = in_visible;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandlerHost::Name_);
  message.set_method_name("FallbackCursorModeSetCursorVisibility");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void WidgetInputHandlerHostProxy::SetTouchActionFromMain(
    ::cc::TouchAction in_touch_action) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandlerHost::SetTouchActionFromMain");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandlerHost_SetTouchActionFromMain_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandlerHost_SetTouchActionFromMain_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::cc::mojom::TouchAction>(
      in_touch_action, &params->touch_action);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandlerHost::Name_);
  message.set_method_name("SetTouchActionFromMain");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void WidgetInputHandlerHostProxy::SetWhiteListedTouchAction(
    ::cc::TouchAction in_touch_action, uint32_t in_unique_touch_event_id, ::content::InputEventAckState in_state) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandlerHost::SetWhiteListedTouchAction");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandlerHost_SetWhiteListedTouchAction_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandlerHost_SetWhiteListedTouchAction_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::cc::mojom::TouchAction>(
      in_touch_action, &params->touch_action);
  params->unique_touch_event_id = in_unique_touch_event_id;
  mojo::internal::Serialize<::content::mojom::InputEventAckState>(
      in_state, &params->state);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandlerHost::Name_);
  message.set_method_name("SetWhiteListedTouchAction");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void WidgetInputHandlerHostProxy::DidOverscroll(
    const ::ui::DidOverscrollParams& in_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandlerHost::DidOverscroll");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandlerHost_DidOverscroll_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandlerHost_DidOverscroll_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->params)::BaseType::BufferWriter
      params_writer;
  mojo::internal::Serialize<::content::mojom::DidOverscrollParamsDataView>(
      in_params, buffer, &params_writer, &serialization_context);
  params->params.Set(
      params_writer.is_null() ? nullptr : params_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in WidgetInputHandlerHost.DidOverscroll request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandlerHost::Name_);
  message.set_method_name("DidOverscroll");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void WidgetInputHandlerHostProxy::DidStartScrollingViewport(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandlerHost::DidStartScrollingViewport");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandlerHost_DidStartScrollingViewport_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandlerHost_DidStartScrollingViewport_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandlerHost::Name_);
  message.set_method_name("DidStartScrollingViewport");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void WidgetInputHandlerHostProxy::ImeCancelComposition(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandlerHost::ImeCancelComposition");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandlerHost_ImeCancelComposition_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandlerHost_ImeCancelComposition_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandlerHost::Name_);
  message.set_method_name("ImeCancelComposition");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void WidgetInputHandlerHostProxy::ImeCompositionRangeChanged(
    const ::gfx::Range& in_range, const std::vector<::gfx::Rect>& in_bounds) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandlerHost::ImeCompositionRangeChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandlerHost_ImeCompositionRangeChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandlerHost_ImeCompositionRangeChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->range)::BaseType::BufferWriter
      range_writer;
  mojo::internal::Serialize<::gfx::mojom::RangeDataView>(
      in_range, buffer, &range_writer, &serialization_context);
  params->range.Set(
      range_writer.is_null() ? nullptr : range_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->range.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null range in WidgetInputHandlerHost.ImeCompositionRangeChanged request");
  typename decltype(params->bounds)::BaseType::BufferWriter
      bounds_writer;
  const mojo::internal::ContainerValidateParams bounds_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::gfx::mojom::RectDataView>>(
      in_bounds, buffer, &bounds_writer, &bounds_validate_params,
      &serialization_context);
  params->bounds.Set(
      bounds_writer.is_null() ? nullptr : bounds_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bounds.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bounds in WidgetInputHandlerHost.ImeCompositionRangeChanged request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandlerHost::Name_);
  message.set_method_name("ImeCompositionRangeChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void WidgetInputHandlerHostProxy::SetMouseCapture(
    bool in_capture) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandlerHost::SetMouseCapture");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandlerHost_SetMouseCapture_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandlerHost_SetMouseCapture_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->capture = in_capture;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandlerHost::Name_);
  message.set_method_name("SetMouseCapture");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool WidgetInputHandlerHostStubDispatch::Accept(
    WidgetInputHandlerHost* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kWidgetInputHandlerHost_FallbackCursorModeLockCursor_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandlerHost::FallbackCursorModeLockCursor",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandlerHost::FallbackCursorModeLockCursor");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::WidgetInputHandlerHost_FallbackCursorModeLockCursor_Params_Data* params =
          reinterpret_cast<internal::WidgetInputHandlerHost_FallbackCursorModeLockCursor_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_left{};
      bool p_right{};
      bool p_up{};
      bool p_down{};
      WidgetInputHandlerHost_FallbackCursorModeLockCursor_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_left = input_data_view.left();
      if (success)
        p_right = input_data_view.right();
      if (success)
        p_up = input_data_view.up();
      if (success)
        p_down = input_data_view.down();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandlerHost::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FallbackCursorModeLockCursor(
std::move(p_left), 
std::move(p_right), 
std::move(p_up), 
std::move(p_down));
      return true;
    }
    case internal::kWidgetInputHandlerHost_FallbackCursorModeSetCursorVisibility_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandlerHost::FallbackCursorModeSetCursorVisibility",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandlerHost::FallbackCursorModeSetCursorVisibility");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::WidgetInputHandlerHost_FallbackCursorModeSetCursorVisibility_Params_Data* params =
          reinterpret_cast<internal::WidgetInputHandlerHost_FallbackCursorModeSetCursorVisibility_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_visible{};
      WidgetInputHandlerHost_FallbackCursorModeSetCursorVisibility_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_visible = input_data_view.visible();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandlerHost::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FallbackCursorModeSetCursorVisibility(
std::move(p_visible));
      return true;
    }
    case internal::kWidgetInputHandlerHost_SetTouchActionFromMain_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandlerHost::SetTouchActionFromMain",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandlerHost::SetTouchActionFromMain");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::WidgetInputHandlerHost_SetTouchActionFromMain_Params_Data* params =
          reinterpret_cast<internal::WidgetInputHandlerHost_SetTouchActionFromMain_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::cc::TouchAction p_touch_action{};
      WidgetInputHandlerHost_SetTouchActionFromMain_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadTouchAction(&p_touch_action))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandlerHost::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetTouchActionFromMain(
std::move(p_touch_action));
      return true;
    }
    case internal::kWidgetInputHandlerHost_SetWhiteListedTouchAction_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandlerHost::SetWhiteListedTouchAction",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandlerHost::SetWhiteListedTouchAction");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::WidgetInputHandlerHost_SetWhiteListedTouchAction_Params_Data* params =
          reinterpret_cast<internal::WidgetInputHandlerHost_SetWhiteListedTouchAction_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::cc::TouchAction p_touch_action{};
      uint32_t p_unique_touch_event_id{};
      ::content::InputEventAckState p_state{};
      WidgetInputHandlerHost_SetWhiteListedTouchAction_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadTouchAction(&p_touch_action))
        success = false;
      if (success)
        p_unique_touch_event_id = input_data_view.unique_touch_event_id();
      if (success && !input_data_view.ReadState(&p_state))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandlerHost::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetWhiteListedTouchAction(
std::move(p_touch_action), 
std::move(p_unique_touch_event_id), 
std::move(p_state));
      return true;
    }
    case internal::kWidgetInputHandlerHost_DidOverscroll_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandlerHost::DidOverscroll",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandlerHost::DidOverscroll");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::WidgetInputHandlerHost_DidOverscroll_Params_Data* params =
          reinterpret_cast<internal::WidgetInputHandlerHost_DidOverscroll_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::ui::DidOverscrollParams p_params{};
      WidgetInputHandlerHost_DidOverscroll_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandlerHost::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidOverscroll(
std::move(p_params));
      return true;
    }
    case internal::kWidgetInputHandlerHost_DidStartScrollingViewport_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandlerHost::DidStartScrollingViewport",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandlerHost::DidStartScrollingViewport");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::WidgetInputHandlerHost_DidStartScrollingViewport_Params_Data* params =
          reinterpret_cast<internal::WidgetInputHandlerHost_DidStartScrollingViewport_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      WidgetInputHandlerHost_DidStartScrollingViewport_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandlerHost::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidStartScrollingViewport();
      return true;
    }
    case internal::kWidgetInputHandlerHost_ImeCancelComposition_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandlerHost::ImeCancelComposition",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandlerHost::ImeCancelComposition");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::WidgetInputHandlerHost_ImeCancelComposition_Params_Data* params =
          reinterpret_cast<internal::WidgetInputHandlerHost_ImeCancelComposition_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      WidgetInputHandlerHost_ImeCancelComposition_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandlerHost::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ImeCancelComposition();
      return true;
    }
    case internal::kWidgetInputHandlerHost_ImeCompositionRangeChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandlerHost::ImeCompositionRangeChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandlerHost::ImeCompositionRangeChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::WidgetInputHandlerHost_ImeCompositionRangeChanged_Params_Data* params =
          reinterpret_cast<internal::WidgetInputHandlerHost_ImeCompositionRangeChanged_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::gfx::Range p_range{};
      std::vector<::gfx::Rect> p_bounds{};
      WidgetInputHandlerHost_ImeCompositionRangeChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadRange(&p_range))
        success = false;
      if (success && !input_data_view.ReadBounds(&p_bounds))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandlerHost::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ImeCompositionRangeChanged(
std::move(p_range), 
std::move(p_bounds));
      return true;
    }
    case internal::kWidgetInputHandlerHost_SetMouseCapture_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandlerHost::SetMouseCapture",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandlerHost::SetMouseCapture");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::WidgetInputHandlerHost_SetMouseCapture_Params_Data* params =
          reinterpret_cast<internal::WidgetInputHandlerHost_SetMouseCapture_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_capture{};
      WidgetInputHandlerHost_SetMouseCapture_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_capture = input_data_view.capture();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandlerHost::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetMouseCapture(
std::move(p_capture));
      return true;
    }
  }
  return false;
}

// static
bool WidgetInputHandlerHostStubDispatch::AcceptWithResponder(
    WidgetInputHandlerHost* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kWidgetInputHandlerHost_FallbackCursorModeLockCursor_Name: {
      break;
    }
    case internal::kWidgetInputHandlerHost_FallbackCursorModeSetCursorVisibility_Name: {
      break;
    }
    case internal::kWidgetInputHandlerHost_SetTouchActionFromMain_Name: {
      break;
    }
    case internal::kWidgetInputHandlerHost_SetWhiteListedTouchAction_Name: {
      break;
    }
    case internal::kWidgetInputHandlerHost_DidOverscroll_Name: {
      break;
    }
    case internal::kWidgetInputHandlerHost_DidStartScrollingViewport_Name: {
      break;
    }
    case internal::kWidgetInputHandlerHost_ImeCancelComposition_Name: {
      break;
    }
    case internal::kWidgetInputHandlerHost_ImeCompositionRangeChanged_Name: {
      break;
    }
    case internal::kWidgetInputHandlerHost_SetMouseCapture_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kWidgetInputHandlerHostValidationInfo[] = {
    {&internal::WidgetInputHandlerHost_FallbackCursorModeLockCursor_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::WidgetInputHandlerHost_FallbackCursorModeSetCursorVisibility_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::WidgetInputHandlerHost_SetTouchActionFromMain_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::WidgetInputHandlerHost_SetWhiteListedTouchAction_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::WidgetInputHandlerHost_DidOverscroll_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::WidgetInputHandlerHost_DidStartScrollingViewport_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::WidgetInputHandlerHost_ImeCancelComposition_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::WidgetInputHandlerHost_ImeCompositionRangeChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::WidgetInputHandlerHost_SetMouseCapture_Params_Data::Validate,
     nullptr /* no response */},
};

bool WidgetInputHandlerHostRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::content::mojom::WidgetInputHandlerHost::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kWidgetInputHandlerHostValidationInfo);
}

const char WidgetInputHandler::Name_[] = "content.mojom.WidgetInputHandler";

class WidgetInputHandler_ImeCommitText_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  WidgetInputHandler_ImeCommitText_ForwardToCallback(
      WidgetInputHandler::ImeCommitTextCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  WidgetInputHandler::ImeCommitTextCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(WidgetInputHandler_ImeCommitText_ForwardToCallback);
};

class WidgetInputHandler_DispatchEvent_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  WidgetInputHandler_DispatchEvent_ForwardToCallback(
      WidgetInputHandler::DispatchEventCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  WidgetInputHandler::DispatchEventCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(WidgetInputHandler_DispatchEvent_ForwardToCallback);
};

class WidgetInputHandler_WaitForInputProcessed_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  WidgetInputHandler_WaitForInputProcessed_ForwardToCallback(
      WidgetInputHandler::WaitForInputProcessedCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  WidgetInputHandler::WaitForInputProcessedCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(WidgetInputHandler_WaitForInputProcessed_ForwardToCallback);
};

WidgetInputHandlerProxy::WidgetInputHandlerProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void WidgetInputHandlerProxy::SetFocus(
    bool in_focused) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandler::SetFocus");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandler_SetFocus_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandler_SetFocus_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->focused = in_focused;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandler::Name_);
  message.set_method_name("SetFocus");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void WidgetInputHandlerProxy::MouseCaptureLost(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandler::MouseCaptureLost");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandler_MouseCaptureLost_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandler_MouseCaptureLost_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandler::Name_);
  message.set_method_name("MouseCaptureLost");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void WidgetInputHandlerProxy::SetEditCommandsForNextKeyEvent(
    const std::vector<::content::EditCommand>& in_commands) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandler::SetEditCommandsForNextKeyEvent");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandler_SetEditCommandsForNextKeyEvent_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandler_SetEditCommandsForNextKeyEvent_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->commands)::BaseType::BufferWriter
      commands_writer;
  const mojo::internal::ContainerValidateParams commands_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::content::mojom::EditCommandDataView>>(
      in_commands, buffer, &commands_writer, &commands_validate_params,
      &serialization_context);
  params->commands.Set(
      commands_writer.is_null() ? nullptr : commands_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->commands.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null commands in WidgetInputHandler.SetEditCommandsForNextKeyEvent request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandler::Name_);
  message.set_method_name("SetEditCommandsForNextKeyEvent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void WidgetInputHandlerProxy::CursorVisibilityChanged(
    bool in_visible) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandler::CursorVisibilityChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandler_CursorVisibilityChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandler_CursorVisibilityChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->visible = in_visible;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandler::Name_);
  message.set_method_name("CursorVisibilityChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void WidgetInputHandlerProxy::FallbackCursorModeToggled(
    bool in_is_on) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandler::FallbackCursorModeToggled");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandler_FallbackCursorModeToggled_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandler_FallbackCursorModeToggled_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->is_on = in_is_on;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandler::Name_);
  message.set_method_name("FallbackCursorModeToggled");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void WidgetInputHandlerProxy::ImeSetComposition(
    const ::base::string16& in_text, const std::vector<::ui::ImeTextSpan>& in_ime_text_spans, const ::gfx::Range& in_range, int32_t in_start, int32_t in_end) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandler::ImeSetComposition");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandler_ImeSetComposition_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandler_ImeSetComposition_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->text)::BaseType::BufferWriter
      text_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_text, buffer, &text_writer, &serialization_context);
  params->text.Set(
      text_writer.is_null() ? nullptr : text_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->text.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null text in WidgetInputHandler.ImeSetComposition request");
  typename decltype(params->ime_text_spans)::BaseType::BufferWriter
      ime_text_spans_writer;
  const mojo::internal::ContainerValidateParams ime_text_spans_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::ui::mojom::ImeTextSpanDataView>>(
      in_ime_text_spans, buffer, &ime_text_spans_writer, &ime_text_spans_validate_params,
      &serialization_context);
  params->ime_text_spans.Set(
      ime_text_spans_writer.is_null() ? nullptr : ime_text_spans_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->ime_text_spans.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null ime_text_spans in WidgetInputHandler.ImeSetComposition request");
  typename decltype(params->range)::BaseType::BufferWriter
      range_writer;
  mojo::internal::Serialize<::gfx::mojom::RangeDataView>(
      in_range, buffer, &range_writer, &serialization_context);
  params->range.Set(
      range_writer.is_null() ? nullptr : range_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->range.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null range in WidgetInputHandler.ImeSetComposition request");
  params->start = in_start;
  params->end = in_end;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandler::Name_);
  message.set_method_name("ImeSetComposition");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void WidgetInputHandlerProxy::ImeCommitText(
    const ::base::string16& in_text, const std::vector<::ui::ImeTextSpan>& in_ime_text_spans, const ::gfx::Range& in_range, int32_t in_relative_cursor_position, ImeCommitTextCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandler::ImeCommitText");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandler_ImeCommitText_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandler_ImeCommitText_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->text)::BaseType::BufferWriter
      text_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_text, buffer, &text_writer, &serialization_context);
  params->text.Set(
      text_writer.is_null() ? nullptr : text_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->text.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null text in WidgetInputHandler.ImeCommitText request");
  typename decltype(params->ime_text_spans)::BaseType::BufferWriter
      ime_text_spans_writer;
  const mojo::internal::ContainerValidateParams ime_text_spans_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::ui::mojom::ImeTextSpanDataView>>(
      in_ime_text_spans, buffer, &ime_text_spans_writer, &ime_text_spans_validate_params,
      &serialization_context);
  params->ime_text_spans.Set(
      ime_text_spans_writer.is_null() ? nullptr : ime_text_spans_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->ime_text_spans.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null ime_text_spans in WidgetInputHandler.ImeCommitText request");
  typename decltype(params->range)::BaseType::BufferWriter
      range_writer;
  mojo::internal::Serialize<::gfx::mojom::RangeDataView>(
      in_range, buffer, &range_writer, &serialization_context);
  params->range.Set(
      range_writer.is_null() ? nullptr : range_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->range.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null range in WidgetInputHandler.ImeCommitText request");
  params->relative_cursor_position = in_relative_cursor_position;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandler::Name_);
  message.set_method_name("ImeCommitText");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new WidgetInputHandler_ImeCommitText_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void WidgetInputHandlerProxy::ImeFinishComposingText(
    bool in_keep_selection) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandler::ImeFinishComposingText");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandler_ImeFinishComposingText_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandler_ImeFinishComposingText_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->keep_selection = in_keep_selection;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandler::Name_);
  message.set_method_name("ImeFinishComposingText");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void WidgetInputHandlerProxy::RequestTextInputStateUpdate(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandler::RequestTextInputStateUpdate");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandler_RequestTextInputStateUpdate_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandler_RequestTextInputStateUpdate_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandler::Name_);
  message.set_method_name("RequestTextInputStateUpdate");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void WidgetInputHandlerProxy::RequestCompositionUpdates(
    bool in_immediate_request, bool in_monitor_request) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandler::RequestCompositionUpdates");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandler_RequestCompositionUpdates_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandler_RequestCompositionUpdates_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->immediate_request = in_immediate_request;
  params->monitor_request = in_monitor_request;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandler::Name_);
  message.set_method_name("RequestCompositionUpdates");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void WidgetInputHandlerProxy::DispatchEvent(
    ::std::unique_ptr<::content::InputEvent> in_event, DispatchEventCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandler::DispatchEvent");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandler_DispatchEvent_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandler_DispatchEvent_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->event)::BaseType::BufferWriter
      event_writer;
  mojo::internal::Serialize<::content::mojom::EventDataView>(
      in_event, buffer, &event_writer, &serialization_context);
  params->event.Set(
      event_writer.is_null() ? nullptr : event_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->event.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null event in WidgetInputHandler.DispatchEvent request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandler::Name_);
  message.set_method_name("DispatchEvent");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new WidgetInputHandler_DispatchEvent_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void WidgetInputHandlerProxy::DispatchNonBlockingEvent(
    ::std::unique_ptr<::content::InputEvent> in_event) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandler::DispatchNonBlockingEvent");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandler_DispatchNonBlockingEvent_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandler_DispatchNonBlockingEvent_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->event)::BaseType::BufferWriter
      event_writer;
  mojo::internal::Serialize<::content::mojom::EventDataView>(
      in_event, buffer, &event_writer, &serialization_context);
  params->event.Set(
      event_writer.is_null() ? nullptr : event_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->event.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null event in WidgetInputHandler.DispatchNonBlockingEvent request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandler::Name_);
  message.set_method_name("DispatchNonBlockingEvent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void WidgetInputHandlerProxy::WaitForInputProcessed(
    WaitForInputProcessedCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandler::WaitForInputProcessed");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandler_WaitForInputProcessed_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandler_WaitForInputProcessed_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandler::Name_);
  message.set_method_name("WaitForInputProcessed");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new WidgetInputHandler_WaitForInputProcessed_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void WidgetInputHandlerProxy::AttachSynchronousCompositor(
    mojo::PendingRemote<::content::mojom::SynchronousCompositorControlHost> in_control_host, mojo::PendingAssociatedRemote<::content::mojom::SynchronousCompositorHost> in_host, mojo::PendingAssociatedReceiver<::content::mojom::SynchronousCompositor> in_compositor_request) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::WidgetInputHandler::AttachSynchronousCompositor");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandler_AttachSynchronousCompositor_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandler_AttachSynchronousCompositor_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::content::mojom::SynchronousCompositorControlHostInterfaceBase>>(
      in_control_host, &params->control_host, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->control_host),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid control_host in WidgetInputHandler.AttachSynchronousCompositor request");
  mojo::internal::Serialize<::content::mojom::SynchronousCompositorHostAssociatedPtrInfoDataView>(
      in_host, &params->host, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->host),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid host in WidgetInputHandler.AttachSynchronousCompositor request");
  mojo::internal::Serialize<::content::mojom::SynchronousCompositorAssociatedRequestDataView>(
      in_compositor_request, &params->compositor_request, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->compositor_request),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid compositor_request in WidgetInputHandler.AttachSynchronousCompositor request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandler::Name_);
  message.set_method_name("AttachSynchronousCompositor");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
class WidgetInputHandler_ImeCommitText_ProxyToResponder {
 public:
  static WidgetInputHandler::ImeCommitTextCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<WidgetInputHandler_ImeCommitText_ProxyToResponder> proxy(
        new WidgetInputHandler_ImeCommitText_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&WidgetInputHandler_ImeCommitText_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~WidgetInputHandler_ImeCommitText_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  WidgetInputHandler_ImeCommitText_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "WidgetInputHandler::ImeCommitTextCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(WidgetInputHandler_ImeCommitText_ProxyToResponder);
};

bool WidgetInputHandler_ImeCommitText_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "content::mojom::WidgetInputHandler::ImeCommitTextCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::WidgetInputHandler_ImeCommitText_ResponseParams_Data* params =
      reinterpret_cast<
          internal::WidgetInputHandler_ImeCommitText_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  WidgetInputHandler_ImeCommitText_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        WidgetInputHandler::Name_, 6, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void WidgetInputHandler_ImeCommitText_ProxyToResponder::Run(
    ) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandler_ImeCommitText_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandler_ImeCommitText_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)content::mojom::WidgetInputHandler::ImeCommitTextCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandler::Name_);
  message.set_method_name("ImeCommitText");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class WidgetInputHandler_DispatchEvent_ProxyToResponder {
 public:
  static WidgetInputHandler::DispatchEventCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<WidgetInputHandler_DispatchEvent_ProxyToResponder> proxy(
        new WidgetInputHandler_DispatchEvent_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&WidgetInputHandler_DispatchEvent_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~WidgetInputHandler_DispatchEvent_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  WidgetInputHandler_DispatchEvent_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "WidgetInputHandler::DispatchEventCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::content::InputEventAckSource in_source, const ::ui::LatencyInfo& in_updated_latency, ::content::InputEventAckState in_state, const base::Optional<::ui::DidOverscrollParams>& in_overscroll, const base::Optional<::cc::TouchAction>& in_touch_action);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(WidgetInputHandler_DispatchEvent_ProxyToResponder);
};

bool WidgetInputHandler_DispatchEvent_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "content::mojom::WidgetInputHandler::DispatchEventCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::WidgetInputHandler_DispatchEvent_ResponseParams_Data* params =
      reinterpret_cast<
          internal::WidgetInputHandler_DispatchEvent_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  ::content::InputEventAckSource p_source{};
  ::ui::LatencyInfo p_updated_latency{};
  ::content::InputEventAckState p_state{};
  base::Optional<::ui::DidOverscrollParams> p_overscroll{};
  base::Optional<::cc::TouchAction> p_touch_action{};
  WidgetInputHandler_DispatchEvent_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadSource(&p_source))
    success = false;
  if (success && !input_data_view.ReadUpdatedLatency(&p_updated_latency))
    success = false;
  if (success && !input_data_view.ReadState(&p_state))
    success = false;
  if (success && !input_data_view.ReadOverscroll(&p_overscroll))
    success = false;
  if (success && !input_data_view.ReadTouchAction(&p_touch_action))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        WidgetInputHandler::Name_, 10, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_source), 
std::move(p_updated_latency), 
std::move(p_state), 
std::move(p_overscroll), 
std::move(p_touch_action));
  return true;
}

void WidgetInputHandler_DispatchEvent_ProxyToResponder::Run(
    ::content::InputEventAckSource in_source, const ::ui::LatencyInfo& in_updated_latency, ::content::InputEventAckState in_state, const base::Optional<::ui::DidOverscrollParams>& in_overscroll, const base::Optional<::cc::TouchAction>& in_touch_action) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandler_DispatchEvent_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandler_DispatchEvent_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::content::mojom::InputEventAckSource>(
      in_source, &params->source);
  typename decltype(params->updated_latency)::BaseType::BufferWriter
      updated_latency_writer;
  mojo::internal::Serialize<::ui::mojom::LatencyInfoDataView>(
      in_updated_latency, buffer, &updated_latency_writer, &serialization_context);
  params->updated_latency.Set(
      updated_latency_writer.is_null() ? nullptr : updated_latency_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->updated_latency.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null updated_latency in ");
  mojo::internal::Serialize<::content::mojom::InputEventAckState>(
      in_state, &params->state);
  typename decltype(params->overscroll)::BaseType::BufferWriter
      overscroll_writer;
  mojo::internal::Serialize<::content::mojom::DidOverscrollParamsDataView>(
      in_overscroll, buffer, &overscroll_writer, &serialization_context);
  params->overscroll.Set(
      overscroll_writer.is_null() ? nullptr : overscroll_writer.data());
  typename decltype(params->touch_action)::BaseType::BufferWriter
      touch_action_writer;
  mojo::internal::Serialize<::content::mojom::TouchActionOptionalDataView>(
      in_touch_action, buffer, &touch_action_writer, &serialization_context);
  params->touch_action.Set(
      touch_action_writer.is_null() ? nullptr : touch_action_writer.data());
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)content::mojom::WidgetInputHandler::DispatchEventCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandler::Name_);
  message.set_method_name("DispatchEvent");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class WidgetInputHandler_WaitForInputProcessed_ProxyToResponder {
 public:
  static WidgetInputHandler::WaitForInputProcessedCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<WidgetInputHandler_WaitForInputProcessed_ProxyToResponder> proxy(
        new WidgetInputHandler_WaitForInputProcessed_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&WidgetInputHandler_WaitForInputProcessed_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~WidgetInputHandler_WaitForInputProcessed_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  WidgetInputHandler_WaitForInputProcessed_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "WidgetInputHandler::WaitForInputProcessedCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(WidgetInputHandler_WaitForInputProcessed_ProxyToResponder);
};

bool WidgetInputHandler_WaitForInputProcessed_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "content::mojom::WidgetInputHandler::WaitForInputProcessedCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::WidgetInputHandler_WaitForInputProcessed_ResponseParams_Data* params =
      reinterpret_cast<
          internal::WidgetInputHandler_WaitForInputProcessed_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  WidgetInputHandler_WaitForInputProcessed_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        WidgetInputHandler::Name_, 12, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void WidgetInputHandler_WaitForInputProcessed_ProxyToResponder::Run(
    ) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kWidgetInputHandler_WaitForInputProcessed_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::WidgetInputHandler_WaitForInputProcessed_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)content::mojom::WidgetInputHandler::WaitForInputProcessedCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(WidgetInputHandler::Name_);
  message.set_method_name("WaitForInputProcessed");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool WidgetInputHandlerStubDispatch::Accept(
    WidgetInputHandler* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kWidgetInputHandler_SetFocus_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandler::SetFocus",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandler::SetFocus");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::WidgetInputHandler_SetFocus_Params_Data* params =
          reinterpret_cast<internal::WidgetInputHandler_SetFocus_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_focused{};
      WidgetInputHandler_SetFocus_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_focused = input_data_view.focused();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandler::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetFocus(
std::move(p_focused));
      return true;
    }
    case internal::kWidgetInputHandler_MouseCaptureLost_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandler::MouseCaptureLost",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandler::MouseCaptureLost");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::WidgetInputHandler_MouseCaptureLost_Params_Data* params =
          reinterpret_cast<internal::WidgetInputHandler_MouseCaptureLost_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      WidgetInputHandler_MouseCaptureLost_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandler::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->MouseCaptureLost();
      return true;
    }
    case internal::kWidgetInputHandler_SetEditCommandsForNextKeyEvent_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandler::SetEditCommandsForNextKeyEvent",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandler::SetEditCommandsForNextKeyEvent");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::WidgetInputHandler_SetEditCommandsForNextKeyEvent_Params_Data* params =
          reinterpret_cast<internal::WidgetInputHandler_SetEditCommandsForNextKeyEvent_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      std::vector<::content::EditCommand> p_commands{};
      WidgetInputHandler_SetEditCommandsForNextKeyEvent_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadCommands(&p_commands))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandler::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetEditCommandsForNextKeyEvent(
std::move(p_commands));
      return true;
    }
    case internal::kWidgetInputHandler_CursorVisibilityChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandler::CursorVisibilityChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandler::CursorVisibilityChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::WidgetInputHandler_CursorVisibilityChanged_Params_Data* params =
          reinterpret_cast<internal::WidgetInputHandler_CursorVisibilityChanged_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_visible{};
      WidgetInputHandler_CursorVisibilityChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_visible = input_data_view.visible();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandler::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CursorVisibilityChanged(
std::move(p_visible));
      return true;
    }
    case internal::kWidgetInputHandler_FallbackCursorModeToggled_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandler::FallbackCursorModeToggled",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandler::FallbackCursorModeToggled");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::WidgetInputHandler_FallbackCursorModeToggled_Params_Data* params =
          reinterpret_cast<internal::WidgetInputHandler_FallbackCursorModeToggled_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_is_on{};
      WidgetInputHandler_FallbackCursorModeToggled_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_is_on = input_data_view.is_on();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandler::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FallbackCursorModeToggled(
std::move(p_is_on));
      return true;
    }
    case internal::kWidgetInputHandler_ImeSetComposition_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandler::ImeSetComposition",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandler::ImeSetComposition");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::WidgetInputHandler_ImeSetComposition_Params_Data* params =
          reinterpret_cast<internal::WidgetInputHandler_ImeSetComposition_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::base::string16 p_text{};
      std::vector<::ui::ImeTextSpan> p_ime_text_spans{};
      ::gfx::Range p_range{};
      int32_t p_start{};
      int32_t p_end{};
      WidgetInputHandler_ImeSetComposition_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadText(&p_text))
        success = false;
      if (success && !input_data_view.ReadImeTextSpans(&p_ime_text_spans))
        success = false;
      if (success && !input_data_view.ReadRange(&p_range))
        success = false;
      if (success)
        p_start = input_data_view.start();
      if (success)
        p_end = input_data_view.end();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandler::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ImeSetComposition(
std::move(p_text), 
std::move(p_ime_text_spans), 
std::move(p_range), 
std::move(p_start), 
std::move(p_end));
      return true;
    }
    case internal::kWidgetInputHandler_ImeCommitText_Name: {
      break;
    }
    case internal::kWidgetInputHandler_ImeFinishComposingText_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandler::ImeFinishComposingText",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandler::ImeFinishComposingText");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::WidgetInputHandler_ImeFinishComposingText_Params_Data* params =
          reinterpret_cast<internal::WidgetInputHandler_ImeFinishComposingText_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_keep_selection{};
      WidgetInputHandler_ImeFinishComposingText_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_keep_selection = input_data_view.keep_selection();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandler::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ImeFinishComposingText(
std::move(p_keep_selection));
      return true;
    }
    case internal::kWidgetInputHandler_RequestTextInputStateUpdate_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandler::RequestTextInputStateUpdate",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandler::RequestTextInputStateUpdate");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::WidgetInputHandler_RequestTextInputStateUpdate_Params_Data* params =
          reinterpret_cast<internal::WidgetInputHandler_RequestTextInputStateUpdate_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      WidgetInputHandler_RequestTextInputStateUpdate_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandler::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RequestTextInputStateUpdate();
      return true;
    }
    case internal::kWidgetInputHandler_RequestCompositionUpdates_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandler::RequestCompositionUpdates",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandler::RequestCompositionUpdates");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::WidgetInputHandler_RequestCompositionUpdates_Params_Data* params =
          reinterpret_cast<internal::WidgetInputHandler_RequestCompositionUpdates_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      bool p_immediate_request{};
      bool p_monitor_request{};
      WidgetInputHandler_RequestCompositionUpdates_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_immediate_request = input_data_view.immediate_request();
      if (success)
        p_monitor_request = input_data_view.monitor_request();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandler::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RequestCompositionUpdates(
std::move(p_immediate_request), 
std::move(p_monitor_request));
      return true;
    }
    case internal::kWidgetInputHandler_DispatchEvent_Name: {
      break;
    }
    case internal::kWidgetInputHandler_DispatchNonBlockingEvent_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandler::DispatchNonBlockingEvent",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandler::DispatchNonBlockingEvent");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::WidgetInputHandler_DispatchNonBlockingEvent_Params_Data* params =
          reinterpret_cast<internal::WidgetInputHandler_DispatchNonBlockingEvent_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::std::unique_ptr<::content::InputEvent> p_event{};
      WidgetInputHandler_DispatchNonBlockingEvent_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadEvent(&p_event))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandler::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DispatchNonBlockingEvent(
std::move(p_event));
      return true;
    }
    case internal::kWidgetInputHandler_WaitForInputProcessed_Name: {
      break;
    }
    case internal::kWidgetInputHandler_AttachSynchronousCompositor_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandler::AttachSynchronousCompositor",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandler::AttachSynchronousCompositor");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::WidgetInputHandler_AttachSynchronousCompositor_Params_Data* params =
          reinterpret_cast<internal::WidgetInputHandler_AttachSynchronousCompositor_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      mojo::PendingRemote<::content::mojom::SynchronousCompositorControlHost> p_control_host{};
      mojo::PendingAssociatedRemote<::content::mojom::SynchronousCompositorHost> p_host{};
      mojo::PendingAssociatedReceiver<::content::mojom::SynchronousCompositor> p_compositor_request{};
      WidgetInputHandler_AttachSynchronousCompositor_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success) {
        p_control_host =
            input_data_view.TakeControlHost<decltype(p_control_host)>();
      }
      if (success) {
        p_host =
            input_data_view.TakeHost<decltype(p_host)>();
      }
      if (success) {
        p_compositor_request =
            input_data_view.TakeCompositorRequest<decltype(p_compositor_request)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandler::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AttachSynchronousCompositor(
std::move(p_control_host), 
std::move(p_host), 
std::move(p_compositor_request));
      return true;
    }
  }
  return false;
}

// static
bool WidgetInputHandlerStubDispatch::AcceptWithResponder(
    WidgetInputHandler* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kWidgetInputHandler_SetFocus_Name: {
      break;
    }
    case internal::kWidgetInputHandler_MouseCaptureLost_Name: {
      break;
    }
    case internal::kWidgetInputHandler_SetEditCommandsForNextKeyEvent_Name: {
      break;
    }
    case internal::kWidgetInputHandler_CursorVisibilityChanged_Name: {
      break;
    }
    case internal::kWidgetInputHandler_FallbackCursorModeToggled_Name: {
      break;
    }
    case internal::kWidgetInputHandler_ImeSetComposition_Name: {
      break;
    }
    case internal::kWidgetInputHandler_ImeCommitText_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandler::ImeCommitText",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandler::ImeCommitText");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::WidgetInputHandler_ImeCommitText_Params_Data* params =
          reinterpret_cast<
              internal::WidgetInputHandler_ImeCommitText_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::base::string16 p_text{};
      std::vector<::ui::ImeTextSpan> p_ime_text_spans{};
      ::gfx::Range p_range{};
      int32_t p_relative_cursor_position{};
      WidgetInputHandler_ImeCommitText_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadText(&p_text))
        success = false;
      if (success && !input_data_view.ReadImeTextSpans(&p_ime_text_spans))
        success = false;
      if (success && !input_data_view.ReadRange(&p_range))
        success = false;
      if (success)
        p_relative_cursor_position = input_data_view.relative_cursor_position();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandler::Name_, 6, false);
        return false;
      }
      WidgetInputHandler::ImeCommitTextCallback callback =
          WidgetInputHandler_ImeCommitText_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ImeCommitText(
std::move(p_text), 
std::move(p_ime_text_spans), 
std::move(p_range), 
std::move(p_relative_cursor_position), std::move(callback));
      return true;
    }
    case internal::kWidgetInputHandler_ImeFinishComposingText_Name: {
      break;
    }
    case internal::kWidgetInputHandler_RequestTextInputStateUpdate_Name: {
      break;
    }
    case internal::kWidgetInputHandler_RequestCompositionUpdates_Name: {
      break;
    }
    case internal::kWidgetInputHandler_DispatchEvent_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandler::DispatchEvent",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandler::DispatchEvent");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::WidgetInputHandler_DispatchEvent_Params_Data* params =
          reinterpret_cast<
              internal::WidgetInputHandler_DispatchEvent_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::std::unique_ptr<::content::InputEvent> p_event{};
      WidgetInputHandler_DispatchEvent_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadEvent(&p_event))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandler::Name_, 10, false);
        return false;
      }
      WidgetInputHandler::DispatchEventCallback callback =
          WidgetInputHandler_DispatchEvent_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DispatchEvent(
std::move(p_event), std::move(callback));
      return true;
    }
    case internal::kWidgetInputHandler_DispatchNonBlockingEvent_Name: {
      break;
    }
    case internal::kWidgetInputHandler_WaitForInputProcessed_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::WidgetInputHandler::WaitForInputProcessed",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::WidgetInputHandler::WaitForInputProcessed");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::WidgetInputHandler_WaitForInputProcessed_Params_Data* params =
          reinterpret_cast<
              internal::WidgetInputHandler_WaitForInputProcessed_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      WidgetInputHandler_WaitForInputProcessed_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            WidgetInputHandler::Name_, 12, false);
        return false;
      }
      WidgetInputHandler::WaitForInputProcessedCallback callback =
          WidgetInputHandler_WaitForInputProcessed_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->WaitForInputProcessed(std::move(callback));
      return true;
    }
    case internal::kWidgetInputHandler_AttachSynchronousCompositor_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kWidgetInputHandlerValidationInfo[] = {
    {&internal::WidgetInputHandler_SetFocus_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::WidgetInputHandler_MouseCaptureLost_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::WidgetInputHandler_SetEditCommandsForNextKeyEvent_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::WidgetInputHandler_CursorVisibilityChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::WidgetInputHandler_FallbackCursorModeToggled_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::WidgetInputHandler_ImeSetComposition_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::WidgetInputHandler_ImeCommitText_Params_Data::Validate,
     &internal::WidgetInputHandler_ImeCommitText_ResponseParams_Data::Validate},
    {&internal::WidgetInputHandler_ImeFinishComposingText_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::WidgetInputHandler_RequestTextInputStateUpdate_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::WidgetInputHandler_RequestCompositionUpdates_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::WidgetInputHandler_DispatchEvent_Params_Data::Validate,
     &internal::WidgetInputHandler_DispatchEvent_ResponseParams_Data::Validate},
    {&internal::WidgetInputHandler_DispatchNonBlockingEvent_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::WidgetInputHandler_WaitForInputProcessed_Params_Data::Validate,
     &internal::WidgetInputHandler_WaitForInputProcessed_ResponseParams_Data::Validate},
    {&internal::WidgetInputHandler_AttachSynchronousCompositor_Params_Data::Validate,
     nullptr /* no response */},
};

bool WidgetInputHandlerRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::content::mojom::WidgetInputHandler::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kWidgetInputHandlerValidationInfo);
}

bool WidgetInputHandlerResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::content::mojom::WidgetInputHandler::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kWidgetInputHandlerValidationInfo);
}
const char FrameInputHandler::Name_[] = "content.mojom.FrameInputHandler";

class FrameInputHandler_SelectWordAroundCaret_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FrameInputHandler_SelectWordAroundCaret_ForwardToCallback(
      FrameInputHandler::SelectWordAroundCaretCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  FrameInputHandler::SelectWordAroundCaretCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(FrameInputHandler_SelectWordAroundCaret_ForwardToCallback);
};

FrameInputHandlerProxy::FrameInputHandlerProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void FrameInputHandlerProxy::SetCompositionFromExistingText(
    int32_t in_start, int32_t in_end, const std::vector<::ui::ImeTextSpan>& in_ime_text_spans) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::SetCompositionFromExistingText");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_SetCompositionFromExistingText_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_SetCompositionFromExistingText_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->start = in_start;
  params->end = in_end;
  typename decltype(params->ime_text_spans)::BaseType::BufferWriter
      ime_text_spans_writer;
  const mojo::internal::ContainerValidateParams ime_text_spans_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::ui::mojom::ImeTextSpanDataView>>(
      in_ime_text_spans, buffer, &ime_text_spans_writer, &ime_text_spans_validate_params,
      &serialization_context);
  params->ime_text_spans.Set(
      ime_text_spans_writer.is_null() ? nullptr : ime_text_spans_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->ime_text_spans.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null ime_text_spans in FrameInputHandler.SetCompositionFromExistingText request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("SetCompositionFromExistingText");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::ExtendSelectionAndDelete(
    int32_t in_before, int32_t in_after) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::ExtendSelectionAndDelete");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_ExtendSelectionAndDelete_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_ExtendSelectionAndDelete_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->before = in_before;
  params->after = in_after;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("ExtendSelectionAndDelete");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::DeleteSurroundingText(
    int32_t in_before, int32_t in_after) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::DeleteSurroundingText");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_DeleteSurroundingText_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_DeleteSurroundingText_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->before = in_before;
  params->after = in_after;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("DeleteSurroundingText");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::DeleteSurroundingTextInCodePoints(
    int32_t in_before, int32_t in_after) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::DeleteSurroundingTextInCodePoints");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_DeleteSurroundingTextInCodePoints_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_DeleteSurroundingTextInCodePoints_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->before = in_before;
  params->after = in_after;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("DeleteSurroundingTextInCodePoints");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::SetEditableSelectionOffsets(
    int32_t in_start, int32_t in_end) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::SetEditableSelectionOffsets");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_SetEditableSelectionOffsets_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_SetEditableSelectionOffsets_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->start = in_start;
  params->end = in_end;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("SetEditableSelectionOffsets");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::ExecuteEditCommand(
    const std::string& in_command, const base::Optional<::base::string16>& in_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::ExecuteEditCommand");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_ExecuteEditCommand_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_ExecuteEditCommand_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->command)::BaseType::BufferWriter
      command_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_command, buffer, &command_writer, &serialization_context);
  params->command.Set(
      command_writer.is_null() ? nullptr : command_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->command.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null command in FrameInputHandler.ExecuteEditCommand request");
  typename decltype(params->value)::BaseType::BufferWriter
      value_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_value, buffer, &value_writer, &serialization_context);
  params->value.Set(
      value_writer.is_null() ? nullptr : value_writer.data());
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("ExecuteEditCommand");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::Undo(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::Undo");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_Undo_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_Undo_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("Undo");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::Redo(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::Redo");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_Redo_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_Redo_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("Redo");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::Cut(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::Cut");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_Cut_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_Cut_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("Cut");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::Copy(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::Copy");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_Copy_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_Copy_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("Copy");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::CopyToFindPboard(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::CopyToFindPboard");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_CopyToFindPboard_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_CopyToFindPboard_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("CopyToFindPboard");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::Paste(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::Paste");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_Paste_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_Paste_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("Paste");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::PasteAndMatchStyle(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::PasteAndMatchStyle");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_PasteAndMatchStyle_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_PasteAndMatchStyle_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("PasteAndMatchStyle");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::Delete(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::Delete");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_Delete_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_Delete_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("Delete");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::SelectAll(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::SelectAll");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_SelectAll_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_SelectAll_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("SelectAll");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::CollapseSelection(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::CollapseSelection");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_CollapseSelection_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_CollapseSelection_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("CollapseSelection");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::Replace(
    const ::base::string16& in_word) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::Replace");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_Replace_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_Replace_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->word)::BaseType::BufferWriter
      word_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_word, buffer, &word_writer, &serialization_context);
  params->word.Set(
      word_writer.is_null() ? nullptr : word_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->word.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null word in FrameInputHandler.Replace request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("Replace");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::ReplaceMisspelling(
    const ::base::string16& in_word) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::ReplaceMisspelling");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_ReplaceMisspelling_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_ReplaceMisspelling_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->word)::BaseType::BufferWriter
      word_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_word, buffer, &word_writer, &serialization_context);
  params->word.Set(
      word_writer.is_null() ? nullptr : word_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->word.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null word in FrameInputHandler.ReplaceMisspelling request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("ReplaceMisspelling");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::SelectRange(
    const ::gfx::Point& in_base, const ::gfx::Point& in_extent) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::SelectRange");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_SelectRange_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_SelectRange_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->base)::BaseType::BufferWriter
      base_writer;
  mojo::internal::Serialize<::gfx::mojom::PointDataView>(
      in_base, buffer, &base_writer, &serialization_context);
  params->base.Set(
      base_writer.is_null() ? nullptr : base_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->base.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null base in FrameInputHandler.SelectRange request");
  typename decltype(params->extent)::BaseType::BufferWriter
      extent_writer;
  mojo::internal::Serialize<::gfx::mojom::PointDataView>(
      in_extent, buffer, &extent_writer, &serialization_context);
  params->extent.Set(
      extent_writer.is_null() ? nullptr : extent_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->extent.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null extent in FrameInputHandler.SelectRange request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("SelectRange");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::AdjustSelectionByCharacterOffset(
    int32_t in_start, int32_t in_end, ::blink::mojom::SelectionMenuBehavior in_behavior) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::AdjustSelectionByCharacterOffset");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_AdjustSelectionByCharacterOffset_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_AdjustSelectionByCharacterOffset_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->start = in_start;
  params->end = in_end;
  mojo::internal::Serialize<::blink::mojom::SelectionMenuBehavior>(
      in_behavior, &params->behavior);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("AdjustSelectionByCharacterOffset");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::SelectWordAroundCaret(
    SelectWordAroundCaretCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::SelectWordAroundCaret");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_SelectWordAroundCaret_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_SelectWordAroundCaret_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("SelectWordAroundCaret");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FrameInputHandler_SelectWordAroundCaret_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void FrameInputHandlerProxy::MoveRangeSelectionExtent(
    const ::gfx::Point& in_extent) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::MoveRangeSelectionExtent");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_MoveRangeSelectionExtent_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_MoveRangeSelectionExtent_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->extent)::BaseType::BufferWriter
      extent_writer;
  mojo::internal::Serialize<::gfx::mojom::PointDataView>(
      in_extent, buffer, &extent_writer, &serialization_context);
  params->extent.Set(
      extent_writer.is_null() ? nullptr : extent_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->extent.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null extent in FrameInputHandler.MoveRangeSelectionExtent request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("MoveRangeSelectionExtent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::ScrollFocusedEditableNodeIntoRect(
    const ::gfx::Rect& in_rect) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::ScrollFocusedEditableNodeIntoRect");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_ScrollFocusedEditableNodeIntoRect_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_ScrollFocusedEditableNodeIntoRect_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->rect)::BaseType::BufferWriter
      rect_writer;
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_rect, buffer, &rect_writer, &serialization_context);
  params->rect.Set(
      rect_writer.is_null() ? nullptr : rect_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->rect.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null rect in FrameInputHandler.ScrollFocusedEditableNodeIntoRect request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("ScrollFocusedEditableNodeIntoRect");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::MoveCaret(
    const ::gfx::Point& in_point) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::MoveCaret");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_MoveCaret_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_MoveCaret_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->point)::BaseType::BufferWriter
      point_writer;
  mojo::internal::Serialize<::gfx::mojom::PointDataView>(
      in_point, buffer, &point_writer, &serialization_context);
  params->point.Set(
      point_writer.is_null() ? nullptr : point_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->point.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null point in FrameInputHandler.MoveCaret request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("MoveCaret");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void FrameInputHandlerProxy::GetWidgetInputHandler(
    mojo::PendingAssociatedReceiver<WidgetInputHandler> in_interface_request, mojo::PendingRemote<WidgetInputHandlerHost> in_host) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "content::mojom::FrameInputHandler::GetWidgetInputHandler");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_GetWidgetInputHandler_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_GetWidgetInputHandler_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::content::mojom::WidgetInputHandlerAssociatedRequestDataView>(
      in_interface_request, &params->interface_request, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->interface_request),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid interface_request in FrameInputHandler.GetWidgetInputHandler request");
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::content::mojom::WidgetInputHandlerHostInterfaceBase>>(
      in_host, &params->host, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->host),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid host in FrameInputHandler.GetWidgetInputHandler request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("GetWidgetInputHandler");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
class FrameInputHandler_SelectWordAroundCaret_ProxyToResponder {
 public:
  static FrameInputHandler::SelectWordAroundCaretCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FrameInputHandler_SelectWordAroundCaret_ProxyToResponder> proxy(
        new FrameInputHandler_SelectWordAroundCaret_ProxyToResponder(
            request_id, is_sync, std::move(responder)));
    return base::BindOnce(&FrameInputHandler_SelectWordAroundCaret_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FrameInputHandler_SelectWordAroundCaret_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  FrameInputHandler_SelectWordAroundCaret_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FrameInputHandler::SelectWordAroundCaretCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_did_select, int32_t in_start_adjust, int32_t in_end_adjust);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(FrameInputHandler_SelectWordAroundCaret_ProxyToResponder);
};

bool FrameInputHandler_SelectWordAroundCaret_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "content::mojom::FrameInputHandler::SelectWordAroundCaretCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::FrameInputHandler_SelectWordAroundCaret_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FrameInputHandler_SelectWordAroundCaret_ResponseParams_Data*>(
              message->mutable_payload());
  
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  bool success = true;
  bool p_did_select{};
  int32_t p_start_adjust{};
  int32_t p_end_adjust{};
  FrameInputHandler_SelectWordAroundCaret_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success)
    p_did_select = input_data_view.did_select();
  if (success)
    p_start_adjust = input_data_view.start_adjust();
  if (success)
    p_end_adjust = input_data_view.end_adjust();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FrameInputHandler::Name_, 20, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_did_select), 
std::move(p_start_adjust), 
std::move(p_end_adjust));
  return true;
}

void FrameInputHandler_SelectWordAroundCaret_ProxyToResponder::Run(
    bool in_did_select, int32_t in_start_adjust, int32_t in_end_adjust) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kFrameInputHandler_SelectWordAroundCaret_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::content::mojom::internal::FrameInputHandler_SelectWordAroundCaret_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->did_select = in_did_select;
  params->start_adjust = in_start_adjust;
  params->end_adjust = in_end_adjust;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)content::mojom::FrameInputHandler::SelectWordAroundCaretCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameInputHandler::Name_);
  message.set_method_name("SelectWordAroundCaret");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool FrameInputHandlerStubDispatch::Accept(
    FrameInputHandler* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kFrameInputHandler_SetCompositionFromExistingText_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::SetCompositionFromExistingText",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::SetCompositionFromExistingText");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_SetCompositionFromExistingText_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_SetCompositionFromExistingText_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int32_t p_start{};
      int32_t p_end{};
      std::vector<::ui::ImeTextSpan> p_ime_text_spans{};
      FrameInputHandler_SetCompositionFromExistingText_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_start = input_data_view.start();
      if (success)
        p_end = input_data_view.end();
      if (success && !input_data_view.ReadImeTextSpans(&p_ime_text_spans))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetCompositionFromExistingText(
std::move(p_start), 
std::move(p_end), 
std::move(p_ime_text_spans));
      return true;
    }
    case internal::kFrameInputHandler_ExtendSelectionAndDelete_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::ExtendSelectionAndDelete",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::ExtendSelectionAndDelete");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_ExtendSelectionAndDelete_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_ExtendSelectionAndDelete_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int32_t p_before{};
      int32_t p_after{};
      FrameInputHandler_ExtendSelectionAndDelete_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_before = input_data_view.before();
      if (success)
        p_after = input_data_view.after();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ExtendSelectionAndDelete(
std::move(p_before), 
std::move(p_after));
      return true;
    }
    case internal::kFrameInputHandler_DeleteSurroundingText_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::DeleteSurroundingText",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::DeleteSurroundingText");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_DeleteSurroundingText_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_DeleteSurroundingText_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int32_t p_before{};
      int32_t p_after{};
      FrameInputHandler_DeleteSurroundingText_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_before = input_data_view.before();
      if (success)
        p_after = input_data_view.after();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DeleteSurroundingText(
std::move(p_before), 
std::move(p_after));
      return true;
    }
    case internal::kFrameInputHandler_DeleteSurroundingTextInCodePoints_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::DeleteSurroundingTextInCodePoints",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::DeleteSurroundingTextInCodePoints");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_DeleteSurroundingTextInCodePoints_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_DeleteSurroundingTextInCodePoints_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int32_t p_before{};
      int32_t p_after{};
      FrameInputHandler_DeleteSurroundingTextInCodePoints_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_before = input_data_view.before();
      if (success)
        p_after = input_data_view.after();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DeleteSurroundingTextInCodePoints(
std::move(p_before), 
std::move(p_after));
      return true;
    }
    case internal::kFrameInputHandler_SetEditableSelectionOffsets_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::SetEditableSelectionOffsets",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::SetEditableSelectionOffsets");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_SetEditableSelectionOffsets_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_SetEditableSelectionOffsets_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int32_t p_start{};
      int32_t p_end{};
      FrameInputHandler_SetEditableSelectionOffsets_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_start = input_data_view.start();
      if (success)
        p_end = input_data_view.end();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetEditableSelectionOffsets(
std::move(p_start), 
std::move(p_end));
      return true;
    }
    case internal::kFrameInputHandler_ExecuteEditCommand_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::ExecuteEditCommand",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::ExecuteEditCommand");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_ExecuteEditCommand_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_ExecuteEditCommand_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      std::string p_command{};
      base::Optional<::base::string16> p_value{};
      FrameInputHandler_ExecuteEditCommand_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadCommand(&p_command))
        success = false;
      if (success && !input_data_view.ReadValue(&p_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ExecuteEditCommand(
std::move(p_command), 
std::move(p_value));
      return true;
    }
    case internal::kFrameInputHandler_Undo_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::Undo",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::Undo");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_Undo_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_Undo_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      FrameInputHandler_Undo_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Undo();
      return true;
    }
    case internal::kFrameInputHandler_Redo_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::Redo",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::Redo");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_Redo_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_Redo_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      FrameInputHandler_Redo_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Redo();
      return true;
    }
    case internal::kFrameInputHandler_Cut_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::Cut",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::Cut");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_Cut_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_Cut_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      FrameInputHandler_Cut_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Cut();
      return true;
    }
    case internal::kFrameInputHandler_Copy_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::Copy",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::Copy");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_Copy_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_Copy_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      FrameInputHandler_Copy_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Copy();
      return true;
    }
    case internal::kFrameInputHandler_CopyToFindPboard_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::CopyToFindPboard",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::CopyToFindPboard");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_CopyToFindPboard_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_CopyToFindPboard_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      FrameInputHandler_CopyToFindPboard_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CopyToFindPboard();
      return true;
    }
    case internal::kFrameInputHandler_Paste_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::Paste",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::Paste");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_Paste_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_Paste_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      FrameInputHandler_Paste_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Paste();
      return true;
    }
    case internal::kFrameInputHandler_PasteAndMatchStyle_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::PasteAndMatchStyle",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::PasteAndMatchStyle");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_PasteAndMatchStyle_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_PasteAndMatchStyle_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      FrameInputHandler_PasteAndMatchStyle_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PasteAndMatchStyle();
      return true;
    }
    case internal::kFrameInputHandler_Delete_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::Delete",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::Delete");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_Delete_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_Delete_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      FrameInputHandler_Delete_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Delete();
      return true;
    }
    case internal::kFrameInputHandler_SelectAll_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::SelectAll",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::SelectAll");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_SelectAll_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_SelectAll_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      FrameInputHandler_SelectAll_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 14, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SelectAll();
      return true;
    }
    case internal::kFrameInputHandler_CollapseSelection_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::CollapseSelection",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::CollapseSelection");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_CollapseSelection_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_CollapseSelection_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      FrameInputHandler_CollapseSelection_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 15, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CollapseSelection();
      return true;
    }
    case internal::kFrameInputHandler_Replace_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::Replace",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::Replace");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_Replace_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_Replace_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::base::string16 p_word{};
      FrameInputHandler_Replace_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadWord(&p_word))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 16, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Replace(
std::move(p_word));
      return true;
    }
    case internal::kFrameInputHandler_ReplaceMisspelling_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::ReplaceMisspelling",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::ReplaceMisspelling");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_ReplaceMisspelling_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_ReplaceMisspelling_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::base::string16 p_word{};
      FrameInputHandler_ReplaceMisspelling_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadWord(&p_word))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 17, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ReplaceMisspelling(
std::move(p_word));
      return true;
    }
    case internal::kFrameInputHandler_SelectRange_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::SelectRange",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::SelectRange");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_SelectRange_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_SelectRange_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::gfx::Point p_base{};
      ::gfx::Point p_extent{};
      FrameInputHandler_SelectRange_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadBase(&p_base))
        success = false;
      if (success && !input_data_view.ReadExtent(&p_extent))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 18, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SelectRange(
std::move(p_base), 
std::move(p_extent));
      return true;
    }
    case internal::kFrameInputHandler_AdjustSelectionByCharacterOffset_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::AdjustSelectionByCharacterOffset",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::AdjustSelectionByCharacterOffset");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_AdjustSelectionByCharacterOffset_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_AdjustSelectionByCharacterOffset_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      int32_t p_start{};
      int32_t p_end{};
      ::blink::mojom::SelectionMenuBehavior p_behavior{};
      FrameInputHandler_AdjustSelectionByCharacterOffset_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_start = input_data_view.start();
      if (success)
        p_end = input_data_view.end();
      if (success && !input_data_view.ReadBehavior(&p_behavior))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 19, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AdjustSelectionByCharacterOffset(
std::move(p_start), 
std::move(p_end), 
std::move(p_behavior));
      return true;
    }
    case internal::kFrameInputHandler_SelectWordAroundCaret_Name: {
      break;
    }
    case internal::kFrameInputHandler_MoveRangeSelectionExtent_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::MoveRangeSelectionExtent",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::MoveRangeSelectionExtent");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_MoveRangeSelectionExtent_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_MoveRangeSelectionExtent_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::gfx::Point p_extent{};
      FrameInputHandler_MoveRangeSelectionExtent_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadExtent(&p_extent))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 21, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->MoveRangeSelectionExtent(
std::move(p_extent));
      return true;
    }
    case internal::kFrameInputHandler_ScrollFocusedEditableNodeIntoRect_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::ScrollFocusedEditableNodeIntoRect",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::ScrollFocusedEditableNodeIntoRect");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_ScrollFocusedEditableNodeIntoRect_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_ScrollFocusedEditableNodeIntoRect_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::gfx::Rect p_rect{};
      FrameInputHandler_ScrollFocusedEditableNodeIntoRect_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadRect(&p_rect))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 22, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ScrollFocusedEditableNodeIntoRect(
std::move(p_rect));
      return true;
    }
    case internal::kFrameInputHandler_MoveCaret_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::MoveCaret",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::MoveCaret");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_MoveCaret_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_MoveCaret_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      ::gfx::Point p_point{};
      FrameInputHandler_MoveCaret_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadPoint(&p_point))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 23, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->MoveCaret(
std::move(p_point));
      return true;
    }
    case internal::kFrameInputHandler_GetWidgetInputHandler_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::GetWidgetInputHandler",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::GetWidgetInputHandler");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      DCHECK(message->is_serialized());
      internal::FrameInputHandler_GetWidgetInputHandler_Params_Data* params =
          reinterpret_cast<internal::FrameInputHandler_GetWidgetInputHandler_Params_Data*>(
              message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      mojo::PendingAssociatedReceiver<WidgetInputHandler> p_interface_request{};
      mojo::PendingRemote<WidgetInputHandlerHost> p_host{};
      FrameInputHandler_GetWidgetInputHandler_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success) {
        p_interface_request =
            input_data_view.TakeInterfaceRequest<decltype(p_interface_request)>();
      }
      if (success) {
        p_host =
            input_data_view.TakeHost<decltype(p_host)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 24, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetWidgetInputHandler(
std::move(p_interface_request), 
std::move(p_host));
      return true;
    }
  }
  return false;
}

// static
bool FrameInputHandlerStubDispatch::AcceptWithResponder(
    FrameInputHandler* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  switch (message->header()->name) {
    case internal::kFrameInputHandler_SetCompositionFromExistingText_Name: {
      break;
    }
    case internal::kFrameInputHandler_ExtendSelectionAndDelete_Name: {
      break;
    }
    case internal::kFrameInputHandler_DeleteSurroundingText_Name: {
      break;
    }
    case internal::kFrameInputHandler_DeleteSurroundingTextInCodePoints_Name: {
      break;
    }
    case internal::kFrameInputHandler_SetEditableSelectionOffsets_Name: {
      break;
    }
    case internal::kFrameInputHandler_ExecuteEditCommand_Name: {
      break;
    }
    case internal::kFrameInputHandler_Undo_Name: {
      break;
    }
    case internal::kFrameInputHandler_Redo_Name: {
      break;
    }
    case internal::kFrameInputHandler_Cut_Name: {
      break;
    }
    case internal::kFrameInputHandler_Copy_Name: {
      break;
    }
    case internal::kFrameInputHandler_CopyToFindPboard_Name: {
      break;
    }
    case internal::kFrameInputHandler_Paste_Name: {
      break;
    }
    case internal::kFrameInputHandler_PasteAndMatchStyle_Name: {
      break;
    }
    case internal::kFrameInputHandler_Delete_Name: {
      break;
    }
    case internal::kFrameInputHandler_SelectAll_Name: {
      break;
    }
    case internal::kFrameInputHandler_CollapseSelection_Name: {
      break;
    }
    case internal::kFrameInputHandler_Replace_Name: {
      break;
    }
    case internal::kFrameInputHandler_ReplaceMisspelling_Name: {
      break;
    }
    case internal::kFrameInputHandler_SelectRange_Name: {
      break;
    }
    case internal::kFrameInputHandler_AdjustSelectionByCharacterOffset_Name: {
      break;
    }
    case internal::kFrameInputHandler_SelectWordAroundCaret_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)content::mojom::FrameInputHandler::SelectWordAroundCaret",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)content::mojom::FrameInputHandler::SelectWordAroundCaret");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      mojo::internal::MessageDispatchContext dispatch_context(message);

      internal::FrameInputHandler_SelectWordAroundCaret_Params_Data* params =
          reinterpret_cast<
              internal::FrameInputHandler_SelectWordAroundCaret_Params_Data*>(
                  message->mutable_payload());
      
      mojo::internal::SerializationContext serialization_context;
      serialization_context.TakeHandlesFromMessage(message);
      bool success = true;
      FrameInputHandler_SelectWordAroundCaret_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameInputHandler::Name_, 20, false);
        return false;
      }
      FrameInputHandler::SelectWordAroundCaretCallback callback =
          FrameInputHandler_SelectWordAroundCaret_ProxyToResponder::CreateCallback(
              message->request_id(),
              message->has_flag(mojo::Message::kFlagIsSync),
              std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SelectWordAroundCaret(std::move(callback));
      return true;
    }
    case internal::kFrameInputHandler_MoveRangeSelectionExtent_Name: {
      break;
    }
    case internal::kFrameInputHandler_ScrollFocusedEditableNodeIntoRect_Name: {
      break;
    }
    case internal::kFrameInputHandler_MoveCaret_Name: {
      break;
    }
    case internal::kFrameInputHandler_GetWidgetInputHandler_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kFrameInputHandlerValidationInfo[] = {
    {&internal::FrameInputHandler_SetCompositionFromExistingText_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_ExtendSelectionAndDelete_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_DeleteSurroundingText_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_DeleteSurroundingTextInCodePoints_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_SetEditableSelectionOffsets_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_ExecuteEditCommand_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_Undo_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_Redo_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_Cut_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_Copy_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_CopyToFindPboard_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_Paste_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_PasteAndMatchStyle_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_Delete_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_SelectAll_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_CollapseSelection_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_Replace_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_ReplaceMisspelling_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_SelectRange_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_AdjustSelectionByCharacterOffset_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_SelectWordAroundCaret_Params_Data::Validate,
     &internal::FrameInputHandler_SelectWordAroundCaret_ResponseParams_Data::Validate},
    {&internal::FrameInputHandler_MoveRangeSelectionExtent_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_ScrollFocusedEditableNodeIntoRect_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_MoveCaret_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameInputHandler_GetWidgetInputHandler_Params_Data::Validate,
     nullptr /* no response */},
};

bool FrameInputHandlerRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::content::mojom::FrameInputHandler::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kFrameInputHandlerValidationInfo);
}

bool FrameInputHandlerResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::content::mojom::FrameInputHandler::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kFrameInputHandlerValidationInfo);
}
}  // namespace mojom
}  // namespace content

namespace mojo {


// static
bool StructTraits<::content::mojom::KeyData::DataView, ::content::mojom::KeyDataPtr>::Read(
    ::content::mojom::KeyData::DataView input,
    ::content::mojom::KeyDataPtr* output) {
  bool success = true;
  ::content::mojom::KeyDataPtr result(::content::mojom::KeyData::New());
  
      if (success)
        result->dom_key = input.dom_key();
      if (success)
        result->dom_code = input.dom_code();
      if (success)
        result->windows_key_code = input.windows_key_code();
      if (success)
        result->native_key_code = input.native_key_code();
      if (success)
        result->is_system_key = input.is_system_key();
      if (success)
        result->is_browser_shortcut = input.is_browser_shortcut();
      if (success && !input.ReadText(&result->text))
        success = false;
      if (success && !input.ReadUnmodifiedText(&result->unmodified_text))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::content::mojom::PointerData::DataView, ::content::mojom::PointerDataPtr>::Read(
    ::content::mojom::PointerData::DataView input,
    ::content::mojom::PointerDataPtr* output) {
  bool success = true;
  ::content::mojom::PointerDataPtr result(::content::mojom::PointerData::New());
  
      if (success)
        result->pointer_id = input.pointer_id();
      if (success)
        result->force = input.force();
      if (success)
        result->tilt_x = input.tilt_x();
      if (success)
        result->tilt_y = input.tilt_y();
      if (success)
        result->tangential_pressure = input.tangential_pressure();
      if (success)
        result->twist = input.twist();
      if (success && !input.ReadButton(&result->button))
        success = false;
      if (success && !input.ReadPointerType(&result->pointer_type))
        success = false;
      if (success)
        result->movement_x = input.movement_x();
      if (success)
        result->movement_y = input.movement_y();
      if (success)
        result->is_raw_movement_event = input.is_raw_movement_event();
      if (success && !input.ReadWidgetPosition(&result->widget_position))
        success = false;
      if (success && !input.ReadScreenPosition(&result->screen_position))
        success = false;
      if (success && !input.ReadMouseData(&result->mouse_data))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::content::mojom::WheelData::DataView, ::content::mojom::WheelDataPtr>::Read(
    ::content::mojom::WheelData::DataView input,
    ::content::mojom::WheelDataPtr* output) {
  bool success = true;
  ::content::mojom::WheelDataPtr result(::content::mojom::WheelData::New());
  
      if (success)
        result->delta_x = input.delta_x();
      if (success)
        result->delta_y = input.delta_y();
      if (success)
        result->wheel_ticks_x = input.wheel_ticks_x();
      if (success)
        result->wheel_ticks_y = input.wheel_ticks_y();
      if (success)
        result->acceleration_ratio_x = input.acceleration_ratio_x();
      if (success)
        result->acceleration_ratio_y = input.acceleration_ratio_y();
      if (success)
        result->phase = input.phase();
      if (success)
        result->momentum_phase = input.momentum_phase();
      if (success && !input.ReadCancelable(&result->cancelable))
        success = false;
      if (success)
        result->event_action = input.event_action();
      if (success)
        result->delta_units = input.delta_units();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::content::mojom::MouseData::DataView, ::content::mojom::MouseDataPtr>::Read(
    ::content::mojom::MouseData::DataView input,
    ::content::mojom::MouseDataPtr* output) {
  bool success = true;
  ::content::mojom::MouseDataPtr result(::content::mojom::MouseData::New());
  
      if (success)
        result->click_count = input.click_count();
      if (success && !input.ReadWheelData(&result->wheel_data))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::content::mojom::ScrollUpdate::DataView, ::content::mojom::ScrollUpdatePtr>::Read(
    ::content::mojom::ScrollUpdate::DataView input,
    ::content::mojom::ScrollUpdatePtr* output) {
  bool success = true;
  ::content::mojom::ScrollUpdatePtr result(::content::mojom::ScrollUpdate::New());
  
      if (success)
        result->velocity_x = input.velocity_x();
      if (success)
        result->velocity_y = input.velocity_y();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::content::mojom::ScrollData::DataView, ::content::mojom::ScrollDataPtr>::Read(
    ::content::mojom::ScrollData::DataView input,
    ::content::mojom::ScrollDataPtr* output) {
  bool success = true;
  ::content::mojom::ScrollDataPtr result(::content::mojom::ScrollData::New());
  
      if (success)
        result->delta_x = input.delta_x();
      if (success)
        result->delta_y = input.delta_y();
      if (success && !input.ReadDeltaUnits(&result->delta_units))
        success = false;
      if (success)
        result->target_viewport = input.target_viewport();
      if (success && !input.ReadInertialPhase(&result->inertial_phase))
        success = false;
      if (success)
        result->synthetic = input.synthetic();
      if (success)
        result->pointer_count = input.pointer_count();
      if (success && !input.ReadUpdateDetails(&result->update_details))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::content::mojom::PinchBeginData::DataView, ::content::mojom::PinchBeginDataPtr>::Read(
    ::content::mojom::PinchBeginData::DataView input,
    ::content::mojom::PinchBeginDataPtr* output) {
  bool success = true;
  ::content::mojom::PinchBeginDataPtr result(::content::mojom::PinchBeginData::New());
  
      if (success)
        result->needs_wheel_event = input.needs_wheel_event();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::content::mojom::PinchUpdateData::DataView, ::content::mojom::PinchUpdateDataPtr>::Read(
    ::content::mojom::PinchUpdateData::DataView input,
    ::content::mojom::PinchUpdateDataPtr* output) {
  bool success = true;
  ::content::mojom::PinchUpdateDataPtr result(::content::mojom::PinchUpdateData::New());
  
      if (success)
        result->scale = input.scale();
      if (success)
        result->zoom_disabled = input.zoom_disabled();
      if (success)
        result->needs_wheel_event = input.needs_wheel_event();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::content::mojom::PinchEndData::DataView, ::content::mojom::PinchEndDataPtr>::Read(
    ::content::mojom::PinchEndData::DataView input,
    ::content::mojom::PinchEndDataPtr* output) {
  bool success = true;
  ::content::mojom::PinchEndDataPtr result(::content::mojom::PinchEndData::New());
  
      if (success)
        result->needs_wheel_event = input.needs_wheel_event();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::content::mojom::FlingData::DataView, ::content::mojom::FlingDataPtr>::Read(
    ::content::mojom::FlingData::DataView input,
    ::content::mojom::FlingDataPtr* output) {
  bool success = true;
  ::content::mojom::FlingDataPtr result(::content::mojom::FlingData::New());
  
      if (success)
        result->velocity_x = input.velocity_x();
      if (success)
        result->velocity_y = input.velocity_y();
      if (success)
        result->target_viewport = input.target_viewport();
      if (success)
        result->prevent_boosting = input.prevent_boosting();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::content::mojom::TapData::DataView, ::content::mojom::TapDataPtr>::Read(
    ::content::mojom::TapData::DataView input,
    ::content::mojom::TapDataPtr* output) {
  bool success = true;
  ::content::mojom::TapDataPtr result(::content::mojom::TapData::New());
  
      if (success)
        result->tap_count = input.tap_count();
      if (success)
        result->needs_wheel_event = input.needs_wheel_event();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::content::mojom::GestureData::DataView, ::content::mojom::GestureDataPtr>::Read(
    ::content::mojom::GestureData::DataView input,
    ::content::mojom::GestureDataPtr* output) {
  bool success = true;
  ::content::mojom::GestureDataPtr result(::content::mojom::GestureData::New());
  
      if (success && !input.ReadScreenPosition(&result->screen_position))
        success = false;
      if (success && !input.ReadWidgetPosition(&result->widget_position))
        success = false;
      if (success && !input.ReadSourceDevice(&result->source_device))
        success = false;
      if (success)
        result->is_source_touch_event_set_non_blocking = input.is_source_touch_event_set_non_blocking();
      if (success && !input.ReadPrimaryPointerType(&result->primary_pointer_type))
        success = false;
      if (success)
        result->unique_touch_event_id = input.unique_touch_event_id();
      if (success && !input.ReadContactSize(&result->contact_size))
        success = false;
      if (success && !input.ReadScrollData(&result->scroll_data))
        success = false;
      if (success && !input.ReadPinchBeginData(&result->pinch_begin_data))
        success = false;
      if (success && !input.ReadPinchUpdateData(&result->pinch_update_data))
        success = false;
      if (success && !input.ReadPinchEndData(&result->pinch_end_data))
        success = false;
      if (success && !input.ReadTapData(&result->tap_data))
        success = false;
      if (success && !input.ReadFlingData(&result->fling_data))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::content::mojom::TouchPoint::DataView, ::content::mojom::TouchPointPtr>::Read(
    ::content::mojom::TouchPoint::DataView input,
    ::content::mojom::TouchPointPtr* output) {
  bool success = true;
  ::content::mojom::TouchPointPtr result(::content::mojom::TouchPoint::New());
  
      if (success && !input.ReadState(&result->state))
        success = false;
      if (success)
        result->radius_x = input.radius_x();
      if (success)
        result->radius_y = input.radius_y();
      if (success)
        result->rotation_angle = input.rotation_angle();
      if (success && !input.ReadPointerData(&result->pointer_data))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::content::mojom::TouchData::DataView, ::content::mojom::TouchDataPtr>::Read(
    ::content::mojom::TouchData::DataView input,
    ::content::mojom::TouchDataPtr* output) {
  bool success = true;
  ::content::mojom::TouchDataPtr result(::content::mojom::TouchData::New());
  
      if (success && !input.ReadCancelable(&result->cancelable))
        success = false;
      if (success)
        result->moved_beyond_slop_region = input.moved_beyond_slop_region();
      if (success)
        result->touch_start_or_first_move = input.touch_start_or_first_move();
      if (success)
        result->hovering = input.hovering();
      if (success)
        result->unique_touch_event_id = input.unique_touch_event_id();
      if (success && !input.ReadTouches(&result->touches))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::content::mojom::Event::DataView, ::content::mojom::EventPtr>::Read(
    ::content::mojom::Event::DataView input,
    ::content::mojom::EventPtr* output) {
  bool success = true;
  ::content::mojom::EventPtr result(::content::mojom::Event::New());
  
      if (success && !input.ReadType(&result->type))
        success = false;
      if (success)
        result->modifiers = input.modifiers();
      if (success && !input.ReadTimestamp(&result->timestamp))
        success = false;
      if (success && !input.ReadLatency(&result->latency))
        success = false;
      if (success && !input.ReadKeyData(&result->key_data))
        success = false;
      if (success && !input.ReadPointerData(&result->pointer_data))
        success = false;
      if (success && !input.ReadGestureData(&result->gesture_data))
        success = false;
      if (success && !input.ReadTouchData(&result->touch_data))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::content::mojom::TouchActionOptional::DataView, ::content::mojom::TouchActionOptionalPtr>::Read(
    ::content::mojom::TouchActionOptional::DataView input,
    ::content::mojom::TouchActionOptionalPtr* output) {
  bool success = true;
  ::content::mojom::TouchActionOptionalPtr result(::content::mojom::TouchActionOptional::New());
  
      if (success && !input.ReadTouchAction(&result->touch_action))
        success = false;
  *output = std::move(result);
  return success;
}

}  // namespace mojo

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif