// content/common/input/input_injector.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif


#include "content/common/input/input_injector.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"
#include "content/common/native_types.mojom.h"


#ifndef CONTENT_COMMON_INPUT_INPUT_INJECTOR_MOJOM_JUMBO_H_
#define CONTENT_COMMON_INPUT_INPUT_INJECTOR_MOJOM_JUMBO_H_
#include "content/common/frame_messages.h"
#include "content/common/input/input_event_mojom_traits.h"
#include "content/common/input/touch_action_optional_mojom_traits.h"
#include "content/common/input_messages.h"
#include "content/common/view_messages.h"
#include "content/common/widget_messages.h"
#include "content/public/common/common_param_traits.h"
#include "services/network/public/cpp/p2p_param_traits.h"
#endif


namespace content {
namespace mojom {


void InputInjectorInterceptorForTesting::QueueSyntheticSmoothDrag(const ::content::SyntheticSmoothDragGestureParams& drag, QueueSyntheticSmoothDragCallback callback) {
  GetForwardingInterface()->QueueSyntheticSmoothDrag(std::move(drag), std::move(callback));
}
void InputInjectorInterceptorForTesting::QueueSyntheticSmoothScroll(const ::content::SyntheticSmoothScrollGestureParams& scroll, QueueSyntheticSmoothScrollCallback callback) {
  GetForwardingInterface()->QueueSyntheticSmoothScroll(std::move(scroll), std::move(callback));
}
void InputInjectorInterceptorForTesting::QueueSyntheticPinch(const ::content::SyntheticPinchGestureParams& pinch, QueueSyntheticPinchCallback callback) {
  GetForwardingInterface()->QueueSyntheticPinch(std::move(pinch), std::move(callback));
}
void InputInjectorInterceptorForTesting::QueueSyntheticTap(const ::content::SyntheticTapGestureParams& tap, QueueSyntheticTapCallback callback) {
  GetForwardingInterface()->QueueSyntheticTap(std::move(tap), std::move(callback));
}
void InputInjectorInterceptorForTesting::QueueSyntheticPointerAction(const ::content::SyntheticPointerActionListParams& pointer_action, QueueSyntheticPointerActionCallback callback) {
  GetForwardingInterface()->QueueSyntheticPointerAction(std::move(pointer_action), std::move(callback));
}
InputInjectorAsyncWaiter::InputInjectorAsyncWaiter(
    InputInjector* proxy) : proxy_(proxy) {}

InputInjectorAsyncWaiter::~InputInjectorAsyncWaiter() = default;

void InputInjectorAsyncWaiter::QueueSyntheticSmoothDrag(
    const ::content::SyntheticSmoothDragGestureParams& drag) {
  base::RunLoop loop;
  proxy_->QueueSyntheticSmoothDrag(std::move(drag),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void InputInjectorAsyncWaiter::QueueSyntheticSmoothScroll(
    const ::content::SyntheticSmoothScrollGestureParams& scroll) {
  base::RunLoop loop;
  proxy_->QueueSyntheticSmoothScroll(std::move(scroll),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void InputInjectorAsyncWaiter::QueueSyntheticPinch(
    const ::content::SyntheticPinchGestureParams& pinch) {
  base::RunLoop loop;
  proxy_->QueueSyntheticPinch(std::move(pinch),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void InputInjectorAsyncWaiter::QueueSyntheticTap(
    const ::content::SyntheticTapGestureParams& tap) {
  base::RunLoop loop;
  proxy_->QueueSyntheticTap(std::move(tap),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void InputInjectorAsyncWaiter::QueueSyntheticPointerAction(
    const ::content::SyntheticPointerActionListParams& pointer_action) {
  base::RunLoop loop;
  proxy_->QueueSyntheticPointerAction(std::move(pointer_action),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}





}  // namespace mojom
}  // namespace content

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif