// content/common/input/input_handler.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif


#include "content/common/input/input_handler.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"
#include "cc/mojom/touch_action.mojom.h"
#include "content/common/input/synchronous_compositor.mojom.h"
#include "content/common/native_types.mojom.h"
#include "mojo/public/mojom/base/string16.mojom.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "third_party/blink/public/mojom/selection_menu/selection_menu_behavior.mojom.h"
#include "ui/base/ime/mojom/ime_types.mojom.h"
#include "ui/events/mojom/event.mojom.h"
#include "ui/events/mojom/event_constants.mojom.h"
#include "ui/events/mojom/scroll_granularity.mojom.h"
#include "ui/gfx/geometry/mojom/geometry.mojom.h"
#include "ui/gfx/range/mojom/range.mojom.h"
#include "ui/latency/mojom/latency_info.mojom.h"


#ifndef CONTENT_COMMON_INPUT_INPUT_HANDLER_MOJOM_JUMBO_H_
#define CONTENT_COMMON_INPUT_INPUT_HANDLER_MOJOM_JUMBO_H_
#include "cc/ipc/cc_param_traits_macros.h"
#include "content/common/frame_messages.h"
#include "content/common/input/input_event_mojom_traits.h"
#include "content/common/input/touch_action_optional_mojom_traits.h"
#include "content/common/input_messages.h"
#include "content/common/view_messages.h"
#include "content/common/widget_messages.h"
#include "content/public/common/common_param_traits.h"
#include "mojo/public/cpp/base/string16_mojom_traits.h"
#include "mojo/public/cpp/base/time_mojom_traits.h"
#include "services/network/public/cpp/p2p_param_traits.h"
#include "ui/base/ime/mojom/ime_types_mojom_traits.h"
#include "ui/events/ipc/ui_events_param_traits_macros.h"
#include "ui/gfx/geometry/mojom/geometry_mojom_traits.h"
#include "ui/gfx/range/mojom/range_mojom_traits.h"
#include "ui/latency/mojom/latency_info_mojom_traits.h"
#endif


namespace content {
namespace mojom {


void WidgetInputHandlerHostInterceptorForTesting::FallbackCursorModeLockCursor(bool left, bool right, bool up, bool down) {
  GetForwardingInterface()->FallbackCursorModeLockCursor(std::move(left), std::move(right), std::move(up), std::move(down));
}
void WidgetInputHandlerHostInterceptorForTesting::FallbackCursorModeSetCursorVisibility(bool visible) {
  GetForwardingInterface()->FallbackCursorModeSetCursorVisibility(std::move(visible));
}
void WidgetInputHandlerHostInterceptorForTesting::SetTouchActionFromMain(::cc::TouchAction touch_action) {
  GetForwardingInterface()->SetTouchActionFromMain(std::move(touch_action));
}
void WidgetInputHandlerHostInterceptorForTesting::SetWhiteListedTouchAction(::cc::TouchAction touch_action, uint32_t unique_touch_event_id, ::content::InputEventAckState state) {
  GetForwardingInterface()->SetWhiteListedTouchAction(std::move(touch_action), std::move(unique_touch_event_id), std::move(state));
}
void WidgetInputHandlerHostInterceptorForTesting::DidOverscroll(const ::ui::DidOverscrollParams& params) {
  GetForwardingInterface()->DidOverscroll(std::move(params));
}
void WidgetInputHandlerHostInterceptorForTesting::DidStartScrollingViewport() {
  GetForwardingInterface()->DidStartScrollingViewport();
}
void WidgetInputHandlerHostInterceptorForTesting::ImeCancelComposition() {
  GetForwardingInterface()->ImeCancelComposition();
}
void WidgetInputHandlerHostInterceptorForTesting::ImeCompositionRangeChanged(const ::gfx::Range& range, const std::vector<::gfx::Rect>& bounds) {
  GetForwardingInterface()->ImeCompositionRangeChanged(std::move(range), std::move(bounds));
}
void WidgetInputHandlerHostInterceptorForTesting::SetMouseCapture(bool capture) {
  GetForwardingInterface()->SetMouseCapture(std::move(capture));
}
WidgetInputHandlerHostAsyncWaiter::WidgetInputHandlerHostAsyncWaiter(
    WidgetInputHandlerHost* proxy) : proxy_(proxy) {}

WidgetInputHandlerHostAsyncWaiter::~WidgetInputHandlerHostAsyncWaiter() = default;




void WidgetInputHandlerInterceptorForTesting::SetFocus(bool focused) {
  GetForwardingInterface()->SetFocus(std::move(focused));
}
void WidgetInputHandlerInterceptorForTesting::MouseCaptureLost() {
  GetForwardingInterface()->MouseCaptureLost();
}
void WidgetInputHandlerInterceptorForTesting::SetEditCommandsForNextKeyEvent(const std::vector<::content::EditCommand>& commands) {
  GetForwardingInterface()->SetEditCommandsForNextKeyEvent(std::move(commands));
}
void WidgetInputHandlerInterceptorForTesting::CursorVisibilityChanged(bool visible) {
  GetForwardingInterface()->CursorVisibilityChanged(std::move(visible));
}
void WidgetInputHandlerInterceptorForTesting::FallbackCursorModeToggled(bool is_on) {
  GetForwardingInterface()->FallbackCursorModeToggled(std::move(is_on));
}
void WidgetInputHandlerInterceptorForTesting::ImeSetComposition(const ::base::string16& text, const std::vector<::ui::ImeTextSpan>& ime_text_spans, const ::gfx::Range& range, int32_t start, int32_t end) {
  GetForwardingInterface()->ImeSetComposition(std::move(text), std::move(ime_text_spans), std::move(range), std::move(start), std::move(end));
}
void WidgetInputHandlerInterceptorForTesting::ImeCommitText(const ::base::string16& text, const std::vector<::ui::ImeTextSpan>& ime_text_spans, const ::gfx::Range& range, int32_t relative_cursor_position, ImeCommitTextCallback callback) {
  GetForwardingInterface()->ImeCommitText(std::move(text), std::move(ime_text_spans), std::move(range), std::move(relative_cursor_position), std::move(callback));
}
void WidgetInputHandlerInterceptorForTesting::ImeFinishComposingText(bool keep_selection) {
  GetForwardingInterface()->ImeFinishComposingText(std::move(keep_selection));
}
void WidgetInputHandlerInterceptorForTesting::RequestTextInputStateUpdate() {
  GetForwardingInterface()->RequestTextInputStateUpdate();
}
void WidgetInputHandlerInterceptorForTesting::RequestCompositionUpdates(bool immediate_request, bool monitor_request) {
  GetForwardingInterface()->RequestCompositionUpdates(std::move(immediate_request), std::move(monitor_request));
}
void WidgetInputHandlerInterceptorForTesting::DispatchEvent(::std::unique_ptr<::content::InputEvent> event, DispatchEventCallback callback) {
  GetForwardingInterface()->DispatchEvent(std::move(event), std::move(callback));
}
void WidgetInputHandlerInterceptorForTesting::DispatchNonBlockingEvent(::std::unique_ptr<::content::InputEvent> event) {
  GetForwardingInterface()->DispatchNonBlockingEvent(std::move(event));
}
void WidgetInputHandlerInterceptorForTesting::WaitForInputProcessed(WaitForInputProcessedCallback callback) {
  GetForwardingInterface()->WaitForInputProcessed(std::move(callback));
}
void WidgetInputHandlerInterceptorForTesting::AttachSynchronousCompositor(mojo::PendingRemote<::content::mojom::SynchronousCompositorControlHost> control_host, mojo::PendingAssociatedRemote<::content::mojom::SynchronousCompositorHost> host, mojo::PendingAssociatedReceiver<::content::mojom::SynchronousCompositor> compositor_request) {
  GetForwardingInterface()->AttachSynchronousCompositor(std::move(control_host), std::move(host), std::move(compositor_request));
}
WidgetInputHandlerAsyncWaiter::WidgetInputHandlerAsyncWaiter(
    WidgetInputHandler* proxy) : proxy_(proxy) {}

WidgetInputHandlerAsyncWaiter::~WidgetInputHandlerAsyncWaiter() = default;

void WidgetInputHandlerAsyncWaiter::ImeCommitText(
    const ::base::string16& text, const std::vector<::ui::ImeTextSpan>& ime_text_spans, const ::gfx::Range& range, int32_t relative_cursor_position) {
  base::RunLoop loop;
  proxy_->ImeCommitText(std::move(text),std::move(ime_text_spans),std::move(range),std::move(relative_cursor_position),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void WidgetInputHandlerAsyncWaiter::DispatchEvent(
    ::std::unique_ptr<::content::InputEvent> event, ::content::InputEventAckSource* out_source, ::ui::LatencyInfo* out_updated_latency, ::content::InputEventAckState* out_state, base::Optional<::ui::DidOverscrollParams>* out_overscroll, base::Optional<::cc::TouchAction>* out_touch_action) {
  base::RunLoop loop;
  proxy_->DispatchEvent(std::move(event),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::content::InputEventAckSource* out_source
,
             ::ui::LatencyInfo* out_updated_latency
,
             ::content::InputEventAckState* out_state
,
             base::Optional<::ui::DidOverscrollParams>* out_overscroll
,
             base::Optional<::cc::TouchAction>* out_touch_action
,
             ::content::InputEventAckSource source,
             const ::ui::LatencyInfo& updated_latency,
             ::content::InputEventAckState state,
             const base::Optional<::ui::DidOverscrollParams>& overscroll,
             const base::Optional<::cc::TouchAction>& touch_action) {*out_source = std::move(source);*out_updated_latency = std::move(updated_latency);*out_state = std::move(state);*out_overscroll = std::move(overscroll);*out_touch_action = std::move(touch_action);
            loop->Quit();
          },
          &loop,
          out_source,
          out_updated_latency,
          out_state,
          out_overscroll,
          out_touch_action));
  loop.Run();
}
void WidgetInputHandlerAsyncWaiter::WaitForInputProcessed(
    ) {
  base::RunLoop loop;
  proxy_->WaitForInputProcessed(
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}



void FrameInputHandlerInterceptorForTesting::SetCompositionFromExistingText(int32_t start, int32_t end, const std::vector<::ui::ImeTextSpan>& ime_text_spans) {
  GetForwardingInterface()->SetCompositionFromExistingText(std::move(start), std::move(end), std::move(ime_text_spans));
}
void FrameInputHandlerInterceptorForTesting::ExtendSelectionAndDelete(int32_t before, int32_t after) {
  GetForwardingInterface()->ExtendSelectionAndDelete(std::move(before), std::move(after));
}
void FrameInputHandlerInterceptorForTesting::DeleteSurroundingText(int32_t before, int32_t after) {
  GetForwardingInterface()->DeleteSurroundingText(std::move(before), std::move(after));
}
void FrameInputHandlerInterceptorForTesting::DeleteSurroundingTextInCodePoints(int32_t before, int32_t after) {
  GetForwardingInterface()->DeleteSurroundingTextInCodePoints(std::move(before), std::move(after));
}
void FrameInputHandlerInterceptorForTesting::SetEditableSelectionOffsets(int32_t start, int32_t end) {
  GetForwardingInterface()->SetEditableSelectionOffsets(std::move(start), std::move(end));
}
void FrameInputHandlerInterceptorForTesting::ExecuteEditCommand(const std::string& command, const base::Optional<::base::string16>& value) {
  GetForwardingInterface()->ExecuteEditCommand(std::move(command), std::move(value));
}
void FrameInputHandlerInterceptorForTesting::Undo() {
  GetForwardingInterface()->Undo();
}
void FrameInputHandlerInterceptorForTesting::Redo() {
  GetForwardingInterface()->Redo();
}
void FrameInputHandlerInterceptorForTesting::Cut() {
  GetForwardingInterface()->Cut();
}
void FrameInputHandlerInterceptorForTesting::Copy() {
  GetForwardingInterface()->Copy();
}
void FrameInputHandlerInterceptorForTesting::CopyToFindPboard() {
  GetForwardingInterface()->CopyToFindPboard();
}
void FrameInputHandlerInterceptorForTesting::Paste() {
  GetForwardingInterface()->Paste();
}
void FrameInputHandlerInterceptorForTesting::PasteAndMatchStyle() {
  GetForwardingInterface()->PasteAndMatchStyle();
}
void FrameInputHandlerInterceptorForTesting::Delete() {
  GetForwardingInterface()->Delete();
}
void FrameInputHandlerInterceptorForTesting::SelectAll() {
  GetForwardingInterface()->SelectAll();
}
void FrameInputHandlerInterceptorForTesting::CollapseSelection() {
  GetForwardingInterface()->CollapseSelection();
}
void FrameInputHandlerInterceptorForTesting::Replace(const ::base::string16& word) {
  GetForwardingInterface()->Replace(std::move(word));
}
void FrameInputHandlerInterceptorForTesting::ReplaceMisspelling(const ::base::string16& word) {
  GetForwardingInterface()->ReplaceMisspelling(std::move(word));
}
void FrameInputHandlerInterceptorForTesting::SelectRange(const ::gfx::Point& base, const ::gfx::Point& extent) {
  GetForwardingInterface()->SelectRange(std::move(base), std::move(extent));
}
void FrameInputHandlerInterceptorForTesting::AdjustSelectionByCharacterOffset(int32_t start, int32_t end, ::blink::mojom::SelectionMenuBehavior behavior) {
  GetForwardingInterface()->AdjustSelectionByCharacterOffset(std::move(start), std::move(end), std::move(behavior));
}
void FrameInputHandlerInterceptorForTesting::SelectWordAroundCaret(SelectWordAroundCaretCallback callback) {
  GetForwardingInterface()->SelectWordAroundCaret(std::move(callback));
}
void FrameInputHandlerInterceptorForTesting::MoveRangeSelectionExtent(const ::gfx::Point& extent) {
  GetForwardingInterface()->MoveRangeSelectionExtent(std::move(extent));
}
void FrameInputHandlerInterceptorForTesting::ScrollFocusedEditableNodeIntoRect(const ::gfx::Rect& rect) {
  GetForwardingInterface()->ScrollFocusedEditableNodeIntoRect(std::move(rect));
}
void FrameInputHandlerInterceptorForTesting::MoveCaret(const ::gfx::Point& point) {
  GetForwardingInterface()->MoveCaret(std::move(point));
}
void FrameInputHandlerInterceptorForTesting::GetWidgetInputHandler(mojo::PendingAssociatedReceiver<WidgetInputHandler> interface_request, mojo::PendingRemote<WidgetInputHandlerHost> host) {
  GetForwardingInterface()->GetWidgetInputHandler(std::move(interface_request), std::move(host));
}
FrameInputHandlerAsyncWaiter::FrameInputHandlerAsyncWaiter(
    FrameInputHandler* proxy) : proxy_(proxy) {}

FrameInputHandlerAsyncWaiter::~FrameInputHandlerAsyncWaiter() = default;

void FrameInputHandlerAsyncWaiter::SelectWordAroundCaret(
    bool* out_did_select, int32_t* out_start_adjust, int32_t* out_end_adjust) {
  base::RunLoop loop;
  proxy_->SelectWordAroundCaret(
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_did_select
,
             int32_t* out_start_adjust
,
             int32_t* out_end_adjust
,
             bool did_select,
             int32_t start_adjust,
             int32_t end_adjust) {*out_did_select = std::move(did_select);*out_start_adjust = std::move(start_adjust);*out_end_adjust = std::move(end_adjust);
            loop->Quit();
          },
          &loop,
          out_did_select,
          out_start_adjust,
          out_end_adjust));
  loop.Run();
}





}  // namespace mojom
}  // namespace content

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif