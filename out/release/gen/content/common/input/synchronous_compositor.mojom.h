// content/common/input/synchronous_compositor.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CONTENT_COMMON_INPUT_SYNCHRONOUS_COMPOSITOR_MOJOM_H_
#define CONTENT_COMMON_INPUT_SYNCHRONOUS_COMPOSITOR_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "base/callback.h"
#include "base/macros.h"
#include "base/optional.h"

#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#if BUILDFLAG(MOJO_TRACE_ENABLED)
#include "base/trace_event/trace_event.h"
#endif
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"
#include "content/common/input/synchronous_compositor.mojom-shared.h"
#include "content/common/input/synchronous_compositor.mojom-forward.h"
#include "mojo/public/mojom/base/shared_memory.mojom-forward.h"
#include "mojo/public/mojom/base/time.mojom-forward.h"
#include "services/viz/public/mojom/compositing/begin_frame_args.mojom-forward.h"
#include "services/viz/public/mojom/compositing/compositor_frame.mojom-forward.h"
#include "services/viz/public/mojom/compositing/compositor_frame_metadata.mojom-forward.h"
#include "services/viz/public/mojom/compositing/frame_timing_details.mojom-forward.h"
#include "services/viz/public/mojom/compositing/returned_resource.mojom-forward.h"
#include "services/viz/public/mojom/hit_test/hit_test_region_list.mojom-forward.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-forward.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/associated_interface_ptr.h"
#include "mojo/public/cpp/bindings/associated_interface_ptr_info.h"
#include "mojo/public/cpp/bindings/associated_interface_request.h"
#include "mojo/public/cpp/bindings/interface_ptr.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"
#include "mojo/public/cpp/bindings/thread_safe_interface_ptr.h"


#include "mojo/public/cpp/bindings/lib/native_enum_serialization.h"
#include "mojo/public/cpp/bindings/lib/native_struct_serialization.h"
#include "content/common/input/sync_compositor_messages.h"
#include "content/common/content_export.h"




namespace content {
namespace mojom {

class SynchronousCompositorProxy;

template <typename ImplRefTraits>
class SynchronousCompositorStub;

class SynchronousCompositorRequestValidator;
class SynchronousCompositorResponseValidator;


class CONTENT_EXPORT SynchronousCompositor
    : public SynchronousCompositorInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = true;

  using Base_ = SynchronousCompositorInterfaceBase;
  using Proxy_ = SynchronousCompositorProxy;

  template <typename ImplRefTraits>
  using Stub_ = SynchronousCompositorStub<ImplRefTraits>;

  using RequestValidator_ = SynchronousCompositorRequestValidator;
  using ResponseValidator_ = SynchronousCompositorResponseValidator;
  enum MethodMinVersions : uint32_t {
    kDemandDrawHwAsyncMinVersion = 0,
    kDemandDrawHwMinVersion = 0,
    kSetSharedMemoryMinVersion = 0,
    kDemandDrawSwMinVersion = 0,
    kWillSkipDrawMinVersion = 0,
    kZeroSharedMemoryMinVersion = 0,
    kZoomByMinVersion = 0,
    kSetMemoryPolicyMinVersion = 0,
    kReclaimResourcesMinVersion = 0,
    kSetScrollMinVersion = 0,
    kBeginFrameMinVersion = 0,
    kSetBeginFrameSourcePausedMinVersion = 0,
  };
  virtual ~SynchronousCompositor() {}

  
  virtual void DemandDrawHwAsync(const ::content::SyncCompositorDemandDrawHwParams& draw_params) = 0;

  // Sync method. This signature is used by the client side; the service side
  // should implement the signature with callback below.
  
  virtual bool DemandDrawHw(const ::content::SyncCompositorDemandDrawHwParams& draw_params, ::content::SyncCompositorCommonRendererParams* out_result, uint32_t* out_layer_tree_frame_sink_id, uint32_t* out_metadata_version, base::Optional<::viz::CompositorFrame>* out_frame, base::Optional<::viz::HitTestRegionList>* out_hit_test_region_list);

  using DemandDrawHwCallback = base::OnceCallback<void(const ::content::SyncCompositorCommonRendererParams&, uint32_t, uint32_t, base::Optional<::viz::CompositorFrame>, base::Optional<::viz::HitTestRegionList>)>;
  
  virtual void DemandDrawHw(const ::content::SyncCompositorDemandDrawHwParams& draw_params, DemandDrawHwCallback callback) = 0;

  // Sync method. This signature is used by the client side; the service side
  // should implement the signature with callback below.
  
  virtual bool SetSharedMemory(::base::WritableSharedMemoryRegion shm_region, bool* out_success, ::content::SyncCompositorCommonRendererParams* out_result);

  using SetSharedMemoryCallback = base::OnceCallback<void(bool, const ::content::SyncCompositorCommonRendererParams&)>;
  
  virtual void SetSharedMemory(::base::WritableSharedMemoryRegion shm_region, SetSharedMemoryCallback callback) = 0;

  // Sync method. This signature is used by the client side; the service side
  // should implement the signature with callback below.
  
  virtual bool DemandDrawSw(const ::content::SyncCompositorDemandDrawSwParams& draw_params, ::content::SyncCompositorCommonRendererParams* out_result, uint32_t* out_metadata_version, base::Optional<::viz::CompositorFrameMetadata>* out_meta_data);

  using DemandDrawSwCallback = base::OnceCallback<void(const ::content::SyncCompositorCommonRendererParams&, uint32_t, base::Optional<::viz::CompositorFrameMetadata>)>;
  
  virtual void DemandDrawSw(const ::content::SyncCompositorDemandDrawSwParams& draw_params, DemandDrawSwCallback callback) = 0;

  
  virtual void WillSkipDraw() = 0;

  
  virtual void ZeroSharedMemory() = 0;

  // Sync method. This signature is used by the client side; the service side
  // should implement the signature with callback below.
  
  virtual bool ZoomBy(float delta, const ::gfx::Point& anchor, ::content::SyncCompositorCommonRendererParams* out_result);

  using ZoomByCallback = base::OnceCallback<void(const ::content::SyncCompositorCommonRendererParams&)>;
  
  virtual void ZoomBy(float delta, const ::gfx::Point& anchor, ZoomByCallback callback) = 0;

  
  virtual void SetMemoryPolicy(uint32_t bytes_limit) = 0;

  
  virtual void ReclaimResources(uint32_t layer_tree_frame_sink_id, const std::vector<::viz::ReturnedResource>& resources) = 0;

  
  virtual void SetScroll(const ::gfx::ScrollOffset& offset) = 0;

  
  virtual void BeginFrame(const ::viz::BeginFrameArgs& args, const base::flat_map<uint32_t, ::viz::FrameTimingDetails>& timing_details) = 0;

  
  virtual void SetBeginFrameSourcePaused(bool paused) = 0;
};

class SynchronousCompositorHostProxy;

template <typename ImplRefTraits>
class SynchronousCompositorHostStub;

class SynchronousCompositorHostRequestValidator;


class CONTENT_EXPORT SynchronousCompositorHost
    : public SynchronousCompositorHostInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = SynchronousCompositorHostInterfaceBase;
  using Proxy_ = SynchronousCompositorHostProxy;

  template <typename ImplRefTraits>
  using Stub_ = SynchronousCompositorHostStub<ImplRefTraits>;

  using RequestValidator_ = SynchronousCompositorHostRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kLayerTreeFrameSinkCreatedMinVersion = 0,
    kUpdateStateMinVersion = 0,
    kSetNeedsBeginFramesMinVersion = 0,
  };
  virtual ~SynchronousCompositorHost() {}

  
  virtual void LayerTreeFrameSinkCreated() = 0;

  
  virtual void UpdateState(const ::content::SyncCompositorCommonRendererParams& params) = 0;

  
  virtual void SetNeedsBeginFrames(bool needs_begin_frames) = 0;
};

class SynchronousCompositorControlHostProxy;

template <typename ImplRefTraits>
class SynchronousCompositorControlHostStub;

class SynchronousCompositorControlHostRequestValidator;


class CONTENT_EXPORT SynchronousCompositorControlHost
    : public SynchronousCompositorControlHostInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = SynchronousCompositorControlHostInterfaceBase;
  using Proxy_ = SynchronousCompositorControlHostProxy;

  template <typename ImplRefTraits>
  using Stub_ = SynchronousCompositorControlHostStub<ImplRefTraits>;

  using RequestValidator_ = SynchronousCompositorControlHostRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kReturnFrameMinVersion = 0,
    kBeginFrameResponseMinVersion = 0,
  };
  virtual ~SynchronousCompositorControlHost() {}

  
  virtual void ReturnFrame(uint32_t layer_tree_frame_sink_id, uint32_t metadata_version, base::Optional<::viz::CompositorFrame> frame, base::Optional<::viz::HitTestRegionList> hit_test_region_list) = 0;

  
  virtual void BeginFrameResponse(const ::content::SyncCompositorCommonRendererParams& params) = 0;
};



class CONTENT_EXPORT SynchronousCompositorProxy
    : public SynchronousCompositor {
 public:
  using InterfaceType = SynchronousCompositor;

  explicit SynchronousCompositorProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void DemandDrawHwAsync(const ::content::SyncCompositorDemandDrawHwParams& draw_params) final;
  
  bool DemandDrawHw(const ::content::SyncCompositorDemandDrawHwParams& draw_params, ::content::SyncCompositorCommonRendererParams* out_result, uint32_t* out_layer_tree_frame_sink_id, uint32_t* out_metadata_version, base::Optional<::viz::CompositorFrame>* out_frame, base::Optional<::viz::HitTestRegionList>* out_hit_test_region_list) final;
  
  void DemandDrawHw(const ::content::SyncCompositorDemandDrawHwParams& draw_params, DemandDrawHwCallback callback) final;
  
  bool SetSharedMemory(::base::WritableSharedMemoryRegion shm_region, bool* out_success, ::content::SyncCompositorCommonRendererParams* out_result) final;
  
  void SetSharedMemory(::base::WritableSharedMemoryRegion shm_region, SetSharedMemoryCallback callback) final;
  
  bool DemandDrawSw(const ::content::SyncCompositorDemandDrawSwParams& draw_params, ::content::SyncCompositorCommonRendererParams* out_result, uint32_t* out_metadata_version, base::Optional<::viz::CompositorFrameMetadata>* out_meta_data) final;
  
  void DemandDrawSw(const ::content::SyncCompositorDemandDrawSwParams& draw_params, DemandDrawSwCallback callback) final;
  
  void WillSkipDraw() final;
  
  void ZeroSharedMemory() final;
  
  bool ZoomBy(float delta, const ::gfx::Point& anchor, ::content::SyncCompositorCommonRendererParams* out_result) final;
  
  void ZoomBy(float delta, const ::gfx::Point& anchor, ZoomByCallback callback) final;
  
  void SetMemoryPolicy(uint32_t bytes_limit) final;
  
  void ReclaimResources(uint32_t layer_tree_frame_sink_id, const std::vector<::viz::ReturnedResource>& resources) final;
  
  void SetScroll(const ::gfx::ScrollOffset& offset) final;
  
  void BeginFrame(const ::viz::BeginFrameArgs& args, const base::flat_map<uint32_t, ::viz::FrameTimingDetails>& timing_details) final;
  
  void SetBeginFrameSourcePaused(bool paused) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class CONTENT_EXPORT SynchronousCompositorHostProxy
    : public SynchronousCompositorHost {
 public:
  using InterfaceType = SynchronousCompositorHost;

  explicit SynchronousCompositorHostProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void LayerTreeFrameSinkCreated() final;
  
  void UpdateState(const ::content::SyncCompositorCommonRendererParams& params) final;
  
  void SetNeedsBeginFrames(bool needs_begin_frames) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class CONTENT_EXPORT SynchronousCompositorControlHostProxy
    : public SynchronousCompositorControlHost {
 public:
  using InterfaceType = SynchronousCompositorControlHost;

  explicit SynchronousCompositorControlHostProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void ReturnFrame(uint32_t layer_tree_frame_sink_id, uint32_t metadata_version, base::Optional<::viz::CompositorFrame> frame, base::Optional<::viz::HitTestRegionList> hit_test_region_list) final;
  
  void BeginFrameResponse(const ::content::SyncCompositorCommonRendererParams& params) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class CONTENT_EXPORT SynchronousCompositorStubDispatch {
 public:
  static bool Accept(SynchronousCompositor* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      SynchronousCompositor* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<SynchronousCompositor>>
class SynchronousCompositorStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  SynchronousCompositorStub() {}
  ~SynchronousCompositorStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return SynchronousCompositorStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return SynchronousCompositorStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class CONTENT_EXPORT SynchronousCompositorHostStubDispatch {
 public:
  static bool Accept(SynchronousCompositorHost* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      SynchronousCompositorHost* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<SynchronousCompositorHost>>
class SynchronousCompositorHostStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  SynchronousCompositorHostStub() {}
  ~SynchronousCompositorHostStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return SynchronousCompositorHostStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return SynchronousCompositorHostStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class CONTENT_EXPORT SynchronousCompositorControlHostStubDispatch {
 public:
  static bool Accept(SynchronousCompositorControlHost* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      SynchronousCompositorControlHost* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<SynchronousCompositorControlHost>>
class SynchronousCompositorControlHostStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  SynchronousCompositorControlHostStub() {}
  ~SynchronousCompositorControlHostStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return SynchronousCompositorControlHostStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return SynchronousCompositorControlHostStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class CONTENT_EXPORT SynchronousCompositorRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class CONTENT_EXPORT SynchronousCompositorHostRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class CONTENT_EXPORT SynchronousCompositorControlHostRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class CONTENT_EXPORT SynchronousCompositorResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};











}  // namespace mojom
}  // namespace content

namespace mojo {

}  // namespace mojo

#endif  // CONTENT_COMMON_INPUT_SYNCHRONOUS_COMPOSITOR_MOJOM_H_