// content/common/input/synchronous_compositor.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4056)
#pragma warning(disable:4065)
#pragma warning(disable:4756)
#endif


#include "content/common/input/synchronous_compositor.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"
#include "mojo/public/mojom/base/shared_memory.mojom.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "services/viz/public/mojom/compositing/begin_frame_args.mojom.h"
#include "services/viz/public/mojom/compositing/compositor_frame.mojom.h"
#include "services/viz/public/mojom/compositing/compositor_frame_metadata.mojom.h"
#include "services/viz/public/mojom/compositing/frame_timing_details.mojom.h"
#include "services/viz/public/mojom/compositing/returned_resource.mojom.h"
#include "services/viz/public/mojom/hit_test/hit_test_region_list.mojom.h"
#include "ui/gfx/geometry/mojom/geometry.mojom.h"


#ifndef CONTENT_COMMON_INPUT_SYNCHRONOUS_COMPOSITOR_MOJOM_JUMBO_H_
#define CONTENT_COMMON_INPUT_SYNCHRONOUS_COMPOSITOR_MOJOM_JUMBO_H_
#include "content/common/input/sync_compositor_messages.h"
#include "gpu/ipc/common/mailbox_holder_mojom_traits.h"
#include "gpu/ipc/common/mailbox_mojom_traits.h"
#include "gpu/ipc/common/sync_token_mojom_traits.h"
#include "gpu/ipc/common/vulkan_ycbcr_info_mojom_traits.h"
#include "mojo/public/cpp/base/shared_memory_mojom_traits.h"
#include "mojo/public/cpp/base/time_mojom_traits.h"
#include "mojo/public/cpp/base/unguessable_token_mojom_traits.h"
#include "services/viz/public/cpp/compositing/begin_frame_args_mojom_traits.h"
#include "services/viz/public/cpp/compositing/compositor_frame_metadata_mojom_traits.h"
#include "services/viz/public/cpp/compositing/compositor_frame_mojom_traits.h"
#include "services/viz/public/cpp/compositing/copy_output_request_mojom_traits.h"
#include "services/viz/public/cpp/compositing/filter_operation_mojom_traits.h"
#include "services/viz/public/cpp/compositing/filter_operations_mojom_traits.h"
#include "services/viz/public/cpp/compositing/frame_deadline_mojom_traits.h"
#include "services/viz/public/cpp/compositing/frame_sink_id_mojom_traits.h"
#include "services/viz/public/cpp/compositing/frame_timing_details_mojom_traits.h"
#include "services/viz/public/cpp/compositing/local_surface_id_mojom_traits.h"
#include "services/viz/public/cpp/compositing/paint_filter_mojom_traits.h"
#include "services/viz/public/cpp/compositing/quads_mojom_traits.h"
#include "services/viz/public/cpp/compositing/render_pass_mojom_traits.h"
#include "services/viz/public/cpp/compositing/returned_resource_mojom_traits.h"
#include "services/viz/public/cpp/compositing/shared_quad_state_mojom_traits.h"
#include "services/viz/public/cpp/compositing/surface_id_mojom_traits.h"
#include "services/viz/public/cpp/compositing/surface_range_mojom_traits.h"
#include "services/viz/public/cpp/compositing/transferable_resource_mojom_traits.h"
#include "services/viz/public/cpp/hit_test/hit_test_region_list_mojom_traits.h"
#include "skia/public/mojom/blur_image_filter_tile_mode_mojom_traits.h"
#include "ui/gfx/geometry/mojom/geometry_mojom_traits.h"
#include "ui/gfx/mojom/color_space_mojom_traits.h"
#include "ui/gfx/mojom/overlay_transform_mojom_traits.h"
#include "ui/gfx/mojom/presentation_feedback_mojom_traits.h"
#include "ui/gfx/mojom/rrect_f_mojom_traits.h"
#include "ui/gfx/mojom/swap_timings_mojom_traits.h"
#include "ui/gfx/mojom/transform_mojom_traits.h"
#include "ui/latency/mojom/latency_info_mojom_traits.h"
#endif


namespace content {
namespace mojom {


void SynchronousCompositorInterceptorForTesting::DemandDrawHwAsync(const ::content::SyncCompositorDemandDrawHwParams& draw_params) {
  GetForwardingInterface()->DemandDrawHwAsync(std::move(draw_params));
}
void SynchronousCompositorInterceptorForTesting::DemandDrawHw(const ::content::SyncCompositorDemandDrawHwParams& draw_params, DemandDrawHwCallback callback) {
  GetForwardingInterface()->DemandDrawHw(std::move(draw_params), std::move(callback));
}
void SynchronousCompositorInterceptorForTesting::SetSharedMemory(::base::WritableSharedMemoryRegion shm_region, SetSharedMemoryCallback callback) {
  GetForwardingInterface()->SetSharedMemory(std::move(shm_region), std::move(callback));
}
void SynchronousCompositorInterceptorForTesting::DemandDrawSw(const ::content::SyncCompositorDemandDrawSwParams& draw_params, DemandDrawSwCallback callback) {
  GetForwardingInterface()->DemandDrawSw(std::move(draw_params), std::move(callback));
}
void SynchronousCompositorInterceptorForTesting::WillSkipDraw() {
  GetForwardingInterface()->WillSkipDraw();
}
void SynchronousCompositorInterceptorForTesting::ZeroSharedMemory() {
  GetForwardingInterface()->ZeroSharedMemory();
}
void SynchronousCompositorInterceptorForTesting::ZoomBy(float delta, const ::gfx::Point& anchor, ZoomByCallback callback) {
  GetForwardingInterface()->ZoomBy(std::move(delta), std::move(anchor), std::move(callback));
}
void SynchronousCompositorInterceptorForTesting::SetMemoryPolicy(uint32_t bytes_limit) {
  GetForwardingInterface()->SetMemoryPolicy(std::move(bytes_limit));
}
void SynchronousCompositorInterceptorForTesting::ReclaimResources(uint32_t layer_tree_frame_sink_id, const std::vector<::viz::ReturnedResource>& resources) {
  GetForwardingInterface()->ReclaimResources(std::move(layer_tree_frame_sink_id), std::move(resources));
}
void SynchronousCompositorInterceptorForTesting::SetScroll(const ::gfx::ScrollOffset& offset) {
  GetForwardingInterface()->SetScroll(std::move(offset));
}
void SynchronousCompositorInterceptorForTesting::BeginFrame(const ::viz::BeginFrameArgs& args, const base::flat_map<uint32_t, ::viz::FrameTimingDetails>& timing_details) {
  GetForwardingInterface()->BeginFrame(std::move(args), std::move(timing_details));
}
void SynchronousCompositorInterceptorForTesting::SetBeginFrameSourcePaused(bool paused) {
  GetForwardingInterface()->SetBeginFrameSourcePaused(std::move(paused));
}
SynchronousCompositorAsyncWaiter::SynchronousCompositorAsyncWaiter(
    SynchronousCompositor* proxy) : proxy_(proxy) {}

SynchronousCompositorAsyncWaiter::~SynchronousCompositorAsyncWaiter() = default;

void SynchronousCompositorAsyncWaiter::DemandDrawHw(
    const ::content::SyncCompositorDemandDrawHwParams& draw_params, ::content::SyncCompositorCommonRendererParams* out_result, uint32_t* out_layer_tree_frame_sink_id, uint32_t* out_metadata_version, base::Optional<::viz::CompositorFrame>* out_frame, base::Optional<::viz::HitTestRegionList>* out_hit_test_region_list) {
  base::RunLoop loop;
  proxy_->DemandDrawHw(std::move(draw_params),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::content::SyncCompositorCommonRendererParams* out_result
,
             uint32_t* out_layer_tree_frame_sink_id
,
             uint32_t* out_metadata_version
,
             base::Optional<::viz::CompositorFrame>* out_frame
,
             base::Optional<::viz::HitTestRegionList>* out_hit_test_region_list
,
             const ::content::SyncCompositorCommonRendererParams& result,
             uint32_t layer_tree_frame_sink_id,
             uint32_t metadata_version,
             base::Optional<::viz::CompositorFrame> frame,
             base::Optional<::viz::HitTestRegionList> hit_test_region_list) {*out_result = std::move(result);*out_layer_tree_frame_sink_id = std::move(layer_tree_frame_sink_id);*out_metadata_version = std::move(metadata_version);*out_frame = std::move(frame);*out_hit_test_region_list = std::move(hit_test_region_list);
            loop->Quit();
          },
          &loop,
          out_result,
          out_layer_tree_frame_sink_id,
          out_metadata_version,
          out_frame,
          out_hit_test_region_list));
  loop.Run();
}
void SynchronousCompositorAsyncWaiter::SetSharedMemory(
    ::base::WritableSharedMemoryRegion shm_region, bool* out_success, ::content::SyncCompositorCommonRendererParams* out_result) {
  base::RunLoop loop;
  proxy_->SetSharedMemory(std::move(shm_region),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             ::content::SyncCompositorCommonRendererParams* out_result
,
             bool success,
             const ::content::SyncCompositorCommonRendererParams& result) {*out_success = std::move(success);*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_success,
          out_result));
  loop.Run();
}
void SynchronousCompositorAsyncWaiter::DemandDrawSw(
    const ::content::SyncCompositorDemandDrawSwParams& draw_params, ::content::SyncCompositorCommonRendererParams* out_result, uint32_t* out_metadata_version, base::Optional<::viz::CompositorFrameMetadata>* out_meta_data) {
  base::RunLoop loop;
  proxy_->DemandDrawSw(std::move(draw_params),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::content::SyncCompositorCommonRendererParams* out_result
,
             uint32_t* out_metadata_version
,
             base::Optional<::viz::CompositorFrameMetadata>* out_meta_data
,
             const ::content::SyncCompositorCommonRendererParams& result,
             uint32_t metadata_version,
             base::Optional<::viz::CompositorFrameMetadata> meta_data) {*out_result = std::move(result);*out_metadata_version = std::move(metadata_version);*out_meta_data = std::move(meta_data);
            loop->Quit();
          },
          &loop,
          out_result,
          out_metadata_version,
          out_meta_data));
  loop.Run();
}
void SynchronousCompositorAsyncWaiter::ZoomBy(
    float delta, const ::gfx::Point& anchor, ::content::SyncCompositorCommonRendererParams* out_result) {
  base::RunLoop loop;
  proxy_->ZoomBy(std::move(delta),std::move(anchor),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::content::SyncCompositorCommonRendererParams* out_result
,
             const ::content::SyncCompositorCommonRendererParams& result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}



void SynchronousCompositorHostInterceptorForTesting::LayerTreeFrameSinkCreated() {
  GetForwardingInterface()->LayerTreeFrameSinkCreated();
}
void SynchronousCompositorHostInterceptorForTesting::UpdateState(const ::content::SyncCompositorCommonRendererParams& params) {
  GetForwardingInterface()->UpdateState(std::move(params));
}
void SynchronousCompositorHostInterceptorForTesting::SetNeedsBeginFrames(bool needs_begin_frames) {
  GetForwardingInterface()->SetNeedsBeginFrames(std::move(needs_begin_frames));
}
SynchronousCompositorHostAsyncWaiter::SynchronousCompositorHostAsyncWaiter(
    SynchronousCompositorHost* proxy) : proxy_(proxy) {}

SynchronousCompositorHostAsyncWaiter::~SynchronousCompositorHostAsyncWaiter() = default;




void SynchronousCompositorControlHostInterceptorForTesting::ReturnFrame(uint32_t layer_tree_frame_sink_id, uint32_t metadata_version, base::Optional<::viz::CompositorFrame> frame, base::Optional<::viz::HitTestRegionList> hit_test_region_list) {
  GetForwardingInterface()->ReturnFrame(std::move(layer_tree_frame_sink_id), std::move(metadata_version), std::move(frame), std::move(hit_test_region_list));
}
void SynchronousCompositorControlHostInterceptorForTesting::BeginFrameResponse(const ::content::SyncCompositorCommonRendererParams& params) {
  GetForwardingInterface()->BeginFrameResponse(std::move(params));
}
SynchronousCompositorControlHostAsyncWaiter::SynchronousCompositorControlHostAsyncWaiter(
    SynchronousCompositorControlHost* proxy) : proxy_(proxy) {}

SynchronousCompositorControlHostAsyncWaiter::~SynchronousCompositorControlHostAsyncWaiter() = default;






}  // namespace mojom
}  // namespace content

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif