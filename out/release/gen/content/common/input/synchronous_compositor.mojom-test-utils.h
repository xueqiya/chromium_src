// content/common/input/synchronous_compositor.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CONTENT_COMMON_INPUT_SYNCHRONOUS_COMPOSITOR_MOJOM_TEST_UTILS_H_
#define CONTENT_COMMON_INPUT_SYNCHRONOUS_COMPOSITOR_MOJOM_TEST_UTILS_H_

#include "content/common/input/synchronous_compositor.mojom.h"
#include "content/common/content_export.h"


namespace content {
namespace mojom {


class CONTENT_EXPORT SynchronousCompositorInterceptorForTesting : public SynchronousCompositor {
  virtual SynchronousCompositor* GetForwardingInterface() = 0;
  void DemandDrawHwAsync(const ::content::SyncCompositorDemandDrawHwParams& draw_params) override;
  void DemandDrawHw(const ::content::SyncCompositorDemandDrawHwParams& draw_params, DemandDrawHwCallback callback) override;
  void SetSharedMemory(::base::WritableSharedMemoryRegion shm_region, SetSharedMemoryCallback callback) override;
  void DemandDrawSw(const ::content::SyncCompositorDemandDrawSwParams& draw_params, DemandDrawSwCallback callback) override;
  void WillSkipDraw() override;
  void ZeroSharedMemory() override;
  void ZoomBy(float delta, const ::gfx::Point& anchor, ZoomByCallback callback) override;
  void SetMemoryPolicy(uint32_t bytes_limit) override;
  void ReclaimResources(uint32_t layer_tree_frame_sink_id, const std::vector<::viz::ReturnedResource>& resources) override;
  void SetScroll(const ::gfx::ScrollOffset& offset) override;
  void BeginFrame(const ::viz::BeginFrameArgs& args, const base::flat_map<uint32_t, ::viz::FrameTimingDetails>& timing_details) override;
  void SetBeginFrameSourcePaused(bool paused) override;
};
class CONTENT_EXPORT SynchronousCompositorAsyncWaiter {
 public:
  explicit SynchronousCompositorAsyncWaiter(SynchronousCompositor* proxy);
  ~SynchronousCompositorAsyncWaiter();
  void DemandDrawHw(
      const ::content::SyncCompositorDemandDrawHwParams& draw_params, ::content::SyncCompositorCommonRendererParams* out_result, uint32_t* out_layer_tree_frame_sink_id, uint32_t* out_metadata_version, base::Optional<::viz::CompositorFrame>* out_frame, base::Optional<::viz::HitTestRegionList>* out_hit_test_region_list);
  void SetSharedMemory(
      ::base::WritableSharedMemoryRegion shm_region, bool* out_success, ::content::SyncCompositorCommonRendererParams* out_result);
  void DemandDrawSw(
      const ::content::SyncCompositorDemandDrawSwParams& draw_params, ::content::SyncCompositorCommonRendererParams* out_result, uint32_t* out_metadata_version, base::Optional<::viz::CompositorFrameMetadata>* out_meta_data);
  void ZoomBy(
      float delta, const ::gfx::Point& anchor, ::content::SyncCompositorCommonRendererParams* out_result);

 private:
  SynchronousCompositor* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(SynchronousCompositorAsyncWaiter);
};


class CONTENT_EXPORT SynchronousCompositorHostInterceptorForTesting : public SynchronousCompositorHost {
  virtual SynchronousCompositorHost* GetForwardingInterface() = 0;
  void LayerTreeFrameSinkCreated() override;
  void UpdateState(const ::content::SyncCompositorCommonRendererParams& params) override;
  void SetNeedsBeginFrames(bool needs_begin_frames) override;
};
class CONTENT_EXPORT SynchronousCompositorHostAsyncWaiter {
 public:
  explicit SynchronousCompositorHostAsyncWaiter(SynchronousCompositorHost* proxy);
  ~SynchronousCompositorHostAsyncWaiter();

 private:
  SynchronousCompositorHost* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(SynchronousCompositorHostAsyncWaiter);
};


class CONTENT_EXPORT SynchronousCompositorControlHostInterceptorForTesting : public SynchronousCompositorControlHost {
  virtual SynchronousCompositorControlHost* GetForwardingInterface() = 0;
  void ReturnFrame(uint32_t layer_tree_frame_sink_id, uint32_t metadata_version, base::Optional<::viz::CompositorFrame> frame, base::Optional<::viz::HitTestRegionList> hit_test_region_list) override;
  void BeginFrameResponse(const ::content::SyncCompositorCommonRendererParams& params) override;
};
class CONTENT_EXPORT SynchronousCompositorControlHostAsyncWaiter {
 public:
  explicit SynchronousCompositorControlHostAsyncWaiter(SynchronousCompositorControlHost* proxy);
  ~SynchronousCompositorControlHostAsyncWaiter();

 private:
  SynchronousCompositorControlHost* const proxy_;

  DISALLOW_COPY_AND_ASSIGN(SynchronousCompositorControlHostAsyncWaiter);
};




}  // namespace mojom
}  // namespace content

#endif  // CONTENT_COMMON_INPUT_SYNCHRONOUS_COMPOSITOR_MOJOM_TEST_UTILS_H_