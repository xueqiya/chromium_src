// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'chrome://resources/mojo/mojo/public/js/mojo_bindings_lite.js';
import 'chrome://resources/mojo/mojo/public/mojom/base/text_direction.mojom-lite.js';
import 'chrome://resources/mojo/url/mojom/url.mojom-lite.js';
import 'chrome://new-tab-page/skcolor.mojom-lite.js';
import 'chrome://new-tab-page/new_tab_page.mojom-lite.js';

import {BrowserProxy} from 'chrome://new-tab-page/browser_proxy.js';
import {getDeepActiveElement} from 'chrome://resources/js/util.m.js';
import {keyDownOn} from 'chrome://resources/polymer/v3_0/iron-test-helpers/mock-interactions.js';
import {TestBrowserProxy} from 'chrome://test/test_browser_proxy.m.js';

/** @implements {BrowserProxy} */
export class TestProxy extends TestBrowserProxy {
  constructor() {
    super([
      'navigate',
      'setTimeout',
      'clearTimeout',
    ]);

    /** @type {newTabPage.mojom.PageCallbackRouter} */
    this.callbackRouter = new newTabPage.mojom.PageCallbackRouter();

    /** @type {!newTabPage.mojom.PageRemote} */
    this.callbackRouterRemote =
        this.callbackRouter.$.bindNewPipeAndPassRemote();

    /** @type {newTabPage.mojom.PageHandlerInterface} */
    this.handler = new FakePageHandler();
  }

  /** @override */
  navigate(href) {
    this.methodCalled('navigate', [href]);
  }

  /** @override */
  setTimeout(callback, duration) {
    this.methodCalled('setTimeout', [callback, duration]);
    return 0;
  }

  /** @override */
  clearTimeout(id) {
    this.methodCalled('clearTimeout', [id]);
  }
}

/** @implements {newTabPage.mojom.PageHandlerInterface} */
class FakePageHandler extends TestBrowserProxy {
  /** @param {newTabPage.mojom.PageInterface} */
  constructor() {
    super([
      'addMostVisitedTile',
      'deleteMostVisitedTile',
      'reorderMostVisitedTile',
      'restoreMostVisitedDefaults',
      'setMostVisitedSettings',
      'undoMostVisitedTileAction',
      'updateMostVisitedInfo',
      'updateMostVisitedTile',
      'getChromeThemes',
      'applyDefaultTheme',
      'applyAutogeneratedTheme',
      'applyChromeTheme',
      'confirmThemeChanges',
    ]);
  }

  /** @override */
  addMostVisitedTile(url, title) {
    this.methodCalled('addMostVisitedTile', [url, title]);
    return {success: true};
  }

  /** @override */
  deleteMostVisitedTile(url) {
    this.methodCalled('deleteMostVisitedTile', url);
    return {success: true};
  }

  /** @override */
  reorderMostVisitedTile(url, newPos) {
    this.methodCalled('reorderMostVisitedTile', [url, newPos]);
  }

  /** @override */
  restoreMostVisitedDefaults() {
    this.methodCalled('restoreMostVisitedDefaults');
  }

  /** @override */
  setMostVisitedSettings(customLinksEnabled, visible) {
    this.methodCalled('setMostVisitedSettings', [customLinksEnabled, visible]);
  }

  /** @override */
  undoMostVisitedTileAction() {
    this.methodCalled('undoMostVisitedTileAction');
  }

  /** @override */
  updateMostVisitedInfo() {
    this.methodCalled('updateMostVisitedInfo');
  }

  /** @override */
  updateMostVisitedTile(url, newUrl, newTitle) {
    this.methodCalled('updateMostVisitedTile', [url, newUrl, newTitle]);
    return {success: true};
  }

  /** @override */
  getChromeThemes() {
    this.methodCalled('getChromeThemes');
    return this.getResultFor('getChromeThemes', Promise.resolve({
      chromeThemes: [],
    }));
  }

  /** @override */
  applyDefaultTheme() {
    this.methodCalled('applyDefaultTheme');
  }

  /** @override */
  applyAutogeneratedTheme(frameColor) {
    this.methodCalled('applyAutogeneratedTheme', frameColor);
  }

  /** @override */
  applyChromeTheme(id) {
    this.methodCalled('applyChromeTheme', id);
  }

  /** @override */
  confirmThemeChanges() {
    this.methodCalled('confirmThemeChanges');
  }
}

/**
 * @param {!HTMLElement} element
 * @param {string} key
 */
export function keydown(element, key) {
  keyDownOn(element, '', [], key);
}

/**
 * @param {!HTMLElement} element
 * @return {boolean}
 */
export function isVisible(element) {
  return !!(
      element.offsetWidth || element.offsetHeight ||
      element.getClientRects().length);
}

/**
 * Asserts the computed style value for an element.
 * @param {!HTMLElement} element The element.
 * @param {string} name The name of the style to assert.
 * @param {string} expected The expected style value.
 */
export function assertStyle(element, name, expected) {
  const actual = window.getComputedStyle(element).getPropertyValue(name).trim();
  assertEquals(expected, actual);
}

/**
 * Asserts that an element is focused.
 * @param {!HTMLElement} element The element to test.
 */
export function assertFocus(element) {
  assertEquals(element, getDeepActiveElement());
}
